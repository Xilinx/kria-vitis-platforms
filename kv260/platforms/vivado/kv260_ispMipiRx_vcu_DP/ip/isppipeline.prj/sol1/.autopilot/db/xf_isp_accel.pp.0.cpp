# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_accel.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 361 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/etc/autopilot_ssdm_op.h" 1
# 154 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/etc/autopilot_ssdm_op.h"
extern "C" {






    void _ssdm_op_IfRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_StreamRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_ReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Read(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_WriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Write(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_PrintNone(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_PrintInt(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_PrintDouble(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Wait(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Return(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecInterface(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecKeepValue(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_RegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_Unroll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_UnrollRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_InlineAll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_Inline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecStream(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecStable(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecStableContent(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBindPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipoDepth(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecExpr(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecDependence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_DataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBitsMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecLicense(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void __xilinx_ip_top(...) __attribute__ ((nothrow)) __attribute__((overloadable));


}
# 2 "<built-in>" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_accel.cpp" 2
# 17 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_accel.cpp"
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 1
# 22 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_stream.h" 1
# 61 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_stream.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_stream_39.h" 1
# 72 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_stream_39.h"
namespace hls {
# 94 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_stream_39.h"
template<typename __STREAM_T__, int DEPTH=0>
class stream;

template<typename __STREAM_T__>
class stream<__STREAM_T__, 0>
{
  public:
    using value_type = __STREAM_T__;

    inline __attribute__((always_inline)) stream() {
      __fpga_set_stream_depth(&this->V, 0);
    }

    inline __attribute__((always_inline)) stream(const char* name) {
      (void)(name);
      __fpga_set_stream_depth(&this->V, 0);
    }


  private:
    inline __attribute__((always_inline)) stream(const stream< __STREAM_T__ >& chn):V(chn.V) {
    }

    inline __attribute__((always_inline)) stream& operator= (const stream< __STREAM_T__ >& chn) {
        V = chn.V;
        return *this;
    }

  public:

    inline __attribute__((always_inline)) void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    inline __attribute__((always_inline)) void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }


  public:

    inline __attribute__((always_inline)) bool empty() const {
        return !__fpga_fifo_not_empty(&V);
    }

    inline __attribute__((always_inline)) bool full() const {
        return !__fpga_fifo_not_full(&V);
    }


    inline __attribute__((always_inline)) void read(__STREAM_T__& dout) {
        __fpga_fifo_pop(&V, &dout);
    }


    inline __attribute__((noinline)) bool read_dep(__STREAM_T__& dout, volatile bool flag) {
        __fpga_fifo_pop(&V, &dout);
        return flag;
    }

    inline __attribute__((always_inline)) __STREAM_T__ read() {
        __STREAM_T__ tmp;
        read(tmp);
        return tmp;
    }


    inline __attribute__((always_inline)) bool read_nb(__STREAM_T__& dout) {
        __STREAM_T__ tmp;

        if (__fpga_fifo_nb_pop(&V, &tmp)) {
            dout = tmp;
            return true;
        } else {
            return false;
        }
    }


    inline __attribute__((always_inline)) void write(const __STREAM_T__& din) {
        __fpga_fifo_push(&V, &din);
    }


    inline __attribute__((noinline)) bool write_dep(const __STREAM_T__& din, volatile bool flag) {
        __fpga_fifo_push(&V, &din);
        return flag;
    }


    inline __attribute__((always_inline)) bool write_nb(const __STREAM_T__& din) {
        return __fpga_fifo_nb_push(&V, &din);
    }


    inline __attribute__((always_inline)) unsigned size() const {
        return __fpga_fifo_size(&V);
    }


    inline __attribute__((always_inline)) unsigned capacity() const {
        return __fpga_fifo_capacity(&V);
    }


    void set_name(const char* name) { (void)(name); }

  public:
    __STREAM_T__ V __attribute__((no_ctor));
};

template<typename __STREAM_T__, int DEPTH>
class stream : public stream<__STREAM_T__, 0> {
  public:
    inline __attribute__((always_inline)) stream() {
      __fpga_set_stream_depth(&this->V, DEPTH);
    }

    inline __attribute__((always_inline)) stream(const char* name) {
      (void)(name);
      __fpga_set_stream_depth(&this->V, DEPTH);
    }
};
}
# 62 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_stream.h" 2
# 23 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 56 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_common.h" 1
# 87 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_common.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_decl.h" 1
# 100 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_decl.h"
enum ap_q_mode {
  AP_RND,
  AP_RND_ZERO,
  AP_RND_MIN_INF,
  AP_RND_INF,
  AP_RND_CONV,
  AP_TRN,
  AP_TRN_ZERO,
};
# 122 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_decl.h"
enum ap_o_mode {
  AP_SAT,
  AP_SAT_ZERO,
  AP_SAT_SYM,
  AP_WRAP,
  AP_WRAP_SM,
};
# 179 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_decl.h"
template <int _AP_W, bool _AP_S>
struct ap_int_base;

template <int _AP_W>
struct ap_int;

template <int _AP_W>
struct ap_uint;

template <int _AP_W, bool _AP_S>
struct ap_range_ref;

template <int _AP_W, bool _AP_S>
struct ap_bit_ref;

template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref;

template <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed_base;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_ufixed;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref;


enum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };
# 233 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_decl.h"
typedef signed long long ap_slong;
typedef unsigned long long ap_ulong;


enum {
  _AP_SIZE_char = 8,
  _AP_SIZE_short = sizeof(short) * 8,
  _AP_SIZE_int = sizeof(int) * 8,
  _AP_SIZE_long = sizeof(long) * 8,
  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8
};
# 88 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_common.h" 2
# 208 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_common.h"
enum { CHAR_IS_SIGNED = (char)-1 < 0 };


namespace _ap_type {
template <typename _Tp>
struct is_signed {
  static const bool value = _Tp(-1) < _Tp(1);
};

template <typename _Tp>
struct is_integral {
  static const bool value = false;
};





template <> struct is_integral<bool> { static const bool value = true; };
template <> struct is_integral<char> { static const bool value = true; };
template <> struct is_integral<signed char> { static const bool value = true; };
template <> struct is_integral<unsigned char> { static const bool value = true; };
template <> struct is_integral<short> { static const bool value = true; };
template <> struct is_integral<unsigned short> { static const bool value = true; };
template <> struct is_integral<int> { static const bool value = true; };
template <> struct is_integral<unsigned int> { static const bool value = true; };
template <> struct is_integral<long> { static const bool value = true; };
template <> struct is_integral<unsigned long> { static const bool value = true; };
template <> struct is_integral<ap_slong> { static const bool value = true; };
template <> struct is_integral<ap_ulong> { static const bool value = true; };


template <bool, typename _Tp = void>
struct enable_if {};

template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};
}
# 551 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_common.h"
template <int _AP_N, bool _AP_S>
struct ssdm_int;

template <int _AP_N>
struct ssdm_int<_AP_N, true> {
  typedef int __attribute__((bitwidth(_AP_N))) DataType;
  int V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, true>(){};
                inline __attribute__((always_inline)) ssdm_int<_AP_N, true>(int o __attribute__((bitwidth(_AP_N)))):V(o){};
};

template <int _AP_N>
struct ssdm_int<_AP_N, false> {
  typedef unsigned __attribute__((bitwidth(_AP_N))) DataType;
  unsigned V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, false>(){};
                inline __attribute__((always_inline)) ssdm_int<_AP_N, false>(unsigned o __attribute__((bitwidth(_AP_N)))):V(o){};
};
# 619 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_common.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/etc/autopilot_ssdm_bits.h" 1
# 620 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_common.h" 2

extern "C" void _ssdm_string2bits(...);
# 631 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_common.h"
static inline unsigned char guess_radix(const char* s) {
  unsigned char rd = 10;
  const char* p = s;

  if (p[0] == '-' || p[0] == '+') ++p;

  if (p[0] == '0') {
    if (p[1] == 'b' || p[1] == 'B') {
      rd = 2;
    } else if (p[1] == 'o' || p[1] == 'O') {
      rd = 8;
    } else if (p[1] == 'x' || p[1] == 'X') {
      rd = 16;
    } else if (p[1] == 'd' || p[1] == 'D') {
      rd = 10;
    }
  }
  return rd;
}







typedef __fp16 half;
# 762 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_common.h"
inline __attribute__((always_inline)) ap_ulong doubleToRawBits(double pf) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned int floatToRawBits(float pf) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned short halfToRawBits(half pf) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__D = pf;
  return LD.__L;



}


inline __attribute__((always_inline)) double rawBitsToDouble(ap_ulong pi) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) float rawBitsToFloat(unsigned long pi) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) half rawBitsToHalf(unsigned short pi) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__L = pi;
  return LD.__D;






}
# 57 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h" 1
# 86 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_N, bool _AP_S>
struct retval;


template <int _AP_N>
struct retval<_AP_N, true> {
  typedef ap_slong Type;
};

template <int _AP_N>
struct retval<_AP_N, false> {
  typedef ap_ulong Type;
};


template <>
struct retval<1, true> {
  typedef signed char Type;
};

template <>
struct retval<1, false> {
  typedef unsigned char Type;
};


template <>
struct retval<2, true> {
  typedef short Type;
};

template <>
struct retval<2, false> {
  typedef unsigned short Type;
};


template <>
struct retval<3, true> {
  typedef long Type;
};

template <>
struct retval<3, false> {
  typedef unsigned long Type;
};

template <>
struct retval<4, true> {
  typedef long Type;
};

template <>
struct retval<4, false> {
  typedef unsigned long Type;
};




template <int _AP_W2, bool _AP_S2>
struct _ap_int_factory;
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };

template <int _AP_W, bool _AP_S>
struct ap_int_base : public ssdm_int<_AP_W, _AP_S> {
 private:
                inline __attribute__((always_inline)) int countLeadingOnes() const {




    return 0;

  }

 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;







  typedef typename retval<(((_AP_W + 7) / 8) > (8) ? ((_AP_W + 7) / 8) : (8)), _AP_S>::Type RetType;

  static const int width = _AP_W;
  static const bool sign_flag = _AP_S;

  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };


    typedef ap_int_base<mult_w, mult_s> mult_base;
    typedef ap_int_base<plus_w, plus_s> plus_base;
    typedef ap_int_base<minus_w, minus_s> minus_base;
    typedef ap_int_base<logic_w, logic_s> logic_base;
    typedef ap_int_base<div_w, div_s> div_base;
    typedef ap_int_base<mod_w, mod_s> mod_base;
    typedef ap_int_base<_AP_W, _AP_S> arg1_base;

    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;
    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;
    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;
    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;
    typedef typename _ap_int_factory<div_w, div_s>::type div;
    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;
    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;
    typedef bool reduce;
  };





  inline __attribute__((always_inline)) ap_int_base() {





  }


  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op.V) {
    Base::V = op.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }
# 254 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base(const bool op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const signed char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const short op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned short op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const int op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned int op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const long op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned long op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const ap_slong op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const ap_ulong op):Base(op) { Base::V = op; }




  inline __attribute__((always_inline)) ap_int_base(half op) {
    ap_int_base<_AP_W, _AP_S> t((float)op);
    Base::V = t.V;
  }


  inline __attribute__((always_inline)) ap_int_base(float op) {
    const int BITS = 23 + 8 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = floatToRawBits(op);
    bool is_neg = ({ __typeof__(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<8 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 23, BITS - 2); __Result__; });
    exp = exp - ((1L << (8 - 1L)) - 1L);

    ap_int_base<23 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 23 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23); __Result__; });


    if ((reg.V & 0x7ffffffful) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 23 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 23 + 2) {
          ap_int_base<23 + 2, true> man_shift;
          man_shift.V = (man.V >> sh_amt);






          Base::V = man_shift.V;
        } else {



            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {



          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  inline __attribute__((always_inline)) ap_int_base(double op) {
    const int BITS = 52 + 11 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = doubleToRawBits(op);
    bool is_neg = ({ __typeof__(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<11 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, BITS - 2); __Result__; });
    exp = exp - ((1L << (11 - 1L)) - 1L);

    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });


    if ((reg.V & 0x7fffffffffffffffull) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 52 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 52 + 2) {
          ap_int_base<23 + 2, true> man_shift;
          man_shift.V = (man.V >> sh_amt);






          Base::V = man_shift.V;
        } else {



           Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {



          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_int_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    op.checkOverflowCsimFix(_AP_W, _AP_S);
    Base::V = op.to_ap_int_base().V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = (ref.get()).V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = ref.operator bool();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {
    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,
                      false>
        tmp = ref.get();
    Base::V = tmp.V;
  }
# 431 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base(const char* s) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) ap_int_base(const char* s, signed char rd) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = (val.get()).V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = val.operator bool();
  }

  inline __attribute__((always_inline)) ap_int_base read() volatile {

    ap_int_base ret;
    ret.V = Base::V;
    return ret;
  }

  inline __attribute__((always_inline)) void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {

    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) void operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(
      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline __attribute__((always_inline)) ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }


  ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) = default;
# 525 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base& operator=(bool op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(signed char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(ap_slong op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(ap_ulong op) { Base::V = op; return *this; }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (bool)op2;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
    return *this;
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {
    Base::V = op2.get().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = (bool)op;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
    return *this;
  }





                inline __attribute__((always_inline)) operator RetType() const { return (RetType)(Base::V); }




                inline __attribute__((always_inline)) bool to_bool() const { return (bool)(Base::V); }
                inline __attribute__((always_inline)) char to_char() const { return (char)(Base::V); }
                inline __attribute__((always_inline)) signed char to_schar() const { return (signed char)(Base::V); }
                inline __attribute__((always_inline)) unsigned char to_uchar() const { return (unsigned char)(Base::V); }
                inline __attribute__((always_inline)) short to_short() const { return (short)(Base::V); }
                inline __attribute__((always_inline)) unsigned short to_ushort() const { return (unsigned short)(Base::V); }
                inline __attribute__((always_inline)) int to_int() const { return (int)(Base::V); }
                inline __attribute__((always_inline)) unsigned to_uint() const { return (unsigned)(Base::V); }
                inline __attribute__((always_inline)) long to_long() const { return (long)(Base::V); }
                inline __attribute__((always_inline)) unsigned long to_ulong() const { return (unsigned long)(Base::V); }
                inline __attribute__((always_inline)) ap_slong to_int64() const { return (ap_slong)(Base::V); }
                inline __attribute__((always_inline)) ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
  inline __attribute__((always_inline)) half to_half() const { return (float)(Base::V); }
                inline __attribute__((always_inline)) float to_float() const { return (float)(Base::V); }
                inline __attribute__((always_inline)) double to_double() const { return (double)(Base::V); }
# 630 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) int length() const volatile { return _AP_W; }
                inline __attribute__((always_inline)) int length() const { return _AP_W; }


                inline __attribute__((always_inline)) bool iszero() const { return Base::V == 0; }


                inline __attribute__((always_inline)) bool is_zero() const { return Base::V == 0; }


                      inline __attribute__((always_inline)) bool sign() const {
    if (_AP_S &&
        ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }))
      return true;
    else
      return false;
  }


  inline __attribute__((always_inline)) void clear(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) void invert(int i) {
                                                           ;
    bool val = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    if (val)
      Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    else
      Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }

  inline __attribute__((always_inline)) bool test(int i) const {
                                                           ;
    return ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


                inline __attribute__((always_inline)) ap_int_base& get() { return *this; }


  inline __attribute__((always_inline)) void set(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) void set(int i, bool v) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }



  inline __attribute__((always_inline)) ap_int_base& lrotate(int n) {
                                                              ;


    __typeof__(Base::V) l_p = Base::V << n;
    __typeof__(Base::V) r_p = Base::V >> (_AP_W - n);
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) ap_int_base& rrotate(int n) {
                                                              ;


    __typeof__(Base::V) l_p = Base::V << (_AP_W - n);
    __typeof__(Base::V) r_p = Base::V >> n;
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) ap_int_base& reverse() {
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
    return *this;
  }


  inline __attribute__((always_inline)) void set_bit(int i, bool v) {
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) bool get_bit(int i) const {
    return (bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


  inline __attribute__((always_inline)) void b_not() { Base::V = ~Base::V; }

  template<typename T>
                inline __attribute__((always_inline)) void checkOverflowBaseC(T val) {
# 801 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
    (void)val;

    return;
  }

                inline __attribute__((always_inline)) bool checkOverflowCsim(int _ap_w2, bool _ap_s2,
          bool print = true) const {
# 851 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
      (void)_ap_w2;
      (void)_ap_s2;
      (void)print;

      return 0;
  }
# 885 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator *=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V *= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator +=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V += op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator -=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V -= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator /=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V /= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator %=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V %= op2.V; return *this; }
# 903 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator &=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V &= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator |=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V |= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator ^=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V ^= op2.V; return *this; }





  inline __attribute__((always_inline)) ap_int_base& operator++() {
    operator+=((ap_int_base<1, false>)1);
    return *this;
  }
  inline __attribute__((always_inline)) ap_int_base& operator--() {
    operator-=((ap_int_base<1, false>)1);
    return *this;
  }




  inline __attribute__((always_inline)) const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {
    ap_int_base t = *this;
    operator+=((ap_int_base<1, false>)1);
    return t;
  }
  inline __attribute__((always_inline)) const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {
    ap_int_base t = *this;
    operator-=((ap_int_base<1, false>)1);
    return t;
  }




                inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }


                inline __attribute__((always_inline)) typename RType<1, false>::minus operator-() const {
    return ap_int_base<1, false>(0) - *this;
  }




                inline __attribute__((always_inline)) bool operator!() const { return Base::V == 0; }





                inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator~() const {
    ap_int_base<_AP_W, _AP_S> r(0);
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_W2>
                      inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>(sh);
    } else
      return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r(0);
    r.V = Base::V << op2.to_uint();
    return r;
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<(sh);
    }
    return operator>>(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r(0);
    r.V = Base::V >> op2.to_uint();
    return r;
  }
# 1014 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>=(sh);
    } else
      return operator<<=(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V <<= op2.to_uint();
    return *this;
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<=(sh);
    }
    return operator>>=(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V >>= op2.to_uint();
    return *this;
  }
# 1063 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V == op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return !(Base::V == op2.V);
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V < op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V >= op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V > op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V <= op2.V;
  }




  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }
# 1172 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> operator[](int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) bool operator[](int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());
    return br.to_bool();
  }

  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> bit(int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) bool bit(int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {
    return bit(index.to_int());
  }
# 1239 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
                inline __attribute__((always_inline)) int countLeadingZeros() const {

    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1UL), x;
      x.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __typeof__(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      ap_int_base<64, false> x;
      x.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __typeof__(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return __builtin_ctzll(t.V);
    } else {
      enum { __N = (_AP_W + 63) / 64 };
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      VITIS_LOOP_1257_1: for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - i * 64 - 64, _AP_W - i * 64 - 1); __Result__; });
        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V);
        hitNonZero |= (t.V != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        enum { REST = (_AP_W - 1) % 64 };
        ap_int_base<64, false> x;
        x.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, REST); __Result__; });
        t.V = ({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __typeof__(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 63 - REST, 63); __Result__; });
        NZeros += __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator&(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this & a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator|(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this | a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator^(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this ^ a2.get();
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    Base::V = val.V;
  }





  inline __attribute__((always_inline)) bool and_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool nand_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool or_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool nor_reduce() const { return !(({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); })); }
  inline __attribute__((always_inline)) bool xor_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool xnor_reduce() const {
    return !(({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
  }
# 1479 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) char* to_string(signed char rd = 2, bool sign = _AP_S) const {
    (void)(rd);
    (void)(sign);
    return 0;
  }

};
# 1540 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base ret(0); ret.V = lhs.V * rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base ret(0); ret.V = lhs.V + rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base ret(0); ret.V = lhs.V - rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V & rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V | rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V ^ rhs.V; return ret; }
# 1559 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::div_base ret(0); ret.V = op.V / op2.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mod_base ret(0); ret.V = op.V % op2.V; return ret; }
# 1587 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator +(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator -(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 - i_op; }
# 1616 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator *(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator *(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator /(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator /(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator +(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator +(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator -(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator -(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator *(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator *(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator /(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator /(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator +(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator +(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator -(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator -(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1641 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator *(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator *(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator /(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator /(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator +(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator +(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator -(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator -(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1673 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op * ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op + ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op - ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op / ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op % ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op & ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op | ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op ^ ap_int_base<1, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op * ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op + ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op - ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op / ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op % ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op & ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op | ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op ^ ap_int_base<8, CHAR_IS_SIGNED>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op * ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op + ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op - ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op / ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op % ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op & ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op | ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op ^ ap_int_base<8, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op * ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op + ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op - ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op / ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op % ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op & ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op | ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op ^ ap_int_base<8, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op * ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op + ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op - ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op / ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op % ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op & ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op | ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op ^ ap_int_base<_AP_SIZE_short, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op * ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op + ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op - ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op / ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op % ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op & ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op | ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op ^ ap_int_base<_AP_SIZE_short, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op * ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op + ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op - ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op / ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op % ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op & ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op | ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op ^ ap_int_base<_AP_SIZE_int, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op * ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op + ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op - ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op / ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op % ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op & ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op | ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op ^ ap_int_base<_AP_SIZE_int, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op * ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op + ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op - ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op / ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op % ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op & ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op | ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op ^ ap_int_base<_AP_SIZE_long, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op * ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op + ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op - ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op / ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op % ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op & ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op | ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op ^ ap_int_base<_AP_SIZE_long, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, false>(i_op); }
# 1712 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
# 1736 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
# 1767 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op += ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op -= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op *= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op /= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op %= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op &= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op |= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op ^= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >>= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <<= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op += ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op -= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op *= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op /= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op %= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op &= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op |= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op ^= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >>= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <<= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op += ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op -= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op *= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op /= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op %= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op &= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op |= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op ^= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >>= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <<= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op += ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op -= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op *= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op /= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op %= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op &= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op |= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op ^= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >>= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <<= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op += ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op -= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op *= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op /= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op %= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op &= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op |= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op ^= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >>= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <<= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op += ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op -= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op *= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op /= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op %= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op &= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op |= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op ^= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >>= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <<= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op += ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op -= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op *= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op /= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op %= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op &= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op |= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op ^= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >>= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <<= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op += ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op -= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op *= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op /= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op %= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op &= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op |= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op ^= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >>= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <<= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op += ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op -= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op *= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op /= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op %= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op &= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op |= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op ^= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >>= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <<= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op += ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op -= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op *= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op /= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op %= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op &= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op |= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op ^= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >>= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <<= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1800 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator +=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator -=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator *=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator /=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator +=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator -=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator *=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator /=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator +=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator -=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator *=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator /=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 /= op_rt; }
# 1828 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1865 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; }
# 1895 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<_AP_W2, false>(op2); }
# 1926 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator +=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator -=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator *=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator /=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator %=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator >>=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator <<=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1958 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator &=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator |=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator ^=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1977 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_int_base<_AP_W2, false>()); }
# 2004 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) + op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) - op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) * op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) / op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) % op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) & op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) | op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) ^ op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >> op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) << op2; }
# 2035 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator +=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator -=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator *=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator /=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator %=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator >>=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator <<=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 2067 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator &=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator |=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator ^=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 2086 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 == ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) == op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 != ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) != op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 > ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) > op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >= op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 < ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) < op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) <= op2; }
# 2193 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 == op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() == op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 != op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() != op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 > op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() > op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 >= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() >= op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 < op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() < op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 <= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() <= op2; }
# 58 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h" 1
# 73 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
  enum {
    _AP_WR = _AP_W1 + _AP_W2,
  };

  _AP_T1& mbv1;
  _AP_T2& mbv2;

  inline __attribute__((always_inline)) ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)
      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}

  inline __attribute__((always_inline)) ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> Part1;
    Part1.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(Part1);
    ap_int_base<_AP_W2, false> Part2;
    Part2.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(Part2);
    return *this;
  }
# 116 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_concat_ref& operator=(bool val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(signed char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(ap_slong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(ap_ulong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(half val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(float val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(double val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }





  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }
  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((const ap_int_base<_AP_W3, false>)(val));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&
          val) {
    return operator=(val.to_ap_int_base());
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((ap_ulong)(bool)(val));
  }

  inline __attribute__((always_inline)) operator ap_int_base<_AP_WR, false>() const { return get(); }

  inline __attribute__((always_inline)) operator ap_ulong() const { return get().to_uint64(); }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                       ap_range_ref<_AP_W3, _AP_S3> >
  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_range_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {

    ap_int_base<_AP_W3, _AP_S3> op(a2);
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >
  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(
        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_WR, ap_concat_ref, _AP_W3,
      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
  operator,(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, _AP_W3,
        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<
            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, 1,
                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>
                    &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, 1,
        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(
            a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator&(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() & a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator|(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() | a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator^(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() ^ a2;
  }
# 304 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_int_base<_AP_WR, false> get() const {
    ap_int_base<_AP_WR, false> tmpVal(0);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W2, false> v2(mbv2);
    ap_int_base<_AP_W1, false> v1(mbv1);
    tmpVal.V = ({ typename _ap_type::remove_const<__typeof__(tmpVal.V)>::type __Result__ = 0; __typeof__(tmpVal.V) __Val2__ = tmpVal.V; __typeof__(v2.V) __Repl2__ = v2.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, W_ref2 - 1); __Result__; });
    tmpVal.V =
        ({ typename _ap_type::remove_const<__typeof__(tmpVal.V)>::type __Result__ = 0; __typeof__(tmpVal.V) __Val2__ = tmpVal.V; __typeof__(v1.V) __Repl2__ = v1.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    return tmpVal;
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> tmpVal1;
    tmpVal1.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(tmpVal1);
    ap_int_base<_AP_W2, false> tmpVal2;
    tmpVal2.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(tmpVal2);
  }

  inline __attribute__((always_inline)) int length() const { return mbv1.length() + mbv2.length(); }
};




template <int _AP_W, bool _AP_S>
struct ap_range_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:
  inline __attribute__((always_inline)) ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

  inline __attribute__((always_inline)) ap_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) ap_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) operator ap_ulong() const { return to_uint64(); }
# 385 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_range_ref& operator=(bool val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(signed char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(ap_slong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(ap_ulong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(half val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(float val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(double val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }




  inline __attribute__((always_inline)) ap_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_range_ref& val) {
    return operator=((const ap_int_base<_AP_W, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    return operator=(val.to_ap_int_base());
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  inline __attribute__((always_inline))
  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >
  operator,(ap_int_base<_AP_W, _AP_S>& a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                         ap_int_base<_AP_W, _AP_S> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_range_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop == hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop < hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop <= hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<=(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= op2.V;
    return *this;
  };



  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline __attribute__((always_inline)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned to_uint() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (unsigned)(({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned long to_ulong() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (unsigned long)(({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (ap_ulong)(({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) bool and_reduce() const {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_722_1: for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret &= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) bool or_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_736_1: for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret |= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) bool xor_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_750_1: for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret ^= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }
# 766 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) char* to_string(signed char radix = 2) const {
    (void)(radix);
    return 0;
  }

};
# 806 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int d_index;

 public:

  inline __attribute__((always_inline)) ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}

  inline __attribute__((always_inline)) ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) ap_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}

  inline __attribute__((always_inline)) operator bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
  inline __attribute__((always_inline)) bool to_bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
# 844 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_bit_ref& operator=(bool val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(signed char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(short val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned short val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(int val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned int val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(long val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned long val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(ap_slong val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(ap_ulong val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
# 866 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_bit_ref& operator=(half val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(float val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(double val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(val.V != 0));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_int_base<_AP_W2, false>)val);
  }



  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_bit_ref& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      1, ap_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        1, ap_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() != op.get();
  }

  inline __attribute__((always_inline)) bool get() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) bool get() { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    operator=(val);
  }

  inline __attribute__((always_inline)) bool operator~() const {
    bool bit = ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) int length() const { return 1; }





  inline __attribute__((always_inline)) char* to_string() const { return 0; }

};
# 1064 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }






template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1123 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::div operator /(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::div operator /(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::div operator /(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
# 1146 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
# 1174 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())+( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())-( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())*( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())/( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())%( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())&( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())|( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())^( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())>>( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())<<( rhs.operator ap_int_base<_AP_W2, false>()); }
# 1223 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::plus operator +( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::minus operator -( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mult operator *( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::div operator /( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mod operator %( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator &( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator |( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator ^( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator >>( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator <<( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
# 1370 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op2); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op1); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
# 1394 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }

template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
# 59 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 2




template <int _AP_W>
struct ap_int : ap_int_base<_AP_W, true> {
  typedef ap_int_base<_AP_W, true> Base;

  inline __attribute__((always_inline)) ap_int() {}
  template <int _AP_W2>
                inline __attribute__((always_inline)) ap_int(const ap_int<_AP_W2>& op): Base((ap_int_base<_AP_W2, true>)op){



    op.checkOverflowCsim(_AP_W, true);

    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const volatile ap_int<_AP_W2>& op) {
    const_cast<const ap_int<_AP_W2>& >(op).checkOverflowCsim(_AP_W, true);
    Base::V = op.V;
  }

  template <int _AP_W2>
                inline __attribute__((always_inline)) ap_int(const ap_uint<_AP_W2>& op): Base((ap_int_base<_AP_W2, false>)op){



    op.checkOverflowCsim(_AP_W, true);

    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const volatile ap_uint<_AP_W2>& op) {
    const_cast<const ap_uint<_AP_W2>& >(op).checkOverflowCsim(_AP_W, true);
    Base::V = op.V;
  }




                inline __attribute__((always_inline)) ap_int(unsigned V __attribute__((bitwidth(_AP_W))), bool raw): Base(0) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) ap_int(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op) {

  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                inline __attribute__((always_inline)) ap_int(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                inline __attribute__((always_inline)) ap_int(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}







  inline __attribute__((always_inline)) ap_int(bool val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(signed char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(unsigned char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(short val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(unsigned short val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(int val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(unsigned int val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(long val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(unsigned long val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(ap_slong val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_int(ap_ulong val):Base(val){ this->checkOverflowBaseC(val); }

                ap_int(double val) : Base(val) {}
                ap_int(float val) : Base(val) {}
  ap_int(half val) : Base(val) {}


  inline __attribute__((always_inline)) ap_int(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_int(const char* s, signed char rd) : Base(s, rd) {}




  ap_int &operator=(const ap_int<_AP_W> &op2) = default;
# 207 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h"
  inline __attribute__((always_inline)) ap_int& operator=(const volatile ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) void operator=(const ap_int<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(const volatile ap_int<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

};




template <int _AP_W>
struct ap_uint : ap_int_base<_AP_W, false> {
  typedef ap_int_base<_AP_W, false> Base;

  inline __attribute__((always_inline)) ap_uint() {}
  template <int _AP_W2>
                inline __attribute__((always_inline)) ap_uint(const ap_uint<_AP_W2>& op):Base((ap_int_base<_AP_W2, false>)op) {
    op.checkOverflowCsim(_AP_W, false);

  }

  template <int _AP_W2>
                inline __attribute__((always_inline)) ap_uint(const ap_int<_AP_W2>& op):Base((ap_int_base<_AP_W2, true>)op) {
    op.checkOverflowCsim(_AP_W, false);

  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const volatile ap_uint<_AP_W2>& op) {
    const_cast<const ap_uint<_AP_W2>& >(op).checkOverflowCsim(_AP_W, false);
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const volatile ap_int<_AP_W2>& op) {
    const_cast<const ap_int<_AP_W2>& >(op).checkOverflowCsim(_AP_W, false);
    Base::V = op.V;
  }




                inline __attribute__((always_inline)) ap_uint(unsigned V __attribute__((bitwidth(_AP_W))), bool raw):Base(0) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op) {

  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}






  inline __attribute__((always_inline)) ap_uint(bool val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(signed char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(unsigned char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(short val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(unsigned short val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(int val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(unsigned int val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(long val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(unsigned long val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(ap_slong val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) ap_uint(ap_ulong val):Base(val) { this->checkOverflowBaseC(val); }

                ap_uint(double val) : Base(val) {}
                ap_uint(float val) : Base(val) {}
  ap_uint(half val) : Base(val) {}


  inline __attribute__((always_inline)) ap_uint(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_uint(const char* s, signed char rd) : Base(s, rd) {}





  ap_uint &operator=(const ap_uint<_AP_W> &op2) = default;
# 363 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h"
  inline __attribute__((always_inline)) ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) void operator=(const ap_uint<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(const volatile ap_uint<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

};
# 398 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_special.h" 1
# 61 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_special.h"
template <int _AP_W>
class complex<ap_int<_AP_W> > {
 public:
  typedef ap_int<_AP_W> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 222 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int_special.h"
template <int _AP_W>
inline bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W>
inline bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W>
inline bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W>
inline bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 399 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 2







# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h" 1
# 56 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h" 1
# 62 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 63 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h" 2
# 133 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
template <int _AP_W2, int _AP_I2, bool _AP_S2>
struct _ap_fixed_factory;
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, true> {
  typedef ap_fixed<_AP_W2, _AP_I2> type;
};
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, false> {
  typedef ap_ufixed<_AP_W2, _AP_I2> type;
};
# 154 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct ap_fixed_base : ssdm_int<_AP_W, _AP_S> {
 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;
  static const int width = _AP_W;
  static const int iwidth = _AP_I;
  static const ap_q_mode qmode = _AP_Q;
  static const ap_o_mode omode = _AP_O;


  template <int _AP_W2, int _AP_I2, bool _AP_S2>
  struct RType {
    enum {
      _AP_F = _AP_W - _AP_I,
      F2 = _AP_W2 - _AP_I2,
      mult_w = _AP_W + _AP_W2,
      mult_i = _AP_I + _AP_I2,
      mult_s = _AP_S || _AP_S2,
      plus_w = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
               1 + ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      plus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1 +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      minus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,

      div_w = _AP_S2 + _AP_W + ((F2) > (0) ? (F2) : (0)),



      div_i = _AP_S2 + _AP_I + F2,
      div_s = _AP_S || _AP_S2,
      logic_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      logic_i = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };

    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;
    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;

    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;
    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;
    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;
    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;
    typedef ap_fixed_base<div_w, div_i, div_s> div_base;
    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;

    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;
    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;
    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;
    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;
    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;
    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;
  };

 private:
# 341 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
                      inline __attribute__((always_inline)) void report() {}




                      inline __attribute__((always_inline)) void overflow_adjust(bool underflow, bool overflow, bool lD,
                              bool sign) {
    if (!underflow && !overflow) return;
    if (_AP_O == AP_WRAP) {
      if (_AP_N == 0) return;
      if (_AP_S) {


        Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        if (_AP_N > 1) {

          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
      } else {

        ap_int_base<_AP_W, false> mask(-1);
        Base::V =
            ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 1); __Result__; });
      }
    } else if (_AP_O == AP_SAT_ZERO) {
      Base::V = 0;
    } else if (_AP_O == AP_WRAP_SM && _AP_S) {
      bool Ro = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      if (_AP_N == 0) {
        if (lD != Ro) {
          Base::V = ~Base::V;
          Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(lD) __Repl2__ = !!lD; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        }
      } else {
        if (_AP_N == 1 && sign != Ro) {
          Base::V = ~Base::V;
        } else if (_AP_N > 1) {
          bool lNo = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - _AP_N); __Result__; });
          if (lNo == sign) Base::V = ~Base::V;
          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
        Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
      }
    } else {
      if (_AP_S) {
        if (overflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          Base::V = ~Base::V;
        } else if (underflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          if (_AP_O == AP_SAT_SYM) Base::V |= 1;
        }
      } else {
        if (overflow)
          Base::V = ~(ap_int_base<_AP_W, false>(0).V);
        else if (underflow)
          Base::V = 0;
      }
    }
  }

                      inline __attribute__((always_inline)) bool quantization_adjust(bool qb, bool r, bool s) {
    bool carry = (bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    if (_AP_Q == AP_TRN) return false;
    if (_AP_Q == AP_RND_ZERO)
      qb &= s || r;
    else if (_AP_Q == AP_RND_MIN_INF)
      qb &= r;
    else if (_AP_Q == AP_RND_INF)
      qb &= !s || r;
    else if (_AP_Q == AP_RND_CONV)
      qb &= ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 0); __Result__; }) || r;
    else if (_AP_Q == AP_TRN_ZERO)
      qb = s && (qb || r);
    Base::V += qb;
    return carry && (!(bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }));
  }


                      inline __attribute__((always_inline)) int countLeadingOnes() const {




    return 0;

  }

 public:



  inline __attribute__((always_inline)) ap_fixed_base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.V) {

    operator=(op);



    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op.V) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp(0);
    tmp.V = op.V;

    operator=(tmp);



    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }
# 502 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
  inline __attribute__((always_inline)) ap_fixed_base(const char* s) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) ap_fixed_base(const char* s, signed char rd) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    *this = ((bool)op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_fixed_base(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (bool(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }
# 570 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
  inline __attribute__((always_inline)) ap_fixed_base(const bool x) { ap_fixed_base<(1), (1), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const char x) { ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const signed char x) { ap_fixed_base<(8), (8), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned char x) { ap_fixed_base<(8), (8), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const ap_slong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const ap_ulong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)> tmp; tmp.V = x; *this = tmp; }







          ap_fixed_base(double d) {
    ap_int_base<64, false> ireg;
    ireg.V = doubleToRawBits(d);
    bool isneg = ({ __typeof__(ireg.V) __Val2__ = ireg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 63); __Result__; });

    ap_int_base<11 + 1, true> exp;
    ap_int_base<11, false> exp_tmp;
    exp_tmp.V =
        ({ typename _ap_type::remove_const<__typeof__(ireg.V)>::type __Result__ = 0; __typeof__(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, 52 + 11 - 1); __Result__; });
    exp = exp_tmp - ((1L << (11 - 1L)) - 1L);
    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(ireg.V)>::type __Result__ = 0; __typeof__(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));

    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });
    if (isneg) man = -man;
    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {
      Base::V = 0;
    } else {
      int _AP_W2 = 52 + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,
          F2 = _AP_W2 - _AP_I2;
      bool _AP_S2 = true,
           QUAN_INC = F2 > _AP_F &&
                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));
      bool carry = false;

      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
      if (F2 == _AP_F)
        Base::V = man.V;
      else if (F2 > _AP_F) {
        if (sh_amt < 52 + 2)
          Base::V = man.V >> sh_amt;
        else {
          Base::V = isneg ? -1 : 0;
        }
        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {
          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)({ __typeof__(man.V) __Val2__ = man.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

          bool r =
              (F2 > _AP_F + 1)
                  ? ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, (F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1)); __Result__; }) != 0


                  : false;
          carry = quantization_adjust(qb, r, isneg);
        }
      } else {
        Base::V = man.V;
        if (sh_amt < _AP_W)
          Base::V = Base::V << sh_amt;
        else
          Base::V = 0;
      }

      if ((_AP_O != AP_WRAP || _AP_N != 0) &&
          ((!_AP_S && _AP_S2) ||
           _AP_I - _AP_S <
               _AP_I2 - _AP_S2 +
                   (QUAN_INC ||
                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) {
        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;
        bool neg_src = isneg;
        bool lD = false;
        int pos1 = F2 - _AP_F + _AP_W;
        int pos2 = F2 - _AP_F + _AP_W + 1;
        bool newsignbit = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
        if (pos1 < _AP_W2 && pos1 >= 0)

          lD = (man.V >> pos1) & 1;
        if (pos1 < _AP_W2) {
          bool Range1_all_ones = true;
          bool Range1_all_zeros = true;
          bool Range2_all_ones = true;
          ap_int_base<52 + 2, false> Range2;
          ap_int_base<52 + 2, false> all_ones(-1);

          if (pos2 >= 0 && pos2 < _AP_W2) {


            Range2.V = man.V;
            Range2.V >>= pos2;
            Range2_all_ones = Range2 == (all_ones >> pos2);
          } else if (pos2 < 0)
            Range2_all_ones = false;
          if (pos1 >= 0 && pos2 < _AP_W2) {
            Range1_all_ones = Range2_all_ones && lD;
            Range1_all_zeros = !Range2.V && !lD;
          } else if (pos2 == _AP_W2) {
            Range1_all_ones = lD;
            Range1_all_zeros = !lD;
          } else if (pos1 < 0) {
            Range1_all_zeros = !man.V;
            Range1_all_ones = false;
          }

          deleted_zeros =
              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
          deleted_ones =
              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
          neg_src = isneg && !(carry && Range1_all_ones);
        } else
          neg_src = isneg && newsignbit;
        bool neg_trg = _AP_S && newsignbit;
        bool overflow = (neg_trg || !deleted_zeros) && !isneg;
        bool underflow = (!neg_trg || !deleted_ones) && neg_src;
        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
          underflow |=
              neg_src &&
              (_AP_W > 1 ? ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                         : true);
        overflow_adjust(underflow, overflow, lD, neg_src);
      }
    }
    report();
  }


  inline __attribute__((always_inline)) ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }


  inline __attribute__((always_inline)) ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }
# 844 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {

    const int _AP_F = _AP_W - _AP_I;
    const int F2 = _AP_W2 - _AP_I2;
    const int QUAN_INC =
          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));

    if (!op) Base::V = 0;
    bool carry = false;
    bool signbit = ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    bool isneg = signbit && _AP_S2;
    if (F2 == _AP_F)
      Base::V = op.V;
    else if (F2 > _AP_F) {
      unsigned int sh_amt = F2 - _AP_F;

      if (sh_amt < _AP_W2) {
        Base::V = op.V >> sh_amt;
      } else {
        Base::V = isneg ? -1 : 0;
      }
      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {
        bool qbit = ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;
        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };

        bool r = (F2 > _AP_F + 1) ? (({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, hi); __Result__; }) != 0) : false;
        carry = quantization_adjust(qb, r, isneg);
      }
    } else {
      unsigned sh_amt = _AP_F - F2;

      if (sh_amt < _AP_W) {
        if (_AP_W > _AP_W2) {

          Base::V = op.V;
          Base::V <<= sh_amt;
        } else {

          Base::V = op.V << sh_amt;
        }
      } else {
        Base::V = 0;
      }
    }

    if ((_AP_O != AP_WRAP || _AP_N != 0) &&
        ((!_AP_S && _AP_S2) ||
         _AP_I - _AP_S <
             _AP_I2 - _AP_S2 +
                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) {
      bool deleted_zeros = _AP_S2 ? true : !carry;
      bool deleted_ones = true;
      bool neg_src = isneg;
      bool newsignbit = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };
      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), pos1); __Result__; })
                                             : false;
      if (pos1 < _AP_W2) {
        bool Range1_all_ones = true;
        bool Range1_all_zeros = true;
        bool Range2_all_ones = true;
        ap_int_base<_AP_W2, false> all_ones(-1);

        if (pos2 < _AP_W2 && pos2 >= 0) {
          ap_int_base<_AP_W2, false> Range2(0);
          Range2.V = ({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos2, _AP_W2 - 1); __Result__; });
          Range2_all_ones = Range2 == (all_ones >> pos2);
        } else if (pos2 < 0) {
          Range2_all_ones = false;
        }

        if (pos1 >= 0 && pos2 < _AP_W2) {
          ap_int_base<_AP_W2, false> Range1(0);
          Range1.V = ({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, _AP_W2 - 1); __Result__; });
          Range1_all_ones = Range1 == (all_ones >> pos1);
          Range1_all_zeros = !Range1.V;
        } else if (pos2 == _AP_W2) {
          Range1_all_ones = lD;
          Range1_all_zeros = !lD;
        } else if (pos1 < 0) {
          Range1_all_zeros = !op.V;
          Range1_all_ones = false;
        }

        deleted_zeros =
            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
        deleted_ones =
            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
        neg_src = isneg && !(carry && Range1_all_ones);
      } else
        neg_src = isneg && newsignbit;
      bool neg_trg = _AP_S && newsignbit;
      bool overflow = (neg_trg || !deleted_zeros) && !isneg;
      bool underflow = (!neg_trg || !deleted_ones) && neg_src;
      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
        underflow |=
            neg_src &&
            (_AP_W > 1 ? ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                       : true);

      overflow_adjust(underflow, overflow, lD, neg_src);
    }
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator=(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));
    return *this;
  }


                      inline __attribute__((always_inline)) ap_fixed_base& setBits(ap_ulong bv) {

    Base::V = bv;
    return *this;
  }


  static inline __attribute__((always_inline)) ap_fixed_base bitsToFixed(ap_ulong bv) {

    ap_fixed_base t;

    t.V = bv;



    return t;
  }

                      inline __attribute__((always_inline)) void checkOverflowCsimFix(int _ap_w2, bool _ap_s2) const {
# 1017 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
      (void)_ap_w2;
      (void)_ap_s2;

      return;
  }





                      inline __attribute__((always_inline)) ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> to_ap_int_base(
      bool Cnative = true) const {
    ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> ret(0);
    if (_AP_I == 0) {
      ret.V = 0;
    } else if (_AP_I > 0 && _AP_I <= _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_I, _AP_W - 1); __Result__; });
    } else if (_AP_I > _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 1); __Result__; });
      ret.V <<= (_AP_I - _AP_W);
    }
# 1046 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
    if (Cnative && _AP_I < _AP_W) {

      if (_AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }) && (_AP_I < _AP_W) &&
          (({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1); __Result__; }) != (unsigned long)0))


        ret = ret + 1;
    } else {

    }
    return ret;
  };

 public:
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) operator ap_int_base<_AP_W2, _AP_S2>() const {
    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());
  }


                      inline __attribute__((always_inline)) char to_char() const { return to_ap_int_base().to_char(); }

                      inline __attribute__((always_inline)) int to_int() const { return to_ap_int_base().to_int(); }

                      inline __attribute__((always_inline)) unsigned to_uint() const { return to_ap_int_base().to_uint(); }

                      inline __attribute__((always_inline)) ap_slong to_int64() const { return to_ap_int_base().to_int64(); }

                      inline __attribute__((always_inline)) ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }

                      inline __attribute__((always_inline)) ap_int<_AP_I> to_ap_int() const { return ap_int<_AP_I>(to_ap_int_base()); }



  inline __attribute__((always_inline)) double to_double() const {




    enum { BITS = 52 + 11 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp(0);
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (11 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 52;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    ap_ulong m = 0;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))
                           : (ap_ulong)(tmp.V << (1 - lsb_index));
    } else {
      m = (ap_ulong)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;


    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 52 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52 + 11 - 1); __Result__; });


    return rawBitsToDouble(m);
  }



  inline __attribute__((always_inline)) float to_float() const {




    enum { BITS = 23 + 8 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (8 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 23;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned long m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))
                           : (unsigned long)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned long)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 23 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23 + 8 - 1); __Result__; });

    return rawBitsToFloat(m);
  }



  inline __attribute__((always_inline)) half to_half() const {




    enum { BITS = 10 + 5 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (5 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 10;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned short m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))
                           : (unsigned short)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned short)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 10 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 10, 10 + 5 - 1); __Result__; });

    return rawBitsToHalf(m);
  }


  inline __attribute__((always_inline)) operator long double() const { return (long double)to_double(); }

  inline __attribute__((always_inline)) operator double() const { return to_double(); }

  inline __attribute__((always_inline)) operator float() const { return to_float(); }

  inline __attribute__((always_inline)) operator half() const { return to_half(); }

                      inline __attribute__((always_inline)) operator bool() const { return (bool)Base::V != 0; }

                      inline __attribute__((always_inline)) operator char() const { return (char)to_int(); }

                      inline __attribute__((always_inline)) operator signed char() const { return (signed char)to_int(); }

                      inline __attribute__((always_inline)) operator unsigned char() const { return (unsigned char)to_uint(); }

                      inline __attribute__((always_inline)) operator short() const { return (short)to_int(); }

                      inline __attribute__((always_inline)) operator unsigned short() const { return (unsigned short)to_uint(); }

                      inline __attribute__((always_inline)) operator int() const { return to_int(); }

                      inline __attribute__((always_inline)) operator unsigned int() const { return to_uint(); }



                      inline __attribute__((always_inline)) operator long() const { return (long)to_int64(); }

                      inline __attribute__((always_inline)) operator unsigned long() const { return (unsigned long)to_uint64(); }






                      inline __attribute__((always_inline)) operator ap_ulong() const { return to_uint64(); }

                      inline __attribute__((always_inline)) operator ap_slong() const { return to_int64(); }

                      inline __attribute__((always_inline)) int length() const { return _AP_W; };
# 1275 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
                      inline __attribute__((always_inline)) int countLeadingZeros() const {


    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return __builtin_ctzll(t.V);
    } else {
      enum {__N = (_AP_W + 63) / 64};
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      VITIS_LOOP_1291_1: for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.range(0, 63) = this->range(_AP_W - i * 64 - 64, _AP_W - i * 64 - 1);
        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V);
        hitNonZero |= (t != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        t.range(63 - (_AP_W - 1) % 64, 63) = this->range(0, (_AP_W - 1) % 64);
        NZeros += __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r(0), t(0);
    r.V = Base::V;
    t.V = op2.V;
    r.V *= op2.V;
    return r;
  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;
# 1345 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
        ap_fixed_base<_AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)),_AP_I, _AP_S> t(*this);



        r.V = t.V / op2.V;
# 1378 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
    return r;
  }
# 1393 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::plus_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V + rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::minus_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V - rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V & rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V | rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V ^ rhs.V; return ret; }
# 1411 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator *=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator *(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator /=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator /(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator +=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator +(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator -=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator -(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator &=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator &(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator |=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator |(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator ^=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator ^(op2); return *this; }





  inline __attribute__((always_inline)) ap_fixed_base& operator++() {
    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) ap_fixed_base& operator--() {
    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) const ap_fixed_base operator++(int) {
    ap_fixed_base r(*this);
    operator++();
    return r;
  }


  inline __attribute__((always_inline)) const ap_fixed_base operator--(int) {
    ap_fixed_base r(*this);
    operator--();
    return r;
  }



  inline __attribute__((always_inline)) typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type operator+() { return *this; }

                      inline __attribute__((always_inline)) typename _ap_fixed_factory<_AP_W + 1, _AP_I + 1, true>::type operator-() const {
    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);
    r.V = -r.V;
    return r;
  }

                      inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {
    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);
    r.V = -r.V;
    return r;
  }



                      inline __attribute__((always_inline)) bool operator!() const { return Base::V == (unsigned long)0; }




                      inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {
    ap_fixed_base<_AP_W, _AP_I, _AP_S> r(0);
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_SHIFT>
                      inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {
    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r(0);
    r.V = Base::V;
    return r;
  }

  template <int _AP_SHIFT>
                      inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {
    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r(0);
    r.V = Base::V;
    return r;
  }





                      inline __attribute__((always_inline)) ap_fixed_base operator<<(unsigned int sh) const {
    ap_fixed_base r(0);
    r.V = Base::V << sh;
# 1529 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
    return r;
  }

                      inline __attribute__((always_inline)) ap_fixed_base operator>>(unsigned int sh) const {
    ap_fixed_base r(0);
    r.V = Base::V >> sh;
# 1551 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
    return r;
  }


                      inline __attribute__((always_inline)) ap_fixed_base operator<<(int sh) const {
    ap_fixed_base r(0);
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator>>(ush);
    } else {
      return operator<<(ush);
    }
  }

                      inline __attribute__((always_inline)) ap_fixed_base operator>>(int sh) const {
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator<<(ush);
    } else {
      return operator>>(ush);
    }
  }


  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {


    int sh = op2.to_int();
    return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    int sh = op2.to_int();
    return operator>>(sh);
  }


  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator>>(sh);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base operator<<(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator<<(op2.to_ap_int_base());
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base operator>>(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator>>(op2.to_ap_int_base());
  }





                      inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const int sh) {
    *this = operator<<(sh);
    return *this;
  }

                      inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const unsigned int sh) {
    *this = operator<<(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator<<=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }


                      inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const int sh) {
    *this = operator>>(sh);
    return *this;
  }

                      inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const unsigned int sh) {
    *this = operator>>(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator>>=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }
# 1695 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V > op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V < op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V >= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V <= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator ==(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V == op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator !=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V != op2.V; return false; }





  inline __attribute__((always_inline)) bool operator >(double d) const { return to_double() > d; }
  inline __attribute__((always_inline)) bool operator <(double d) const { return to_double() < d; }
  inline __attribute__((always_inline)) bool operator >=(double d) const { return to_double() >= d; }
  inline __attribute__((always_inline)) bool operator <=(double d) const { return to_double() <= d; }
  inline __attribute__((always_inline)) bool operator ==(double d) const { return to_double() == d; }
  inline __attribute__((always_inline)) bool operator !=(double d) const { return to_double() != d; }


  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

                      inline __attribute__((always_inline)) bool operator[](unsigned index) const {
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

                      inline __attribute__((always_inline)) bool bit(unsigned index) const {
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(
      const ap_int_base<_AP_W2, true>& index) {
    (static_cast<void>(0));

    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        this, index.to_int() + _AP_W - _AP_I);
  }

                      inline __attribute__((always_inline)) bool get_bit(int index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index + _AP_W - _AP_I); __Result__; });

  }
# 1781 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2>
                      inline __attribute__((always_inline)) bool get_bit(const ap_int_base<_AP_W2, true>& index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index.to_int() + _AP_W - _AP_I); __Result__; });

  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,
                                                                      int Lo) {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      int Hi, int Lo) const {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        const_cast<ap_fixed_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

                      inline __attribute__((always_inline)) bool is_zero() const { return Base::V == (unsigned long)0; }

                      inline __attribute__((always_inline)) bool is_neg() const {
    if (_AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; })) return true;
    return false;
  }

                      inline __attribute__((always_inline)) int wl() const { return _AP_W; }

                      inline __attribute__((always_inline)) int iwl() const { return _AP_I; }

                      inline __attribute__((always_inline)) ap_q_mode q_mode() const { return _AP_Q; }

                      inline __attribute__((always_inline)) ap_o_mode o_mode() const { return _AP_O; }

                      inline __attribute__((always_inline)) int n_bits() const { return _AP_N; }
# 1964 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
  inline __attribute__((always_inline)) char* to_string(unsigned char radix = 2, bool sign = _AP_S) const {
    (void)(radix);
    (void)(sign);
    return 0;
  }

};

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) void b_not(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
  ret.V = ~op.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) void b_and(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V & op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) void b_or(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V | op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) void b_xor(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V ^ op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) void neg(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,
                _AP_N2>
      t(0);
  t.V = -op.V;
  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) void lshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F2 = _AP_W2 - _AP_I2,
    _AP_I3 = ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)),
    _AP_W3 = _AP_I3 + F2,
  };

  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t(0);
  t.V = op.V;
  t.V <<= i;

  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) void rshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F = _AP_W - _AP_I,
    F2 = _AP_W2 - _AP_I2,
    F3 = ((F) > (F2) ? (F) : (F2)),
    _AP_W3 = _AP_I2 + F3,
    sh = F - F2,
  };

  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t(0);
  t.V = op.V;
  if (sh >= 0)
    t.V <<= (int) sh;
  t.V >>= i;

  ret = t;
}
# 2416 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ==(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator !=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator !=(op); }
# 2504 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::plus operator +( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::minus operator -( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::mult operator *( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::div operator /( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator &( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator |( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator ^( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator +=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator +=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator -=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator -=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator *=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator *=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator /=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator /=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator &=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator &=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator |=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator |=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator ^=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator ^=(op.to_ap_int_base()); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ==(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ==(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator !=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <=(op); }




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator==(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator==(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator!=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator!=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator>(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator>=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator<(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator<=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>=(op1);
}
# 57 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_ref.h" 1
# 71 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int d_index;

 public:
  inline __attribute__((always_inline)) af_bit_ref(
      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {






  }

  inline __attribute__((always_inline)) af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) af_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}


  inline __attribute__((always_inline)) operator bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }



  inline __attribute__((always_inline)) af_bit_ref& operator=(bool val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
    return *this;
  }



  inline __attribute__((always_inline)) af_bit_ref& operator=(const af_bit_ref& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=(val != 0);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));
  }




  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,
                                                                        op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      1, af_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        1, af_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator==(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator!=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() != op.get();
  }


  inline __attribute__((always_inline)) bool operator~() const {
    bool bit = ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) bool get() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) int length() const { return 1; }





  inline __attribute__((always_inline)) char* to_string() const { return 0; }

};
# 258 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:

  inline __attribute__((always_inline)) af_range_ref(
      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}




  inline __attribute__((always_inline)) af_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {
# 288 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_ref.h"
  }

  inline __attribute__((always_inline)) af_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {
# 300 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_ref.h"
  }
# 312 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_ref.h"
  inline __attribute__((always_inline)) af_range_ref& operator=(const bool val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_slong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_ulong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const half val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const float val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const double val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }



  inline __attribute__((always_inline)) af_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }



  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) af_range_ref& operator=(const af_range_ref& val) {
    ap_int_base<_AP_W, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);
    return operator=(tmp);
  }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator==(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator!=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator<(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator>(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator<=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator>=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator<(op2));
  }





  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  inline __attribute__((always_inline)) operator ap_ulong() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret.to_uint64();
  }

  inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> to_ap_int_base() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }


  inline __attribute__((always_inline)) char to_char() const {
    return (char)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned to_uint() const {
    return (unsigned)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned long to_ulong() const {
    return (unsigned long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const {
    return (ap_ulong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }



  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }
# 661 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_ref.h"
  inline __attribute__((always_inline)) char* to_string(signed char rd = 2) const {
     (void)(rd);
    return 0;
  }

};
# 725 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
# 771 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<1, false>(op); }
# 58 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h" 2





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) ap_fixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                      _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                               _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 112 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) ap_fixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 147 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}





                      inline __attribute__((always_inline)) ap_fixed(bool v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(char v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(signed char v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(unsigned char v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(short v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(unsigned short v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(int v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(unsigned int v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(long v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(unsigned long v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(ap_slong v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_fixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) ap_fixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_fixed(const char* s, signed char rd) : Base(s, rd) {}







  ap_fixed &
  operator=(const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;
# 214 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h"
  inline __attribute__((always_inline)) void operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) ap_fixed& operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) void operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }
};





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) ap_ufixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                       _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                                _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 283 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) ap_ufixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 315 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}




                      inline __attribute__((always_inline)) ap_ufixed(bool v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(char v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(signed char v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(unsigned char v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(short v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(unsigned short v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(int v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(unsigned int v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(long v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(unsigned long v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(ap_slong v) : Base(v) {}
                      inline __attribute__((always_inline)) ap_ufixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) ap_ufixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}



  ap_ufixed &
  operator=(const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;
# 373 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h"
  inline __attribute__((always_inline)) void operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) ap_ufixed& operator=(
      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                                 _AP_N>& op) volatile {
    Base::V = op.V;
  }
};
# 411 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_special.h" 1
# 61 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    auto tmp1 = __z;
    complex<_Tp> tmp2 = {tmp1.real(), tmp1.imag()};
    *this = tmp2;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 231 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    auto tmp1 = __z;
    complex<_Tp> tmp2 = {tmp1.real(), tmp1.imag()};
    *this = tmp2;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 364 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 412 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_fixed.h" 2
# 407 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 2
# 24 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_common.hpp" 1
# 20 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_common.hpp"
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp" 1
# 27 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_axi_sdata.h" 1
# 87 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_axi_sdata.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/climits" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/climits" 3

# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 236 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 258 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 508 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 39 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 464 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 465 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/os_defines.h" 2 3
# 509 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 512 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 42 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/climits" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/limits.h" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 81 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4
extern "C" {
extern long int __sysconf (int __name) noexcept (true);
}
# 82 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 38 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/limits.h" 2 3
# 43 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/climits" 2 3
# 88 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_axi_sdata.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 89 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_axi_sdata.h" 2

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed;
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed;

namespace hls {

template <typename T> constexpr std::size_t bitwidth = sizeof(T) * 8;

template <std::size_t W> constexpr std::size_t bitwidth<ap_int<W>> = W;
template <std::size_t W> constexpr std::size_t bitwidth<ap_uint<W>> = W;
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
constexpr std::size_t bitwidth<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>> = _AP_W;
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
constexpr std::size_t bitwidth<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>> = _AP_W;

template <typename T>
constexpr std::size_t bytewidth = (bitwidth<T> + 8 - 1) / 8;

template <typename T, std::size_t WUser, std::size_t WId, std::size_t WDest> struct axis {
  static constexpr std::size_t NewWUser = (WUser == 0) ? 1 : WUser;
  static constexpr std::size_t NewWId = (WId == 0) ? 1 : WId;
  static constexpr std::size_t NewWDest = (WDest == 0) ? 1 : WDest;
  T data;
  ap_uint<bytewidth<T>> keep;
  ap_uint<bytewidth<T>> strb;
  ap_uint<NewWUser> user;
  ap_uint<1> last;
  ap_uint<NewWId> id;
  ap_uint<NewWDest> dest;

  ap_uint<NewWUser> *get_user_ptr() {
#pragma HLS inline
 return (WUser == 0) ? nullptr : &user;
  }
  ap_uint<NewWId> *get_id_ptr() {
#pragma HLS inline
 return (WId == 0) ? nullptr : &id;
  }
  ap_uint<NewWDest> *get_dest_ptr() {
#pragma HLS inline
 return (WDest == 0) ? nullptr : &dest;
  }
};

}

template <std::size_t WData, std::size_t WUser, std::size_t WId, std::size_t WDest>
using ap_axis = hls::axis<ap_int<WData>, WUser, WId, WDest>;

template <std::size_t WData, std::size_t WUser, std::size_t WId, std::size_t WDest>
using ap_axiu = hls::axis<ap_uint<WData>, WUser, WId, WDest>;


template <std::size_t WData, std::size_t WUser, std::size_t WId, std::size_t WDest>
struct qdma_axis;

template <std::size_t WData> struct qdma_axis<WData, 0, 0, 0> {

  static constexpr std::size_t kBytes = (WData + 7) / 8;

  ap_uint<WData> data;
  ap_uint<kBytes> keep;
  ap_uint<1> strb;
  ap_uint<1> user;
  ap_uint<1> last;
  ap_uint<1> id;
  ap_uint<1> dest;

  ap_uint<1> *get_strb_ptr() {
#pragma HLS inline
 return nullptr;
  }
  ap_uint<1> *get_user_ptr() {
#pragma HLS inline
 return nullptr;
  }
  ap_uint<1> *get_id_ptr() {
#pragma HLS inline
 return nullptr;
  }
  ap_uint<1> *get_dest_ptr() {
#pragma HLS inline
 return nullptr;
  }


  ap_uint<WData> get_data() const {
#pragma HLS inline
 return data;
  }
  ap_uint<kBytes> get_keep() const {
#pragma HLS inline
 return keep;
  }
  ap_uint<1> get_last() const {
#pragma HLS inline
 return last;
  }

  void set_data(const ap_uint<WData> &d) {
#pragma HLS inline
 data = d;
  }
  void set_keep(const ap_uint<kBytes> &k) {
#pragma HLS inline
 keep = k;
  }
  void set_last(const ap_uint<1> &l) {
#pragma HLS inline
 last = l;
  }
  void keep_all() {
#pragma HLS inline
 ap_uint<kBytes> k = 0;
    keep = ~k;
  }

  qdma_axis() {
#pragma HLS inline
 ;
  }
  qdma_axis(ap_uint<WData> d) : data(d) {
#pragma HLS inline
 ;
  }
  qdma_axis(ap_uint<WData> d, ap_uint<kBytes> k) : data(d), keep(k) {
#pragma HLS inline
 ;
  }
  qdma_axis(ap_uint<WData> d, ap_uint<kBytes> k, ap_uint<1> l)
      : data(d), keep(k), last(l) {
#pragma HLS inline
 ;
  }
  qdma_axis(const qdma_axis<WData, 0, 0, 0> &d)
      : data(d.data), keep(d.keep), last(d.last) {
#pragma HLS inline
 ;
  }
  qdma_axis &operator=(const qdma_axis<WData, 0, 0, 0> &d) {
#pragma HLS inline
 data = d.data;
    keep = d.keep;
    last = d.last;
    return *this;
  }
};




namespace hls {

template <typename T, std::size_t WUser, std::size_t WId, std::size_t WDest>
class stream<axis<T, WUser, WId, WDest>> final {
  typedef axis<T, WUser, WId, WDest> __STREAM_T__;

public:

  inline __attribute__((always_inline)) stream() {}

  inline __attribute__((always_inline)) stream(const char *name) { (void)name; }


private:
  inline __attribute__((always_inline)) stream(const stream<__STREAM_T__> &chn) : V(chn.V) {}

public:

  inline __attribute__((always_inline)) void operator>>(__STREAM_T__ &rdata) { read(rdata); }

  inline __attribute__((always_inline)) void operator<<(const __STREAM_T__ &wdata) { write(wdata); }


  bool empty() {
#pragma HLS inline
 bool tmp = __fpga_axis_valid(&V.data, &V.keep, &V.strb, V.get_user_ptr(),
                                 &V.last, V.get_id_ptr(), V.get_dest_ptr());
    return !tmp;
  }

  bool full() {
#pragma HLS inline
 bool tmp = __fpga_axis_ready(&V.data, &V.keep, &V.strb, V.get_user_ptr(),
                                 &V.last, V.get_id_ptr(), V.get_dest_ptr());
    return !tmp;
  }


  void read(__STREAM_T__ &dout) {
#pragma HLS inline
 __STREAM_T__ tmp;
    __fpga_axis_pop(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                    V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                    &tmp.strb, tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                    tmp.get_dest_ptr());
    dout = tmp;
  }

  __STREAM_T__ read() {
#pragma HLS inline
 __STREAM_T__ tmp;
    __fpga_axis_pop(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                    V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                    &tmp.strb, tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                    tmp.get_dest_ptr());
    return tmp;
  }


  void write(const __STREAM_T__ &din) {
#pragma HLS inline
 __STREAM_T__ tmp = din;
    __fpga_axis_push(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                     V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                     &tmp.strb, tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                     tmp.get_dest_ptr());
  }


  bool read_nb(__STREAM_T__ &dout) {
#pragma HLS inline
 __STREAM_T__ tmp;
    if (__fpga_axis_nb_pop(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                           V.get_id_ptr(), V.get_dest_ptr(), &tmp.data,
                           &tmp.keep, &tmp.strb, tmp.get_user_ptr(),
                           &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr())) {
      dout = tmp;
      return true;
    } else {
      return false;
    }
  }


  bool write_nb(const __STREAM_T__ &in) {
#pragma HLS inline
 __STREAM_T__ tmp = in;
    bool full_n = __fpga_axis_nb_push(
        &V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last, V.get_id_ptr(),
        V.get_dest_ptr(), &tmp.data, &tmp.keep, &tmp.strb, tmp.get_user_ptr(),
        &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr());
    return full_n;
  }

private:
  __STREAM_T__ V __attribute__((no_ctor));
};


template <std::size_t WData>
class stream<qdma_axis<WData, 0, 0, 0>> {
  typedef qdma_axis<WData, 0, 0, 0> __STREAM_T__;

public:

  inline __attribute__((always_inline)) stream() {}

  inline __attribute__((always_inline)) stream(const char *name) { (void)name; }


private:
  inline __attribute__((always_inline)) stream(const stream<__STREAM_T__> &chn) : V(chn.V) {}

public:

  inline __attribute__((always_inline)) void operator>>(__STREAM_T__ &rdata) { read(rdata); }

  inline __attribute__((always_inline)) void operator<<(const __STREAM_T__ &wdata) { write(wdata); }


  bool empty() {
#pragma HLS inline
 bool tmp = __fpga_axis_valid(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(),
                                 &V.last, V.get_id_ptr(), V.get_dest_ptr());
    return !tmp;
  }

  bool full() {
#pragma HLS inline
 bool tmp = __fpga_axis_ready(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(),
                                 &V.last, V.get_id_ptr(), V.get_dest_ptr());
    return !tmp;
  }


  void read(__STREAM_T__ &dout) {
#pragma HLS inline
 __STREAM_T__ tmp;
    __fpga_axis_pop(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(),
                    &V.last, V.get_id_ptr(), V.get_dest_ptr(), &tmp.data,
                    &tmp.keep, tmp.get_strb_ptr(), tmp.get_user_ptr(),
                    &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr());
    dout = tmp;
  }

  __STREAM_T__ read() {
#pragma HLS inline
 __STREAM_T__ tmp;
    __fpga_axis_pop(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(), &V.last,
                    V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                    tmp.get_strb_ptr(), tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                    tmp.get_dest_ptr());
    return tmp;
  }


  void write(const __STREAM_T__ &din) {
#pragma HLS inline
 __STREAM_T__ tmp = din;
    __fpga_axis_push(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(), &V.last,
                     V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                     tmp.get_strb_ptr(), tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                     tmp.get_dest_ptr());
  }


  bool read_nb(__STREAM_T__ &dout) {
#pragma HLS inline
 __STREAM_T__ tmp;

    if (__fpga_axis_nb_pop(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                           V.get_id_ptr(), V.get_dest_ptr(), &tmp.data,
                           &tmp.keep, &tmp.strb, tmp.get_user_ptr(),
                           &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr())) {
      dout = tmp;
      return true;
    } else {
      return false;
    }
  }


  bool write_nb(const __STREAM_T__ &in) {
#pragma HLS inline
 __STREAM_T__ tmp = in;
    bool full_n = __fpga_axis_nb_push(
        &V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(), &V.last, V.get_id_ptr(),
        V.get_dest_ptr(), &tmp.data, &tmp.keep, tmp.get_strb_ptr(), tmp.get_user_ptr(),
        &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr());
    return full_n;
  }

private:
  __STREAM_T__ V __attribute__((no_ctor));
};

}
# 28 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp" 2

# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_types.hpp" 1
# 24 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_types.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 25 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_types.hpp" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_params.hpp" 1
# 24 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_params.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 25 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_params.hpp" 2




enum _channel_extract {
    XF_EXTRACT_CH_0,
    XF_EXTRACT_CH_1,
    XF_EXTRACT_CH_2,
    XF_EXTRACT_CH_3,
    XF_EXTRACT_CH_R,
    XF_EXTRACT_CH_G,
    XF_EXTRACT_CH_B,
    XF_EXTRACT_CH_A,
    XF_EXTRACT_CH_Y,
    XF_EXTRACT_CH_U,
    XF_EXTRACT_CH_V
};
typedef _channel_extract XF_channel_extract_e;


enum _convert_policy { XF_CONVERT_POLICY_SATURATE, XF_CONVERT_POLICY_TRUNCATE };
typedef _convert_policy XF_convert_policy_e;


enum _convert_bit_depth {

    XF_CONVERT_16U_TO_8U,
    XF_CONVERT_16S_TO_8U,
    XF_CONVERT_32S_TO_8U,
    XF_CONVERT_32S_TO_16U,
    XF_CONVERT_32S_TO_16S,

    XF_CONVERT_8U_TO_16U,
    XF_CONVERT_8U_TO_16S,
    XF_CONVERT_8U_TO_32S,
    XF_CONVERT_16U_TO_32S,
    XF_CONVERT_16S_TO_32S
};
typedef _convert_bit_depth XF_convert_bit_depth_e;


enum _threshold_type {
    XF_THRESHOLD_TYPE_BINARY = 0,
    XF_THRESHOLD_TYPE_BINARY_INV = 1,
    XF_THRESHOLD_TYPE_TRUNC = 2,
    XF_THRESHOLD_TYPE_TOZERO = 3,
    XF_THRESHOLD_TYPE_TOZERO_INV = 4,
};
typedef _threshold_type XF_threshold_type_e;


enum _ccm_type {
    XF_CCM_bt2020_bt709 = 0,
    XF_CCM_bt709_bt2020 = 1,
    XF_CCM_rgb_yuv_601 = 2,
    XF_CCM_rgb_yuv_709 = 3,
    XF_CCM_rgb_yuv_2020 = 4,
    XF_CCM_yuv_rgb_601 = 5,
    XF_CCM_yuv_rgb_709 = 6,
    XF_CCM_yuv_rgb_2020 = 7,
    XF_CCM_full_from_16_235 = 8,
    XF_CCM_full_to_16_235 = 9,

};
typedef _ccm_type XF_ccm_type_e;


enum _comparison_op { XF_CMP_EQ = 0, XF_CMP_GT = 1, XF_CMP_GE = 2, XF_CMP_LT = 3, XF_CMP_LE = 4, XF_CMP_NE = 5 };
typedef _comparison_op _comparison_op_e;


enum _reduction_op { REDUCE_SUM = 0, REDUCE_AVG = 1, REDUCE_MAX = 2, REDUCE_MIN = 3 };
typedef _reduction_op _reduction_op_e;


enum _pixel_per_cycle {
    XF_NPPC1 = 1,
    XF_NPPC2 = 2,
    XF_NPPC4 = 4,
    XF_NPPC8 = 8,
    XF_NPPC16 = 16,
    XF_NPPC32 = 32,
    XF_NPPC64 = 64
};
typedef _pixel_per_cycle XF_nppc_e;


enum _pixel_type {
    XF_8UP = 0,
    XF_8SP = 1,
    XF_16UP = 2,
    XF_16SP = 3,
    XF_32UP = 4,
    XF_32SP = 5,
    XF_19SP = 6,
    XF_32FP = 7,
    XF_35SP = 8,
    XF_24SP = 9,
    XF_20SP = 10,
    XF_48SP = 11,
    XF_2UP = 12,
    XF_9SP = 13,
    XF_9UP = 14,
    XF_24UP = 15,
    XF_64UP = 16,
    XF_10UP = 17,
    XF_12UP = 18,
    XF_40UP = 19,
    XF_48UP = 20,
    XF_30UP = 21,
    XF_36UP = 22,
    XF_96FP = 23
};
typedef _pixel_type XF_pixel_type_e;


enum _word_width {
    XF_2UW = 0,
    XF_8UW = 1,
    XF_9UW = 2,
    XF_10UW = 3,
    XF_12UW = 4,
    XF_16UW = 5,
    XF_19SW = 6,
    XF_20UW = 7,
    XF_22UW = 8,
    XF_24UW = 9,
    XF_24SW = 10,
    XF_30UW = 11,
    XF_32UW = 12,
    XF_32FW = 13,
    XF_35SW = 14,
    XF_36UW = 15,
    XF_40UW = 16,
    XF_48UW = 17,
    XF_48SW = 18,
    XF_60UW = 19,
    XF_64UW = 20,
    XF_72UW = 21,
    XF_80UW = 22,
    XF_96UW = 23,
    XF_96SW = 24,
    XF_120UW = 25,
    XF_128UW = 26,
    XF_144UW = 27,
    XF_152SW = 28,
    XF_160UW = 29,
    XF_160SW = 30,
    XF_176UW = 31,
    XF_192UW = 32,
    XF_192SW = 33,
    XF_240UW = 34,
    XF_256UW = 35,
    XF_280SW = 36,
    XF_288UW = 37,
    XF_304SW = 38,
    XF_320UW = 39,
    XF_352UW = 40,
    XF_384UW = 41,
    XF_384SW = 42,
    XF_512UW = 43,
    XF_560SW = 44,
    XF_576UW = 45,
    XF_96FW = 46,
    XF_192FW = 47,
    XF_384FW = 48,
    XF_768FW = 49,
    XF_1536FW = 50
};
typedef _word_width XF_word_width_e;


enum _filter_size { XF_FILTER_3X3 = 3, XF_FILTER_5X5 = 5, XF_FILTER_7X7 = 7 };
typedef _filter_size XF_filter_size_e;


enum _nms_radius { XF_NMS_RADIUS_1 = 1, XF_NMS_RADIUS_2 = 2, XF_NMS_RADIUS_3 = 3 };
typedef _nms_radius XF_nms_radius_e;


enum _image_pyramid_params {
    XF_PYRAMID_TYPE_GXFSSIAN = 0,
    XF_PYRAMID_TYPE_LAPLACIAN = 1,
    XF_PYRAMID_SCALE_HALF = 2,
    XF_PYRAMID_SCALE_ORB = 3,
    XF_PYRAMID_SCALE_DOUBLE = 4
};
typedef _image_pyramid_params XF_image_pyramid_params_e;


enum _normalisation_params { XF_L1NORM = 0, XF_L2NORM = 1 };
typedef _normalisation_params XF_normalisation_params_e;

enum _border_type {
    XF_BORDER_CONSTANT = 0,
    XF_BORDER_REPLICATE = 1,
    XF_BORDER_REFLECT = 2,
    XF_BORDER_WRAP = 3,
    XF_BORDER_REFLECT_101 = 4,
    XF_BORDER_TRANSPARENT = 5,
    XF_BORDER_REFLECT101 = XF_BORDER_REFLECT_101,
    XF_BORDER_DEFAULT = XF_BORDER_REFLECT_101,
    XF_BORDER_ISOLATED = 16,
};
typedef _border_type XF_border_type_e;

enum _structuring_element_shape {
    XF_SHAPE_RECT = 0,
    XF_SHAPE_ELLIPSE = 1,
    XF_SHAPE_CROSS = 2,

};
enum _wb_type {
    XF_WB_GRAY = 0,
    XF_WB_SIMPLE = 1,
};


enum _phase_params { XF_RADIANS = 0, XF_DEGREES = 1 };
typedef _phase_params XF_phase_params_e;


enum _interpolation_types { XF_INTERPOLATION_NN = 0, XF_INTERPOLATION_BILINEAR = 1, XF_INTERPOLATION_AREA = 2 };
typedef _interpolation_types _interpolation_types_e;


enum _loop_dependent_vars { XF_GXFSSIANLOOP = 8, XF_BUFSIZE = 12 };
typedef _loop_dependent_vars loop_dependent_vars_e;


enum _image_size { XF_SDIMAGE = 0, XF_HDIMAGE = 1 };
typedef _image_size image_size_e;


enum _input_image_type { XF_GRAY = 1, XF_RGB = 3 };
typedef _input_image_type input_image_type_e;


enum _HOG_output_type { XF_HOG_RB = 0, XF_HOG_NRB = 1 };
typedef _HOG_output_type HOG_output_type_e;

enum use_model { XF_STANDALONE = 0, XF_PIPELINE = 1 };
typedef use_model use_model_e;


enum _HOG_type { XF_DHOG = 0, XF_SHOG = 1 };
typedef _HOG_type HOG_type_e;


enum XF_stereo_prefilter_type { XF_STEREO_PREFILTER_SOBEL_TYPE, XF_STEREO_PREFILTER_NORM_TYPE };


enum XF_demosaicing {
    XF_BAYER_BG,
    XF_BAYER_GB,
    XF_BAYER_GR,
    XF_BAYER_RG,
};
# 293 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_params.hpp"
enum _ARCH_type {
    XF_STREAM = 0,
    XF_MEMORYMAPPED = 1

};
typedef _ARCH_type _ARCH_type_e;

enum _pixeltype {
    XF_8UC1 = 0,
    XF_16UC1 = 1,
    XF_16SC1 = 2,
    XF_32UC1 = 3,
    XF_32FC1 = 4,
    XF_32SC1 = 5,
    XF_8UC2 = 6,
    XF_8UC4 = 7,
    XF_2UC1 = 8,
    XF_8UC3 = 9,
    XF_16UC3 = 10,
    XF_16SC3 = 11,
    XF_16UC4 = 12,
    XF_10UC1 = 13,
    XF_10UC4 = 14,
    XF_12UC1 = 15,
    XF_12UC4 = 16,
    XF_10UC3 = 17,
    XF_12UC3 = 18,
    XF_32FC3 = 19,
    XF_64UC1 = 20
};
typedef _pixeltype XF_npt_e;

enum _ramtype {
    RAM_1P_BRAM = 0,
    RAM_1P_LUTRAM = 1,
    RAM_1P_URAM = 2,
    RAM_2P_BRAM = 3,
    RAM_2P_LUTRAM = 4,
    RAM_2P_URAM = 5,
    RAM_S2P_BRAM = 6,
    RAM_S2P_LUTRAM = 7,
    RAM_S2P_URAM = 8,
    RAM_T2P_BRAM = 9,
    RAM_T2P_URAM = 10
};
typedef _ramtype XF_ramtype_e;
# 26 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_types.hpp" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdint.h" 1 3
# 63 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdint.h" 3
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 64 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdint.h" 2 3
# 27 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_types.hpp" 2

template <int N>
struct floatn {
    float f[N];
    float& operator[](int idx) { return f[idx]; }
    const float& operator[](int idx) const { return f[idx]; }
};
typedef floatn<3> float3;

template <int T>
struct StreamType {};
template <>
struct StreamType<XF_2UW> {
    typedef ap_uint<2> name;
    static const int bitdepth = 2;
};
template <>
struct StreamType<XF_8UW> {
    typedef ap_uint<8> name;
    static const int bitdepth = 8;
};
template <>
struct StreamType<XF_9UW> {
    typedef ap_uint<9> name;
    static const int bitdepth = 9;
};
template <>
struct StreamType<XF_10UW> {
    typedef ap_uint<10> name;
    static const int bitdepth = 10;
};
template <>
struct StreamType<XF_12UW> {
    typedef ap_uint<12> name;
    static const int bitdepth = 12;
};
template <>
struct StreamType<XF_16UW> {
    typedef ap_uint<16> name;
    static const int bitdepth = 16;
};
template <>
struct StreamType<XF_19SW> {
    typedef ap_int<19> name;
    static const int bitdepth = 19;
};
template <>
struct StreamType<XF_20UW> {
    typedef ap_uint<20> name;
    static const int bitdepth = 20;
};
template <>
struct StreamType<XF_22UW> {
    typedef ap_uint<22> name;
    static const int bitdepth = 22;
};
template <>
struct StreamType<XF_24UW> {
    typedef ap_uint<24> name;
    static const int bitdepth = 24;
};
template <>
struct StreamType<XF_24SW> {
    typedef ap_int<24> name;
    static const int bitdepth = 24;
};
template <>
struct StreamType<XF_30UW> {
    typedef ap_uint<30> name;
    static const int bitdepth = 30;
};
template <>
struct StreamType<XF_32UW> {
    typedef ap_uint<32> name;
    static const int bitdepth = 32;
};
template <>
struct StreamType<XF_32FW> {
    typedef float name;
    static const int bitdepth = 32;
};
template <>
struct StreamType<XF_96FW> {
    typedef floatn<3> name;
    static const int bitdepth = 96;
};
template <>
struct StreamType<XF_192FW> {
    typedef floatn<6> name;
    static const int bitdepth = 192;
};
template <>
struct StreamType<XF_384FW> {
    typedef floatn<12> name;
    static const int bitdepth = 384;
};
template <>
struct StreamType<XF_768FW> {
    typedef floatn<24> name;
    static const int bitdepth = 768;
};
template <>
struct StreamType<XF_1536FW> {
    typedef floatn<48> name;
    static const int bitdepth = 1536;
};
template <>
struct StreamType<XF_35SW> {
    typedef ap_int<35> name;
    static const int bitdepth = 35;
};
template <>
struct StreamType<XF_36UW> {
    typedef ap_uint<36> name;
    static const int bitdepth = 36;
};
template <>
struct StreamType<XF_40UW> {
    typedef ap_uint<40> name;
    static const int bitdepth = 40;
};
template <>
struct StreamType<XF_48UW> {
    typedef ap_uint<48> name;
    static const int bitdepth = 48;
};
template <>
struct StreamType<XF_48SW> {
    typedef ap_int<48> name;
    static const int bitdepth = 48;
};
template <>
struct StreamType<XF_60UW> {
    typedef ap_uint<60> name;
    static const int bitdepth = 60;
};
template <>
struct StreamType<XF_64UW> {
    typedef ap_uint<64> name;
    static const int bitdepth = 64;
};
template <>
struct StreamType<XF_72UW> {
    typedef ap_uint<72> name;
    static const int bitdepth = 72;
};
template <>
struct StreamType<XF_80UW> {
    typedef ap_uint<80> name;
    static const int bitdepth = 80;
};
template <>
struct StreamType<XF_96UW> {
    typedef ap_uint<96> name;
    static const int bitdepth = 96;
};
template <>
struct StreamType<XF_96SW> {
    typedef ap_int<96> name;
    static const int bitdepth = 96;
};
template <>
struct StreamType<XF_120UW> {
    typedef ap_uint<120> name;
    static const int bitdepth = 120;
};
template <>
struct StreamType<XF_128UW> {
    typedef ap_uint<128> name;
    static const int bitdepth = 128;
};
template <>
struct StreamType<XF_144UW> {
    typedef ap_uint<144> name;
    static const int bitdepth = 144;
};
template <>
struct StreamType<XF_152SW> {
    typedef ap_int<152> name;
    static const int bitdepth = 152;
};
template <>
struct StreamType<XF_160UW> {
    typedef ap_uint<160> name;
    static const int bitdepth = 160;
};
template <>
struct StreamType<XF_160SW> {
    typedef ap_int<160> name;
    static const int bitdepth = 160;
};
template <>
struct StreamType<XF_176UW> {
    typedef ap_uint<176> name;
    static const int bitdepth = 176;
};
template <>
struct StreamType<XF_192UW> {
    typedef ap_uint<192> name;
    static const int bitdepth = 192;
};
template <>
struct StreamType<XF_192SW> {
    typedef ap_int<192> name;
    static const int bitdepth = 192;
};
template <>
struct StreamType<XF_256UW> {
    typedef ap_uint<256> name;
    static const int bitdepth = 256;
};
template <>
struct StreamType<XF_280SW> {
    typedef ap_int<280> name;
    static const int bitdepth = 280;
};
template <>
struct StreamType<XF_288UW> {
    typedef ap_uint<288> name;
    static const int bitdepth = 288;
};
template <>
struct StreamType<XF_304SW> {
    typedef ap_int<304> name;
    static const int bitdepth = 304;
};
template <>
struct StreamType<XF_320UW> {
    typedef ap_int<320> name;
    static const int bitdepth = 320;
};
template <>
struct StreamType<XF_352UW> {
    typedef ap_uint<352> name;
    static const int bitdepth = 352;
};
template <>
struct StreamType<XF_384UW> {
    typedef ap_uint<384> name;
    static const int bitdepth = 384;
};
template <>
struct StreamType<XF_384SW> {
    typedef ap_int<384> name;
    static const int bitdepth = 384;
};
template <>
struct StreamType<XF_512UW> {
    typedef ap_uint<512> name;
    static const int bitdepth = 512;
};
template <>
struct StreamType<XF_560SW> {
    typedef ap_int<560> name;
    static const int bitdepth = 560;
};
template <>
struct StreamType<XF_576UW> {
    typedef ap_uint<576> name;
    static const int bitdepth = 576;
};

template <int T>
struct PixelType {};
template <>
struct PixelType<XF_8UP> {
    typedef ap_uint<8> name;
    typedef ap_uint<8> uname;
    typedef unsigned char name2;
    static const int bitdepth = 8;
};
template <>
struct PixelType<XF_8SP> {
    typedef ap_int<8> name;
    typedef ap_uint<8> uname;
    static const int bitdepth = 8;
};
template <>
struct PixelType<XF_9UP> {
    typedef ap_uint<9> name;
    typedef ap_uint<9> uname;
    static const int bitdepth = 9;
};
template <>
struct PixelType<XF_9SP> {
    typedef ap_int<9> name;
    typedef ap_uint<9> uname;
    static const int bitdepth = 9;
};
template <>
struct PixelType<XF_16UP> {
    typedef ap_uint<16> name;
    typedef ap_uint<16> uname;
    static const int bitdepth = 16;
};
template <>
struct PixelType<XF_16SP> {
    typedef ap_int<16> name;
    typedef ap_uint<16> uname;
    static const int bitdepth = 16;
};
template <>
struct PixelType<XF_32UP> {
    typedef ap_uint<32> name;
    typedef ap_uint<32> uname;
    static const int bitdepth = 32;
};
template <>
struct PixelType<XF_32SP> {
    typedef ap_int<32> name;
    typedef ap_uint<32> uname;
    static const int bitdepth = 32;
};
template <>
struct PixelType<XF_19SP> {
    typedef ap_int<19> name;
    typedef ap_uint<19> uname;
    static const int bitdepth = 19;
};
template <>
struct PixelType<XF_35SP> {
    typedef ap_int<35> name;
    typedef ap_uint<35> uname;
    static const int bitdepth = 35;
};
template <>
struct PixelType<XF_32FP> {
    typedef float name;
    static const int bitdepth = 32;
};
template <>
struct PixelType<XF_96FP> {
    typedef floatn<3> name;
    static const int bitdepth = 96;
};
template <>
struct PixelType<XF_24SP> {
    typedef ap_int<24> name;
    typedef ap_uint<24> uname;
    static const int bitdepth = 24;
};
template <>
struct PixelType<XF_20SP> {
    typedef ap_int<20> name;
    typedef ap_uint<20> uname;
    static const int bitdepth = 20;
};
template <>
struct PixelType<XF_48SP> {
    typedef ap_int<48> name;
    typedef ap_uint<48> uname;
    static const int bitdepth = 48;
};
template <>
struct PixelType<XF_2UP> {
    typedef ap_uint<2> name;
    static const int bitdepth = 2;
};
template <>
struct PixelType<XF_24UP> {
    typedef ap_uint<24> name;
    typedef ap_uint<24> uname;
    static const int bitdepth = 24;
};

template <>
struct PixelType<XF_10UP> {
    typedef ap_uint<10> name;
    typedef ap_uint<10> uname;
    static const int bitdepth = 10;
};
template <>
struct PixelType<XF_12UP> {
    typedef ap_uint<12> name;
    typedef ap_uint<12> uname;
    static const int bitdepth = 12;
};




template <int T>
struct xfNPixelsPerCycle {};
template <>
struct xfNPixelsPerCycle<XF_NPPC1> {
    static const int datashift = 0;
    static const int nppc = 1;
};
template <>
struct xfNPixelsPerCycle<XF_NPPC2> {
    static const int datashift = 1;
    static const int nppc = 2;
};
template <>
struct xfNPixelsPerCycle<XF_NPPC4> {
    static const int datashift = 2;
    static const int nppc = 4;
};
template <>
struct xfNPixelsPerCycle<XF_NPPC8> {
    static const int datashift = 3;
    static const int nppc = 8;
};
template <>
struct xfNPixelsPerCycle<XF_NPPC16> {
    static const int datashift = 4;
    static const int nppc = 16;
};
template <>
struct xfNPixelsPerCycle<XF_NPPC32> {
    static const int datashift = 5;
    static const int nppc = 32;
};

template <int T, int M>
struct DataType {};


template <>
struct DataType<XF_2UC1, XF_NPPC1> {
    typedef ap_uint<2> name;
    typedef ap_uint<2> uname;
    typedef ap_uint<2> cname;
    typedef unsigned char sname;
    static const int bitdepth = 2;
    static const int pixelwidth = 2;
    static const int pixeldepth = XF_2UP;
    static const int wordwidth = XF_2UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_2UC1, XF_NPPC32> {
    typedef ap_uint<64> name;
    typedef ap_uint<2> uname;
    typedef ap_uint<2> cname;
    typedef unsigned char sname;
    static const int bitdepth = 2;
    static const int pixelwidth = 2;
    static const int pixeldepth = XF_2UP;
    static const int wordwidth = XF_64UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_2UC1, XF_NPPC4> {
    typedef ap_uint<8> name;
    typedef ap_uint<2> uname;
    typedef ap_uint<2> cname;
    typedef unsigned char sname;
    static const int bitdepth = 2;
    static const int pixelwidth = 2;
    static const int pixeldepth = XF_2UP;
    static const int wordwidth = XF_8UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_2UC1, XF_NPPC8> {
    typedef ap_uint<16> name;
    typedef ap_uint<2> uname;
    typedef ap_uint<2> cname;
    typedef unsigned char sname;
    static const int bitdepth = 2;
    static const int pixelwidth = 2;
    static const int pixeldepth = XF_2UP;
    static const int wordwidth = XF_16UW;
    static const int channel = 1;
};

template <>
struct DataType<XF_8UC1, XF_NPPC1> {
    typedef ap_uint<8> name;
    typedef ap_uint<8> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned char wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 8;
    static const int pixeldepth = XF_8UP;
    static const int wordwidth = XF_8UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_8UC1, XF_NPPC2> {
    typedef ap_uint<16> name;
    typedef ap_uint<8> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned short wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 8;
    static const int pixeldepth = XF_8UP;
    static const int wordwidth = XF_16UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_8UC1, XF_NPPC4> {
    typedef ap_uint<32> name;
    typedef ap_uint<8> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 8;
    static const int pixeldepth = XF_8UP;
    static const int wordwidth = XF_32UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_8UC1, XF_NPPC8> {
    typedef ap_uint<64> name;
    typedef ap_uint<8> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 8;
    static const int pixeldepth = XF_8UP;
    static const int wordwidth = XF_64UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_8UC1, XF_NPPC16> {
    typedef ap_uint<128> name;
    typedef ap_uint<8> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 8;
    static const int pixeldepth = XF_8UP;
    static const int wordwidth = XF_128UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_8UC1, XF_NPPC32> {
    typedef ap_uint<256> name;
    typedef ap_uint<8> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 8;
    static const int pixeldepth = XF_8UP;
    static const int wordwidth = XF_256UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_8UC1, XF_NPPC64> {
    typedef ap_uint<512> name;
    typedef ap_uint<8> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 8;
    static const int pixeldepth = XF_8UP;
    static const int wordwidth = XF_512UW;
    static const int channel = 1;
};

template <>
struct DataType<XF_10UC1, XF_NPPC1> {
    typedef ap_uint<10> name;
    typedef ap_uint<10> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 10;
    static const int pixeldepth = XF_10UP;
    static const int wordwidth = XF_10UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_10UC1, XF_NPPC2> {
    typedef ap_uint<20> name;
    typedef ap_uint<10> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 10;
    static const int pixeldepth = XF_10UP;
    static const int wordwidth = XF_20UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_10UC1, XF_NPPC4> {
    typedef ap_uint<40> name;
    typedef ap_uint<10> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 10;
    static const int pixeldepth = XF_10UP;
    static const int wordwidth = XF_40UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_10UC1, XF_NPPC8> {
    typedef ap_uint<80> name;
    typedef ap_uint<10> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 10;
    static const int pixeldepth = XF_10UP;
    static const int wordwidth = XF_80UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_10UC1, XF_NPPC16> {
    typedef ap_uint<160> name;
    typedef ap_uint<10> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 10;
    static const int pixeldepth = XF_10UP;
    static const int wordwidth = XF_160UW;
    static const int channel = 1;
};

template <>
struct DataType<XF_12UC1, XF_NPPC1> {
    typedef ap_uint<12> name;
    typedef ap_uint<12> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 12;
    static const int pixeldepth = XF_12UP;
    static const int wordwidth = XF_12UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_12UC1, XF_NPPC2> {
    typedef ap_uint<24> name;
    typedef ap_uint<12> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 12;
    static const int pixeldepth = XF_12UP;
    static const int wordwidth = XF_24UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_12UC1, XF_NPPC4> {
    typedef ap_uint<48> name;
    typedef ap_uint<12> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 12;
    static const int pixeldepth = XF_12UP;
    static const int wordwidth = XF_48UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_12UC1, XF_NPPC8> {
    typedef ap_uint<96> name;
    typedef ap_uint<12> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 12;
    static const int pixeldepth = XF_12UP;
    static const int wordwidth = XF_96UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_12UC1, XF_NPPC16> {
    typedef ap_uint<192> name;
    typedef ap_uint<12> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short int sname;
    typedef unsigned short wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 12;
    static const int pixeldepth = XF_12UP;
    static const int wordwidth = XF_192UW;
    static const int channel = 1;
};

template <>
struct DataType<XF_16SC1, XF_NPPC1> {
    typedef ap_uint<16> name;
    typedef ap_uint<16> uname;
    typedef ap_int<16> cname;
    typedef short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16SP;
    static const int wordwidth = XF_16UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_16SC1, XF_NPPC2> {
    typedef ap_uint<32> name;
    typedef ap_uint<16> uname;
    typedef ap_int<16> cname;
    typedef short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16SP;
    static const int wordwidth = XF_32UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_16SC1, XF_NPPC4> {
    typedef ap_uint<64> name;
    typedef ap_uint<16> uname;
    typedef ap_int<16> cname;
    typedef short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16SP;
    static const int wordwidth = XF_64UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_16SC1, XF_NPPC8> {
    typedef ap_uint<128> name;
    typedef ap_uint<16> uname;
    typedef ap_int<16> cname;
    typedef short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16SP;
    static const int wordwidth = XF_128UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_16SC1, XF_NPPC16> {
    typedef ap_uint<256> name;
    typedef ap_uint<16> uname;
    typedef ap_int<16> cname;
    typedef short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16SP;
    static const int wordwidth = XF_256UW;
    static const int channel = 1;
};

template <>
struct DataType<XF_16UC1, XF_NPPC1> {
    typedef ap_uint<16> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_16UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_16UC1, XF_NPPC2> {
    typedef ap_uint<32> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_32UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_16UC1, XF_NPPC4> {
    typedef ap_uint<64> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_64UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_16UC1, XF_NPPC8> {
    typedef ap_uint<128> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_128UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_16UC1, XF_NPPC16> {
    typedef ap_uint<256> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short sname;
    static const int bitdepth = 16;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_256UW;
    static const int channel = 1;
};

template <>
struct DataType<XF_32UC1, XF_NPPC1> {
    typedef ap_uint<32> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef unsigned int sname;
    typedef unsigned int wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_32UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_64UC1, XF_NPPC1> {
    typedef ap_uint<64> name;
    typedef ap_uint<64> uname;
    typedef ap_uint<64> cname;
    typedef unsigned int sname;
    typedef unsigned int wname;
    static const int bitdepth = 64;
    static const int pixelwidth = 64;
    static const int pixeldepth = XF_64UP;
    static const int wordwidth = XF_64UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32UC1, XF_NPPC2> {
    typedef ap_uint<64> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef unsigned int sname;
    typedef unsigned long long wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_64UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32UC1, XF_NPPC4> {
    typedef ap_uint<128> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef unsigned int sname;
    typedef unsigned long long wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_128UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32UC1, XF_NPPC8> {
    typedef ap_uint<256> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef unsigned int sname;
    typedef unsigned long long wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_256UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32UC1, XF_NPPC16> {
    typedef ap_uint<512> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef unsigned int sname;
    typedef unsigned long long wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_512UW;
    static const int channel = 1;
};

template <>
struct DataType<XF_32FC1, XF_NPPC1> {
    typedef ap_uint<32> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32FP;
    static const int wordwidth = XF_32FW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32FC1, XF_NPPC2> {
    typedef ap_uint<64> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32FP;
    static const int wordwidth = XF_64UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32FC1, XF_NPPC4> {
    typedef ap_uint<128> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32FP;
    static const int wordwidth = XF_128UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32FC1, XF_NPPC8> {
    typedef ap_uint<256> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32FP;
    static const int wordwidth = XF_256UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32FC1, XF_NPPC16> {
    typedef ap_uint<512> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32FP;
    static const int wordwidth = XF_512UW;
    static const int channel = 1;
};

template <>
struct DataType<XF_32FC3, XF_NPPC1> {
    typedef ap_uint<96> name;
    typedef ap_uint<96> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    typedef floatn<3> wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 96;
    static const int pixeldepth = XF_96FP;
    static const int wordwidth = XF_96FW;
    static const int channel = 3;
};
template <>
struct DataType<XF_32FC3, XF_NPPC2> {
    typedef ap_uint<192> name;
    typedef ap_uint<96> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    typedef floatn<6> wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 96;
    static const int pixeldepth = XF_96FP;
    static const int wordwidth = XF_192FW;
    static const int channel = 3;
};
template <>
struct DataType<XF_32FC3, XF_NPPC4> {
    typedef ap_uint<384> name;
    typedef ap_uint<96> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    typedef floatn<12> wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 96;
    static const int pixeldepth = XF_96FP;
    static const int wordwidth = XF_384FW;
    static const int channel = 3;
};
template <>
struct DataType<XF_32FC3, XF_NPPC8> {
    typedef ap_uint<768> name;
    typedef ap_uint<96> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    typedef floatn<24> wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 96;
    static const int pixeldepth = XF_96FP;
    static const int wordwidth = XF_768FW;
    static const int channel = 3;
};
template <>
struct DataType<XF_32FC3, XF_NPPC16> {
    typedef ap_uint<1536> name;
    typedef ap_uint<96> uname;
    typedef ap_uint<32> cname;
    typedef float sname;
    typedef floatn<48> wname;
    static const int bitdepth = 32;
    static const int pixelwidth = 96;
    static const int pixeldepth = XF_96FP;
    static const int wordwidth = XF_1536FW;
    static const int channel = 3;
};

template <>
struct DataType<XF_32SC1, XF_NPPC1> {
    typedef ap_uint<32> name;
    typedef ap_uint<32> uname;
    typedef ap_int<32> cname;
    typedef int sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32SP;
    static const int wordwidth = XF_32UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32SC1, XF_NPPC2> {
    typedef ap_uint<64> name;
    typedef ap_uint<32> uname;
    typedef ap_int<32> cname;
    typedef int sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32SP;
    static const int wordwidth = XF_64UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32SC1, XF_NPPC4> {
    typedef ap_uint<128> name;
    typedef ap_uint<32> uname;
    typedef ap_int<32> cname;
    typedef int sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32SP;
    static const int wordwidth = XF_128UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32SC1, XF_NPPC8> {
    typedef ap_uint<256> name;
    typedef ap_uint<32> uname;
    typedef ap_int<32> cname;
    typedef int sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32SP;
    static const int wordwidth = XF_256UW;
    static const int channel = 1;
};
template <>
struct DataType<XF_32SC1, XF_NPPC16> {
    typedef ap_uint<512> name;
    typedef ap_uint<32> uname;
    typedef ap_int<32> cname;
    typedef int sname;
    static const int bitdepth = 32;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32SP;
    static const int wordwidth = XF_512UW;
    static const int channel = 1;
};


template <>
struct DataType<XF_8UC2, XF_NPPC1> {
    typedef ap_uint<16> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned short int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_16UW;
    static const int channel = 2;
};
template <>
struct DataType<XF_8UC2, XF_NPPC2> {
    typedef ap_uint<32> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned short int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_32UW;
    static const int channel = 2;
};
template <>
struct DataType<XF_8UC2, XF_NPPC4> {
    typedef ap_uint<64> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_64UW;
    static const int channel = 2;
};
template <>
struct DataType<XF_8UC2, XF_NPPC8> {
    typedef ap_uint<128> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_128UW;
    static const int channel = 2;
};
template <>
struct DataType<XF_8UC2, XF_NPPC16> {
    typedef ap_uint<256> name;
    typedef ap_uint<16> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 16;
    static const int pixeldepth = XF_16UP;
    static const int wordwidth = XF_256UW;
    static const int channel = 2;
};
# 1182 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_types.hpp"
template <>
struct DataType<XF_8UC3, XF_NPPC1> {
    typedef ap_uint<24> name;
    typedef ap_uint<24> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 24;
    static const int pixeldepth = XF_24UP;
    static const int wordwidth = XF_24UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_8UC3, XF_NPPC2> {
    typedef ap_uint<48> name;
    typedef ap_uint<24> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 24;
    static const int pixeldepth = XF_24UP;
    static const int wordwidth = XF_48UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_8UC3, XF_NPPC4> {
    typedef ap_uint<96> name;
    typedef ap_uint<24> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 24;
    static const int pixeldepth = XF_24UP;
    static const int wordwidth = XF_96UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_8UC3, XF_NPPC8> {
    typedef ap_uint<192> name;
    typedef ap_uint<24> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 24;
    static const int pixeldepth = XF_24UP;
    static const int wordwidth = XF_192UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_8UC3, XF_NPPC16> {
    typedef ap_uint<384> name;
    typedef ap_uint<24> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 24;
    static const int pixeldepth = XF_24UP;
    static const int wordwidth = XF_384UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_10UC3, XF_NPPC1> {
    typedef ap_uint<30> name;
    typedef ap_uint<30> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short sname;
    typedef unsigned int wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 30;
    static const int pixeldepth = XF_30UP;
    static const int wordwidth = XF_30UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_10UC3, XF_NPPC2> {
    typedef ap_uint<60> name;
    typedef ap_uint<30> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 30;
    static const int pixeldepth = XF_30UP;
    static const int wordwidth = XF_60UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_10UC3, XF_NPPC4> {
    typedef ap_uint<120> name;
    typedef ap_uint<30> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 30;
    static const int pixeldepth = XF_30UP;
    static const int wordwidth = XF_120UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_10UC3, XF_NPPC8> {
    typedef ap_uint<240> name;
    typedef ap_uint<30> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 30;
    static const int pixeldepth = XF_30UP;
    static const int wordwidth = XF_240UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_12UC3, XF_NPPC1> {
    typedef ap_uint<36> name;
    typedef ap_uint<36> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short sname;
    typedef unsigned long int wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 36;
    static const int pixeldepth = XF_36UP;
    static const int wordwidth = XF_36UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_12UC3, XF_NPPC2> {
    typedef ap_uint<72> name;
    typedef ap_uint<36> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short sname;
    typedef unsigned long int wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 36;
    static const int pixeldepth = XF_36UP;
    static const int wordwidth = XF_72UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_12UC3, XF_NPPC4> {
    typedef ap_uint<144> name;
    typedef ap_uint<36> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short sname;
    typedef unsigned long int wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 36;
    static const int pixeldepth = XF_36UP;
    static const int wordwidth = XF_144UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_12UC3, XF_NPPC8> {
    typedef ap_uint<288> name;
    typedef ap_uint<36> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short sname;
    typedef unsigned long int wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 36;
    static const int pixeldepth = XF_36UP;
    static const int wordwidth = XF_288UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_16UC3, XF_NPPC1> {
    typedef ap_uint<48> name;
    typedef ap_uint<48> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48UP;
    static const int wordwidth = XF_48UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_16UC3, XF_NPPC2> {
    typedef ap_uint<96> name;
    typedef ap_uint<48> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48UP;
    static const int wordwidth = XF_96UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_16UC3, XF_NPPC4> {
    typedef ap_uint<192> name;
    typedef ap_uint<48> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48UP;
    static const int wordwidth = XF_192UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_16UC3, XF_NPPC8> {
    typedef ap_uint<384> name;
    typedef ap_uint<48> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48UP;
    static const int wordwidth = XF_384UW;
    static const int channel = 3;
};
template <>
struct DataType<XF_16SC3, XF_NPPC1> {
    typedef ap_uint<48> name;
    typedef ap_uint<48> uname;
    typedef ap_int<16> cname;
    typedef short int sname;
    typedef short int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48SP;
    static const int wordwidth = XF_48SW;
    static const int channel = 3;
};
template <>
struct DataType<XF_16SC3, XF_NPPC2> {
    typedef ap_uint<96> name;
    typedef ap_uint<48> uname;
    typedef ap_int<16> cname;
    typedef short int sname;
    typedef short int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48SP;
    static const int wordwidth = XF_96SW;
    static const int channel = 3;
};
template <>
struct DataType<XF_16SC3, XF_NPPC4> {
    typedef ap_uint<192> name;
    typedef ap_uint<48> uname;
    typedef ap_int<16> cname;
    typedef short int sname;
    typedef short int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48SP;
    static const int wordwidth = XF_192SW;
    static const int channel = 3;
};
template <>
struct DataType<XF_16SC3, XF_NPPC8> {
    typedef ap_uint<384> name;
    typedef ap_uint<48> uname;
    typedef ap_int<16> cname;
    typedef short int sname;
    typedef short int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48SP;
    static const int wordwidth = XF_384SW;
    static const int channel = 3;
};


template <>
struct DataType<XF_8UC4, XF_NPPC1> {
    typedef ap_uint<32> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_32UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_8UC4, XF_NPPC2> {
    typedef ap_uint<64> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 8;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_64UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_8UC4, XF_NPPC4> {
    typedef ap_uint<128> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    static const int bitdepth = 8;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_128UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_8UC4, XF_NPPC8> {
    typedef ap_uint<256> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    static const int bitdepth = 8;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_256UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_8UC4, XF_NPPC16> {
    typedef ap_uint<512> name;
    typedef ap_uint<32> uname;
    typedef ap_uint<8> cname;
    typedef unsigned char sname;
    static const int bitdepth = 8;
    static const int pixelwidth = 32;
    static const int pixeldepth = XF_32UP;
    static const int wordwidth = XF_512UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_10UC4, XF_NPPC1> {
    typedef ap_uint<40> name;
    typedef ap_uint<40> uname;
    typedef ap_uint<10> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 10;
    static const int pixelwidth = 40;
    static const int pixeldepth = XF_40UP;
    static const int wordwidth = XF_40UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_10UC4, XF_NPPC2> {
    typedef ap_uint<80> name;
    typedef ap_uint<40> uname;
    typedef ap_uint<10> cname;
    static const int bitdepth = 10;
    static const int pixelwidth = 40;
    static const int pixeldepth = XF_40UP;
    static const int wordwidth = XF_80UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_10UC4, XF_NPPC4> {
    typedef ap_uint<160> name;
    typedef ap_uint<40> uname;
    typedef ap_uint<10> cname;
    static const int bitdepth = 10;
    static const int pixelwidth = 40;
    static const int pixeldepth = XF_40UP;
    static const int wordwidth = XF_160UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_10UC4, XF_NPPC8> {
    typedef ap_uint<320> name;
    typedef ap_uint<40> uname;
    typedef ap_uint<10> cname;
    static const int bitdepth = 10;
    static const int pixelwidth = 40;
    static const int pixeldepth = XF_40UP;
    static const int wordwidth = XF_320UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_12UC4, XF_NPPC1> {
    typedef ap_uint<48> name;
    typedef ap_uint<48> uname;
    typedef ap_uint<12> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 12;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48UP;
    static const int wordwidth = XF_48UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_12UC4, XF_NPPC2> {
    typedef ap_uint<96> name;
    typedef ap_uint<48> uname;
    typedef ap_uint<12> cname;
    static const int bitdepth = 12;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48UP;
    static const int wordwidth = XF_96UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_12UC4, XF_NPPC4> {
    typedef ap_uint<192> name;
    typedef ap_uint<48> uname;
    typedef ap_uint<12> cname;
    static const int bitdepth = 12;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48UP;
    static const int wordwidth = XF_192UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_12UC4, XF_NPPC8> {
    typedef ap_uint<384> name;
    typedef ap_uint<48> uname;
    typedef ap_uint<12> cname;
    static const int bitdepth = 12;
    static const int pixelwidth = 48;
    static const int pixeldepth = XF_48UP;
    static const int wordwidth = XF_384UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_16UC4, XF_NPPC1> {
    typedef ap_uint<64> name;
    typedef ap_uint<64> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 64;
    static const int pixeldepth = XF_64UP;
    static const int wordwidth = XF_64UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_16UC4, XF_NPPC2> {
    typedef ap_uint<128> name;
    typedef ap_uint<64> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 64;
    static const int pixeldepth = XF_64UP;
    static const int wordwidth = XF_128UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_16UC4, XF_NPPC4> {
    typedef ap_uint<256> name;
    typedef ap_uint<64> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 64;
    static const int pixeldepth = XF_64UP;
    static const int wordwidth = XF_256UW;
    static const int channel = 4;
};
template <>
struct DataType<XF_16UC4, XF_NPPC8> {
    typedef ap_uint<512> name;
    typedef ap_uint<64> uname;
    typedef ap_uint<16> cname;
    typedef unsigned short int sname;
    typedef unsigned long long int wname;
    static const int bitdepth = 16;
    static const int pixelwidth = 64;
    static const int pixeldepth = XF_64UP;
    static const int wordwidth = XF_512UW;
    static const int channel = 4;
};
# 1703 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_types.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 1704 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_types.hpp" 2




typedef unsigned int uint32_t;
typedef unsigned short uint16_t;

typedef int int32_t;
typedef short int int16_t;
typedef unsigned char uchar_t;
typedef unsigned char uint8_t;
typedef signed char int8_t;


typedef ap_uint<1> ap_uint1_t;
typedef ap_uint<2> ap_uint2_t;
typedef ap_uint<4> ap_uint4_t;
typedef ap_uint<5> ap_uint5_t;
typedef ap_uint<8> ap_uint8_t;
typedef ap_uint<9> ap_uint9_t;
typedef ap_uint<16> ap_uint16_t;
typedef ap_uint<17> ap_uint17_t;
typedef ap_uint<18> ap_uint18_t;
typedef ap_uint<20> ap_uint20_t;
typedef ap_uint<22> ap_uint22_t;
typedef ap_uint<23> ap_uint23_t;
typedef ap_uint<24> ap_uint24_t;
typedef ap_uint<32> ap_uint32_t;
typedef ap_uint<33> ap_uint33_t;
typedef ap_uint<34> ap_uint34_t;
typedef ap_uint<35> ap_uint35_t;
typedef ap_uint<38> ap_uint38_t;
typedef ap_uint<45> ap_uint45_t;
typedef ap_uint<48> ap_uint48_t;
typedef ap_uint<51> ap_uint51_t;
typedef ap_uint<64> ap_uint64_t;
typedef ap_uint<66> ap_uint66_t;
typedef ap_uint<72> ap_uint72_t;
typedef ap_uint<97> ap_uint97_t;
typedef ap_uint<101> ap_uint101_t;
typedef ap_uint<128> ap_uint128_t;
typedef ap_uint<144> ap_uint144_t;
typedef ap_uint<176> ap_uint176_t;
typedef ap_uint<192> ap_uint192_t;
typedef ap_uint<256> ap_uint256_t;
typedef ap_uint<352> ap_uint352_t;
typedef ap_uint<384> ap_uint384_t;
typedef ap_uint<512> ap_uint512_t;
typedef ap_uint<576> ap_uint576_t;

typedef ap_int<8> ap_int8_t;
typedef ap_int<9> ap_int9_t;
typedef ap_int<12> ap_int12_t;
typedef ap_int<15> ap_int15_t;
typedef ap_int<16> ap_int16_t;
typedef ap_int<18> ap_int18_t;
typedef ap_int<19> ap_int19_t;
typedef ap_int<20> ap_int20_t;
typedef ap_int<24> ap_int24_t;
typedef ap_int<32> ap_int32_t;
typedef ap_int<35> ap_int35_t;
typedef ap_int<36> ap_int36_t;
typedef ap_int<42> ap_int42_t;
typedef ap_int<48> ap_int48_t;
typedef ap_int<64> ap_int64_t;
typedef ap_int<152> ap_int152_t;
typedef ap_int<304> ap_int304_t;
typedef ap_int<280> ap_int280_t;
typedef ap_int<560> ap_int560_t;


typedef ap_ufixed<12, 12> uint12_q0;
typedef ap_ufixed<16, 16> uint16_q0;
typedef ap_ufixed<32, 32> uint32_q0;
typedef ap_ufixed<8, 8> uint8_q0;
# 30 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp" 2
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 31 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3


# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 1 3
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 3
# 67 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 278 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 408 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/type_traits.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 44 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

 extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

 extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

 extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


 extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

 extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

 extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);




 extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

 extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

 extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



 extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true);





 extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

 extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

 extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





 extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


 extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


 extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);




 extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


 extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




 extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


 extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






 extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



 extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




 extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__)); extern double __ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__)); extern double __fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__)); extern double __floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 183 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





 extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
 extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__)); extern double __round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__)); extern double __trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);



extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__)); extern double __roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalize (double *__cx, const double *__x) noexcept (true);






extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

 extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

 extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

 extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


 extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

 extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

 extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);




 extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

 extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

 extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



 extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true);





 extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

 extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

 extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





 extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


 extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


 extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);




 extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


 extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




 extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


 extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






 extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



 extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




 extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





 extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
 extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);



extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef (float *__cx, const float *__x) noexcept (true);






extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

 extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

 extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

 extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


 extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

 extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

 extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);




 extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

 extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

 extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true);





 extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

 extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

 extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





 extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


 extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


 extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);




 extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


 extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




 extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


 extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






 extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



 extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




 extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





 extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
 extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);



extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);






extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);




 extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true);





 extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





 extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


 extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


 extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);




 extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


 extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




 extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


 extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




 extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





 extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
 extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);




 extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true);





 extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





 extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


 extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


 extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);




 extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


 extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




 extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


 extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




 extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





 extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
 extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 468 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);




 extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true);





 extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





 extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


 extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


 extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);




 extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


 extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




 extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


 extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




 extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





 extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
 extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);




 extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true);





 extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





 extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


 extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


 extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);




 extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


 extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




 extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


 extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




 extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





 extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
 extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float ffma (double __x, double __y, double __z) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsqrt (double __x) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float ffmal (long double __x, long double __y, long double __z) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsqrtl (long double __x) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dfmal (long double __x, long double __y, long double __z) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsqrtl (long double __x) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32sqrtf32x (_Float32x __x) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32sqrtf64 (_Float64 __x) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32sqrtf64x (_Float64x __x) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 718 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsqrtf64 (_Float64 __x) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsqrtf64x (_Float64x __x) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 758 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64sqrtf64x (_Float64x __x) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 788 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1054 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     noexcept (true) __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }



}
# 1055 "/usr/include/math.h" 2 3 4
# 1066 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}





}
# 1097 "/usr/include/math.h" 3 4
extern "C++" {
# 1128 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1363 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};
# 1406 "/usr/include/math.h" 3 4
template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 2 3

# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/std_abs.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/std_abs.h" 3




# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 62 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 159 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 233 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 251 "/usr/include/stdlib.h" 3 4
extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 273 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 274 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 317 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 338 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;






# 1 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{



  return ((__uint16_t) ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));

}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{



  return ((((__bsx) & 0xff000000u) >> 24) | (((__bsx) & 0x00ff0000u) >> 8) | (((__bsx) & 0x0000ff00u) << 8) | (((__bsx) & 0x000000ffu) << 24));

}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{



  return ((((__bsx) & 0xff00000000000000ull) >> 56) | (((__bsx) & 0x00ff000000000000ull) >> 40) | (((__bsx) & 0x0000ff0000000000ull) >> 24) | (((__bsx) & 0x000000ff00000000ull) >> 8) | (((__bsx) & 0x00000000ff000000ull) << 8) | (((__bsx) & 0x0000000000ff0000ull) << 24) | (((__bsx) & 0x000000000000ff00ull) << 40) | (((__bsx) & 0x00000000000000ffull) << 56));

}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;






# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 396 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
                                         ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) ;


extern void free (void *__ptr) noexcept (true);







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))

                       ;


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) ;




# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 575 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
                                         ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
                                         ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 617 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 682 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 727 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 738 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 769 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 791 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
                              ;
# 808 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 880 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
                                      ;

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)

                                    ;






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 967 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) ;


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1023 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1024 "/usr/include/stdlib.h" 2 3 4
# 1035 "/usr/include/stdlib.h" 3 4
}
# 39 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/std_abs.h" 2 3







extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }







  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
# 107 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/std_abs.h" 3
}
}
# 48 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 2 3
# 77 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1889 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
}





}
# 37 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 32 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {




# 1 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdarg.h" 1 3 4
# 30 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) noexcept (true);

extern int rename (const char *__old, const char *__new) noexcept (true);



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) noexcept (true);
# 170 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) noexcept (true);






extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) ;
# 200 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) ;



extern char *tmpnam (char[20]) noexcept (true) ;




extern char *tmpnam_r (char __s[20]) noexcept (true) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   noexcept (true) __attribute__ ((__malloc__)) ;






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) noexcept (true)
  __attribute__ ((__malloc__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  noexcept (true) __attribute__ ((__malloc__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) noexcept (true);



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) noexcept (true);




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) noexcept (true);


extern void setlinebuf (FILE *__stream) noexcept (true);







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) noexcept (true);





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) noexcept (true);



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) noexcept (true);
# 434 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf") ;


extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf") ;

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc99_sscanf");
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
                                                         ;
# 605 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
                                                  ;
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 779 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) noexcept (true);

extern int feof (FILE *__stream) noexcept (true) ;

extern int ferror (FILE *__stream) noexcept (true) ;



extern void clearerr_unlocked (FILE *__stream) noexcept (true);
extern int feof_unlocked (FILE *__stream) noexcept (true) ;
extern int ferror_unlocked (FILE *__stream) noexcept (true) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) noexcept (true) ;




extern int fileno_unlocked (FILE *__stream) noexcept (true) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) ;






extern char *ctermid (char *__s) noexcept (true)
                                     ;





extern char *cuserid (char *__s)
                                     ;




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) noexcept (true);



extern int ftrylockfile (FILE *__stream) noexcept (true) ;


extern void funlockfile (FILE *__stream) noexcept (true);
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 902 "/usr/include/stdio.h" 3 4
}
# 33 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 56 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }






    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 180 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 312 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 340 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };
# 712 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 747 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __bool_constant<__is_assignable(_Tp, _Up)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, __bool_constant<
        __is_trivially_constructible(_Tp, _Args...)>>::type
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<is_default_constructible<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };
# 1452 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };
# 1509 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1590 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1694 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;
# 1744 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };
# 1781 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };
# 1820 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1840 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 1879 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }
# 2072 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };

  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };



  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };
# 2351 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename...> using __void_t = void;
# 2364 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2408 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };
# 2613 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 2974 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
}
# 34 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp" 2

namespace xf {
namespace cv {

template <int T>
ap_uint<T> xf_satcast(int in_val) {
    if (in_val > ((1 << T) - 1)) {
        return ((1 << T) - 1);
    } else if (in_val < 0) {
        return 0;
    } else {
        return in_val;
    }
}

template <typename T>
T float2ap_uint(float val) {
    T* val_out = (T*)(&val);
    return *val_out;
}

template <typename T>
float ap_uint2float(T val) {
    float* val_out = (float*)(&val);
    return *val_out;
}




template <int WSIZE, int NDISP, int NDISP_UNIT>
class xFSBMState {
   public:

    int preFilterType;
    int preFilterSize;
    int preFilterCap;



    int SADWindowSize;
    int minDisparity;
    int numberOfDisparities;


    int textureThreshold;


    int uniquenessRatio;






    int ndisp_unit;
    int sweepFactor;
    int remainder;

    xFSBMState() {
        preFilterType = XF_STEREO_PREFILTER_SOBEL_TYPE;
        preFilterSize = WSIZE;
        preFilterCap = 31;
        SADWindowSize = WSIZE;
        minDisparity = 0;
        numberOfDisparities = NDISP;
        textureThreshold = 10;
        uniquenessRatio = 15;
        sweepFactor = (NDISP / NDISP_UNIT) + ((NDISP % NDISP_UNIT) != 0);
        ndisp_unit = NDISP_UNIT;
        remainder = NDISP_UNIT * sweepFactor - NDISP;
    }
};





template <typename T>
class Point_ {
   public:
    Point_();
    Point_(T _x, T _y);
    Point_(const Point_& pt);
    ~Point_();

    T x, y;
};


template <typename T>
inline Point_<T>::Point_() {}
template <typename T>
inline Point_<T>::Point_(T _x, T _y) : x(_x), y(_y) {}
template <typename T>
inline Point_<T>::Point_(const Point_<T>& pt) : x(pt.x), y(pt.y) {}
template <typename T>
inline Point_<T>::~Point_() {}

typedef Point_<int> Point;





template <typename T>
class Size_ {
   public:
    Size_();
    Size_(T _width, T _height);
    Size_(const Size_<T>& sz);
    Size_(const Point_<T>& pt);
    T area();
    ~Size_();

    T width, height;
};


template <typename T>
inline Size_<T>::Size_() {}
template <typename T>
inline Size_<T>::Size_(T _width, T _height) : width(_width), height(_height) {}
template <typename T>
inline Size_<T>::Size_(const Size_<T>& sz) : width(sz.width), height(sz.height) {}
template <typename T>
inline Size_<T>::Size_(const Point_<T>& pt) : width(pt.x), height(pt.y) {}
template <typename T>
inline T Size_<T>::area() {
    return width * height;
}
template <typename T>
inline Size_<T>::~Size_() {}

typedef Size_<int> Size;





template <typename T>
class Rect_ {
   public:
    Rect_();
    Rect_(T _x, T _y, T _width, T _height);
    Rect_(const Rect_& rect);
    Rect_(const Point_<T>& pt, const Size_<T>& sz);
    T area();
    Size_<T> size();
    Point_<T> tl();
    Point_<T> tr();
    Point_<T> bl();
    Point_<T> br();
    bool bContains(const Point_<T>& pt);
    ~Rect_();

    T x, y, width, height;
};


template <typename T>
inline Rect_<T>::Rect_() {}
template <typename T>
inline Rect_<T>::Rect_(T _x, T _y, T _width, T _height) : x(_x), y(_y), width(_width), height(_height) {}
template <typename T>
inline Rect_<T>::Rect_(const Rect_<T>& rect) : x(rect.x), y(rect.y), width(rect.width), height(rect.height) {}
template <typename T>
inline Rect_<T>::Rect_(const Point_<T>& pt, const Size_<T>& sz)
    : x(pt.x), y(pt.y), width(sz.width), height(sz.height) {}
template <typename T>
inline T Rect_<T>::area() {
    return width * height;
}
template <typename T>
inline Size_<T> Rect_<T>::size() {
    return Size_<T>(width, height);
}
template <typename T>
inline Point_<T> Rect_<T>::tl() {
    return Point_<T>(x, y);
}
template <typename T>
inline Point_<T> Rect_<T>::tr() {
    return Point_<T>(x + width, y);
}
template <typename T>
inline Point_<T> Rect_<T>::bl() {
    return Point_<T>(x, y + height);
}
template <typename T>
inline Point_<T> Rect_<T>::br() {
    return Point_<T>(x + width, y + height);
}
template <typename T>
inline bool Rect_<T>::bContains(const Point_<T>& pt) {
    return (pt.x >= x && pt.x < x + width && pt.y >= y && pt.y < y + height);
}
template <typename T>
inline Rect_<T>::~Rect_() {}

typedef Rect_<int> Rect;





template <int N, typename T>
class Scalar {
   public:
    Scalar() {

#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete

 (__builtin_assume(static_cast <bool> (N > 0)));
    }
    Scalar(T v0) {

#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete

 (__builtin_assume(static_cast <bool> (N >= 1 && "Scalar must have enough channels for constructor.")));
        val[0] = v0;
    }
    Scalar(T v0, T v1) {

#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
#pragma HLS INLINE

 (__builtin_assume(static_cast <bool> (N >= 2 && "Scalar must have enough channels for constructor.")));
        val[0] = v0;
        val[1] = v1;
    }
    Scalar(T v0, T v1, T v2) {

#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
#pragma HLS INLINE

 (__builtin_assume(static_cast <bool> (N >= 3 && "Scalar must have enough channels for constructor.")));
        val[0] = v0;
        val[1] = v1;
        val[2] = v2;
    }
    Scalar(T v0, T v1, T v2, T v3) {

#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
#pragma HLS INLINE

 (__builtin_assume(static_cast <bool> (N >= 4 && "Scalar must have enough channels for constructor.")));
        val[0] = v0;
        val[1] = v1;
        val[2] = v2;
        val[3] = v3;
    }

    void operator=(T value);
    Scalar<N, T> operator+(T value);
    Scalar<N, T> operator+(Scalar<N, T> s);
    Scalar<N, T> operator-(T value);
    Scalar<N, T> operator-(Scalar<N, T> s);
    Scalar<N, T> operator*(T value);
    Scalar<N, T> operator*(Scalar<N, T> s);
    Scalar<N, T> operator/(T value);
    Scalar<N, T> operator/(Scalar<N, T> s);

    T val[N];
};

template <int N, typename T>
void Scalar<N, T>::operator=(T value) {

#pragma HLS inline

 VITIS_LOOP_307_1: for (int k = 0; k < N; k++) {

#pragma HLS unroll

 val[k] = value;
    }
}

template <int N, typename T>
Scalar<N, T> Scalar<N, T>::operator+(T value) {

#pragma HLS inline

 Scalar<N, T> res;
    VITIS_LOOP_321_1: for (int k = 0; k < N; k++) {

#pragma HLS unroll

 res.val[k] = val[k] + value;
    }
    return res;
}

template <int N, typename T>
Scalar<N, T> Scalar<N, T>::operator+(Scalar<N, T> s) {

#pragma HLS inline

 Scalar<N, T> res;
    VITIS_LOOP_336_1: for (int k = 0; k < N; k++) {

#pragma HLS unroll

 res.val[k] = val[k] + s.val[k];
    }
    return res;
}

template <int N, typename T>
Scalar<N, T> Scalar<N, T>::operator-(T value) {

#pragma HLS inline

 Scalar<N, T> res;
    VITIS_LOOP_351_1: for (int k = 0; k < N; k++) {

#pragma HLS unroll

 res.val[k] = val[k] - value;
    }
    return res;
}

template <int N, typename T>
Scalar<N, T> Scalar<N, T>::operator-(Scalar<N, T> s) {

#pragma HLS inline

 Scalar<N, T> res;
    VITIS_LOOP_366_1: for (int k = 0; k < N; k++) {

#pragma HLS unroll

 res.val[k] = val[k] - s.val[k];
    }
    return res;
}

template <int N, typename T>
Scalar<N, T> Scalar<N, T>::operator*(T value) {

#pragma HLS inline

 Scalar<N, T> res;
    VITIS_LOOP_381_1: for (int k = 0; k < N; k++) {

#pragma HLS unroll

 res.val[k] = val[k] * value;
    }
    return res;
}

template <int N, typename T>
Scalar<N, T> Scalar<N, T>::operator*(Scalar<N, T> s) {

#pragma HLS inline

 Scalar<N, T> res;
    VITIS_LOOP_396_1: for (int k = 0; k < N; k++) {

#pragma HLS unroll

 res.val[k] = val[k] * s.val[k];
    }
    return res;
}

template <int N, typename T>
Scalar<N, T> Scalar<N, T>::operator/(T value) {

#pragma HLS inline

 Scalar<N, T> res;
    VITIS_LOOP_411_1: for (int k = 0; k < N; k++) {

#pragma HLS unroll

 res.val[k] = val[k] / value;
    }
    return res;
}

template <int N, typename T>
Scalar<N, T> Scalar<N, T>::operator/(Scalar<N, T> s) {

#pragma HLS inline

 Scalar<N, T> res;
    VITIS_LOOP_426_1: for (int k = 0; k < N; k++) {

#pragma HLS unroll

 res.val[k] = val[k] / s.val[k];
    }
    return res;
}






static constexpr int _XFCVDEPTH_DEFAULT = 2;




template <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>
class Mat {
   public:
    unsigned char allocatedFlag;
    int rows, cols, size;





    typedef typename DataType<T, NPC>::name DATATYPE;
    using _DATATTYPE = typename std::conditional<
        (XFCVDEPTH < 0),
        DATATYPE*,
        typename std::conditional<
            (XFCVDEPTH == 0),
            hls::stream<DATATYPE>,
            hls::stream<DATATYPE, XFCVDEPTH>
            >::type>::type;
    _DATATTYPE data;

    Mat();
    Mat(Size _sz);
    Mat(int _rows, int _cols);
    Mat(int _size, int _rows, int _cols);
    Mat(int _rows, int _cols, void* _data);
    Mat(const Mat&);

    ~Mat();

    Mat& operator=(const Mat&);



    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>
    void alloc_data() {
# 490 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp"
    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>
    void alloc_data() {

    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>
    void free_data() {
        if (data != __null) {



        }
    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>
    void free_data() {}

    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>
    void copyData(const Mat& src) {
        VITIS_LOOP_511_1: for (int i = 0; i < (rows * ((cols + NPC - 1) >> xfNPixelsPerCycle<NPC>::datashift)); ++i) {
            data[i] = src.data[i];
        }
    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>
    void copyData(const Mat& src) {

        (__builtin_assume(static_cast <bool> (0)));
    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>
    void assignDataPtr(void* _data) {
        data = (DATATYPE*)_data;
    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>
    void assignDataPtr(void* _data) {

        (__builtin_assume(static_cast <bool> (0)));
    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>
    typename DataType<T, NPC>::name
    read(int index) {
        return data[index];
    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>
    typename DataType<T, NPC>::name
    read(int index) {
        return data.read();
    }
    float read_float(int index);

    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>
    void write(int index, typename DataType<T, NPC>::name val) {
        data[index] = val;
    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>
    void write(int index, typename DataType<T, NPC>::name val) {
        data.write(val);
    }
    void write_float(int index, float val);

    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>
    void init(int _rows, int _cols, void* _data) {
        init(_rows, _cols);
        copyTo(_data);
    }

    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>
    void init(int _rows, int _cols, void* _data) {
        init(_rows, _cols, false);
        assignDataPtr(_data);
    }

    void init(int _rows, int _cols, bool allocate = true);
    void copyTo(void* fromData);
    unsigned char* copyFrom();

    const int type() const;
    const int depth() const;
    const int channels() const;

    template <int DST_T>
    void convertTo(Mat<DST_T, ROWS, COLS, NPC, XFCVDEPTH>& dst, int otype, double alpha = 1, double beta = 0);
};

template <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>
const int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::type() const {

#pragma HLS inline

 return (T);
}

template <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>
const int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::depth() const {

#pragma HLS inline

 return DataType<T, NPC>::bitdepth;
}
template <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>
const int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::channels() const {

#pragma HLS inline

 return DataType<T, NPC>::channel;
}

template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
inline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::init(int _rows, int _cols, bool allocate) {

#pragma HLS inline


 (__builtin_assume(static_cast <bool> ((_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) && "The number of rows and columns must be less than the template " "arguments.")));



    rows = _rows;
    cols = _cols;
    allocatedFlag = 0;
    size = _rows * ((_cols + NPPC - 1) >> xfNPixelsPerCycle<NPPC>::datashift);

    if (allocate) {
        alloc_data();
    }
}


template <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>
inline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::Mat(const Mat& src) {
    init(src.rows, src.cols);




}


template <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>
inline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::operator=(const Mat& src) {
    if (this == &src) {
        return *this;
    }


    free_data();
    allocatedFlag = 0;

    init(src.rows, src.cols);
    copyData(src);

    return *this;
}

template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
inline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat() {

#pragma HLS inline


 init(ROWS, COLS);
}

template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
inline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols, void* _data) {

#pragma HLS inline


 init(_rows, _cols, _data);
}

template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
inline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols) {

#pragma HLS inline


 init(_rows, _cols);
}

template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
inline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(Size _sz) {

#pragma HLS inline


 init(_sz.height, _sz.width);
}

template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
inline float Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::read_float(int index) {
    union int2float {
        unsigned I;
        float F;
    };
    int2float val;
    val.I = read(index).to_uint();
    return val.F;
}

template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
inline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::write_float(int index, float float_val) {
    float val = float_val;
    ap_uint<32>* val_out = (ap_uint<32>*)(&val);
    write(index, *val_out);
}

template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
inline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyTo(void* _input) {

#pragma HLS inline


 typename DataType<T, NPPC>::sname* input = (typename DataType<T, NPPC>::sname*)_input;
    typename DataType<T, NPPC>::cname in_val;

    int packcols = cols >> xfNPixelsPerCycle<NPPC>::datashift;
    int pixdepth = DataType<T, NPPC>::pixelwidth;
    int bitdepth = pixdepth / DataType<T, NPPC>::channel;
    int nppc = xfNPixelsPerCycle<NPPC>::nppc;

    VITIS_LOOP_719_1: for (int r = 0; r < rows; r++) {
        VITIS_LOOP_720_2: for (int c = 0; c < packcols; c++) {
            VITIS_LOOP_721_3: for (int p = 0; p < nppc; p++) {
                DATATYPE out_val;
                VITIS_LOOP_723_4: for (int ch = 0; ch < DataType<T, NPPC>::channel; ch++) {
                    if (T == XF_32FC1) {
                        in_val = float2ap_uint<ap_uint<32> >(
                            input[DataType<T, NPPC>::channel * ((r * packcols + c) * nppc + p) + ch]);
                    } else {
                        in_val = input[DataType<T, NPPC>::channel * ((r * packcols + c) * nppc + p) + ch];
                    }

                    out_val.range((p * pixdepth) + (ch + 1) * bitdepth - 1, (p * pixdepth) + ch * bitdepth) = in_val;
                }
                write((r * packcols + c), out_val);
            }
        }
    }
}

template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
inline unsigned char* Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyFrom() {

#pragma HLS inline




 int pixdepth = DataType<T, NPPC>::pixelwidth;
    int bitdepth = pixdepth / DataType<T, NPPC>::channel;
    int nppc = xfNPixelsPerCycle<NPPC>::nppc;

    int cv_nbytes = bitdepth / 8;

    unsigned char* value =
        (unsigned char*)malloc(rows * cols * (DataType<T, NPPC>::channel) * (sizeof(unsigned char)) * cv_nbytes);

    int xf_npc_idx = 0;
    int diff_ptr = 0;
    int xf_ptr = 0;
    int cv_ptr = 0;

    VITIS_LOOP_761_1: for (int r = 0; r < rows; r++) {
        VITIS_LOOP_762_2: for (int c = 0; c < cols; c++) {
            DATATYPE in_val = read(xf_ptr);
            VITIS_LOOP_764_3: for (int ch = 0; ch < DataType<T, NPPC>::channel; ch++) {
                VITIS_LOOP_765_4: for (int b = 0; b < cv_nbytes; ++b) {
                    value[cv_ptr++] = in_val.range((xf_npc_idx * pixdepth) + (ch * bitdepth) + (b + 1) * 8 - 1,
                                                   (xf_npc_idx * pixdepth) + (ch * bitdepth) + b * 8);
                }
            }
            if (xf_npc_idx == nppc - 1) {
                xf_npc_idx = 0;
                xf_ptr++;
            } else {
                xf_npc_idx++;
            }
        }
    }

    return (unsigned char*)value;
}


template <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>
template <int DST_T>
inline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::convertTo(Mat<DST_T, ROWS, COLS, NPPC, XFCVDEPTH>& dst,
                                                           int otype,
                                                           double alpha,
                                                           double beta) {
    (__builtin_assume(static_cast <bool> ((DataType<T, NPPC>::channel == 1) && "Multi-channel images not supported")));

    typename DataType<T, NPPC>::name tmp_in_pix;
    typename DataType<DST_T, NPPC>::name tmp_out_pix;

    typename DataType<T, NPPC>::cname in_pix;
    typename DataType<DST_T, NPPC>::cname out_pix;

    int min, max;

    if (DST_T == XF_8UC1) {
        min = 0;
        max = 255;
    } else if (DST_T == XF_16UC1) {
        min = 0;
        max = 65535;
    } else if (DST_T == XF_16SC1) {
        min = -32768;
        max = 32767;
    } else if (DST_T == XF_32SC1) {
        min = -2147483648;
        max = 2147483647;
    } else {
        (__builtin_assume(static_cast <bool> (1 && "Output image type not supoorted. XF_8UC1, XF_16UC1, XF_16SC1 " "and XF_32SC1 are valid")));


    }



    VITIS_LOOP_819_1: for (int i = 0; i < rows; i++) {
        VITIS_LOOP_820_2: for (int j = 0; j<cols>> (xfNPixelsPerCycle<NPPC>::datashift); j++) {
            int IN_STEP = PixelType<DataType<T, NPPC>::pixeldepth>::bitdepth;
            int OUT_STEP = PixelType<DataType<DST_T, NPPC>::pixeldepth>::bitdepth;
            int in_shift = 0;
            int out_shift = 0;
            DATATYPE in_val = read((i * cols >> (xfNPixelsPerCycle<NPPC>::datashift)) + j);
            DATATYPE out_val;

            VITIS_LOOP_828_3: for (int k = 0; k < (1 << (xfNPixelsPerCycle<NPPC>::datashift)); k++) {

                in_pix = in_val.range(in_shift + IN_STEP - 1, in_shift);




                if (otype == XF_CONVERT_16U_TO_8U || otype == XF_CONVERT_16S_TO_8U || otype == XF_CONVERT_32S_TO_8U ||
                    otype == XF_CONVERT_32S_TO_16U || otype == XF_CONVERT_32S_TO_16S) {
                    float tmp = (float)(in_pix * alpha + beta);
                    in_pix = (tmp >= max ? max : (tmp < 0 ? 0 : lround(tmp)));

                    if (in_pix < min) in_pix = min;
                    if (in_pix > max) in_pix = max;

                    tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = in_pix;
                } else {
                    if ((((typename PixelType<DataType<DST_T, NPPC>::pixeldepth>::name)in_pix * alpha) + beta) > max) {
                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = max;

                    } else if ((((typename PixelType<DataType<DST_T, NPPC>::pixeldepth>::name)in_pix * alpha) + beta) < min) {
                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = min;

                    } else {
                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = (in_pix * alpha + beta >= max ? max : (in_pix * alpha + beta < 0 ? 0 : lround(in_pix * alpha + beta)));
                    }
                }

                out_pix = tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift);

                out_val.range(out_shift + OUT_STEP - 1, out_shift) = out_pix;




                in_shift = in_shift + IN_STEP;
                out_shift = out_shift + OUT_STEP;
            }
            write(((i * cols >> (xfNPixelsPerCycle<NPPC>::datashift)) + j), out_val);
        }
    }
}

template <int SRC_T, int ROWS, int COLS, int NPC, int XFCVDEPTH>
Mat<SRC_T, ROWS, COLS, NPC, XFCVDEPTH>::~Mat() {





}



template <int N>
struct log2 {
   public:
    static constexpr int fvalue = 1 + (log2<N / 2>::fvalue);
    static constexpr int cvalue = (N > (1 << fvalue)) ? (fvalue + 1) : fvalue;
};

template <>
struct log2<1> {
   public:
    static constexpr int fvalue = 0;
    static constexpr int cvalue = 0;
};

struct bgr2y8_params {
    int black_Vmax = 20;
    int black_Smax = 70;
    int brown_Hmax = 15;
    int brown_Vmax = 40;
    int Smin = 60;
    int Smax = 90;
    int darkgreen_Vmax = 35;
    int darkgreen_Hmin = 30;
    int darkgreen_Hmax = 45;
    int green_Hmax = 90;
    int green_Hmin = 50;
    int green_Vmax = 45;
};
# 919 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_structs.hpp"
template <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>
class MMIter : public Mat<T, ROWS, COLS, NPC, XFCVDEPTH> {
   public:
    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;
    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;
    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;

    static constexpr int XF_BITS_PER_CLOCK = DataType<T, NPC>::pixelwidth * xfNPixelsPerCycle<NPC>::nppc;
    static constexpr int COLS_BOUND_PER_NPC = ((COLS + (xfNPixelsPerCycle<NPC>::nppc - 1)) >> xfNPixelsPerCycle<NPC>::datashift);
    static constexpr int LOOPBOUND = ROWS * COLS_BOUND_PER_NPC;
    static constexpr int ADDRBOUND = ((ROWS * COLS * DataType<T, NPC>::pixelwidth) + (PTR_WIDTH - 1)) >>
                                     (log2<PTR_WIDTH>::cvalue);
    static constexpr int LAST_BLK_PXL_WIDTH =
        ((COLS >> xfNPixelsPerCycle<NPC>::datashift) == COLS_BOUND_PER_NPC)
            ? XF_BITS_PER_CLOCK
            : DataType<T, NPC>::pixelwidth * (COLS - ((COLS >> xfNPixelsPerCycle<NPC>::datashift) << xfNPixelsPerCycle<NPC>::datashift));
    static constexpr int COLS_ADDRBOUND = ((COLS * DataType<T, NPC>::pixelwidth) + (PTR_WIDTH - 1)) >>
                                          (log2<PTR_WIDTH>::cvalue);
    static int cols_npc_aligned(int cols) { return ((cols + (xfNPixelsPerCycle<NPC>::nppc - 1)) >> xfNPixelsPerCycle<NPC>::datashift); }

    static int last_blk_pxl_width(int cols, int cols_bound_per_npc) {
        return ((cols >> xfNPixelsPerCycle<NPC>::datashift) == cols_bound_per_npc)
                   ? XF_BITS_PER_CLOCK
                   : DataType<T, NPC>::pixelwidth * (cols - ((cols >> xfNPixelsPerCycle<NPC>::datashift) << xfNPixelsPerCycle<NPC>::datashift));
    }

    static int loopbound(int rows, int cols) { return rows * cols_npc_aligned(cols); }

    int loopbound() { return rows * cols_npc_aligned(cols); }

    static int addrbound(int rows, int cols) {
        ap_uint<16> rows_int16 = rows;
        ap_uint<16> cols_int16 = cols;

        ap_uint<32> mul_rows_cols;


#pragma HLS BIND_OP variable=mul_rows_cols op=mul impl=dsp latency=2


 mul_rows_cols = rows_int16 * cols_int16;

        return ((mul_rows_cols * DataType<T, NPC>::pixelwidth) + (PTR_WIDTH - 1)) >> (log2<PTR_WIDTH>::cvalue);
    }
    MMIter() : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>() {}

    MMIter(int _rows, int _cols) : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>(_rows, _cols) {}
};


template <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>
class MMIterIn : public MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH> {
   public:
    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;
    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;
    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;

    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::XF_BITS_PER_CLOCK;
    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::ADDRBOUND;
    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::COLS_BOUND_PER_NPC;
    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::LAST_BLK_PXL_WIDTH;
    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::LOOPBOUND;
    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::COLS_ADDRBOUND;

   private:
    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,
                              hls::stream<ap_uint<PTR_WIDTH> >& dout,
                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {
        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;
    MMIterInLoop1:
        for (i = 0; i < addrbound; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND
#pragma HLS PIPELINE

 dout.write(din[i]);
        }
    }

    static void Axi2AxiStream(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,
                              hls::stream<ap_uint<PTR_WIDTH> >& dout,
                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {
        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;
    MMIterInLoop3:
        for (i = 0; i < addrbound; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND
#pragma HLS PIPELINE

 ap_axiu<PTR_WIDTH, 0, 0, 0> v = din.read();
            dout.write(v.data);
        }
    }

    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,
                              hls::stream<ap_uint<PTR_WIDTH> >& dout,
                              int rows_burst,
                              int rows,
                              int cols,
                              int stride = -1) {
        ap_uint<log2<ADDRBOUND>::cvalue + 1> cols_addrbound = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(rows_burst, cols);
        ap_uint<log2<ADDRBOUND>::cvalue + 1> stride_addrbound = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(rows_burst, stride);
        ap_uint<log2<ADDRBOUND>::cvalue + 1> addrbound = (stride == -1) ? cols_addrbound : stride_addrbound;
        ap_uint<log2<ADDRBOUND>::cvalue + 1> c;
    MMIterInLoop1:
        for (int r = 0; r < rows; r++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS

 VITIS_LOOP_1028_1: for (c = 0; c < cols_addrbound; c++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_ADDRBOUND
#pragma HLS PIPELINE II=1

 dout.write(din[c + r * addrbound]);
            }
        }
    }
    template <int DEPTH>
    static void AxiStream2MatStream(hls::stream<ap_uint<PTR_WIDTH> >& din,
                                    hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,
                                    int rows,
                                    int cols_bound_per_npc,
                                    int last_blk_width,
                                    int stride = -1) {
        int stride_bound_per_npc, strideBased_last_blk_width;


        stride_bound_per_npc = cols_bound_per_npc;
        strideBased_last_blk_width = last_blk_width;





        int rd_cnt = 0;

        int rem = 0;
        ap_uint<PTR_WIDTH> val = 0;
        int i;
        int j = 0;
        int bound = rows * stride_bound_per_npc;
    MMIterInLoopRow:
        for (i = 0; i < bound; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND
#pragma HLS PIPELINE

 bool bLast = (j == (stride_bound_per_npc - 1));
            int xf_bits_per_clock = bLast ? strideBased_last_blk_width : XF_BITS_PER_CLOCK;
            int ptr_width_minus = bLast ? (PTR_WIDTH - strideBased_last_blk_width) : (PTR_WIDTH - XF_BITS_PER_CLOCK);
            int ptr_width_plus = bLast ? (PTR_WIDTH + strideBased_last_blk_width) : (PTR_WIDTH + XF_BITS_PER_CLOCK);

            ap_uint<XF_BITS_PER_CLOCK> localbuffer = 0;
            if (rem < xf_bits_per_clock) {
                if (rem != 0) {
                    localbuffer.range(rem - 1, 0) = val.range(PTR_WIDTH - 1, (PTR_WIDTH - rem));
                }
                val = din.read();
                rd_cnt++;
                localbuffer.range((xf_bits_per_clock - 1), rem) = val.range(((xf_bits_per_clock - 1) - rem), 0);
                rem = ptr_width_minus + rem;
            } else {
                localbuffer = val.range(((ptr_width_plus - 1) - rem), (PTR_WIDTH - rem));
                rem = rem - xf_bits_per_clock;
            }

            bool bLast_width = (j == (cols_bound_per_npc - 1));
            ap_uint<XF_BITS_PER_CLOCK> localbuffer2 = 0;
            if (bLast_width == 0)
                localbuffer2 = localbuffer;
            else
                localbuffer2 = localbuffer.range(last_blk_width - 1, 0);

            if (j < cols_bound_per_npc) dout.write(localbuffer2);
            j = (bLast) ? 0 : (j + 1);
        }
    }

    template <int DEPTH>
    static void MatStream2Mat(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,
                              ap_uint<XF_BITS_PER_CLOCK>* dout,
                              int rows,
                              int cols_bound_per_npc) {
        int i;
        int bound = rows * cols_bound_per_npc;
    MMIterInLoop2:
        for (i = 0; i < bound; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND
#pragma HLS PIPELINE

 dout[i] = din.read();
        }
    }

    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,
                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,
                              int rows = ROWS,
                              int cols = COLS,
                              int stride = -1) {

#pragma HLS DATAFLOW

 int cols_bound_per_npc = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::cols_npc_aligned(cols);
        int last_blk_width = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::last_blk_pxl_width(cols, cols_bound_per_npc);
        AxiStream2MatStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);
    }

    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,
                              ap_uint<XF_BITS_PER_CLOCK>* dout,
                              int rows = ROWS,
                              int cols = COLS,
                              int stride = -1) {

#pragma HLS DATAFLOW

 hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;
        int cols_bound_per_npc = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::cols_npc_aligned(cols);
        int last_blk_width = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::last_blk_pxl_width(cols, cols_bound_per_npc);
        AxiStream2MatStream(din, ldata, rows, cols_bound_per_npc, last_blk_width, stride);
        MatStream2Mat(ldata, dout, rows, cols_bound_per_npc);
    }

    static void Axi2Mat(ap_uint<PTR_WIDTH>* din,
                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,
                        int rows = ROWS,
                        int cols = COLS,
                        int stride = -1) {

#pragma HLS DATAFLOW

 hls::stream<ap_uint<PTR_WIDTH> > ldata;

        int rows_burst, rows_stride;

        if (stride == -1) {
            rows_burst = rows;
            rows_stride = 1;
        } else {
            rows_burst = 1;
            rows_stride = rows;
        }

        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);
        AxiStream2Mat(ldata, dout, rows, cols, stride);
    }

    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,
                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,
                        int rows = ROWS,
                        int cols = COLS) {

#pragma HLS DATAFLOW

 hls::stream<ap_uint<PTR_WIDTH> > ldata;

        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(rows, cols);
        Axi2AxiStream(din, ldata, axibound);
        AxiStream2Mat(ldata, dout, rows, cols);
    }

    static void Axi2Mat(
        ap_uint<PTR_WIDTH>* din, ap_uint<XF_BITS_PER_CLOCK>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {

#pragma HLS DATAFLOW

 hls::stream<ap_uint<PTR_WIDTH> > ldata;

        int rows_burst, rows_stride;

        if (stride == -1) {
            rows_burst = rows;
            rows_stride = 1;
        } else {
            rows_burst = 1;
            rows_stride = rows;
        }

        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);
        AxiStream2Mat(ldata, dout, rows, cols, stride);
    }

    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,
                        ap_uint<XF_BITS_PER_CLOCK>* dout,
                        int rows = ROWS,
                        int cols = COLS) {

#pragma HLS DATAFLOW

 hls::stream<ap_uint<PTR_WIDTH> > ldata;
        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(rows, cols);
        Axi2AxiStream(din, ldata, axibound);
        AxiStream2Mat(ldata, dout, rows, cols);
    }

   public:
    MMIterIn(ap_uint<PTR_WIDTH>* d) : MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>() { Axi2Mat(d, data); }

    MMIterIn(ap_uint<PTR_WIDTH>* d, int _rows, int _cols) : MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>(_rows, _cols) { Axi2Mat(d, data, rows, cols); }

    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d) : MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>() { Axi2Mat(d, data); }

    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d, int _rows, int _cols) : MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>(_rows, _cols) {
        Axi2Mat(d, data, rows, cols);
    }

    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d) : MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>() { AxiStream2Mat(d, data); }

    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d, int _rows, int _cols) : MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>(_rows, _cols) {
        AxiStream2Mat(d, data, rows, cols);
    }

    inline static ap_uint<XF_BITS_PER_CLOCK> read(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& din, int index) {
        return din.read();
    }

    inline static ap_uint<XF_BITS_PER_CLOCK> read(ap_uint<XF_BITS_PER_CLOCK>* din, int index) { return din[index]; }

    ap_uint<XF_BITS_PER_CLOCK> read(int index) { return read(data, index); }

    static void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr,
                            xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat,
                            int stride = -1) {
        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols, stride);
    }

    static void Array2xfMat(
        ap_uint<PTR_WIDTH>* srcPtr, ap_uint<XF_BITS_PER_CLOCK>* dstPtr, int rows, int cols, int stride = -1) {
        Axi2Mat(srcPtr, dstPtr, rows, cols, stride);
    }

    static void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,
                              xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat) {
        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols);
    }
};

template <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int FILLZERO = 1, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>
class MMIterOut : public MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH> {
   public:
    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;
    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;
    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;

    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::XF_BITS_PER_CLOCK;
    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::ADDRBOUND;
    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::COLS_BOUND_PER_NPC;
    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::LAST_BLK_PXL_WIDTH;
    using MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::LOOPBOUND;

   private:
    template <int DEPTH>
    static void Mat2MatStream(ap_uint<XF_BITS_PER_CLOCK>* din,
                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,
                              int rows,
                              int cols_bound_per_npc) {
        int i;
        int bound = rows * cols_bound_per_npc;
    MMIterOutLoop1:
        for (i = 0; i < bound; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND
#pragma HLS PIPELINE

 dout.write(din[i]);
        }
    }

    template <int DEPTH>
    static void MatStream2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,
                                    hls::stream<ap_uint<PTR_WIDTH> >& dout,
                                    int rows,
                                    int cols_bound_per_npc,
                                    int last_blk_width,
                                    int stride = -1) {
        ap_uint<16> strideBased_cols_bound_per_npc;

        strideBased_cols_bound_per_npc = cols_bound_per_npc;




        ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled = 0;
        ap_uint<PTR_WIDTH> localbuffer = 0;
        ap_uint<16> i;
        ap_uint<16> rows_int16 = rows;
        ap_uint<16> j;

    MMIterOutRow:
        for (i = 0; i < rows_int16; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS

 MMIterOutCol:
            for (j = 0; j < strideBased_cols_bound_per_npc; j++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_BOUND_PER_NPC
#pragma HLS PIPELINE


 bool bLast = (j == (cols_bound_per_npc - 1));
                int xf_bits_per_clock = bLast ? last_blk_width : XF_BITS_PER_CLOCK;
                ap_uint<PTR_WIDTH> val;
                if (j < cols_bound_per_npc || FILLZERO == 0)
                    val = din.read();
                else
                    val = 0;

                ap_uint<PTR_WIDTH> tempval = (val << filled);
                localbuffer = (localbuffer | tempval);
                ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled_next;

                if (filled < (PTR_WIDTH - xf_bits_per_clock)) {
                    filled_next = filled + xf_bits_per_clock;
                } else if (j == cols_bound_per_npc - 1 && FILLZERO == 0) {
                    dout.write(localbuffer);
                    localbuffer = 0;
                    filled_next = 0;
                } else {
                    dout.write(localbuffer);
                    localbuffer = (val >> (PTR_WIDTH - filled));
                    filled_next = filled + (xf_bits_per_clock - PTR_WIDTH);
                }

                filled = filled_next;
            }
        }

        if (filled != 0) {
            dout.write(localbuffer);
        }
    }

    static void Mat2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,
                              hls::stream<ap_uint<PTR_WIDTH> >& dout,
                              int rows = ROWS,
                              int cols = COLS,
                              int stride = -1) {

#pragma HLS DATAFLOW

 int cols_bound_per_npc = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::cols_npc_aligned(cols);
        int last_blk_width = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::last_blk_pxl_width(cols, cols_bound_per_npc);
        MatStream2AxiStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);
    }

    static void Mat2AxiStream(ap_uint<XF_BITS_PER_CLOCK>* din,
                              hls::stream<ap_uint<PTR_WIDTH> >& dout,
                              int rows = ROWS,
                              int cols = COLS,
                              int stride = -1) {

#pragma HLS DATAFLOW

 hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;
        int cols_bound_per_npc = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::cols_npc_aligned(cols);
        int last_blk_width = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::last_blk_pxl_width(cols, cols_bound_per_npc);
        Mat2MatStream(din, ldata, rows, cols_bound_per_npc);
        MatStream2AxiStream(ldata, dout, rows, cols_bound_per_npc, last_blk_width, stride);
    }

    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,
                              ap_uint<PTR_WIDTH>* dout,
                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {
        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;

    MMIterOutLoop2:
        for (i = 0; i < addrbound; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND
#pragma HLS PIPELINE

 dout[i] = din.read();
        }
    }

    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,
                              hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,
                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {
        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;

    MMIterOutLoop3:
        for (i = 0; i < addrbound; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND
#pragma HLS PIPELINE

 ap_axiu<PTR_WIDTH, 0, 0, 0> v;
            v.data = din.read();
            dout.write(v);
        }
    }

    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,
                        ap_uint<PTR_WIDTH>* dout,
                        int rows = ROWS,
                        int cols = COLS,
                        int stride = -1) {

#pragma HLS DATAFLOW


 int cols_tmp;
        if (stride == -1)
            cols_tmp = cols;
        else
            cols_tmp = stride;

        hls::stream<ap_uint<PTR_WIDTH> > ldata;
        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(rows, cols_tmp);

        Mat2AxiStream(din, ldata, rows, cols, stride);
        if (FILLZERO == 1)
            AxiStream2Axi(ldata, dout, axibound);
        else {
            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(1, cols);
            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(1, stride);
            VITIS_LOOP_1437_1: for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {
                AxiStream2Axi(ldata, dout + offset, axibound_1row);
            }
        }
    }

    static void Mat2Axi(
        ap_uint<XF_BITS_PER_CLOCK>* din, ap_uint<PTR_WIDTH>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {

#pragma HLS DATAFLOW


 int cols_tmp;
        if (stride == -1)
            cols_tmp = cols;
        else
            cols_tmp = stride;

        hls::stream<ap_uint<PTR_WIDTH> > ldata;
        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(rows, cols_tmp);

        Mat2AxiStream(din, ldata, rows, cols, stride);
        if (FILLZERO == 1)
            AxiStream2Axi(ldata, dout, axibound);
        else {
            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(1, cols);
            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(1, stride);

            VITIS_LOOP_1465_1: for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {
                AxiStream2Axi(ldata, dout + offset, axibound_1row);
            }
        }
    }

    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,
                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,
                        int rows = ROWS,
                        int cols = COLS,
                        int stride = -1) {

#pragma HLS DATAFLOW


 int cols_tmp;
        if (stride == -1)
            cols_tmp = cols;
        else
            cols_tmp = stride;

        hls::stream<ap_uint<PTR_WIDTH> > ldata;
        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(rows, cols_tmp);

        Mat2AxiStream(din, ldata, rows, cols, stride);
        if (FILLZERO == 1)
            AxiStream2Axi(ldata, dout, axibound);
        else {
            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(1, cols);
            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(1, stride);
            VITIS_LOOP_1495_1: for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {
                AxiStream2Axi(ldata, dout + offset, axibound_1row);
            }
        }
    }

    static void Mat2Axi(ap_uint<XF_BITS_PER_CLOCK>* din,
                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,
                        int rows = ROWS,
                        int cols = COLS,
                        int stride = -1) {

#pragma HLS DATAFLOW


 int cols_tmp;
        if (stride == -1)
            cols_tmp = cols;
        else
            cols_tmp = stride;

        hls::stream<ap_uint<PTR_WIDTH> > ldata;
        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(rows, cols_tmp);
        Mat2AxiStream(din, ldata, rows, cols, stride);

        if (FILLZERO == 1)
            AxiStream2Axi(ldata, dout, axibound);
        else {
            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(1, cols);
            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>::addrbound(1, stride);
            VITIS_LOOP_1525_1: for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {
                AxiStream2Axi(ldata, dout + offset, axibound_1row);
            }
        }
    }

   public:
    MMIterOut() : MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>() {}

    MMIterOut(int _rows, int _cols) : MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>(_rows, _cols) {}

    inline static void write(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& dout,
                             ap_uint<XF_BITS_PER_CLOCK>& val,
                             int index) {
        dout.write(val);
    }

    inline static void write(ap_uint<XF_BITS_PER_CLOCK>* dout, ap_uint<XF_BITS_PER_CLOCK>& val, int index) {
        dout[index] = val;
    }

    void write(ap_uint<XF_BITS_PER_CLOCK>& val, int index) { write(data, val, index); }

    void transfer(ap_uint<PTR_WIDTH>* dout) { Mat2Axi(data, dout); }

    void transfer(ap_uint<PTR_WIDTH>* dout, int rows, int cols) { Mat2Axi(data, dout, rows, cols); }

    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout) { Mat2Axi(data, dout); }

    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout, int rows, int cols) {
        Mat2Axi(data, dout, rows, cols);
    }

    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout) { Mat2AxiStream(data, dout); }

    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout, int rows, int cols) { Mat2AxiStream(data, dout, rows, cols); }

    static void xfMat2Array(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,
                            ap_uint<PTR_WIDTH>* dstPtr,
                            int stride = -1) {
        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols, stride);
    }

    static void xfMat2Array(
        ap_uint<XF_BITS_PER_CLOCK>* srcPtr, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols, int stride = -1) {
        Mat2Axi(srcPtr, dstPtr, rows, cols, stride);
    }

    static void xfMat2axiStrm(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,
                              hls::stream<ap_uint<PTR_WIDTH> >& dstPtr) {
        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols);
    }
};

}
}
# 21 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_common.hpp" 2



using namespace xf::cv;
# 25 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2


# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_axi_io.hpp" 1
# 19 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_axi_io.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h" 1
# 37 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_half.h" 1
# 38 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 1 3
# 41 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
# 158 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 382 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1593 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435e-38F; }

      static constexpr float
      max() noexcept { return 3.40282347e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282347e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209290e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return 2.2250738585072014e-308; }

      static constexpr double
      max() noexcept { return 1.7976931348623157e+308; }


      static constexpr double
      lowest() noexcept { return -1.7976931348623157e+308; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return 2.2204460492503131e-16; }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return 4.9406564584124654e-324; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 2.2250738585072014e-308L; }

      static constexpr long double
      max() noexcept { return 1.7976931348623157e+308L; }


      static constexpr long double
      lowest() noexcept { return -1.7976931348623157e+308L; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 2.2204460492503131e-16L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 4.9406564584124654e-324L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 39 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h" 2
# 69 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
namespace hls {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hls::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


namespace hlstmp {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hlstmp::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


static inline
const
uint32_t pow2(uint32_t e)
{
    switch(e) {
        case 0: return 1; break;
        case 1: return 2; break;
        case 2: return 4; break;
        case 3: return 8; break;
        case 4: return 16; break;
        case 5: return 32; break;
        case 6: return 64; break;
        case 7: return 128; break;
        case 8: return 256; break;
        case 9: return 512; break;
        case 10: return 1024; break;
        case 11: return 2048; break;
        default: return 0;
    }
}

template<typename T>


__attribute__((hls_preserve))


T reg(T d)
{
#pragma HLS PIPELINE II=1
#pragma HLS LATENCY min=1 max=1
#pragma HLS INLINE off
 return d;
}
# 271 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
static inline
float to_float(float v)
{
    return v;
}

template<int _W, int _I>
float to_float(ap_fixed<_W, _I> v)
{
    return v.to_float();
}
# 290 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
template <typename T>
class fp_struct
{
};

union single_cast {
    float f;
    uint32_t i;
};

template <>
class fp_struct<float>
{
public:
    const static int EXP_INFNAN = 255;
    const static int EXP_BIAS = 127;
    const static int EXP_BITS = 8;
    const static int SIG_BITS = 23;
    const static int BITS = 32;

    fp_struct() {
    }
    fp_struct(float f) {


        union single_cast dc;
        dc.f = f;
        ap_uint<32> data = dc.i;





        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(ap_uint<32> data) {
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(uint32_t i) {
        ap_uint<32> data = i;
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    inline ap_uint<32> data() const {
        ap_uint<32> t;
        t[31] = sign[0];
        t(30,23) = exp(7,0);
        t(22,0) = sig(22,0);
        return t;
    }
    inline int expv() const {
        return exp-127;
    }
    inline int32_t to_int() const {
        return data().to_int();
    }
    inline float to_float() const {


        union single_cast ret;
        ret.i = data().to_uint();
        return ret.f;







    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline float to_ieee() const {
        return to_float();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static float infinity() {
        fp_struct<float> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static float minus_infinity() {
        fp_struct<float> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint32_t inttype;
    typedef ap_uint<32> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 420 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castSingle(
    float din,
    fp_struct<float> &dout)
{
    fp_struct<float> t(din);
    dout = t;
}

static inline
float
castSingle(
    fp_struct<float> din)
{
    return din.to_float();
}

static inline
void
dumpSingle(
    float da,
    fp_struct<float> ds)
{
# 457 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}







union double_cast {
    double d;
    uint64_t i;
};

template <>
class fp_struct<double>
{
public:
    const static int EXP_INFNAN = 2047;
    const static int EXP_BIAS = 1023;
    const static int EXP_BITS = 11;
    const static int SIG_BITS = 52;
    const static int BITS = 64;

    fp_struct() {
    }
    fp_struct(double f) {
        union double_cast dc;
        dc.d = f;
        ap_uint<64> data = dc.i;
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(ap_uint<64> data) {
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(uint64_t i) {
        ap_uint<64> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<64> data() const {
        ap_uint<64> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int64_t to_int() const {
        return data().to_int64();
    }
    inline int expv() const {
        return exp-1023;
    }
    inline ap_uint<20> sig_msb() const {
        return sig(51,32);
    }
    inline ap_uint<32> sig_lsb() const {
        return sig(31,0);
    }
    inline double to_double() const {
        union double_cast ret;
        ret.i = data().to_uint64();
        return ret.d;
    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline double to_ieee() const {
        return to_double();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static double infinity() {
        fp_struct<double> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static double minus_infinity() {
        fp_struct<double> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint64_t inttype;
    typedef ap_uint<64> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 581 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castDouble(
    double din,
    fp_struct<double> &dout)
{
    fp_struct<double> t(din);
    dout = t;
}

static inline
double
castDouble(
    fp_struct<double> din)
{
    return din.to_double();
}

static inline
void
dumpDouble(
    double da,
    fp_struct<double> ds)
{
# 618 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}
# 631 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
union half_cast {
    half d;
    uint16_t i;
};


template <>
class fp_struct<half>
{
public:
    const static int EXP_INFNAN = 31;
    const static int EXP_BIAS = 15;
    const static int EXP_BITS = 5;
    const static int SIG_BITS = 10;
    const static int BITS = 16;

    fp_struct() {
    }
    fp_struct(half f) {

        union half_cast dc;
        dc.d = f;
        ap_uint<16> data = dc.i;



        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(ap_uint<16> data) {
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(uint16_t i) {
        ap_uint<16> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<16> data() const {
        ap_uint<16> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int expv() const {
        return exp-EXP_BIAS;
    }
    inline int16_t to_int() const {
        return uint16_t(data().to_int());
    }
    inline half to_half() const {

        union half_cast ret;
        ret.i = data().to_uint64();
        return ret.d;





    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline half to_ieee() const {
        return to_half();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static half infinity() {
        fp_struct<half> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static half minus_infinity() {
        fp_struct<half> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint16_t inttype;
    typedef ap_uint<16> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 749 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castHalf(
    half din,
    fp_struct<half> &dout)
{
    fp_struct<half> t(din);
    dout = t;
}

static inline
half
castHalf(
    fp_struct<half> din)
{
    return din.to_half();
}

static inline
void
dumpHalf(
    half da,
    fp_struct<half> ds)
{
# 786 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}
# 804 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Base, unsigned int _Num >
class Power
{
public:
    static const unsigned int Value = _Base * Power< _Base, _Num - 1 >::Value;
};

template < unsigned int _Base >
class Power< _Base, 0 >
{
public:
    static const unsigned int Value = 1;
};
# 826 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class BitWidth
{
public:
    static const unsigned int Value = 1 + BitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class BitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 2;
};
# 848 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class UnsignedBitWidth
{
public:
    static const unsigned int Value = 1 + UnsignedBitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class UnsignedBitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 1;
};
# 869 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
template < typename T >
class Type_BitWidth
{
public:
    static const unsigned int Value = 8*sizeof(T);
};

template <int W >
class Type_BitWidth< ap_uint<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W >
class Type_BitWidth< ap_int<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_ufixed<W, I> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_fixed<W, I> >
{
public:
    static const unsigned int Value = W;
};
# 917 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I=_Num-1>
class Table : public Table<_T, _Num, _I-1>
{
public:
    typedef typename _T::TableType TableType;
    static const typename _T::TableType dummy;
    static const int size = _Num;

};

template <typename _T, int _Num>
class Table<_T, _Num, 0>
{
public:
    static const typename _T::TableType dummy;
    static typename _T::TableType array[_Num];
};
# 944 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I>
const typename _T::TableType Table<_T, _Num, _I>::dummy
    = Table<_T, _Num, 0>::array[_I] = _T::apply(_I,_Num) + 0*Table<_T, _Num, _I-1>::dummy;

template <typename _T, int _Num>
const typename _T::TableType Table<_T, _Num, 0>::dummy
    = Table<_T, _Num, 0>::array[0] = _T::apply(0,_Num);




template <typename _T, int _Num>
typename _T::TableType Table<_T, _Num, 0>::array[_Num];



template <class T>
struct is_fptype { static const bool value = false; };
template <> struct is_fptype<float> { static const bool value = true; };
template <> struct is_fptype<double> { static const bool value = true; };
template <> struct is_fptype<half> { static const bool value = true; };

template <class T>
struct is_integraltype { static const bool value = false; };
template <> struct is_integraltype<int> { static const bool value = true; };
template <> struct is_integraltype<unsigned int> { static const bool value = true; };
template <> struct is_integraltype<char> { static const bool value = true; };
template <> struct is_integraltype<signed char> { static const bool value = true; };
template <> struct is_integraltype<unsigned char> { static const bool value = true; };
template <> struct is_integraltype<short> { static const bool value = true; };
template <> struct is_integraltype<unsigned short> { static const bool value = true; };
template <> struct is_integraltype<long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long> { static const bool value = true; };
template <> struct is_integraltype<long long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long long> { static const bool value = true; };
template <int W> struct is_integraltype<ap_int<W> > { static const bool value = true; };
template <int W> struct is_integraltype<ap_uint<W> > { static const bool value = true; };

template <class T>
struct is_fixedtype { static const bool value = false; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_fixed<W,I,Q,O> > { static const bool value = true; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_ufixed<W,I,Q,O> > { static const bool value = true; };

namespace hls {
    template<bool B, class T = void>
    struct enable_if {};

    template<class T>
    struct enable_if<true, T> { typedef T type; };
    template<typename T, T _v>
    struct integral_constant
    {
        static const T value = _v;
        typedef T value_type;
        typedef integral_constant<T,_v> type;
        operator value_type() { return value; }
    };

    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;

    template<typename T1, typename T2>
    struct is_same;

    template<typename T1, typename T2>
    struct is_same : public false_type { };

    template<typename T1>
    struct is_same<T1,T1> : public true_type { };

    template<typename T>
    struct is_arithmetic : public integral_constant<bool, (is_integraltype<T>::value || is_fptype<T>::value)> { };
}

template<typename T1, typename T2>
struct enable_or { static const bool value = T1::value || T2::value; };

template<typename T1, typename T2>
struct enable_and { static const bool value = T1::value && T2::value; };



template<typename T, bool = is_integraltype<T>::value>
struct __promote { typedef double type; };

template<typename T>
struct __promote<T, false> { };

template<>
struct __promote<double> { typedef double type; };

template<>
struct __promote<float> { typedef float type; };

template<>
struct __promote<half> { typedef half type; };
# 20 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_axi_io.hpp" 2
# 1 "/usr/include/assert.h" 1 3 4
# 21 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_axi_io.hpp" 2

namespace xf {
namespace cv {

template <int W, typename T>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, T& val) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (start >= 0 && start + w <= W)));
    val = (T)pix(start + w - 1, start);
}

template <int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, float& val) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (w == 32 && start >= 0 && start + w <= W)));
    fp_struct<float> temp((ap_uint<32>)pix(start + w - 1, start));
    val = temp.to_float();
}

template <int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, double& val) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (w == 64 && start >= 0 && start + w <= W)));
    fp_struct<double> temp((ap_uint<64>)pix(start + w - 1, start));
    val = temp.to_double();
}

template <int W, typename T>
void AXIGetBitFields(ap_axiu<W, 1, 1, 1> axi, int start, int w, T& val) {

#pragma HLS inline

 AXIGetBitFields(axi.data, start, w, val);
}

template <int W, typename T>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, T val) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (start >= 0 && start + w <= W)));
    pix(start + w - 1, start) = val;
}

template <int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, float val) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (w == 32 && start >= 0 && start + w <= W)));
    fp_struct<float> temp(val);
    pix(start + w - 1, start) = temp.data();
}

template <int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, double val) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (w == 64 && start >= 0 && start + w <= W)));
    fp_struct<double> temp(val);
    pix(start + w - 1, start) = temp.data();
}

template <int W, typename T>
void AXISetBitFields(ap_axiu<W, 1, 1, 1>& axi, int start, int w, T val) {

#pragma HLS inline

 AXISetBitFields(axi.data, start, w, val);
}

}
};
# 28 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "./build/xf_config_params.h" 1
# 29 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2


# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bpc.hpp" 1
# 20 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bpc.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 21 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bpc.hpp" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_utility.hpp" 1
# 22 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_utility.hpp"
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp" 1
# 30 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {





# 1 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;




extern void *memset (void *__s, int __c, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 105 "/usr/include/string.h" 3 4
}
# 115 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
                                           ;
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
                                           ;
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (2))) ;






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) noexcept (true) __attribute__ ((__nonnull__ (2, 4)))
                                           ;





extern char *strdup (const char *__s)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 244 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 271 "/usr/include/string.h" 3 4
}
# 281 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 321 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 348 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 389 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))

                                         ;



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) noexcept (true);
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) ;




extern const char *strerrordesc_np (int __err) noexcept (true);

extern const char *strerrorname_np (int __err) noexcept (true);





extern char *strerror_l (int __errnum, locale_t __l) noexcept (true);




# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) noexcept (true) __attribute__ ((__const__));





extern int ffsl (long int __l) noexcept (true) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     noexcept (true) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
                                                  ;



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) noexcept (true);



extern const char *sigabbrev_np (int __sig) noexcept (true);


extern const char *sigdescr_np (int __sig) noexcept (true);



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
                                          ;







extern "C++" char *basename (char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 539 "/usr/include/string.h" 3 4
}
# 31 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp" 2


typedef ap_uint<32> XF_SIZE_T;

namespace xf {
namespace cv {




template <int ROWS, int COLS, typename T>
class Window {
   public:
    Window(){

#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
#pragma HLS ARRAY_PARTITION variable=val dim=2 complete

 };


    void shift_pixels_left();
    void shift_pixels_right();
    void shift_pixels_up();
    void shift_pixels_down();
    void insert_pixel(T value, int row, int col);
    void insert_row(T value[COLS], int row);
    void insert_top_row(T value[COLS]);
    void insert_bottom_row(T value[COLS]);
    void insert_col(T value[ROWS], int col);
    void insert_left_col(T value[ROWS]);
    void insert_right_col(T value[ROWS]);
    T& getval(int row, int col);
    T& operator()(int row, int col);


    void shift_left();
    void shift_right();
    void shift_up();
    void shift_down();
    void insert(T value, int row, int col);
    void insert_top(T value[COLS]);
    void insert_bottom(T value[COLS]);
    void insert_left(T value[ROWS]);
    void insert_right(T value[ROWS]);



    T val[ROWS][COLS];





};
# 109 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::shift_pixels_left() {

#pragma HLS inline








 XF_SIZE_T i, j;
    VITIS_LOOP_122_1: for (i = 0; i < ROWS; i++) {

#pragma HLS unroll

 VITIS_LOOP_126_2: for (j = 0; j < COLS - 1; j++) {

#pragma HLS unroll

 val[i][j] = val[i][j + 1];
        }
    }
# 147 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}





template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::shift_pixels_right() {

#pragma HLS inline








 XF_SIZE_T i, j;
    VITIS_LOOP_166_1: for (i = 0; i < ROWS; i++) {

#pragma HLS unroll

 VITIS_LOOP_170_2: for (j = COLS - 1; j > 0; j--) {

#pragma HLS unroll

 val[i][j] = val[i][j - 1];
        }
    }
# 191 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}





template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::shift_pixels_up() {

#pragma HLS inline








 XF_SIZE_T i, j;
    VITIS_LOOP_210_1: for (i = 0; i < ROWS - 1; i++) {

#pragma HLS unroll

 VITIS_LOOP_214_2: for (j = 0; j < COLS; j++) {

#pragma HLS unroll

 val[i][j] = val[i + 1][j];
        }
    }
# 235 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}





template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::shift_pixels_down() {

#pragma HLS inline








 XF_SIZE_T i, j;
    VITIS_LOOP_254_1: for (i = ROWS - 1; i > 0; i--) {

#pragma HLS unroll

 VITIS_LOOP_258_2: for (j = 0; j < COLS; j++) {

#pragma HLS unroll

 val[i][j] = val[i - 1][j];
        }
    }
# 279 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_pixel(T value, int row, int col) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (row >= 0 && row < ROWS && col >= 0 && col < COLS)));







    val[row][col] = value;
# 312 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_row(T value[COLS], int row) {

#pragma HLS inline








 XF_SIZE_T j;
    VITIS_LOOP_330_1: for (j = 0; j < COLS; j++) {

#pragma HLS unroll

 val[row][j] = value[j];
    }
# 351 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_top_row(T value[COLS]) {

#pragma HLS inline








 insert_row(value, 0);
# 384 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_bottom_row(T value[COLS]) {

#pragma HLS inline








 insert_row(value, ROWS - 1);
# 417 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_col(T value[ROWS], int col) {

#pragma HLS inline








 XF_SIZE_T i;
    VITIS_LOOP_435_1: for (i = 0; i < ROWS; i++) {

#pragma HLS unroll

 val[i][col] = value[i];
    }
# 456 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_left_col(T value[ROWS]) {

#pragma HLS inline








 insert_col(value, 0);
# 489 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_right_col(T value[ROWS]) {

#pragma HLS inline








 insert_col(value, COLS - 1);
# 522 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T>
T& Window<ROWS, COLS, T>::getval(int row, int col) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (row >= 0 && row < ROWS && col >= 0 && col < COLS)));
    return val[row][col];
}




template <int ROWS, int COLS, typename T>
T& Window<ROWS, COLS, T>::operator()(int row, int col) {

#pragma HLS inline

 return getval(row, col);
}
# 576 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::shift_left() {

#pragma HLS inline

 shift_pixels_left();
}






template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::shift_right() {

#pragma HLS inline

 shift_pixels_right();
}






template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::shift_up() {

#pragma HLS inline

 shift_pixels_up();
}






template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::shift_down() {

#pragma HLS inline

 shift_pixels_down();
}






template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert(T value, int row, int col) {

#pragma HLS inline

 insert_pixel(value, row, col);
}






template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_top(T value[COLS]) {

#pragma HLS inline

 insert_bottom_row(value);
}






template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_bottom(T value[COLS]) {

#pragma HLS inline

 insert_top_row(value);
}






template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_left(T value[ROWS]) {

#pragma HLS inline

 insert_right_col(value);
}






template <int ROWS, int COLS, typename T>
void Window<ROWS, COLS, T>::insert_right(T value[ROWS]) {

#pragma HLS inline

 insert_left_col(value);
}
# 696 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE = RAM_S2P_BRAM, int RESHAPE_FACTOR = 1> class LineBuffer {
   public:
    LineBuffer() {

#pragma HLS INLINE
#pragma HLS dependence variable=val inter false
#pragma HLS dependence variable=val intra false





 switch (MEM_TYPE) {
            case RAM_1P_BRAM:

#pragma HLS RESOURCE variable=val core=RAM_1P_BRAM

 break;
            case RAM_1P_URAM:

#pragma HLS RESOURCE variable=val core=RAM_1P_URAM

 break;
            case RAM_2P_BRAM:

#pragma HLS RESOURCE variable=val core=RAM_2P_BRAM

 break;
            case RAM_2P_URAM:

#pragma HLS RESOURCE variable=val core=RAM_2P_URAM

 break;
            case RAM_S2P_BRAM:

#pragma HLS RESOURCE variable=val core=RAM_S2P_BRAM

 break;
            case RAM_S2P_URAM:

#pragma HLS RESOURCE variable=val core=RAM_S2P_URAM

 break;
            case RAM_T2P_BRAM:

#pragma HLS RESOURCE variable=val core=RAM_T2P_BRAM

 break;
            case RAM_T2P_URAM:

#pragma HLS RESOURCE variable=val core=RAM_T2P_URAM

 break;
            default:
                (__builtin_assume(static_cast <bool> ("MEM_TYPE should be one of RAM_*_BRAM or RAM_*_URAM (*: 1P, 2P, S2P, T2P)")));
        }

        if (RESHAPE_FACTOR == 1) {

#pragma HLS ARRAY_PARTITION variable=val complete dim=1

 } else {

#pragma HLS ARRAY_RESHAPE variable=val factor=RESHAPE_FACTOR dim=1

 }
    };


    void shift_pixels_up(int col);
    void shift_pixels_down(int col);
    void insert_bottom_row(T value, int col);
    void insert_top_row(T value, int col);
    void get_col(T value[ROWS], int col);
    T& getval(int row, int col);
    T& operator()(int row, int col);


    void shift_up(int col);
    void shift_down(int col);
    void insert_bottom(T value, int col);
    void insert_top(T value, int col);



    T val[ROWS][COLS];





};
# 811 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> void LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::shift_pixels_down(int col) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (col >= 0 && col < COLS)));







    XF_SIZE_T i;
    VITIS_LOOP_824_1: for (i = ROWS - 1; i > 0; i--) {

#pragma HLS unroll

 val[i][col] = val[i - 1][col];
    }
# 848 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}





template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> void LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::shift_pixels_up(int col) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (col >= 0 && col < COLS)));







    XF_SIZE_T i;
    VITIS_LOOP_867_1: for (i = 0; i < ROWS - 1; i++) {

#pragma HLS unroll

 val[i][col] = val[i + 1][col];
    }
# 891 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> void LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::insert_bottom_row(T value, int col) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (col >= 0 && col < COLS)));







    val[ROWS - 1][col] = value;
# 924 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> void LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::insert_top_row(T value, int col) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (col >= 0 && col < COLS)));







    val[0][col] = value;
# 957 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}




template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> void LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::get_col(T value[ROWS], int col) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (col >= 0 && col < COLS)));
    XF_SIZE_T i;
    VITIS_LOOP_968_1: for (i = 0; i < ROWS; i++) {

#pragma HLS unroll

 value[i] = val[i][col];
    }
}




template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> T& LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::getval(int row, int col) {

#pragma HLS inline

 (__builtin_assume(static_cast <bool> (row >= 0 && row < ROWS && col >= 0 && col < COLS)));
    return val[row][col];
}




template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> T& LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::operator()(int row, int col) {

#pragma HLS inline

 return getval(row, col);
}






template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> void LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::shift_down(int col) {

#pragma HLS inline

 shift_pixels_down(col);
}






template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> void LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::shift_up(int col) {

#pragma HLS inline

 shift_pixels_up(col);
}






template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> void LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::insert_bottom(T value, int col) {

#pragma HLS inline

 insert_top_row(value, col);
}






template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR> void LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>::insert_top(T value, int col) {

#pragma HLS inline

 insert_bottom_row(value, col);
}
# 1069 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_video_mem.hpp"
}
}
# 23 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_utility.hpp" 2
# 1 "/usr/include/assert.h" 1 3 4
# 24 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_utility.hpp" 2


namespace xf {
namespace cv {




template <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC>
void Ptr2xfMat(ap_uint<BUS_WIDTH>* in_ptr, xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& out_mat) {
#pragma HLS INLINE OFF

 const int c_TRIP_COUNT = ROWS * COLS;
    int loopcount = out_mat.rows * (out_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift);
    VITIS_LOOP_38_1: for (int i = 0; i < loopcount; i++) {
#pragma HLS pipeline II = 1
#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT

 out_mat.write(i, (typename DataType<TYPE, NPPC>::name)in_ptr[i]);
    }

}




template <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC>
void xfMat2Ptr(xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& in_mat, ap_uint<BUS_WIDTH>* out_ptr) {
#pragma HLS INLINE OFF

 const int c_TRIP_COUNT = ROWS * COLS;
    int loopcount = in_mat.rows * (in_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift);

    VITIS_LOOP_57_1: for (int i = 0; i < loopcount; i++) {
#pragma HLS pipeline II = 1
#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT

 out_ptr[i] = in_mat.read(i);
    }

}





template <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC>
void xFDuplicateMat_PTRMAT(xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& in_mat,
                           ap_uint<BUS_WIDTH>* out_ptr,
                           xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& out_mat) {
#pragma HLS INLINE OFF

 const int c_TRIP_COUNT = ROWS * COLS;
    int loopcount = in_mat.rows * (in_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift);

    VITIS_LOOP_79_1: for (int i = 0; i < loopcount; i++) {
#pragma HLS pipeline II = 1
#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT

 typename DataType<TYPE, NPPC>::name tmp = in_mat.read(i);

        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;
        out_mat.write(i, tmp);
    }

}





template <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC>
void xFDuplicateMat_PTRMAT2(xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& in_mat,
                            ap_uint<BUS_WIDTH>* out_ptr,
                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& out_mat1,
                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& out_mat2) {
#pragma HLS INLINE OFF

 const int c_TRIP_COUNT = ROWS * COLS;
    int loopcount = in_mat.rows * (in_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift);

    VITIS_LOOP_105_1: for (int i = 0; i < loopcount; i++) {
#pragma HLS pipeline II = 1
#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT

 typename DataType<TYPE, NPPC>::name tmp = in_mat.read(i);

        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;
        out_mat1.write(i, tmp);
        out_mat2.write(i, tmp);

    }

}





template <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC>
void xFDuplicateMat_PTR_MAT_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& in_mat,
                                ap_uint<BUS_WIDTH>* out_ptr,
                                xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& out_mat,
                                hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {
#pragma HLS INLINE OFF

 const int c_TRIP_COUNT = ROWS * COLS;
    int loopcount = in_mat.rows * (in_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift);

    VITIS_LOOP_133_1: for (int i = 0; i < loopcount; i++) {
#pragma HLS pipeline II = 1
#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT

 ap_axiu<BUS_WIDTH, 0, 0, 0> v;
        typename DataType<TYPE, NPPC>::name tmp = in_mat.read(i);

        out_ptr[i] = tmp;
        out_mat.write(i, tmp);

        v.data = tmp;
        out_axi.write(v);
    }

}





template <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC>
void xFMat2AXI_Strm(xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& in_mat, hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {
#pragma HLS INLINE OFF

 const int c_TRIP_COUNT = ROWS * COLS;
    int loopcount = in_mat.rows * (in_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift);

    VITIS_LOOP_160_1: for (int i = 0; i < loopcount; i++) {
#pragma HLS pipeline II = 1
#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT

 ap_axiu<BUS_WIDTH, 0, 0, 0> v;

        v.data = in_mat.read(i);
        out_axi.write(v);
    }

}





template <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC>
void AXI_Strm2xFMat(hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& in_axi, xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& out_mat) {
#pragma HLS INLINE OFF

 const int c_TRIP_COUNT = ROWS * COLS;
    int loopcount = out_mat.rows * (out_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift);

    VITIS_LOOP_183_1: for (int i = 0; i < loopcount; i++) {
#pragma HLS pipeline II = 1
#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT
 ap_axiu<BUS_WIDTH, 0, 0, 0> v = in_axi.read();

        out_mat.write(i, v.data);
    }

}





template <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC>
void xFDuplicateMat_PTR_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& in_mat,
                            ap_uint<BUS_WIDTH>* out_ptr,
                            hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {
#pragma HLS INLINE OFF

 const int c_TRIP_COUNT = ROWS * COLS;
    int loopcount = in_mat.rows * (in_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift);

    VITIS_LOOP_206_1: for (int i = 0; i < loopcount; i++) {
#pragma HLS pipeline II = 1
#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT
 ap_axiu<BUS_WIDTH, 0, 0, 0> v;
        typename DataType<TYPE, NPPC>::name tmp = in_mat.read(i);

        out_ptr[i] = tmp;

        v.data = tmp;
        out_axi.write(v);
    }

}





template <int K_ROWS, int K_COLS, typename SRC_T, int BORDER_T>
void xFSetBorder(xf::cv::Window<K_ROWS, K_COLS, SRC_T>& src_blk,
                 uint16_t _row,
                 uint16_t _col,
                 uint16_t _src_rows,
                 uint16_t _src_cols) {
#pragma HLS INLINE OFF

 uint16_t blk_t_idx, blk_b_idx;
    uint16_t blk_l_idx, blk_r_idx;

    blk_t_idx = (K_ROWS - _row - 1);
    blk_b_idx = (K_ROWS - (_row - _src_rows + 1) - 1);

    blk_l_idx = (K_COLS - _col - 1);
    blk_r_idx = (K_COLS - (_col - _src_cols + 1) - 1);

    VITIS_LOOP_241_1: for (uint16_t r = 0; r < K_ROWS; r++) {
#pragma HLS UNROLL
 VITIS_LOOP_243_2: for (uint16_t c = 0; c < K_COLS; c++) {
#pragma HLS UNROLL

 bool top_border = ((r < blk_t_idx) && (_row < K_ROWS - 1)) ? true : false;
            bool bottom_border = ((r > blk_b_idx) && (_row >= _src_rows)) ? true : false;
            bool left_border = ((c < blk_l_idx) && (_col < K_COLS - 1)) ? true : false;
            bool right_border = ((c > blk_r_idx) && (_col >= _src_cols)) ? true : false;

            uint16_t r_idx = r, c_idx = c;

            if (BORDER_T == XF_BORDER_REPLICATE) {
                r_idx = top_border ? blk_t_idx : bottom_border ? blk_b_idx : r;

            } else if (BORDER_T == XF_BORDER_REFLECT_101) {
                r_idx = top_border ? (2 * blk_t_idx - r) : bottom_border ? (2 * blk_b_idx - r) : r;

            } else if (BORDER_T == XF_BORDER_REFLECT) {
                r_idx = top_border ? (2 * blk_t_idx - r - 1) : bottom_border ? (2 * blk_b_idx - r + 1) : r;

            } else {
                r_idx = r;
            }

            if (BORDER_T == XF_BORDER_REPLICATE) {
                c_idx = left_border ? blk_l_idx : right_border ? blk_r_idx : c;

            } else if (BORDER_T == XF_BORDER_REFLECT_101) {
                c_idx = left_border ? (2 * blk_l_idx - c) : right_border ? (2 * blk_r_idx - c) : c;

            } else if (BORDER_T == XF_BORDER_REFLECT) {
                c_idx = left_border ? (2 * blk_l_idx - c - 1) : right_border ? (2 * blk_r_idx - c + 1) : c;

            } else {
                c_idx = c;
            }

            if ((top_border | bottom_border | left_border | right_border) && (BORDER_T == XF_BORDER_CONSTANT)) {
                src_blk.val[r][c] = 0;
            } else {
                src_blk.val[r][c] = src_blk.val[r_idx][c_idx];
            }
        }
    }

}







template <int NPC, int WORDWIDTH, int PIXELDEPTH>
void xfPackPixels(
    typename PixelType<PIXELDEPTH>::name * tmp_buf, typename StreamType<WORDWIDTH>::name & val, uint16_t pos, int16_t loopIter, uint16_t& shift) {

#pragma HLS INLINE

 ap_uint<8> STEP = PixelType<PIXELDEPTH>::bitdepth;

    VITIS_LOOP_303_1: for (ap_int<9> i = 0; i < loopIter; i++) {

#pragma HLS unroll

 typename PixelType<PIXELDEPTH>::uname tmp = tmp_buf[pos];
        val = val | (((typename StreamType<WORDWIDTH>::name)tmp) << (shift * STEP));
        pos++;
        shift++;
    }
}

template <int NPC, int WORDWIDTH, int PIXELDEPTH>
void xfExtractPixels(typename PixelType<PIXELDEPTH>::name * tmp_buf, typename StreamType<WORDWIDTH>::name & val1, int pos) {

#pragma HLS inline off

 typename StreamType<WORDWIDTH>::name v = val1;

    int shift = 0;
    int STEP = PixelType<PIXELDEPTH>::bitdepth;
Extract_pixels_loop:
    for (int i = 0; i < (1 << (xfNPixelsPerCycle<NPC>::datashift)); i++) {

#pragma HLS UNROLL

 tmp_buf[pos + i] = v.range(shift + STEP - 1, shift);
        shift = shift + STEP;
    }
}

template <int NPC, int WORDWIDTH_SRC, int DEPTH_SRC>
void xfExtractData(typename PixelType<DEPTH_SRC>::name * src_buf1,
                   typename PixelType<DEPTH_SRC>::name * src_buf2,
                   typename PixelType<DEPTH_SRC>::name * src_buf3,
                   typename PixelType<DEPTH_SRC>::name * src_buf4,
                   typename PixelType<DEPTH_SRC>::name * src_buf5,
                   typename PixelType<DEPTH_SRC>::name * src_buf6,
                   typename PixelType<DEPTH_SRC>::name * src_buf7,
                   typename StreamType<WORDWIDTH_SRC>::name buf0,
                   typename StreamType<WORDWIDTH_SRC>::name buf1,
                   typename StreamType<WORDWIDTH_SRC>::name buf2,
                   typename StreamType<WORDWIDTH_SRC>::name buf3,
                   typename StreamType<WORDWIDTH_SRC>::name buf4,
                   typename StreamType<WORDWIDTH_SRC>::name buf5,
                   typename StreamType<WORDWIDTH_SRC>::name buf6) {

#pragma HLS INLINE

 xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf1[6], buf0, 0);
    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf2[6], buf1, 0);
    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf3[6], buf2, 0);
    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf4[6], buf3, 0);
    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf5[6], buf4, 0);
    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf6[6], buf5, 0);
    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf7[6], buf6, 0);
}

template <int NPC, int DEPTH_SRC>
void xfCopyData(typename PixelType<DEPTH_SRC>::name src_buf1[xfNPixelsPerCycle<NPC>::nppc + 6],
                typename PixelType<DEPTH_SRC>::name src_buf2[xfNPixelsPerCycle<NPC>::nppc + 6],
                typename PixelType<DEPTH_SRC>::name src_buf3[xfNPixelsPerCycle<NPC>::nppc + 6],
                typename PixelType<DEPTH_SRC>::name src_buf4[xfNPixelsPerCycle<NPC>::nppc + 6],
                typename PixelType<DEPTH_SRC>::name src_buf5[xfNPixelsPerCycle<NPC>::nppc + 6],
                typename PixelType<DEPTH_SRC>::name src_buf6[xfNPixelsPerCycle<NPC>::nppc + 6],
                typename PixelType<DEPTH_SRC>::name src_buf7[xfNPixelsPerCycle<NPC>::nppc + 6]) {

#pragma HLS INLINE

 ap_uint<5> buf_size = (xfNPixelsPerCycle<NPC>::nppc + 6);
    ap_uint<4> i = 0;
    ap_uint<4> ind = buf_size - 6;

    VITIS_LOOP_375_1: for (i = 0; i < 6; i++, ind++) {

#pragma HLS LOOP_TRIPCOUNT min=6 max=6
#pragma HLS unroll

 src_buf1[i] = src_buf1[ind];
        src_buf2[i] = src_buf2[ind];
        src_buf3[i] = src_buf3[ind];
        src_buf4[i] = src_buf4[ind];
        src_buf5[i] = src_buf5[ind];
        src_buf6[i] = src_buf6[ind];
        src_buf7[i] = src_buf7[ind];
    }
}




template <int SIZE, int WORDWIDTH>
void xFCopyBlockMemoryOut1(typename StreamType<WORDWIDTH>::name * _src, unsigned long long int* _dst, int nbytes) {



    if (nbytes) memcpy((unsigned long long int*)_dst, (unsigned long long int*)_src, nbytes);

}





template <int SIZE, int WORDWIDTH>
void xFCopyBlockMemoryIn1(unsigned long long int* _src, typename StreamType<WORDWIDTH>::name * _dst, int nbytes) {



    memcpy((typename StreamType<WORDWIDTH>::name*)_dst, (typename StreamType<WORDWIDTH>::name*)_src, nbytes);

}





template <int SIZE, int WORDWIDTH>
void xFCopyBlockMemoryIn(typename StreamType<WORDWIDTH>::name * _src, typename StreamType<WORDWIDTH>::name * _dst, int nbytes) {



    memcpy((typename StreamType<WORDWIDTH>::name*)_dst, (typename StreamType<WORDWIDTH>::name*)_src, nbytes);

}




template <int SIZE, int WORDWIDTH>
void xFCopyBlockMemoryOut(typename StreamType<WORDWIDTH>::name * _src, typename StreamType<WORDWIDTH>::name * _dst, int nbytes) {



    memcpy((typename StreamType<WORDWIDTH>::name*)_dst, (typename StreamType<WORDWIDTH>::name*)_src, nbytes);

}

template <int WORDWIDTH, int NPC, int IN_BH, int IN_BW>
void xFDuplicateStream(hls::stream<typename StreamType<WORDWIDTH>::name>& in_strm,
                       hls::stream<typename StreamType<WORDWIDTH>::name>& out_strm1,
                       hls::stream<typename StreamType<WORDWIDTH>::name>& out_strm2,
                       int imwidth,
                       int imheight) {
    VITIS_LOOP_446_1: for (int i = 0; i < imheight; i++) {

#pragma HLS LOOP_TRIPCOUNT min=IN_BH max=IN_BH
#pragma HLS LOOP_FLATTEN off

 VITIS_LOOP_451_2: for (int j = 0; j < (imwidth >> NPC); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=IN_BW max=IN_BW

 typename StreamType<WORDWIDTH>::name tmp = in_strm.read();
            out_strm1.write(tmp);
            out_strm2.write(tmp);
        }
    }
}




class accel_utils {
   public:




    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>
    void Array2hlsStrm(ap_uint<PTR_WIDTH>* srcPtr, hls::stream<ap_uint<PTR_WIDTH> >& dstStrm, int rows, int cols) {
        int pixel_width = COLOR_T * CH_WIDTH;
        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);

        VITIS_LOOP_477_1: for (int i = 0; i < loop_count; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT
#pragma HLS PIPELINE

 dstStrm.write(srcPtr[i]);
        }
    }

    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int TRIPCOUNT>
    void hlsStrm2xfMat(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,
                       xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& dstMat,
                       int dstMat_cols_align_npc) {
        int rows = dstMat.rows;
        int cols = dstMat.cols;
        int loop_count = (rows * dstMat_cols_align_npc) / xfNPixelsPerCycle<NPC>::nppc;
        int pad = dstMat_cols_align_npc - cols;
        int in_size_bits = DataType<MAT_T, NPC>::pixelwidth * rows * dstMat_cols_align_npc;
        int ddr_read_cycles = (((in_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));
        int ddr_read_cnt = 0;

        int valid_bits = 0;
        const int N_size = DataType<MAT_T, NPC>::pixelwidth * xfNPixelsPerCycle<NPC>::nppc;
        const int last_N_size = DataType<MAT_T, NPC>::pixelwidth * (xfNPixelsPerCycle<NPC>::nppc - pad);
        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;
        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;
        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;
        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;

        int K_size;
        ap_uint<PTR_WIDTH> r;
        typename DataType<MAT_T, NPC>::name out;
        int ncpr = dstMat_cols_align_npc / xfNPixelsPerCycle<NPC>::nppc;
        int clk_cnt = 0;
        int strm_cnt_disply = 0;
    L1:
        for (int i = 0; i < loop_count; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT
#pragma HLS PIPELINE


 int PTR_WIDTH_min_Ksize;
            int PTR_WIDTH_plus_Ksize;

            if (clk_cnt == ncpr - 1) {
                clk_cnt = 0;
                K_size = last_N_size;
                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;
                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;
            } else {
                clk_cnt++;
                K_size = N_size;
                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;
                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;
            }

            int valid_bits_update;
            int valid_bits_tmp = valid_bits - K_size;
            typename DataType<MAT_T, NPC>::name out = 0;

            if (valid_bits < K_size) {
                if (valid_bits != 0) {
                    out.range(valid_bits - 1, 0) = r.range(PTR_WIDTH - 1, PTR_WIDTH - valid_bits);
                }
                if (ddr_read_cnt < ddr_read_cycles) {
                    r = srcStrm.read();
                    ddr_read_cnt++;
                } else {
                    r = 0;
                }
                out.range(K_size - 1, valid_bits) = r.range(K_size - valid_bits - 1, 0);
                valid_bits = PTR_WIDTH_min_Ksize + valid_bits;
            } else {
                out = r.range(PTR_WIDTH_plus_Ksize - valid_bits - 1, PTR_WIDTH - valid_bits);
                valid_bits = valid_bits - K_size;
            }

            dstMat.write(i, out);
        }
        int stop = 0;
    }

    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC>
    void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr, xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& dstMat, int stride = -1) {

        MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>::Array2xfMat(srcPtr, dstMat, stride);
# 582 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_utility.hpp"
    }

    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>
    void axiStrm2hlsStrm(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,
                         hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,
                         int rows,
                         int cols) {
        int pixel_width = COLOR_T * CH_WIDTH;
        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);

        VITIS_LOOP_592_1: for (int i = 0; i < loop_count; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT
#pragma HLS PIPELINE

 ap_axiu<PTR_WIDTH, 0, 0, 0> v = srcPtr.read();
            dstStrm.write(v.data);
        }
    }

    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC>
    void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr, xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& dstMat) {

#pragma HLS DATAFLOW

 (__builtin_assume(static_cast <bool> ((PTR_WIDTH >= StreamType<DataType<MAT_T, NPC>::wordwidth>::bitdepth) && "The PTR_WIDTH must be always greater than or equal to the minimum " "width for the corresponding " "configuration")));



        const int ch_width = DataType<MAT_T, NPC>::bitdepth;

        hls::stream<ap_uint<PTR_WIDTH> > strm;
        int rows = dstMat.rows;
        int cols = dstMat.cols;
        int dstMat_cols_align_npc = ((dstMat.cols + (NPC - 1)) >> xfNPixelsPerCycle<NPC>::datashift) << xfNPixelsPerCycle<NPC>::datashift;
        axiStrm2hlsStrm<PTR_WIDTH, ROWS, COLS, NPC, DataType<MAT_T, NPC>::channel, ch_width,
                        ((ROWS * COLS * DataType<MAT_T, NPC>::channel * ch_width) / PTR_WIDTH)>(srcPtr, strm, rows, cols);
        hlsStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, (ROWS * COLS) / NPC>(strm, dstMat, dstMat_cols_align_npc);
    }





    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int TRIPCOUNT>
    void xfMat2hlsStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& srcMat,
                       hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,
                       int srcMat_cols_align_npc) {
        int rows = srcMat.rows;
        int cols = srcMat.cols;
        int loop_count = (rows * srcMat_cols_align_npc) / xfNPixelsPerCycle<NPC>::nppc;
        int pad = srcMat_cols_align_npc - cols;
        int out_size_bits = DataType<MAT_T, NPC>::pixelwidth * rows * srcMat_cols_align_npc;
        int ddr_write_cycles = (((out_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));
        int ddr_write_cnt = 0;

        int bits_to_add = PTR_WIDTH;
        const int N_size = DataType<MAT_T, NPC>::pixelwidth * xfNPixelsPerCycle<NPC>::nppc;
        const int last_N_size = DataType<MAT_T, NPC>::pixelwidth * (xfNPixelsPerCycle<NPC>::nppc - pad);
        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;
        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;
        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;
        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;

        ap_uint<PTR_WIDTH> r;
        typename DataType<MAT_T, NPC>::name in;
        int ncpr = srcMat_cols_align_npc / xfNPixelsPerCycle<NPC>::nppc;
        int clk_cnt = 0;

    L1:
        for (int i = 0; i < loop_count; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT
#pragma HLS PIPELINE

 int K_size;
            int PTR_WIDTH_min_Ksize;
            int PTR_WIDTH_plus_Ksize;
            if (clk_cnt == ncpr - 1) {
                clk_cnt = 0;
                K_size = last_N_size;
                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;
                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;
            } else {
                clk_cnt++;
                K_size = N_size;
                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;
                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;
            }

            in = srcMat.read(i);

            if (bits_to_add <= K_size) {
                r.range(PTR_WIDTH - 1, PTR_WIDTH - bits_to_add) = in.range(bits_to_add - 1, 0);
                dstStrm.write(r);

                if (bits_to_add != K_size) {
                    r.range(K_size - bits_to_add - 1, 0) = in.range(K_size - 1, bits_to_add);
                }
                bits_to_add = PTR_WIDTH_min_Ksize + bits_to_add;
            } else {
                r.range(PTR_WIDTH_plus_Ksize - bits_to_add - 1, PTR_WIDTH - bits_to_add) = in;
                bits_to_add -= K_size;
            }
        }

        if (bits_to_add != PTR_WIDTH) {
            dstStrm.write(r);
        }
    }

    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>
    void hlsStrm2Array(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols) {
        int pixel_width = COLOR_T * CH_WIDTH;
        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);

        VITIS_LOOP_698_1: for (int i = 0; i < loop_count; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT
#pragma HLS PIPELINE

 dstPtr[i] = srcStrm.read();
        }
    }

    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int FILLZERO = 1>
    void xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& srcMat, ap_uint<PTR_WIDTH>* dstPtr, int stride = -1) {

        MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO>::xfMat2Array(srcMat, dstPtr, stride);
# 731 "../../../../../overlays/Vitis_Libraries/vision//L1/include/common/xf_utility.hpp"
    }

    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>
    void hlsStrm2axiStrm(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,
                         hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr,
                         int rows,
                         int cols) {
        int pixel_width = COLOR_T * CH_WIDTH;
        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);

        VITIS_LOOP_741_1: for (int i = 0; i < loop_count; i++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT
#pragma HLS PIPELINE

 ap_axiu<PTR_WIDTH, 0, 0, 0> v;
            v.data = srcStrm.read();
            dstPtr.write(v);
        }
    }

    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC>
    void xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& srcMat, hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {

#pragma HLS DATAFLOW

 (__builtin_assume(static_cast <bool> ((PTR_WIDTH >= StreamType<DataType<MAT_T, NPC>::wordwidth>::bitdepth) && "The PTR_WIDTH must be always greater than or equal to the minimum " "width for the corresponding " "configuration")));



        const int ch_width = DataType<MAT_T, NPC>::bitdepth;

        hls::stream<ap_uint<PTR_WIDTH> > strm;
        int rows = srcMat.rows;
        int cols = srcMat.cols;
        int srcMat_cols_align_npc = ((srcMat.cols + (NPC - 1)) >> xfNPixelsPerCycle<NPC>::datashift) << xfNPixelsPerCycle<NPC>::datashift;

        xfMat2hlsStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, ROWS*((COLS + NPC - 1) / NPC)>(srcMat, strm,
                                                                                        srcMat_cols_align_npc);
        hlsStrm2axiStrm<PTR_WIDTH, ROWS, COLS, NPC, DataType<MAT_T, NPC>::channel, ch_width,
                        ((ROWS * COLS * DataType<MAT_T, NPC>::channel * ch_width) / PTR_WIDTH)>(strm, dstPtr, rows, cols);
    }
};

template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int FILLZERO = 1>
void xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& srcMat, ap_uint<PTR_WIDTH>* dstPtr, int stride = -1) {

    MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO>::xfMat2Array(srcMat, dstPtr, stride);




}

template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC>
void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr, xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& dstMat, int stride = -1) {

    MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>::Array2xfMat(srcPtr, dstMat, stride);




}

template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC>
void xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& srcMat, hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {
    accel_utils au;
    au.xfMat2axiStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcMat, dstPtr);
}

template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC>
void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr, xf::cv::Mat<MAT_T, ROWS, COLS, NPC>& dstMat) {
    accel_utils au;
    au.axiStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcPtr, dstMat);
}

}
}
# 22 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bpc.hpp" 2





namespace xf {

namespace cv {
# 67 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bpc.hpp"
template <typename F, int SRC_T, int ROWS, int COLS, int K_ROWS, int K_COLS, int NPPC = 1, int BORDER_T = XF_BORDER_CONSTANT, int USE_URAM = 0> class GenericBPC {
   public:

    xf::cv::Window<K_ROWS, xfNPixelsPerCycle<NPPC>::nppc + (K_COLS - 1), typename DataType<SRC_T, NPPC>::uname>
        src_blk;
    xf::cv::Scalar<K_ROWS, uint8_t> row_idx;
    xf::cv::LineBuffer<K_ROWS,
                       (COLS >> (xfNPixelsPerCycle<NPPC>::datashift)),
                       typename DataType<SRC_T, NPPC>::name,
                       (USE_URAM ? RAM_S2P_URAM : RAM_S2P_BRAM),
                       (USE_URAM ? K_ROWS : 1)>
        buff;


    uint16_t num_clks_per_row;
    uint32_t rd_ptr;
    uint32_t wr_ptr;




    GenericBPC() {

#pragma HLS INLINE

 num_clks_per_row = 0;
        rd_ptr = 0;
        wr_ptr = 0;
    }


    void initialize(xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _src);

    void update_row_idx();
    void process_row(uint16_t r,
                     xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _src,
                     xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _dst);
    void process_image(xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _src, xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _dst);
};




template <typename F, int SRC_T, int ROWS, int COLS, int K_ROWS, int K_COLS, int NPPC, int BORDER_T, int USE_URAM> void GenericBPC<F, SRC_T, ROWS, COLS, K_ROWS, K_COLS, NPPC, BORDER_T, USE_URAM>::initialize(xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _src) {
#pragma HLS INLINE



 num_clks_per_row = (_src.cols + (xfNPixelsPerCycle<NPPC>::nppc) - 1) >> (xfNPixelsPerCycle<NPPC>::datashift);


    rd_ptr = 0;
    wr_ptr = 0;


    VITIS_LOOP_122_1: for (uint8_t kr = 0; kr < K_ROWS; kr++) {
#pragma HLS UNROLL
 row_idx.val[kr] = kr;
    }

    return;
}




template <typename F, int SRC_T, int ROWS, int COLS, int K_ROWS, int K_COLS, int NPPC, int BORDER_T, int USE_URAM> void GenericBPC<F, SRC_T, ROWS, COLS, K_ROWS, K_COLS, NPPC, BORDER_T, USE_URAM>::process_row(uint16_t r,
                                                 xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _src,
                                                 xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _dst) {
#pragma HLS INLINE OFF




 const uint32_t _TC = (COLS >> (xfNPixelsPerCycle<NPPC>::datashift)) + (K_COLS >> 1);





    uint16_t col_loop_cnt = num_clks_per_row + ((((K_COLS >> 1) + ((xfNPixelsPerCycle<NPPC>::nppc) - 1)) / (xfNPixelsPerCycle<NPPC>::nppc)));
    ap_uint<32> pix_pos;
    short col = -(K_COLS >> 1);


    typename DataType<SRC_T, NPPC>::name out_pixels, prev_out_pixels;




SRC_INIT_LOOP:
    for (uint8_t kr = 0; kr < K_ROWS; kr++) {
#pragma HLS UNROLL

 VITIS_LOOP_161_1: for (uint8_t kc = 0; kc < ((xfNPixelsPerCycle<NPPC>::nppc) + K_COLS - 1); kc++) {
#pragma HLS UNROLL
 src_blk.val[kr][kc] = 0;
        }
    }




COL_LOOP:
    for (uint16_t c = 0; c < col_loop_cnt; c++) {
#pragma HLS PIPELINE II = 1
#pragma HLS LOOP_TRIPCOUNT min = 1 max = _TC




 if ((r < _src.rows) && (c < num_clks_per_row)) {
            buff.val[row_idx.val[K_ROWS - 1]][c] = _src.read(rd_ptr++);
        }



    BUFF_RD_LOOP:
        for (uint8_t kr = 0; kr < K_ROWS; kr++) {
#pragma HLS UNROLL
 typename DataType<SRC_T, NPPC>::name tmp_rd_buff;


            tmp_rd_buff = buff.val[row_idx.val[kr]][c];




            xfExtractPixels<NPPC, DataType<SRC_T, NPPC>::wordwidth, DataType<SRC_T, NPPC>::pixeldepth>(src_blk.val[kr], tmp_rd_buff,
                                                                                    (K_COLS - 1));
        }
# 206 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bpc.hpp"
    PROCESS_BLK_LOOP:
        for (int pix_idx = 0; pix_idx < (xfNPixelsPerCycle<NPPC>::nppc); pix_idx++) {
#pragma HLS UNROLL
 typename DataType<SRC_T, NPPC>::uname NxM_src_blk[K_ROWS][K_COLS];

#pragma HLS ARRAY_PARTITION variable = NxM_src_blk complete

 typename DataType<SRC_T, NPPC>::uname out_pix;


        REARRANGE_LOOP:
            for (uint8_t kr = 0; kr < K_ROWS; kr++) {
#pragma HLS UNROLL
 VITIS_LOOP_219_2: for (uint8_t kc = 0; kc < K_COLS; kc++) {
#pragma HLS UNROLL
 NxM_src_blk[kr][kc] = src_blk.val[kr][pix_idx + kc];
                }
            }


            F oper;
            oper.apply(NxM_src_blk, &out_pix);


            out_pixels.range(((pix_idx + 1) * (PixelType<DataType<SRC_T, NPPC>::pixeldepth>::bitdepth)) - 1, (pix_idx * (PixelType<DataType<SRC_T, NPPC>::pixeldepth>::bitdepth))) = out_pix;
        }

        col = col + (xfNPixelsPerCycle<NPPC>::nppc);



        if (c >= ((((K_COLS >> 1) + ((xfNPixelsPerCycle<NPPC>::nppc) - 1)) / (xfNPixelsPerCycle<NPPC>::nppc)))) {
            if (((xfNPixelsPerCycle<NPPC>::nppc) - ((K_COLS >> 1) - (((K_COLS >> 1) / (xfNPixelsPerCycle<NPPC>::nppc)) * (xfNPixelsPerCycle<NPPC>::nppc)))) == (xfNPixelsPerCycle<NPPC>::nppc)) {
                _dst.write(wr_ptr++, out_pixels);
            } else {



                prev_out_pixels.range((((xfNPixelsPerCycle<NPPC>::nppc) - ((K_COLS >> 1) - (((K_COLS >> 1) / (xfNPixelsPerCycle<NPPC>::nppc)) * (xfNPixelsPerCycle<NPPC>::nppc)))) * (PixelType<DataType<SRC_T, NPPC>::pixeldepth>::bitdepth)) - 1, 0) =
                    prev_out_pixels.range(((xfNPixelsPerCycle<NPPC>::nppc) * (PixelType<DataType<SRC_T, NPPC>::pixeldepth>::bitdepth)) - 1, (((xfNPixelsPerCycle<NPPC>::nppc) - ((xfNPixelsPerCycle<NPPC>::nppc) - ((K_COLS >> 1) - (((K_COLS >> 1) / (xfNPixelsPerCycle<NPPC>::nppc)) * (xfNPixelsPerCycle<NPPC>::nppc))))) * (PixelType<DataType<SRC_T, NPPC>::pixeldepth>::bitdepth)));
                prev_out_pixels.range(((xfNPixelsPerCycle<NPPC>::nppc) * (PixelType<DataType<SRC_T, NPPC>::pixeldepth>::bitdepth)) - 1, (((xfNPixelsPerCycle<NPPC>::nppc) - ((K_COLS >> 1) - (((K_COLS >> 1) / (xfNPixelsPerCycle<NPPC>::nppc)) * (xfNPixelsPerCycle<NPPC>::nppc)))) * (PixelType<DataType<SRC_T, NPPC>::pixeldepth>::bitdepth))) =
                    out_pixels.range((((xfNPixelsPerCycle<NPPC>::nppc) - ((xfNPixelsPerCycle<NPPC>::nppc) - ((K_COLS >> 1) - (((K_COLS >> 1) / (xfNPixelsPerCycle<NPPC>::nppc)) * (xfNPixelsPerCycle<NPPC>::nppc))))) * (PixelType<DataType<SRC_T, NPPC>::pixeldepth>::bitdepth)) - 1, 0);

                _dst.write(wr_ptr++, prev_out_pixels);
            }
        }
        prev_out_pixels = out_pixels;




    SHIFT_LOOP:
        for (uint8_t kr = 0; kr < K_ROWS; kr++) {
#pragma HLS UNROLL
 VITIS_LOOP_260_3: for (uint8_t kc = 0; kc < K_COLS - 1; kc++) {
#pragma HLS UNROLL
 src_blk.val[kr][kc] = src_blk.val[kr][(xfNPixelsPerCycle<NPPC>::nppc) + kc];
            }
        }
    }

    return;
}




template <typename F, int SRC_T, int ROWS, int COLS, int K_ROWS, int K_COLS, int NPPC, int BORDER_T, int USE_URAM> void GenericBPC<F, SRC_T, ROWS, COLS, K_ROWS, K_COLS, NPPC, BORDER_T, USE_URAM>::update_row_idx() {
#pragma HLS INLINE OFF

 uint8_t tmp_idx = row_idx.val[0];

    VITIS_LOOP_278_1: for (uint8_t kr = 0; kr < K_ROWS - 1; kr++) {
#pragma HLS UNROLL
 row_idx.val[kr] = row_idx.val[kr + 1];
    }
    row_idx.val[K_ROWS - 1] = tmp_idx;

    return;
}




template <typename F, int SRC_T, int ROWS, int COLS, int K_ROWS, int K_COLS, int NPPC, int BORDER_T, int USE_URAM> void GenericBPC<F, SRC_T, ROWS, COLS, K_ROWS, K_COLS, NPPC, BORDER_T, USE_URAM>::process_image(xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _src,
                                                   xf::cv::Mat<SRC_T, ROWS, COLS, NPPC>& _dst) {
#pragma HLS INLINE OFF

 const uint32_t _TC =
        ((COLS >> (xfNPixelsPerCycle<NPPC>::datashift)) + (K_COLS >> 1)) / NPPC;




    initialize(_src);







READ_LINES_INIT:
    for (uint8_t r = (K_ROWS >> 1); r < (K_ROWS - 1); r++) {
#pragma HLS UNROLL
 VITIS_LOOP_311_1: for (uint16_t c = 0; c < num_clks_per_row; c++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min = 1 max = _TC
 buff.val[r][c] = _src.read(rd_ptr++);
        }
    }


BORDER_INIT:
    for (uint8_t r = 0; r < (K_ROWS >> 1); r++) {
#pragma HLS UNROLL
 VITIS_LOOP_322_2: for (uint16_t c = 0; c < num_clks_per_row; c++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min = 1 max = _TC
 buff.val[r][c] = (BORDER_T == XF_BORDER_REPLICATE) ? buff.val[K_ROWS >> 1][c] : (typename DataType<SRC_T, NPPC>::name)0;
        }
    }




ROW_LOOP:
    for (uint16_t r = (K_ROWS >> 1); r < _src.rows + (K_ROWS >> 1); r++) {

#pragma HLS LOOP_TRIPCOUNT min = 1 max = ROWS
 process_row(r, _src, _dst);
        update_row_idx();
    }

    return;
}
# 350 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bpc.hpp"
template <int SRC_T, int NPPC>
class BPC {
   public:





    void apply(typename DataType<SRC_T, NPPC>::uname patch[5][5], typename DataType<SRC_T, NPPC>::uname * out_pix) {
#pragma HLS INLINE

 typename DataType<SRC_T, NPPC>::uname out_val;
        typename DataType<SRC_T, NPPC>::uname array[9];
        typename DataType<SRC_T, NPPC>::uname array_channel[8];
#pragma HLS ARRAY_PARTITION variable = array complete dim = 1

 int array_ptr = 0;
    Compute_Grad_Loop:
        for (int copy_arr = 0; copy_arr < 5; copy_arr = copy_arr + 2) {
#pragma HLS LOOP_TRIPCOUNT min = 1 max = 5
#pragma HLS UNROLL
 VITIS_LOOP_371_1: for (int copy_in = 0; copy_in < 5; copy_in = copy_in + 2) {
#pragma HLS LOOP_TRIPCOUNT min = 1 max = 5
#pragma HLS UNROLL
 array[array_ptr] = patch[copy_arr][copy_in];
                array_ptr++;
            }
        }





        VITIS_LOOP_383_2: for (int p = 0; p < 4; p++) {
#pragma HLS LOOP_TRIPCOUNT min = 1 max = 9
#pragma HLS UNROLL
 array_channel[p] = array[p];
        }
        VITIS_LOOP_388_3: for (int l = 4; l < 8; l++) {
            array_channel[l] = array[l + 1];
        }
        typename DataType<SRC_T, NPPC>::uname min = array_channel[0];
        typename DataType<SRC_T, NPPC>::uname max = array_channel[0];
    xFApplyMaskLoop:
        for (int16_t j = 1; j < 8; j++) {
#pragma HLS LOOP_TRIPCOUNT min = 1 max = 9


 if (array_channel[j] > max) {
                max = array_channel[j];
            }
            if (array_channel[j] < min) {
                min = array_channel[j];
            }
        }
        typename DataType<SRC_T, NPPC>::uname finalout = 0;

        if (array[4] < min)
            finalout = min;
        else if (array[4] > max)
            finalout = max;
        else
            finalout = array[4];

        out_val = finalout;


        *out_pix = out_val;

        return;
    }
};
# 442 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bpc.hpp"
template <int TYPE, int ROWS, int COLS, int NPPC = 1, int BORDER_T = XF_BORDER_CONSTANT, int USE_URAM = 0>
void badpixelcorrection(xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& _src, xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& _dst) {

#pragma HLS INLINE OFF

 GenericBPC<BPC<TYPE, NPPC>, TYPE, ROWS, COLS, 5, 5, NPPC, BORDER_T, USE_URAM> bpc;

    bpc.process_image(_src, _dst);

    return;
}
# 478 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bpc.hpp"
}
}
# 32 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_gaincontrol.hpp" 1
# 38 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_gaincontrol.hpp"
template <typename T>
T xf_satcast_gain(int in_val){};

template <>
inline ap_uint<8> xf_satcast_gain<ap_uint<8> >(int v) {
    return (v > ((1 << 8) - 1) ? 255 : v);
};
template <>
inline ap_uint<10> xf_satcast_gain<ap_uint<10> >(int v) {
    return (v > ((1 << 10) - 1) ? 1023 : v);
};
template <>
inline ap_uint<12> xf_satcast_gain<ap_uint<12> >(int v) {
    return (v > ((1 << 12) - 1) ? 4095 : v);
};
template <>
inline ap_uint<16> xf_satcast_gain<ap_uint<16> >(int v) {
    return (v > ((1 << 16) - 1) ? 65535 : v);
};

namespace xf {

namespace cv {

template <int BFORMAT,
          int SRC_T,
          int ROWS,
          int COLS,
          int NPC,
          int PLANES,
          int DEPTH_SRC,
          int DEPTH_DST,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int TC>
void gaincontrolkernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src1,
                       xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& dst,
                       uint16_t height,
                       uint16_t width,
                       unsigned short rgain,
                       unsigned short bgain) {
    ap_uint<13> i, j, k, l;

    const int STEP = DataType<SRC_T, NPC>::pixelwidth;

    typename DataType<SRC_T, NPC>::name pxl_pack_out;
    typename DataType<SRC_T, NPC>::name pxl_pack1, pxl_pack2;
RowLoop:
    for (i = 0; i < height; i++) {
#pragma HLS LOOP_TRIPCOUNT min = ROWS max = ROWS
#pragma HLS LOOP_FLATTEN OFF
 ColLoop:
        for (j = 0; j < width; j++) {
#pragma HLS LOOP_TRIPCOUNT min = TC max = TC
#pragma HLS pipeline

 pxl_pack1 = (src1.read(i * width + j));

        ProcLoop:
            for (l = 0; l < (xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel); l++) {
                typename PixelType<DEPTH_SRC>::name
                pxl1 = pxl_pack1.range(l * STEP + STEP - 1, l * STEP);
                typename PixelType<DEPTH_SRC>::name t;
                bool cond1 = 0, cond2 = 0;

                if (NPC == XF_NPPC1) {
                    cond1 = (j % 2 == 0);
                    cond2 = (j % 2 != 0);
                } else {
                    cond1 = ((l % 2) == 0);
                    cond2 = ((l % 2) != 0);
                }

                if (BFORMAT == XF_BAYER_RG) {
                    if (i % 2 == 0 && cond1) {
                        typename DataType<SRC_T, NPC>::cname v1 = pxl1;
                        int v2 = (int)((v1 * rgain) >> 7);
                        t = xf_satcast_gain<typename DataType<SRC_T, NPC>::cname>(v2);
                    } else if (i % 2 != 0 && cond2) {
                        typename DataType<SRC_T, NPC>::cname v1 = pxl1;
                        int v2 = (int)((v1 * bgain) >> 7);
                        t = xf_satcast_gain<typename DataType<SRC_T, NPC>::cname>(v2);
                    } else {
                        t = pxl1;
                    }
                }
                if (BFORMAT == XF_BAYER_GR) {
                    if (i % 2 == 0 && cond2) {
                        typename DataType<SRC_T, NPC>::cname v1 = pxl1;
                        int v2 = (int)((v1 * rgain) >> 7);
                        t = xf_satcast_gain<typename DataType<SRC_T, NPC>::cname>(v2);
                    } else if (i % 2 != 0 && cond1) {
                        typename DataType<SRC_T, NPC>::cname v1 = pxl1;
                        int v2 = (int)((v1 * bgain) >> 7);
                        t = xf_satcast_gain<typename DataType<SRC_T, NPC>::cname>(v2);
                    } else {
                        t = pxl1;
                    }
                }
                if (BFORMAT == XF_BAYER_BG) {
                    if (i % 2 == 0 && cond1) {
                        typename DataType<SRC_T, NPC>::cname v1 = pxl1;
                        int v2 = (int)((v1 * bgain) >> 7);
                        t = xf_satcast_gain<typename DataType<SRC_T, NPC>::cname>(v2);
                    } else if (i % 2 != 0 && cond2) {
                        typename DataType<SRC_T, NPC>::cname v1 = pxl1;
                        int v2 = (int)((v1 * rgain) >> 7);
                        t = xf_satcast_gain<typename DataType<SRC_T, NPC>::cname>(v2);
                    } else {
                        t = pxl1;
                    }
                }
                if (BFORMAT == XF_BAYER_GB) {
                    if (i % 2 == 0 && cond2) {
                        typename DataType<SRC_T, NPC>::cname v1 = pxl1;
                        int v2 = (int)((v1 * bgain) >> 7);
                        t = xf_satcast_gain<typename DataType<SRC_T, NPC>::cname>(v2);
                    } else if (i % 2 != 0 && cond1) {
                        typename DataType<SRC_T, NPC>::cname v1 = pxl1;
                        int v2 = (int)((v1 * rgain) >> 7);
                        t = xf_satcast_gain<typename DataType<SRC_T, NPC>::cname>(v2);
                    } else {
                        t = pxl1;
                    }
                }

                pxl_pack_out.range(l * STEP + STEP - 1, l * STEP) = t;
            }

            dst.write(i * width + j, pxl_pack_out);
        }
    }
}

template <int BFORMAT, int SRC_T, int ROWS, int COLS, int NPC = 1>
void gaincontrol(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src1,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& dst,
                 unsigned short rgain,
                 unsigned short bgain) {
#pragma HLS INLINE OFF




 short width = src1.cols >> xfNPixelsPerCycle<NPC>::datashift;

    gaincontrolkernel<BFORMAT, SRC_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::channel, DataType<SRC_T, NPC>::pixeldepth,
                      DataType<SRC_T, NPC>::pixeldepth, DataType<SRC_T, NPC>::wordwidth, DataType<SRC_T, NPC>::wordwidth,
                      (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src1, dst, src1.rows, width, rgain, bgain);
}

template <int SRC_T, int ROWS, int COLS, int NPC = 1>
void gaincontrol_mono(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src1,
                      xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& dst,
                      unsigned short lgain) {
#pragma HLS INLINE OFF




 short width = src1.cols >> xfNPixelsPerCycle<NPC>::datashift;
    short height = src1.rows;

    ap_uint<13> i, j, k, l;

    const int STEP = DataType<SRC_T, NPC>::pixelwidth;

    typename DataType<SRC_T, NPC>::name pxl_pack_out;
    typename DataType<SRC_T, NPC>::name pxl_pack1, pxl_pack2;
RowLoop:
    for (i = 0; i < height; i++) {
#pragma HLS LOOP_TRIPCOUNT min = ROWS max = ROWS
#pragma HLS LOOP_FLATTEN OFF
 ColLoop:
        for (j = 0; j < width; j++) {
#pragma HLS LOOP_TRIPCOUNT min = COLS / NPC max = COLS / NPC
#pragma HLS pipeline

 pxl_pack1 = (src1.read(i * width + j));

        ProcLoop:
            for (l = 0; l < (xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel); l++) {
                typename PixelType<DataType<SRC_T, NPC>::pixeldepth>::name
                pxl1 = pxl_pack1.range(l * STEP + STEP - 1, l * STEP);
                typename PixelType<DataType<SRC_T, NPC>::pixeldepth>::name t;

                int v2 = (int)((pxl1 * lgain) >> 7);
                t = xf_satcast_gain<typename DataType<SRC_T, NPC>::cname>(v2);

                pxl_pack_out.range(l * STEP + STEP - 1, l * STEP) = t;
            }

            dst.write(i * width + j, pxl_pack_out);
        }
    }
}
}
}
# 33 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_autowhitebalance.hpp" 1
# 35 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_autowhitebalance.hpp"
template <typename T>
T xf_satcast_awb(int in_val){};

template <>
inline ap_uint<8> xf_satcast_awb<ap_uint<8> >(int v) {
    return (v > 255 ? 255 : v);
};
template <>
inline ap_uint<10> xf_satcast_awb<ap_uint<10> >(int v) {
    return (v > 1023 ? 1023 : v);
};
template <>
inline ap_uint<12> xf_satcast_awb<ap_uint<12> >(int v) {
    return (v > 4095 ? 4095 : v);
};
template <>
inline ap_uint<16> xf_satcast_awb<ap_uint<16> >(int v) {
    return (v > 65535 ? 65535 : v);
};

namespace xf {
namespace cv {

template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int PLANES,
          int DEPTH_SRC,
          int DEPTH_DST,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int TC>
void AWBGainUpdateKernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src1,
                         xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                         float thresh,
                         int i_gain[3]) {
    int width = src1.cols >> xfNPixelsPerCycle<NPC>::datashift;
    int height = src1.rows;

    printf("%d %d %d\n", i_gain[0], i_gain[1], i_gain[2]);

    const int STEP = DataType<SRC_T, NPC>::bitdepth;

    typename DataType<SRC_T, NPC>::name in_pix, out_pix;

    VITIS_LOOP_82_1: for (int i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN OFF

 ColLoop1:
        for (int j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline

 in_pix = src1.read(i * width + j);

            VITIS_LOOP_95_2: for (int p = 0; p < xfNPixelsPerCycle<NPC>::nppc * PLANES; p++) {

#pragma HLS unroll

 typename DataType<SRC_T, NPC>::cname
                val = in_pix.range(p * STEP + STEP - 1, p * STEP);
                ap_uint<40> outval = ((val * i_gain[p % 3]) >> STEP);

                out_pix.range(p * STEP + STEP - 1, p * STEP) = xf_satcast_awb<typename DataType<SRC_T, NPC>::cname>(outval);
            }

            dst.write(i * width + j, out_pix);
        }
    }
}

template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int PLANES,
          int DEPTH_SRC,
          int DEPTH_DST,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int TC>
void AWBChannelGainKernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src1,
                          xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                          float thresh,
                          int i_gain[3]) {
    int width = src1.cols >> xfNPixelsPerCycle<NPC>::datashift;
    int height = src1.rows;

    const int STEP = DataType<SRC_T, NPC>::bitdepth;
    ap_uint<13> i = 0, j = 0;

    typename DataType<SRC_T, NPC>::name in_pix, out_pix;
    typename DataType<SRC_T, NPC>::cname r, g, b, b1 = 0, g1 = 0, r1 = 0;

    typename StreamType<WORDWIDTH_DST>::name pxl_pack_out;
    typename StreamType<WORDWIDTH_SRC>::name pxl_pack1, pxl_pack2;

    int maxval = (1 << (DataType<SRC_T, NPC>::bitdepth)) - 1;

    ap_ufixed<32, 32> thresh255 = ap_ufixed<32, 32>(thresh * maxval);

    int minRGB, maxRGB;

    ap_ufixed<40, 40> tmpsum_vals[(1 << xfNPixelsPerCycle<NPC>::datashift) * PLANES];

    ap_ufixed<40, 40> sum[PLANES];

#pragma HLS ARRAY_PARTITION variable=tmpsum_vals complete dim=0
#pragma HLS ARRAY_PARTITION variable=sum complete dim=0


 VITIS_LOOP_152_1: for (j = 0; j < ((1 << xfNPixelsPerCycle<NPC>::datashift) * PLANES); j++) {

#pragma HLS UNROLL

 tmpsum_vals[j] = 0;
    }
    VITIS_LOOP_158_2: for (j = 0; j < PLANES; j++) {

#pragma HLS UNROLL

 sum[j] = 0;
    }

    int p = 0, read_index = 0;

Row_Loop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 Col_Loop:
        for (j = 0; j < (width); j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS/NPC max=COLS/NPC
#pragma HLS pipeline II=1
#pragma HLS LOOP_FLATTEN OFF

 typename DataType<SRC_T, NPC>::name in_buf;
            in_buf = src1.read(i * width + j);

            dst.write(i * width + j, in_buf);

        PLANES_LOOP:
            for (int p = 0; p < xfNPixelsPerCycle<NPC>::nppc * PLANES; p = p + PLANES) {

#pragma HLS unroll

 typename DataType<SRC_T, NPC>::cname
                val1 = in_buf.range(p * STEP + STEP - 1, p * STEP);
                typename DataType<SRC_T, NPC>::cname
                val2 = in_buf.range(p * STEP + (2 * STEP) - 1, p * STEP + STEP);
                typename DataType<SRC_T, NPC>::cname
                val3 = in_buf.range(p * STEP + (3 * STEP) - 1, p * STEP + 2 * STEP);

                minRGB = (((val1) < ((((val2) < (val3)) ? (val2) : (val3)))) ? (val1) : ((((val2) < (val3)) ? (val2) : (val3))));
                maxRGB = (((val1) > ((((val2) > (val3)) ? (val2) : (val3)))) ? (val1) : ((((val2) > (val3)) ? (val2) : (val3))));

                if ((maxRGB - minRGB) * maxval > thresh255 * maxRGB) continue;

                tmpsum_vals[p] = tmpsum_vals[p] + val1;
                tmpsum_vals[(p) + 1] = tmpsum_vals[(p) + 1] + val2;
                tmpsum_vals[(p) + 2] = tmpsum_vals[(p) + 2] + val3;
            }
        }
    }

    VITIS_LOOP_208_3: for (int c = 0; c < PLANES; c++) {
        VITIS_LOOP_209_4: for (j = 0; j < (1 << xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS UNROLL

 sum[c] = (sum[c] + tmpsum_vals[j * PLANES + c]);
        }
    }

    ap_ufixed<40, 40> max_sum_fixed = (((sum[0]) > ((((sum[1]) > (sum[2])) ? (sum[1]) : (sum[2])))) ? (sum[0]) : ((((sum[1]) > (sum[2])) ? (sum[1]) : (sum[2]))));

    printf("%ld %ld %ld\n", (unsigned long)sum[0], (unsigned long)sum[1], (unsigned long)sum[2]);

    ap_ufixed<40, 2> bval = (float)0.1;
    ap_ufixed<40, 40> zero = 0;

    ap_ufixed<56, STEP> dinB1;
    ap_ufixed<56, STEP> dinG1;
    ap_ufixed<56, STEP> dinR1;

    if (sum[0] < bval) {
        dinB1 = 0;
    } else {
        dinB1 = (ap_ufixed<56, STEP>)((ap_ufixed<56, STEP>)max_sum_fixed / sum[0]);
    }

    if (sum[1] < bval) {
        dinG1 = 0;
    } else {
        dinG1 = (ap_ufixed<56, STEP>)((ap_ufixed<56, STEP>)max_sum_fixed / sum[1]);
    }
    if (sum[2] < bval) {
        dinR1 = 0;
    } else {
        dinR1 = (ap_ufixed<56, STEP>)((ap_ufixed<56, STEP>)max_sum_fixed / sum[2]);
    }

    ap_ufixed<56, STEP> gain_max1 = (((dinB1) > ((((dinG1) > (dinR1)) ? (dinG1) : (dinR1)))) ? (dinB1) : ((((dinG1) > (dinR1)) ? (dinG1) : (dinR1))));

    if (gain_max1 > 0) {
        dinB1 /= gain_max1;
        dinG1 /= gain_max1;
        dinR1 /= gain_max1;
    }

    float a1 = dinB1;
    float a2 = dinG1;
    float a3 = dinR1;

    printf("division values : %f %f %f\n", a1, a2, a3);


    i_gain[0] = (dinB1 * (1 << STEP));
    i_gain[1] = (dinG1 * (1 << STEP));
    i_gain[2] = (dinR1 * (1 << STEP));
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1, int DEPTH_SRC, int XF_WB_SIMPLE, int HIST_SIZE, int S_DEPTH>
void AWBNormalizationkernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                            xf::cv::Mat<DST_T, ROWS, COLS, NPC, S_DEPTH>& dst,
                            uint32_t hist[3][HIST_SIZE],
                            float p,
                            float inputMin,
                            float inputMax,
                            float outputMin,
                            float outputMax) {

#pragma HLS INLINE OFF

 short width = dst.cols >> xfNPixelsPerCycle<NPC>::datashift;
    short height = dst.rows;
    const int STEP = DataType<SRC_T, NPC>::bitdepth;

    ap_uint<STEP + 1> bins = HIST_SIZE;

    ap_uint<STEP + 1> nElements = HIST_SIZE;

    int total = dst.cols * dst.rows;
    ap_fixed<STEP + 8, STEP + 2> min_vals = inputMin - 0.5f;
    ap_fixed<STEP + 8, STEP + 2> max_vals = inputMax + 0.5f;
    ap_fixed<STEP + 8, STEP + 2> minValue[3] = {min_vals, min_vals, min_vals};
    ap_fixed<STEP + 8, STEP + 2> maxValue[3] = {max_vals, max_vals, max_vals};
    ap_fixed<STEP + 8, 4> s1 = p;
    ap_fixed<STEP + 8, 4> s2 = p;

    int rval = s1 * total / 100;
    int rval1 = (100 - s2) * total / 100;




#pragma HLS ARRAY_PARTITION variable = minValue complete dim = 0
#pragma HLS ARRAY_PARTITION variable = maxValue complete dim = 0


 VITIS_LOOP_303_1: for (int j = 0; j < 3; ++j)

    {
        ap_uint<STEP + 2> p1 = 0;
        ap_uint<STEP + 2> p2 = bins - 1;
        ap_uint<32> n1 = 0;
        ap_uint<32> n2 = total;

        ap_fixed<STEP + 8, STEP + 2> interval = (max_vals - min_vals) / bins;

        VITIS_LOOP_313_2: for (int k = 0; k < 1; ++k)

        {
            int value = hist[j][p1];
            int value1 = hist[j][p2];

            VITIS_LOOP_319_3: while (n1 + hist[j][p1] < rval && p1 < HIST_SIZE) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min = 255 max = 255
#pragma HLS DEPENDENCE variable = hist array intra false
#pragma HLS DEPENDENCE variable = minValue intra false
 n1 += hist[j][p1++];
                minValue[j] += interval;
            }


            VITIS_LOOP_329_4: while (n2 - hist[j][p2] > rval1 && p2 != 0) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min = 255 max = 255
#pragma HLS DEPENDENCE variable = hist array intra false
#pragma HLS DEPENDENCE variable = maxValue intra false
 n2 -= hist[j][p2--];
                maxValue[j] -= interval;
            }



        }
    }



    ap_fixed<STEP + 8, STEP + 2> maxmin_diff[3];

#pragma HLS ARRAY_PARTITION variable = maxmin_diff complete dim = 0


 ap_fixed<STEP + 8, STEP + 2> newmax = inputMax;
    ap_fixed<STEP + 8, STEP + 2> newmin = 0.0f;
    maxmin_diff[0] = maxValue[0] - minValue[0];
    maxmin_diff[1] = maxValue[1] - minValue[1];
    maxmin_diff[2] = maxValue[2] - minValue[2];
    ap_fixed<STEP + 8, STEP + 2> newdiff = newmax - newmin;

    typename DataType<SRC_T, NPC>::name in_buf_n, in_buf_n1, out_buf_n;
    printf("valuesmin max :%f %f %f %f %f %f\n", (float)maxValue[0], (float)maxValue[1], (float)maxValue[2],
           (float)minValue[0], (float)minValue[1], (float)minValue[2]);

    int pval = 0, read_index = 0, write_index = 0;
    ap_uint<13> row, col;

    ap_fixed<STEP + 16, 2> inv_val[3];

    if (maxmin_diff[0] != 0) inv_val[0] = ((ap_fixed<STEP + 16, 2>)1 / maxmin_diff[0]);
    if (maxmin_diff[1] != 0) inv_val[1] = ((ap_fixed<STEP + 16, 2>)1 / maxmin_diff[1]);
    if (maxmin_diff[2] != 0) inv_val[2] = ((ap_fixed<STEP + 16, 2>)1 / maxmin_diff[2]);

Row_Loop1:
    for (row = 0; row < height; row++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS


 Col_Loop1:
        for (col = 0; col < width; col++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS/NPC max=COLS/NPC
#pragma HLS pipeline II=1
#pragma HLS LOOP_FLATTEN OFF

 in_buf_n = src.read(read_index++);

            ap_fixed<STEP + 8, STEP + 2> value = 0;
            ap_fixed<STEP + STEP + 16, STEP + 8> divval = 0;
            ap_fixed<STEP + 16, STEP + 16> finalmul = 0;
            ap_int<32> dstval;

            VITIS_LOOP_390_5: for (int p = 0, bit = 0; p < xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel; p++, bit = p % 3) {

#pragma HLS unroll

 typename DataType<SRC_T, NPC>::cname
                val = in_buf_n.range(p * STEP + STEP - 1, p * STEP);
                value = val - minValue[bit];
                divval = value * inv_val[p % 3];
                finalmul = divval * newdiff;
                dstval = (int)(finalmul + newmin);
                if (dstval.range(31, 31) == 1) {
                    dstval = 0;
                }
                out_buf_n.range(p * STEP + STEP - 1, p * STEP) = xf_satcast_awb<typename DataType<SRC_T, NPC>::cname>(dstval);
            }

            dst.write(row * width + col, out_buf_n);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1, int DEPTH_SRC, int XF_WB_SIMPLE, int HIST_SIZE>
void AWBhistogramkernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src1,
                        xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src2,
                        uint32_t hist[3][HIST_SIZE],
                        float p,
                        float inputMin,
                        float inputMax,
                        float outputMin,
                        float outputMax) {

#pragma HLS INLINE OFF


 const int STEP = DataType<SRC_T, NPC>::bitdepth;

    int width = src1.cols >> xfNPixelsPerCycle<NPC>::datashift;
    int height = src1.rows;

    typename DataType<SRC_T, NPC>::name in_pix, in_pix1, out_pix;
    int writenct = 0;



    int depth = 3;

    int bins = HIST_SIZE;

    int nElements = HIST_SIZE;

    int val[3];



INITIALIZE_HIST:
    for (int k = 0; k < HIST_SIZE; k++) {

#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=HIST_SIZE max=HIST_SIZE

 INITIALIZE:
        for (int hi = 0; hi < 3; hi++) {

#pragma HLS UNROLL

 hist[hi][k] = 0;
        }
    }


    ap_uint<32> tmp_hist[xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel][HIST_SIZE];
    ap_uint<32> tmp_hist1[xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel][HIST_SIZE];

#pragma HLS RESOURCE variable=tmp_hist core=RAM_T2P_BRAM
#pragma HLS RESOURCE variable=tmp_hist1 core=RAM_T2P_BRAM
#pragma HLS ARRAY_PARTITION variable=tmp_hist complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_hist1 complete dim=1

 typename DataType<SRC_T, NPC>::name in_buf, in_buf1, temp_buf;

    bool flag = 0;

HIST_INITIALIZE_LOOP:
    for (ap_uint<32> i = 0; i < HIST_SIZE; i++)
    {

#pragma HLS PIPELINE

 VITIS_LOOP_478_1: for (ap_uint<5> j = 0; j < xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel; j++) {

#pragma HLS LOOP_TRIPCOUNT min=HIST_SIZE max=HIST_SIZE

 tmp_hist[j][i] = 0;
            tmp_hist1[j][i] = 0;
        }
    }

    static uint32_t old[xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel] = {};
    static uint32_t old1[xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel] = {};
    static uint32_t acc[xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel] = {};
    static uint32_t acc1[xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel] = {};
#pragma HLS ARRAY_PARTITION variable = old complete
#pragma HLS ARRAY_PARTITION variable = old1 complete
#pragma HLS ARRAY_PARTITION variable = acc complete
#pragma HLS ARRAY_PARTITION variable = acc1 complete

 int readcnt = 0;
    ap_fixed<STEP + 8, STEP + 2> min_vals = inputMin - 0.5f;
    ap_fixed<STEP + 8, STEP + 2> max_vals = inputMax + 0.5f;

    ap_fixed<STEP + 8, STEP + 2> minValue = min_vals, minValue1 = min_vals;
    ap_fixed<STEP + 8, STEP + 2> maxValue = max_vals, maxValue1 = max_vals;

    ap_fixed<STEP + 8, STEP + 2> interval = ap_fixed<STEP + 8, STEP + 2>(maxValue - minValue) / bins;

    ap_fixed<STEP + 8, 2> internal_inv = ((ap_fixed<STEP + 8, 2>)1 / interval);
    int pos = 0, pos1 = 0;
    int currentBin = 0, currentBin1 = 0;
ROW_LOOP:
    for (int row = 0; row != (height); row++)
    {

#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS

 COL_LOOP:
        for (int col = 0; col < (width); col = col + 2)
        {

#pragma HLS PIPELINE II=2
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS/4


 in_pix = src1.read(row * (width) + col);
            in_pix1 = src1.read((row * (width) + col) + 1);

            src2.write(row * (width) + col, in_pix);
            src2.write(row * (width) + col + 1, in_pix1);

        PLANES_LOOP:
            for (ap_uint<9> j = 0; j < xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel; j++) {

#pragma HLS DEPENDENCE variable=tmp_hist array intra false
#pragma HLS DEPENDENCE variable=tmp_hist1 array intra false
#pragma HLS UNROLL


 typename DataType<SRC_T, NPC>::cname val = 0, val1 = 0;
                val = in_pix.range(j * STEP + STEP - 1, j * STEP);
                val1 = in_pix1.range(j * STEP + STEP - 1, j * STEP);

                currentBin = int((val - minValue) * internal_inv);
                currentBin1 = int((val1 - minValue1) * internal_inv);

                uint32_t tmp = old[j];
                uint32_t tmp1 = old1[j];
                uint32_t tmp_acc = acc[j];
                uint32_t tmp_acc1 = acc1[j];
                if (tmp == currentBin) {
                    tmp_acc = tmp_acc + 1;
                } else {
                    tmp_hist[j][tmp] = tmp_acc;
                    tmp_acc = tmp_hist[j][currentBin] + 1;
                }
                if (tmp1 == currentBin1) {
                    tmp_acc1 = tmp_acc1 + 1;
                } else {
                    tmp_hist1[j][tmp1] = tmp_acc1;
                    tmp_acc1 = tmp_hist1[j][currentBin1] + 1;
                }
                old[j] = currentBin;
                old1[j] = currentBin1;
                acc[j] = tmp_acc;
                acc1[j] = tmp_acc1;
            }
        }
    }
END_HIST_LOOP:
    for (ap_uint<5> ch_ppc = 0; ch_ppc < (xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel); ch_ppc++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=6
#pragma HLS UNROLL

 uint32_t tmp = old[ch_ppc];
        uint32_t tmp1 = old1[ch_ppc];
        tmp_hist[ch_ppc][tmp] = acc[ch_ppc];
        tmp_hist1[ch_ppc][tmp1] = acc1[ch_ppc];
    }


    const int num_ch = DataType<SRC_T, NPC>::channel;

MERGE_HIST_LOOP:
    for (ap_uint<32> i = 0; i < HIST_SIZE; i++) {

#pragma HLS pipeline


 MERGE_HIST_CH_UNROLL:
        for (ap_uint<5> ch = 0; ch < num_ch; ch++) {

#pragma HLS UNROLL


 uint32_t value = 0;

        MERGE_HIST_NPPC_UNROLL:
            for (ap_uint<5> p = 0; p < xfNPixelsPerCycle<NPC>::nppc; p++) {

#pragma HLS UNROLL

 value += tmp_hist[p * num_ch + ch][i] + tmp_hist1[p * num_ch + ch][i];
            }

            hist[ch][i] = value;
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1, int XF_WB_SIMPLE, int HIST_SIZE>
void AWBhistogram(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src1,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src2,
                  uint32_t histogram[3][HIST_SIZE],
                  float thresh,
                  float inputMin,
                  float inputMax,
                  float outputMin,
                  float outputMax) {

#pragma HLS INLINE OFF


 AWBhistogramkernel<SRC_T, SRC_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::pixeldepth, 1, HIST_SIZE>(
        src1, src2, histogram, thresh, inputMin, inputMax, outputMin, outputMax);
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1, int XF_WB_SIMPLE, int HIST_SIZE>
void AWBNormalization(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                      uint32_t histogram[3][HIST_SIZE],
                      float thresh,
                      float inputMin,
                      float inputMax,
                      float outputMin,
                      float outputMax) {

#pragma HLS INLINE OFF


 AWBNormalizationkernel<SRC_T, SRC_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::pixeldepth, 1, HIST_SIZE>(
        src, dst, histogram, thresh, inputMin, inputMax, outputMin, outputMax);
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1, int XF_WB_SIMPLE>
void AWBGainUpdate(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src1,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& src2,
                   float thresh,
                   int i_gain[3]) {
    xf::cv::AWBGainUpdateKernel<SRC_T, SRC_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::channel, DataType<SRC_T, NPC>::pixeldepth,
                                DataType<SRC_T, NPC>::pixeldepth, DataType<SRC_T, NPC>::wordwidth, DataType<SRC_T, NPC>::wordwidth,
                                (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src1, src2, thresh, i_gain);
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1, int XF_WB_SIMPLE>
void AWBChannelGain(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                    xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                    float thresh,
                    int i_gain[3]) {
    xf::cv::AWBChannelGainKernel<SRC_T, SRC_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::channel, DataType<SRC_T, NPC>::pixeldepth,
                                 DataType<SRC_T, NPC>::pixeldepth, DataType<SRC_T, NPC>::wordwidth, DataType<SRC_T, NPC>::wordwidth,
                                 (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src, dst, thresh, i_gain);
}
}
}
# 34 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_demosaicing.hpp" 1
# 20 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_demosaicing.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 21 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_demosaicing.hpp" 2
# 32 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_demosaicing.hpp"
template <typename T>
T xf_satcast(int in_val){};

template <>
inline ap_uint<8> xf_satcast<ap_uint<8> >(int v) {
    return (v > ((1 << 8) - 1) ? 255 : v);
};
template <>
inline ap_uint<10> xf_satcast<ap_uint<10> >(int v) {
    return (v > ((1 << 10) - 1) ? 1023 : v);
};
template <>
inline ap_uint<12> xf_satcast<ap_uint<12> >(int v) {
    return (v > ((1 << 12) - 1) ? 4095 : v);
};
template <>
inline ap_uint<16> xf_satcast<ap_uint<16> >(int v) {
    return (v > ((1 << 16) - 1) ? 65535 : v);
};


namespace xf {
namespace cv {

template <typename T, int buf_size>
int g_kernel(T imgblock[5][buf_size], int loop) {

#pragma HLS inline off

 int res = -(imgblock[0][2 + loop] + imgblock[2][0 + loop] + imgblock[2][4 + loop] + imgblock[4][2 + loop]) +
              (imgblock[1][2 + loop] + imgblock[2][1 + loop] + imgblock[2][3 + loop] + imgblock[3][2 + loop]) * 2 +
              (imgblock[2][2 + loop]) * 4;
    res /= 8;
    if (res < 0) return 0;
    return res;
}

template <typename T, int buf_size>
int rb_kernel(T imgblock[5][buf_size], int loop) {

#pragma HLS inline off

 int t1 = (imgblock[0][2 + loop] + imgblock[2][0 + loop] + imgblock[2][4 + loop] + imgblock[4][2 + loop]);
    t1 = (t1 * 3) / 2;
    int t2 = (imgblock[1][1 + loop] + imgblock[1][3 + loop] + imgblock[3][1 + loop] + imgblock[3][3 + loop]);
    t2 = t2 * 2;
    int t3 = (imgblock[2][2 + loop]) * 6;
    int res = (-t1) + (t2) + (t3);
    res /= 8;
    if (res < 0) return 0;
    return res;
}


template <typename T, int buf_size>
int rgr_bgb_kernel(T imgblock[5][buf_size], int loop) {

#pragma HLS inline off

 int t1 = imgblock[0][2 + loop] + imgblock[4][2 + loop];
    int t2 = imgblock[1][1 + loop] + imgblock[1][3 + loop] + imgblock[2][0 + loop] + imgblock[2][4 + loop] +
             imgblock[3][1 + loop] + imgblock[3][3 + loop];
    int t3 = imgblock[2][1 + loop] + imgblock[2][3 + loop];
    t3 *= 4;
    int t4 = (imgblock[2][2 + loop]) * 5;
    int res = ((t1) >> 1) - (t2) + (t3) + (t4);
    res /= 8;
    if (res < 0) return 0;
    return res;
}

template <typename T, int buf_size>
int rgb_bgr_kernel(T imgblock[5][buf_size], int loop) {

#pragma HLS inline off

 int t1 = (imgblock[2][0 + loop] + imgblock[2][4 + loop]);
    t1 /= 2;
    int t2 = imgblock[0][2 + loop] + imgblock[1][1 + loop] + imgblock[1][3 + loop] + imgblock[3][1 + loop] +
             imgblock[3][3 + loop] + imgblock[4][2 + loop];
    int t3 = imgblock[1][2 + loop] + imgblock[3][2 + loop];
    t3 *= 4;
    int t4 = (imgblock[2][2 + loop]) * 5;
    int res = (t1) - (t2) + (t3) + (t4);
    res /= 8;
    if (res < 0) return 0;
    return res;
}

template <int BFORMAT, int SRC_T, int NPC, int DEPTH, int buf_size>
void Core_Process(typename DataType<SRC_T, NPC>::uname imgblock[5][buf_size], int& b, int& g, int& r, int row, int col, int loop) {
    if (BFORMAT == XF_BAYER_RG) {
        if ((row & 0x00000001) == 0) {
            if ((col & 0x00000001) == 0) {
                b = rb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = g_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                r = imgblock[2][2 + loop];
            } else {
                b = rgb_bgr_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = imgblock[2][2 + loop];
                r = rgr_bgb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            }
        } else {
            if ((col & 0x00000001) == 0) {
                b = rgr_bgb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = imgblock[2][2 + loop];
                r = rgb_bgr_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            } else {
                b = imgblock[2][2 + loop];
                g = g_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                r = rb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            }
        }
    } else if (BFORMAT == XF_BAYER_BG) {
        if ((row & 0x00000001) == 0) {
            if ((col & 0x00000001) == 0) {

                r = rb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = g_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                b = imgblock[2][2 + loop];
            } else {

                b = rgr_bgb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = imgblock[2][2 + loop];
                r = rgb_bgr_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            }
        } else {
            if ((col & 0x00000001) == 0) {
                b = rgb_bgr_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = imgblock[2][2 + loop];
                r = rgr_bgb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            } else {
                r = imgblock[2][2 + loop];
                g = g_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                b = rb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            }
        }
    } else if (BFORMAT == XF_BAYER_GB) {
        if ((row & 0x00000001) == 0) {
            if ((col & 0x00000001) == 0) {

                b = rgr_bgb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = imgblock[2][2 + loop];
                r = rgb_bgr_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            } else {

                b = imgblock[2][2 + loop];
                g = g_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                r = rb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            }
        } else {
            if ((col & 0x00000001) == 0) {
                r = imgblock[2][2 + loop];
                g = g_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                b = rb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            } else {
                b = rgb_bgr_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = imgblock[2][2 + loop];
                r = rgr_bgb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            }
        }
    } else if (BFORMAT == XF_BAYER_GR) {
        if ((row & 0x00000001) == 0) {
            if ((col & 0x00000001) == 0) {

                b = rgb_bgr_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = imgblock[2][2 + loop];
                r = rgr_bgb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            } else {

                r = imgblock[2][2 + loop];
                g = g_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                b = rb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            }
        } else {
            if ((col & 0x00000001) == 0) {
                b = imgblock[2][2 + loop];
                g = g_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                r = rb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            } else {
                b = rgr_bgb_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
                g = imgblock[2][2 + loop];
                r = rgb_bgr_kernel<typename DataType<SRC_T, NPC>::uname, buf_size>(imgblock, loop);
            }
        }
    }
}

template <int BFORMAT, int SRC_T, int DST_T, int ROWS, int COLS, int NPC, bool USE_URAM>
void demosaicing(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_mat, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst_mat) {
# 235 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_demosaicing.hpp"
    const int __BHEIGHT = 5;
    const int __BHEIGHTMINUSONE = __BHEIGHT - 1;
    const int __BWIDTH = NPC + __BHEIGHTMINUSONE + (((NPC - 1) >> 1) << 1);


#pragma HLS INLINE OFF

 typename DataType<SRC_T, NPC>::name linebuffer[__BHEIGHTMINUSONE][COLS >> xfNPixelsPerCycle<NPC>::datashift];
    if (USE_URAM) {

#pragma HLS RESOURCE variable=linebuffer core=RAM_T2P_URAM
#pragma HLS array_reshape variable=linebuffer dim=1 factor=4 cyclic

 } else {

#pragma HLS RESOURCE variable=linebuffer core=RAM_T2P_BRAM
#pragma HLS array_partition variable=linebuffer complete dim=1

 }
    typename DataType<SRC_T, NPC>::cname imgblock[__BHEIGHT][__BWIDTH];
    const int pre_read_count = (2 / NPC) + ((NPC * NPC) >> 2);
    const int post_read_count = pre_read_count + 2;
    const int end_read_count = ((NPC << 1) >> (NPC * NPC)) + 1;


#pragma HLS array_partition variable=imgblock complete dim=0


 int lineStore = 3, read_index = 0, write_index = 0;
LineBuffer:
    for (int i = 0; i < 2; i++) {

#pragma HLS LOOP_TRIPCOUNT min=2 max=2

 VITIS_LOOP_269_1: for (int j = 0; j<src_mat.cols>> xfNPixelsPerCycle<NPC>::datashift; j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS/NPC max=COLS/NPC
#pragma HLS pipeline ii=1

 typename DataType<SRC_T, NPC>::name tmp = src_mat.read(read_index++);
            linebuffer[i][j] = 0;
            linebuffer[i + 2][j] = tmp;
        }
    }
    ap_uint<3> line0 = 3, line1 = 0, line2 = 1, line3 = 2;
    int step = DataType<SRC_T, NPC>::bitdepth;
    int out_step = DataType<DST_T, NPC>::bitdepth;
    typename DataType<SRC_T, NPC>::name tmp;

Row_Loop:
    for (int i = 0; i < src_mat.rows; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 int bram_read_count = 0;
        lineStore++;
        if (lineStore > 3) {
            lineStore = 0;
        }
        if (line0 == 0) {
            line0 = 1;
            line1 = 2;
            line2 = 3;
            line3 = 0;
        } else if (line0 == 1) {
            line0 = 2;
            line1 = 3;
            line2 = 0;
            line3 = 1;
        } else if (line0 == 2) {
            line0 = 3;
            line1 = 0;
            line2 = 1;
            line3 = 2;
        } else {
            line0 = 0;
            line1 = 1;
            line2 = 2;
            line3 = 3;
        }


    Zero:
        for (int p = 0; p < 4; ++p) {

#pragma HLS PIPELINE ii=1

 VITIS_LOOP_322_2: for (int k = 0; k < NPC + 2; k++) {
                imgblock[p][k] = 0;
            }
        }



    Datafill:
        for (int n = 0, w = 0, v = 0; n < pre_read_count; ++n, ++v) {

#pragma HLS UNROLL

 imgblock[0][2 + NPC + n] = linebuffer[line0][w].range((step + step * v) - 1, step * v);
            imgblock[1][2 + NPC + n] = linebuffer[line1][w].range((step + step * v) - 1, step * v);
            imgblock[2][2 + NPC + n] = linebuffer[line2][w].range((step + step * v) - 1, step * v);
            imgblock[3][2 + NPC + n] = linebuffer[line3][w].range((step + step * v) - 1, step * v);
            (NPC == 1) ? (bram_read_count++, w++, v = -1) : bram_read_count;

        }
        (NPC == 2 || NPC == 4) ? (bram_read_count++) : bram_read_count;

    Col_Loop:
        for (int j = 0; j < ((src_mat.cols) >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS PIPELINE ii=1
#pragma HLS dependence variable=linebuffer inter false
#pragma HLS LOOP_TRIPCOUNT min=COLS/NPC max=COLS/NPC
#pragma HLS LOOP_FLATTEN OFF


 if (i < src_mat.rows - 2) {
                tmp = src_mat.read(read_index++);
            } else {
                tmp = 0;
            }

            VITIS_LOOP_358_3: for (int z = 0; z < NPC; ++z) {
                imgblock[4][2 + NPC + z] = tmp.range((step + step * z) - 1, step * z);
            }


            VITIS_LOOP_363_4: for (int k = 0; k < 5; k++) {
                VITIS_LOOP_364_5: for (int m = 0; m < NPC; ++m) {
                    VITIS_LOOP_365_6: for (int l = 0; l < (__BWIDTH - 1); l++) {
                        imgblock[k][l] = imgblock[k][l + 1];
                    }
                }
            }
            typename DataType<SRC_T, NPC>::name
            packed_read1, packed_read2, packed_read3, packed_read4, packed_store;

            if (j < (src_mat.cols >> xfNPixelsPerCycle<NPC>::datashift) - end_read_count) {


                packed_read1 = linebuffer[line0][bram_read_count];
                packed_read2 = linebuffer[line1][bram_read_count];
                packed_read3 = linebuffer[line2][bram_read_count];
                packed_read4 = linebuffer[line3][bram_read_count];

                VITIS_LOOP_381_7: for (int q = 0; q < NPC; ++q) {
                    imgblock[0][post_read_count + q] = packed_read1.range((step + step * q) - 1, step * q);
                    imgblock[1][post_read_count + q] = packed_read2.range((step + step * q) - 1, step * q);
                    imgblock[2][post_read_count + q] = packed_read3.range((step + step * q) - 1, step * q);
                    imgblock[3][post_read_count + q] = packed_read4.range((step + step * q) - 1, step * q);
                    imgblock[4][NPC + 2 + q] = tmp.range((step + step * q) - 1, step * q);
                    packed_store.range((step + step * q) - 1, step * q) = imgblock[4][2 + q];
                }
                linebuffer[lineStore][j] = packed_store;

            } else {
                VITIS_LOOP_392_8: for (int r = 0; r < NPC; ++r) {
                    if (NPC == 1) {
                        imgblock[4][post_read_count + r - 1] = tmp.range((step + step * r) - 1, step * r);
                    }
                    linebuffer[lineStore][j].range((step + step * r) - 1, step * r) = imgblock[4][2 + r];

                    imgblock[0][post_read_count + r] = 0;
                    imgblock[1][post_read_count + r] = 0;
                    imgblock[2][post_read_count + r] = 0;
                    imgblock[3][post_read_count + r] = 0;
                    imgblock[4][post_read_count + r] = 0;
                }
            }

            bram_read_count++;


            int r, g, b;
            typename DataType<DST_T, NPC>::name res_pixel[NPC];

            VITIS_LOOP_412_9: for (int loop = 0; loop < NPC; loop++) {
                Core_Process<BFORMAT, SRC_T, NPC, DataType<SRC_T, NPC>::pixeldepth, __BWIDTH>(imgblock, b, g, r, i, j * NPC + loop,
                                                                                  loop);

                b = xf_satcast<DataType<DST_T, NPC>::bitdepth>(b);
                g = xf_satcast<DataType<DST_T, NPC>::bitdepth>(g);
                r = xf_satcast<DataType<DST_T, NPC>::bitdepth>(r);

                if (DataType<DST_T, NPC>::channel == 4) {
                    res_pixel[loop].range(4 * out_step - 1, 3 * out_step) = ((1 << out_step) - 1);
                }
                res_pixel[loop].range(3 * out_step - 1, 2 * out_step) = r;
                res_pixel[loop].range(2 * out_step - 1, out_step) = g;
                res_pixel[loop].range(out_step - 1, 0) = b;
            }
            typename DataType<DST_T, NPC>::name packed_res_pixel;
            int pstep = DataType<DST_T, NPC>::pixelwidth;
            VITIS_LOOP_429_10: for (int ploop = 0; ploop < NPC; ploop++) {
                packed_res_pixel.range(pstep + pstep * ploop - 1, pstep * ploop) = res_pixel[ploop];
            }

            dst_mat.write(write_index++, packed_res_pixel);

        }
    }
}

}
};
# 35 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_ltm.hpp" 1
# 20 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_ltm.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 21 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_ltm.hpp" 2



# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_duplicateimage.hpp" 1
# 28 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_duplicateimage.hpp"
namespace xf {
namespace cv {
template <int ROWS, int COLS, int SRC_T, int DEPTH, int NPC, int WORDWIDTH, int XFPDEPTH>
void xFDuplicate(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst1,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC, XFPDEPTH>& _dst2,
                 uint16_t img_height,
                 uint16_t img_width) {
    img_width = img_width >> xfNPixelsPerCycle<NPC>::datashift;

    ap_uint<13> row, col;
    int readindex = 0, writeindex1 = 0, writeindex2 = 0;
    const int TRIP_COLS = COLS / NPC;
Row_Loop:
    for (row = 0; row < img_height; row++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 Col_Loop:
        for (col = 0; col < img_width; col++) {

#pragma HLS LOOP_TRIPCOUNT min = TRIP_COLS max = TRIP_COLS
#pragma HLS pipeline

 typename DataType<SRC_T, NPC>::name tmp_src;
            tmp_src = _src.read(readindex++);
            _dst1.write(writeindex1++, tmp_src);
            _dst2.write(writeindex2++, tmp_src);
        }
    }
}

template <int SRC_T, int ROWS, int COLS, int NPC, int XFPDEPTH>
void duplicateMat(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst1,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC, XFPDEPTH>& _dst2) {

#pragma HLS inline off


 xFDuplicate<ROWS, COLS, SRC_T, DataType<SRC_T, NPC>::pixeldepth, NPC, DataType<SRC_T, NPC>::wordwidth, XFPDEPTH>(_src, _dst1, _dst2,
                                                                                                  _src.rows, _src.cols);
}

template <int ROWS, int COLS, int SRC_T, int DEPTH, int NPC, int WORDWIDTH>
void xFDuplicate(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst1,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst2,
                 uint16_t img_height,
                 uint16_t img_width) {
    img_width = img_width >> xfNPixelsPerCycle<NPC>::datashift;

    ap_uint<13> row, col;
    int readindex = 0, writeindex1 = 0, writeindex2 = 0;
    const int TRIP_COLS = COLS / NPC;
Row_Loop:
    for (row = 0; row < img_height; row++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 Col_Loop:
        for (col = 0; col < img_width; col++) {

#pragma HLS LOOP_TRIPCOUNT min = TRIP_COLS max = TRIP_COLS
#pragma HLS pipeline

 typename DataType<SRC_T, NPC>::name tmp_src;
            tmp_src = _src.read(readindex++);
            _dst1.write(writeindex1++, tmp_src);
            _dst2.write(writeindex2++, tmp_src);
        }
    }
}

template <int ROWS, int COLS, int SRC_T, int DEPTH, int NPC, int WORDWIDTH>
void xFDuplicates(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst1,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst2,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst3,
                  uint16_t img_height,
                  uint16_t img_width) {
    img_width = img_width >> xfNPixelsPerCycle<NPC>::datashift;

    ap_uint<13> row, col;
    int readindex = 0, writeindex1 = 0, writeindex2 = 0, writeindex3 = 0;
    const int TRIP_COLS = COLS / NPC;
Row_Loop:
    for (row = 0; row < img_height; row++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 Col_Loop:
        for (col = 0; col < img_width; col++) {

#pragma HLS LOOP_TRIPCOUNT min = TRIP_COLS max = TRIP_COLS
#pragma HLS pipeline

 typename DataType<SRC_T, NPC>::name tmp_src;
            tmp_src = _src.read(readindex++);
            _dst1.write(writeindex1++, tmp_src);
            _dst2.write(writeindex2++, tmp_src);
            _dst3.write(writeindex3++, tmp_src);
        }
    }
}

template <int SRC_T, int ROWS, int COLS, int NPC>
void duplicateMat(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst1,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst2) {

#pragma HLS inline off


 xFDuplicate<ROWS, COLS, SRC_T, DataType<SRC_T, NPC>::pixeldepth, NPC, DataType<SRC_T, NPC>::wordwidth>(_src, _dst1, _dst2, _src.rows,
                                                                                        _src.cols);
}

template <int SRC_T, int ROWS, int COLS, int NPC>
void duplicateimages(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                     xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst1,
                     xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst2,
                     xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst3) {

#pragma HLS inline off


 xFDuplicates<ROWS, COLS, SRC_T, DataType<SRC_T, NPC>::pixeldepth, NPC, DataType<SRC_T, NPC>::wordwidth>(_src, _dst1, _dst2, _dst3,
                                                                                         _src.rows, _src.cols);
}

}
}
# 25 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_ltm.hpp" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 1
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
# 41 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2

# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_fpo.h" 1
# 63 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_fpo.h"
# 1 "/usr/include/assert.h" 1 3 4
# 64 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_fpo.h" 2
# 43 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2


namespace hls {


  int signbit(double);
  int signbit(float);
  int signbit(half);
  int signbitf(float);
  int half_signbit(half);


  double nan(const char*);
  float nanf(const char*);
  half half_nan(const char *);


  int isfinite(double);
  int isfinite(float);
  int isfinite(half);
  int isfinitef(float);
  int half_isfinite(half);


  int __isfinite(double);
  int __isfinite(float);
  int __isfinite(half);
  int __isfinitef(float);


  int isinf(double);
  int isinf(float);
  int isinf(half);
  int isinff(float);
  int half_isinf(half);


  int __isinf(double);
  int __isinf(float);
  int __isinf(half);
  int __isinff(float);


  int isnan(double);
  int isnan(float);
  int isnan(half);
  int isnanf(float);
  int half_isnan(half);


  int __isnan(double);
  int __isnan(float);
  int __isnan(half);
  int __isnanf(float);


  int isnormal(double);
  int isnormal(float);
  int isnormal(half);
  int isnormalf(float);
  int half_isnormal(half);


  int __isnormal(double);
  int __isnormal(float);
  int __isnormal(half);
  int __isnormalf(float);


  int fpclassify(double);
  int fpclassify(float);
  int fpclassify(half);
  int fpclassifyf(float);
  int half_fpclassify(half);


  int __fpclassify(double);
  int __fpclassify(float);
  int __fpclassify(half);
  int __fpclassifyf(float);


  double copysign(double, double);
  float copysign(float, float);
  half copysign(half, half);
  float copysignf(float, float);
  half half_copysign(half, half);
  int8_t copysign(int8_t, int8_t);
  uint8_t copysign(uint8_t, uint8_t);
  int16_t copysign(int16_t, int16_t);
  uint16_t copysign(uint16_t, uint16_t);
  int32_t copysign(int32_t, int32_t);
  uint32_t copysign(uint32_t, uint32_t);


  double fabs(double);
  float fabs(float);
  half fabs(half);
  float fabsf(float);
  half half_fabs(half);
  int8_t fabs(int8_t);
  uint8_t fabs(uint8_t);
  int16_t fabs(int16_t);
  uint16_t fabs(uint16_t);
  int32_t fabs(int32_t);
  uint32_t fabs(uint32_t);


  double abs(double);
  float abs(float);
  half abs(half);
  float absf(float);
  half half_abs(half);
  int8_t abs(int8_t);
  uint8_t abs(uint8_t);
  int16_t abs(int16_t);
  uint16_t abs(uint16_t);
  int32_t abs(int32_t);
  uint32_t abs(uint32_t);


  double fma(double, double, double);
  float fma(float, float, float);
  half fma(half, half, half);
  float fmaf(float, float, float);
  half half_fma(half, half, half);


  double mad(double, double, double);
  float mad(float, float, float);
  half mad(half, half, half);
  float madf(float, float, float);
  half half_mad(half, half, half);


  int isequal(double, double);
  int isequal(float, float);
  int isequal(half, half);
  int isequalf(float, float);
  int half_isequal(half, half);


  int isgreater(double, double);
  int isgreater(float, float);
  int isgreater(half, half);
  int isgreaterf(float, float);
  int half_isgreater(half, half);


  int isgreaterequal(double, double);
  int isgreaterequal(float, float);
  int isgreaterequal(half, half);
  int isgreaterequalf(float, float);
  int half_isgreaterequal(half, half);


  int isless(double, double);
  int isless(float, float);
  int isless(half, half);
  int islessf(float, float);
  int half_isless(half, half);


  int islessequal(double, double);
  int islessequal(float, float);
  int islessequal(half, half);
  int islessequalf(float, float);
  int half_islessequal(half, half);


  int islessgreater(double, double);
  int islessgreater(float, float);
  int islessgreater(half, half);
  int islessgreaterf(float, float);
  int half_islessgreater(half, half);


  int isnotequal(double, double);
  int isnotequal(float, float);
  int isnotequal(half, half);
  int isnotequalf(float, float);
  int half_isnotequal(half, half);


  double fmax(double, double);
  float fmax(float, float);
  half fmax(half, half);
  float fmaxf(float, float);
  half half_fmax(half, half);
  int8_t fmax(int8_t,int8_t);
  uint8_t fmax(uint8_t, uint8_t);
  int16_t fmax(int16_t, int16_t);
  uint16_t fmax(uint16_t, uint16_t);
  int32_t fmax(int32_t, int32_t);
  uint32_t fmax(uint32_t, uint32_t);


  double fmin(double, double);
  float fmin(float, float);
  half fmin(half, half);
  float fminf(float, float);
  half half_fmin(half, half);
  int8_t fmin(int8_t,int8_t);
  uint8_t fmin(uint8_t, uint8_t);
  int16_t fmin(int16_t, int16_t);
  uint16_t fmin(uint16_t, uint16_t);
  int32_t fmin(int32_t, int32_t);
  uint32_t fmin(uint32_t, uint32_t);


  template <class T>
  T max(T x, T y){
 return (x > y) ? x : y;
  }


  template <class T>
  T min(T x, T y){
 return (x < y) ? x : y;
  }


  double fdim(double, double);
  float fdim(float, float);
  half fdim(half, half);
  float fdimf(float, float);
  half half_fdim(half, half);
  int8_t fdim(int8_t,int8_t);
  uint8_t fdim(uint8_t, uint8_t);
  int16_t fdim(int16_t, int16_t);
  uint16_t fdim(uint16_t, uint16_t);
  int32_t fdim(int32_t, int32_t);
  uint32_t fdim(uint32_t, uint32_t);


  double maxmag(double, double);
  float maxmag(float, float);
  half maxmag(half, half);
  float maxmagf(float, float);
  half half_maxmag(half, half);
  int8_t maxmag(int8_t,int8_t);
  uint8_t maxmag(uint8_t, uint8_t);
  int16_t maxmag(int16_t, int16_t);
  uint16_t maxmag(uint16_t, uint16_t);
  int32_t maxmag(int32_t, int32_t);
  uint32_t maxmag(uint32_t, uint32_t);


  double minmag(double, double);
  float minmag(float, float);
  half minmag(half, half);
  float minmagf(float, float);
  half half_minmag(half, half);
  int8_t minmag(int8_t,int8_t);
  uint8_t minmag(uint8_t, uint8_t);
  int16_t minmag(int16_t, int16_t);
  uint16_t minmag(uint16_t, uint16_t);
  int32_t minmag(int32_t, int32_t);
  uint32_t minmag(uint32_t, uint32_t);



  double frexp(double, int*);
  float frexp(float, int*);
  half frexp(half, int*);
  float frexpf(float, int*);
  half half_frexp(half, int*);


  double ldexp(double, int);
  float ldexp(float, int);
  half ldexp(half, int);
  float ldexpf(float, int);
  half half_ldexp(half, int);


  int ilogb(double);
  int ilogb(float);
  int ilogb(half);
  int ilogbf(float);
  int half_ilogb(half);


  double scalbn(double, int);
  float scalbn(float, int);
  half scalbn(half, int);
  float scalbnf(float, int);
  half half_scalbn(half, int);


  double scalbln(double, long int);
  float scalbln(float, long int);
  half scalbln(half, long int);
  float scalblnf(float, long int);
  half half_scalbln(half, long int);


  double ceil(double);
  float ceil(float);
  half ceil(half);
  float ceilf(float);
  half half_ceil(half);


  double floor(double);
  float floor(float);
  half floor(half);
  float floorf(float);
  half half_floor(half);


  double trunc(double);
  float trunc(float);
  half trunc(half);
  float truncf(float);
  half half_trunc(half);


  double round(double);
  float round(float);
  half round(half);
  float roundf(float);
  half half_round(half);


  double rint(double);
  float rint(float);
  half rint(half);
  float rintf(float);
  half half_rint(half);


  long int lround(double);
  long int lround(float);
  long int lround(half);
  long int lroundf(float);
  long int half_lround(half);


  long long int llround(double);
  long long int llround(float);
  long long int llround(half);
  long long int llroundf(float);
  long long int half_llround(half);


  long int lrint(double);
  long int lrint(float);
  long int lrint(half);
  long int lrintf(float);
  long int half_lrint(half);


  long long int llrint(double);
  long long int llrint(float);
  long long int llrint(half);
  long long int llrintf(float);
  long long int half_llrint(half);


  template<class T>
  T cast_IEEE754(double, bool);
  template<class T>
  T cast_IEEE754(float, bool);
  template<class T>
  T cast_IEEE754(half, bool);

  template<class T>
  T cast_IEEE754(double);
  template<class T>
  T cast_IEEE754(float);
  template<class T>
  T cast_IEEE754(half);



  template<>
  char cast_IEEE754<char>(double, bool);
  template<>
  char cast_IEEE754<char>(float, bool);
  template<>
  char cast_IEEE754<char>(half, bool);
  template<>
  char cast_IEEE754<char>(double);
  template<>
  char cast_IEEE754<char>(float);
  template<>
  char cast_IEEE754<char>(half);


  template<>
  int8_t cast_IEEE754<int8_t>(double, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(float, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(half, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(double);
  template<>
  int8_t cast_IEEE754<int8_t>(float);
  template<>
  int8_t cast_IEEE754<int8_t>(half);


  template<>
  uint8_t cast_IEEE754<uint8_t>(double, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(double);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half);


  template<>
  int16_t cast_IEEE754<int16_t>(double, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(float, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(half, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(double);
  template<>
  int16_t cast_IEEE754<int16_t>(float);
  template<>
  int16_t cast_IEEE754<int16_t>(half);


  template<>
  uint16_t cast_IEEE754<uint16_t>(double, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(double);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half);


  template<>
  int32_t cast_IEEE754<int32_t>(double, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(float, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(half, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(double);
  template<>
  int32_t cast_IEEE754<int32_t>(float);
  template<>
  int32_t cast_IEEE754<int32_t>(half);


  template<>
  uint32_t cast_IEEE754<uint32_t>(double, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(double);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half);


  template<>
  int64_t cast_IEEE754<int64_t>(double, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(float, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(half, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(double);
  template<>
  int64_t cast_IEEE754<int64_t>(float);
  template<>
  int64_t cast_IEEE754<int64_t>(half);


  template<>
  uint64_t cast_IEEE754<uint64_t>(double, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(double);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half);



  double nearbyint(double);
  float nearbyint(float);
  half nearbyint(half);
  float nearbyintf(float);
  half half_nearbyint(half);


  double modf(double, double*);
  float modf(float, float*);
  half modf(half, half*);
  float modff(float, float*);
  half half_modf(half, half*);


  double fract(double, double*);
  float fract(float, float*);
  half fract(half, half*);
  float fractf(float, float*);
  half half_fract(half, half*);


  int isordered(double, double);
  int isordered(float, float);
  int isordered(half, half);
  int isorderedf(float, float);
  int half_isordered(half, half);


  int isunordered(double, double);
  int isunordered(float, float);
  int isunordered(half, half);
  int isunorderedf(float, float);
  int half_isunordered(half, half);


  double bitselect(double, double, double);
  float bitselect(float, float, float);
  int bitselect(int, int, int);
  uint32_t bitselect(uint32_t, uint32_t, uint32_t);
  half bitselect(half, half, half);
  float bitselectf(float, float, float);
  half half_bitselect(half, half, half);


  namespace hotbm {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  namespace cordic {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  double sin(double);
  float sin(float);
  half sin(half);
  float sinf(float);
  half half_sin(half);

  double cos(double);
  float cos(float);
  half cos(half);
  float cosf(float);
  half half_cos(half);


  void sincos(double, double*, double*);
  void sincos(float, float*, float*);
  void sincos(half, half*, half*);
  void sincosf(float, float*, float*);
  void half_sincos(half, half*, half*);


  double sinpi(double);
  float sinpi(float);
  half sinpi(half);
  float sinpif(float);
  half half_sinpi(half);


  double cospi(double);
  float cospi(float);
  half cospi(half);
  float cospif(float);
  half half_cospi(half);


  double tanpi(double);
  float tanpi(float);
  half tanpi(half);
  float tanpif(float);
  half half_tanpi(half);


  double atan(double);
  float atan(float);
  half atan(half);
  float atanf(float);
  half half_atan(half);


  double atan2(double, double);
  float atan2(float, float);
  half atan2(half, half);
  float atan2f(float, float);
  half half_atan2(half, half);


  double tan(double);
  float tan(float);
  half tan(half);
  float tanf(float);
  half half_tan(half);


  double sinh(double);
  float sinh(float);
  half sinh(half);
  float sinhf(float);
  half half_sinh(half);


  double cosh(double);
  float cosh(float);
  half cosh(half);
  float coshf(float);
  half half_cosh(half);


  double exp(double);
  float exp(float);
  half exp(half);
  float expf(float);
  half half_exp(half);
  int8_t exp(int8_t);
  uint8_t exp(uint8_t);
  int16_t exp(int16_t);
  uint16_t exp(uint16_t);
  int32_t exp(int32_t);
  uint32_t exp(uint32_t);


  double exp2(double);
  float exp2(float);
  half exp2(half);
  float exp2f(float);
  half half_exp2(half);


  double exp10(double);
  float exp10(float);
  half exp10(half);
  float exp10f(float);
  half half_exp10(half);


  double expm1(double);
  float expm1(float);
  half expm1(half);
  float expm1f(float);
  half half_expm1(half);


  double log(double);
  float log(float);
  half log(half);
  float logf(float);
  half half_log(half);
  int8_t log(int8_t);
  uint8_t log(uint8_t);
  int16_t log(int16_t);
  uint16_t log(uint16_t);
  int32_t log(int32_t);
  uint32_t log(uint32_t);


  double log2(double);
  float log2(float);
  half log2(half);
  float log2f(float);
  half half_log2(half);


  double log10(double);
  float log10(float);
  half log10(half);
  float log10f(float);
  half half_log10(half);
  int8_t log10(int8_t);
  uint8_t log10(uint8_t);
  int16_t log10(int16_t);
  uint16_t log10(uint16_t);
  int32_t log10(int32_t);
  uint32_t log10(uint32_t);


  double logb(double);
  float logb(float);
  half logb(half);
  float logbf(float);
  half half_logb(half);

  double log1p(double);
  float log1p(float);
  half log1p(half);
  float log1pf(float);
  half half_log1p(half);


  half pow(half, half);
  float pow(float, float);
  double pow(double, double);
  float powf(float, float);
  half half_pow(half, half);
  int8_t pow(int8_t, int8_t);
  uint8_t pow(uint8_t, uint8_t);
  int16_t pow(int16_t, int16_t);
  uint16_t pow(uint16_t, uint16_t);
  int32_t pow(int32_t, int32_t);
  uint32_t pow(uint32_t, uint32_t);
  int8_t powr(int8_t, int8_t);
  uint8_t powr(uint8_t, uint8_t);
  int16_t powr(int16_t, int16_t);
  uint16_t powr(uint16_t, uint16_t);
  int32_t powr(int32_t, int32_t);
  uint32_t powr(uint32_t, uint32_t);


  half powr(half, half);
  float powr(float, float);
  double powr(double, double);
  float powrf(float, float);
  half half_powr(half, half);


  half pown(half, int);
  float pown(float, int);
  double pown(double, int);
  float pownf(float, int);
  half half_pown(half, int);


  half rootn(half, int);
  float rootn(float, int);
  double rootn(double, int);
  float rootnf(float, int);
  half half_rootn(half, int);


  double sqrt(double);
  float sqrt(float);
  half sqrt(half);
  float sqrtf(float);
  half half_sqrt(half);
  int8_t sqrt(int8_t);
  uint8_t sqrt(uint8_t);
  int16_t sqrt(int16_t);
  uint16_t sqrt(uint16_t);
  int32_t sqrt(int32_t);
  uint32_t sqrt(uint32_t);
# 858 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h"
  double recip(double);
  float recip(float);
  half recip(half);
  float recipf(float);
  half half_recip(half);
  int8_t recip(int8_t);
  uint8_t recip(uint8_t);
  int16_t recip(int16_t);
  uint16_t recip(uint16_t);
  int32_t recip(int32_t);
  uint32_t recip(uint32_t);


  double rsqrt(double);
  float rsqrt(float);
  half rsqrt(half);
  float rsqrtf(float);
  half half_rsqrt(half);
  int8_t rsqrt(int8_t);
  uint8_t rsqrt(uint8_t);
  int16_t rsqrt(int16_t);
  uint16_t rsqrt(uint16_t);
  int32_t rsqrt(int32_t);
  uint32_t rsqrt(uint32_t);


  double cbrt(double);
  float cbrt(float);
  half cbrt(half);
  float cbrtf(float);
  half half_cbrt(half);


  double hypot(double, double);
  float hypot(float, float);
  half hypot(half, half);
  float hypotf(float, float);
  half half_hypot(half, half);


  double erf(double);
  float erf(float);
  half erf(half);
  float erff(float);
  half half_erf(half);
  int8_t erf(int8_t);
  uint8_t erf(uint8_t);
  int16_t erf(int16_t);
  uint16_t erf(uint16_t);
  int32_t erf(int32_t);
  uint32_t erf(uint32_t);


  double erfc(double);
  float erfc(float);
  half erfc(half);
  float erfcf(float);
  half half_erfc(half);
  int8_t erfc(int8_t);
  uint8_t erfc(uint8_t);
  int16_t erfc(int16_t);
  uint16_t erfc(uint16_t);
  int32_t erfc(int32_t);
  uint32_t erfc(uint32_t);


  double lgamma(double);
  float lgamma(float);
  half lgamma(half);
  float lgammaf(float);
  half half_lgamma(half);
  int8_t lgamma(int8_t);
  uint8_t lgamma(uint8_t);
  int16_t lgamma(int16_t);
  uint16_t lgamma(uint16_t);
  int32_t lgamma(int32_t);
  uint32_t lgamma(uint32_t);


  double lgamma_r(double, int*);
  float lgamma_r(float, int*);
  half lgamma_r(half, int*);
  float lgamma_rf(float, int*);
  half half_lgamma_r(half, int*);
  int8_t lgamma_r(int8_t);
  uint8_t lgamma_r(uint8_t);
  int16_t lgamma_r(int16_t);
  uint16_t lgamma_r(uint16_t);
  int32_t lgamma_r(int32_t);
  uint32_t lgamma_r(uint32_t);


  double tgamma(double);
  float tgamma(float);
  half tgamma(half);
  float tgammaf(float);
  half half_tgamma(half);
  int8_t tgamma(int8_t);
  uint8_t tgamma(uint8_t);
  int16_t tgamma(int16_t);
  uint16_t tgamma(uint16_t);
  int32_t tgamma(int32_t);
  uint32_t tgamma(uint32_t);

  double tgamma_p_reduce(double);
  float tgamma_p_reduce(float);
  float tgammaf_p_reduce(float);


  double fmod(double, double);
  float fmod(float, float);
  half fmod(half, half);
  float fmodf(float, float);
  half half_fmod(half, half);


  double remainder(double, double);
  float remainder(float, float);
  half remainder(half, half);
  float remainderf(float, float);
  half half_remainder(half, half);


  double remquo(double, double, int*);
  float remquo(float, float, int*);
  half remquo(half, half, int*);
  float remquof(float, float, int*);
  half half_remquo(half, half, int*);


  double divide(double, double);
  float divide(float, float);
  half divide(half, half);
  float dividef(float, float);
  half half_divide(half, half);


  double nextafter(double, double);
  float nextafter(float, float);
  half nextafter(half, half);
  float nextafterf(float, float);
  half half_nextafter(half, half);


  double tanh(double);
  float tanh(float);
  half tanh(half);
  float tanhf(float);
  half half_tanh(half);


  double atanh(double);
  float atanh(float);
  half atanh(half);
  float atanhf(float);
  half half_atanh(half);


  double asinh(double);
  float asinh(float);
  half asinh(half);
  float asinhf(float);
  half half_asinh(half);


  double acosh(double);
  float acosh(float);
  half acosh(half);
  float acoshf(float);
  half half_acosh(half);


  double asin(double);
  float asin(float);
  half asin(half);
  float asinf(float);
  half half_asin(half);


  double acos(double);
  float acos(float);
  half acos(half);
  float acosf(float);
  half half_acos(half);


  double asinpi(double);
  float asinpi(float);
  half asinpi(half);
  float asinpif(float);
  half half_asinpi(half);


  double acospi(double);
  float acospi(float);
  half acospi(half);
  float acospif(float);
  half half_acospi(half);


  double atanpi(double);
  float atanpi(float);
  half atanpi(half);
  float atanpif(float);
  half half_atanpi(half);
}


# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hotbm_apfixed.h" 1
# 43 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hotbm_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 44 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hotbm_apfixed.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_defines.h" 1
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_defines.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 41 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_defines.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/hls_version.h" 1
# 42 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_defines.h" 2
# 109 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_defines.h"
template<int M, int E>
struct float_struct {
    ap_uint<M> mant;
    ap_uint<E> exp;
    ap_uint<1> sign;
};




template<int M, int E>
struct float_struct2 {
    ap_int<M> mant;
    ap_uint<E> exp;
};
# 45 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hotbm_apfixed.h" 2







namespace hotbm_apfixed
{

  namespace first_order_fixed_16{
 extern const ap_fixed<19,2> sin_cos_K0[256];
 extern const ap_fixed<11,2> sin_cos_K1[256];
  };

  namespace second_order_float{
 extern const ap_fixed<29,0> cos_K0[128];
 extern const ap_fixed<23,1> cos_K1[128];
 extern const ap_fixed<15,0> cos_K2[128];
 extern const ap_fixed<30,1> sin_K0[128];
 extern const ap_fixed<21,-1> sin_K1[128];
 extern const ap_fixed<13,-2> sin_K2[128];
 extern const ap_ufixed<30,1> sin_cos_K0[256];
 extern const ap_fixed<23,1> sin_cos_K1[256];
 extern const ap_fixed<15,0> sin_cos_K2[256];
  };

  namespace fourth_order_double{
 extern const ap_fixed<59,0> cos_K0[128];
 extern const ap_fixed<53,1> cos_K1[128];
 extern const ap_fixed<45,0> cos_K2[128];
 extern const ap_fixed<35,-3> cos_K3[128];
 extern const ap_fixed<27,-4> cos_K4[128];
 extern const ap_fixed<60,1> sin_K0[128];
 extern const ap_fixed<51,-1> sin_K1[128];
 extern const ap_fixed<43,-2> sin_K2[128];
 extern const ap_fixed<33,-5> sin_K3[128];
 extern const ap_fixed<24,-7> sin_K4[128];
 extern const ap_fixed<59,1> sin_cos_K0[256];
 extern const ap_fixed<52,1> sin_cos_K1[256];
 extern const ap_fixed<44,0> sin_cos_K2[256];
 extern const ap_fixed<34,-3> sin_cos_K3[256];
 extern const ap_fixed<26,-4> sin_cos_K4[256];
  };

  template<class T>
  struct value_list{
  };

  template<>
  struct value_list<double>{
    typedef double T;
 static const int g = 10;
 static const int p1 = 61;
 static const int alpha = 7;

 static const int beta1 = 0;

 static const int beta2 = alpha;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<double>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K2 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K3 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K4 type=ROM_1P impl=LUTRAM

 (void)(Ex);
   ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = fourth_order_double::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*fourth_order_double::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*fourth_order_double::sin_cos_K2[A];
   ap_fixed<Wx, 1> t4 = B_third_power*fourth_order_double::sin_cos_K3[A];
   ap_fixed<Wx, 1> t5 = B_fourth_power*fourth_order_double::sin_cos_K4[A];
   ap_ufixed<Wx, 1> result = Mx*(t1+t2+t3+t4+t5);
   return result;
    }

    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> Mx,
          ap_int<fp_struct<double>::EXP_BITS> Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K2 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K3 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K4 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K2 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K3 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K4 type=ROM_1P impl=LUTRAM

 (void)(k);
          (void)(Ex);
   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   ap_fixed<Wx, 1> cos_t1 = fourth_order_double::cos_K0[A];
   ap_fixed<Wx, 1> cos_t2 = B*fourth_order_double::cos_K1[A];
   ap_fixed<Wx, 1> cos_t3 = B_squared*fourth_order_double::cos_K2[A];
   ap_fixed<Wx, 1> cos_t4 = B_third_power*fourth_order_double::cos_K3[A];
   ap_fixed<Wx, 1> cos_t5 = B_fourth_power*fourth_order_double::cos_K4[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3 + cos_t4 + cos_t5);

   ap_fixed<Wx, 1> sin_t1 = fourth_order_double::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*fourth_order_double::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*fourth_order_double::sin_K2[A];
   ap_fixed<Wx, 1> sin_t4 = B_third_power*fourth_order_double::sin_K3[A];
   ap_fixed<Wx, 1> sin_t5 = B_fourth_power*fourth_order_double::sin_K4[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3 + sin_t4 + sin_t5);
    }
  };

  template<>
  struct value_list<float> {
 typedef float T;
 static const int g = 5;
 static const int p1 = 29;
 static const int alpha = 7;
 static const int beta1 = 0;
 static const int beta2 = 7;

 static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
 static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

 template <int Wx, int Wr>
 static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<float>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};

#pragma HLS array_partition variable=swap_table complete
#pragma HLS BIND_STORAGE variable=second_order_float::sin_cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_cos_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_cos_K2 type=ROM_1P impl=LUTRAM

 (void)(Ex);
   ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = second_order_float::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*second_order_float::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*second_order_float::sin_cos_K2[A];
   ap_ufixed<Wx, 1> result = (t1+t2+t3) * Mx;

   return result;
 }

 template <int Wx, int Wr>
 static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> &Mx,
          ap_int<fp_struct<float>::EXP_BITS> &Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS BIND_STORAGE variable=second_order_float::cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::cos_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::cos_K2 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_K2 type=ROM_1P impl=LUTRAM

 (void)(k);
          (void)(Ex);
   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;


   ap_ufixed<Wx, 1> cos_t1 = second_order_float::cos_K0[A];
   ap_ufixed<Wx, 1> cos_t2 = B*second_order_float::cos_K1[A];
   ap_ufixed<Wx, 1> cos_t3 = B_squared*second_order_float::cos_K2[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3);

   ap_fixed<Wx, 1> sin_t1 = second_order_float::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*second_order_float::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*second_order_float::sin_K2[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3);
 }
  };

  struct sin_cos_fixed_16 {

 typedef half T;
 static const int g = 3;
 static const int p1 = 12;
 static const int alpha = 8;
 static const int beta1 = 4;

 template <int W_dout>
 static ap_ufixed<W_dout, 1> sin_or_cos_approximation(bool do_cos,
               ap_uint<2> &k,
               ap_ufixed<W_dout, 0> &x){

#pragma HLS BIND_STORAGE variable=first_order_fixed_16::sin_cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=first_order_fixed_16::sin_cos_K1 type=ROM_1P impl=LUTRAM
 (void)(do_cos);
          (void)(k);

   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);

   const int BW = (W_dout-alpha-beta1)>1 ? W_dout-alpha-beta1 : 2;
   ap_ufixed<BW, -alpha> B = x;

   ap_fixed<W_dout, 1> t1 = first_order_fixed_16::sin_cos_K0[A];
   ap_fixed<W_dout, 1> t2 = B*first_order_fixed_16::sin_cos_K1[A];
   ap_ufixed<W_dout, 1> result = (t1+t2);

   return result;
 };
  };

  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 16) && (W <= 32), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};

#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 (void)(dummy);
 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<float>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<float>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<float>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  }


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 32) && (W <= 64), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 (void)(dummy);
 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<double>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<double>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<double>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  };


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<W <= 16, bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 4;

 const bool neg_sin_table[8] = {0,0,1,1, 1,1,0,0};
 const bool neg_cos_table[8] = {0,1,1,0, 0,1,1,0};
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 (void)(dummy);
 ap_uint<2> k;
 ap_ufixed<WO+1+g, 0> x;

 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*2;
   x = din*2;
   ap_ufixed<W, 1> Mx_bits_extended = din*2;
 }
 else {
   ap_ufixed<WO+1+g+2, 2> Wx = din * ap_ufixed<W+1+g,2>(2/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }

 bool is_special_case = false;

 if((k[0] == 1) ^ !do_cos) {
   ap_ufixed<WO+1+g+1, 1> Wx = 1-x;
   x = Wx;
   is_special_case = (Wx[Wx.wl()-1] == 1);
 }

 ap_ufixed<WO+1+g, 1> result = sin_cos_fixed_16::sin_or_cos_approximation(do_cos,k,x);

 if(is_special_case) {
   ap_uint<3> index = k;
   index[2] = do_cos;
   const bool special_case_table[8] = {0,1,0,1,1,0,1,0};
   result(result.wl()-2,0) = 0;
   result[result.wl()-1] = special_case_table[index];
 }

 {
   ap_uint<3> index = k;
   index[2] = is_negative;

   if(do_cos ? neg_cos_table[index] : neg_sin_table[index]) {
  return -result;
   } else {
  return result;
   }
 }
  };

};
# 1066 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cordic_apfixed.h" 1
# 41 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cordic_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 42 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cordic_apfixed.h" 2





namespace cordic_apfixed {

  extern const ap_ufixed<128,2> circ_table_arctan_128[128];
  extern const int hyperb_table_tau_128[128];
  extern const ap_ufixed<128,4> hyperb_table_arctanh_128[128];





  template<int W, int I, int Wo>
  void circ_range_redux( ap_ufixed<W,I> x,
                         ap_uint<2> &k,
                         ap_ufixed<Wo,1> &r) {

    ap_ufixed<(Wo+I),0> inv_pi2("0x0.A2F9836E4E43FC715BBF");
    ap_ufixed<Wo+1,1> pi2("1.5707963267948966192313216916397514420985846996876");
    ap_ufixed<Wo+I,I> prod = x * inv_pi2;
    ap_uint<I> kint = prod;

    k = kint;
    r = x - kint * pi2;
  };






  template<int W, int I, int MODE>
  void cordic_circ_apfixed( ap_fixed<W,I> &x,
                            ap_fixed<W,I> &y,
                            ap_fixed<W,I> &z) {

    const int Nmax = W;

    ap_fixed<W,I> tx, ty, tz;
    ap_fixed<W,I> x_s, y_s, z_s;
    ap_uint<1> d;

    VITIS_LOOP_87_1: for (int n=0; n<Nmax; n++){
#pragma HLS pipeline

 if(MODE == 1) {
        d = ~y[W-1];
      }
      else {
        d = z[W-1];
      }

      x_s = x >> n;
      y_s = y >> n;
      z_s = circ_table_arctan_128[n];

      if(d){
        tx = x + y_s;
        ty = y - x_s;
        tz = z + z_s;
      }
      else{
        tx = x - y_s;
        ty = y + x_s;
        tz = z - z_s;
      }

      x = tx;
      y = ty;
      z = tz;
# 126 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  };







  template<int W, int I, int MODE, int INTYPE>
  void doublecordic_apfixed( ap_fixed<W,I> &x,
                             ap_fixed<W,I> &y,
                             ap_fixed<W,I> &z,
                             ap_fixed<W,I> &t) {

    const int Nmax = W - I + 1;

    VITIS_LOOP_143_1: for (int n=0; n<Nmax; n++){

      if(INTYPE==64){
#pragma HLS pipeline II=5
 }
      else if(INTYPE==32){
#pragma HLS pipeline II=3
 }
      else if(INTYPE==16){
#pragma HLS pipeline II=1
 }
      else{
#pragma HLS pipeline II=4
 }

      ap_uint<1> d;
      if(MODE == 0) {
        if(y<=t){
          d = x[W-1];
        }
        else{
          d = ~x[W-1];
        }
      }
      else {
        if(x>=t){
          d = y[W-1];
        }
        else{
          d = ~y[W-1];
        }
      }

      ap_fixed<W,I> x_s = x >> (n-1);
      ap_fixed<W,I> y_s = y >> (n-1);
      ap_fixed<W,I> x_s2 = x_s >> (n+1);
      ap_fixed<W,I> y_s2 = y_s >> (n+1);

      x = x - x_s2;
      y = y - y_s2;
      if(d){
        x = x + y_s;
        y = y - x_s;
      }
      else{
        x = x - y_s;
        y = y + x_s;
      }


      ap_fixed<W,I> t_s;
      int n2 = (n << 1);
      if(n2<W){
        t_s = (t >> n2);
        t = t + t_s;
      }


      ap_fixed<W,I> ca = circ_table_arctan_128[n];
      ap_fixed<W,I> z_s = (ca << 1);
      ap_fixed<W,I> tz;
      if(d){
        tz = z - z_s;
      }
      else{
        tz = z + z_s;
      }
      z = tz;
# 221 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  };



  template<int W, int I>
  void generic_sincos(ap_fixed<W,I> in,
                      ap_fixed<W-I+2,2> & outsin, ap_fixed<W-I+2,2> & outcos){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_ufixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    const int Fr = (W - I) + I + 1;
    ap_uint<2> k;
    ap_ufixed<Fr,1> r;
    circ_range_redux(inabs, k, r);

    ap_fixed<W+2,3> x, y, z;

    const ap_fixed<W+2,3> K1("0x0.9B74EDA8435E47F277F7");
    x = K1;
    y = 0;

    if(k==1 or k==3){
      ap_ufixed<Fr,1> pi2("0x1.921FB54442D1846");

      z = pi2 - r;
    }
    else{
      z = r;
    }







    cordic_circ_apfixed<W+2,3,0>(x,y,z);







    if(k==0){
      outsin = y;
      outcos = x;
    }
    else if(k==1){
      outsin = y;
      outcos = -x;
    }
    else if(k==2){
      outsin = -y;
      outcos = -x;
    }
    else{
      outsin = -y;
      outcos = x;
    }

    if(sign0==0)
      outsin = -outsin;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_tan(ap_fixed<W,I> x){

    const int Ix = I;
    const int Fx = (((W-I)>(I-1)) ? (W-I): (I-1)) + I;
    const int Wx = I + Fx;

    ap_fixed<Wx,Ix> xs = x;

    ap_fixed<Wx-Ix+2,2> outsin;
    ap_fixed<Wx-Ix+2,2> outcos;
    generic_sincos(xs, outsin, outcos);

    ap_fixed<W,I> out = outsin / outcos;


    if(I==1){
      if(out[W-1]==1){
        out[W-1] = 0;
        VITIS_LOOP_315_1: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 out[i] = 1;
        }
      }
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,I> generic_tan(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_tan(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_tan(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_tan(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_tan(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_tan(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };
# 366 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cordic_apfixed.h"
  template<int W, int I, int Wo>
  void circ_range_redux_pi( ap_ufixed<W,I> x,
                             ap_uint<2> &k,
                             ap_ufixed<Wo,1> &r) {

    ap_ufixed<Wo+1,1> pi2("1.5707963267948966192313216916397514420985846996876");
    ap_ufixed<W+1,I+1> prod = x << 1;
    ap_uint<I+1> kint = prod;

    k = kint;
    r = (prod - kint) * pi2;
  };

  template<int W, int I>
  void generic_sincospi(ap_fixed<W,I> in,
                      ap_fixed<W-I+2,2> & outsin, ap_fixed<W-I+2,2> & outcos){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_ufixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    const int Fr = (W - I) + I + 1;
    ap_uint<2> k;
    ap_ufixed<Fr,1> r;
    circ_range_redux_pi(inabs, k, r);

    ap_fixed<W+2,3> x, y, z;

    const ap_fixed<W+2,3> K1("0x0.9B74EDA8435E47F277F7");
    x = K1;
    y = 0;

    if(k==1 or k==3){
      ap_ufixed<Fr,1> pi2("0x1.921FB54442D1846");
      z = pi2 - r;
    }
    else{
      z = r;
    }







    cordic_circ_apfixed<W+2,3,0>(x,y,z);







    if(k==0){
      outsin = y;
      outcos = x;
    }
    else if(k==1){
      outsin = y;
      outcos = -x;
    }
    else if(k==2){
      outsin = -y;
      outcos = -x;
    }
    else{
      outsin = -y;
      outcos = x;
    }

    if(sign0==0)
      outsin = -outsin;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_tanpi(ap_fixed<W,I> x){

    const int Ix = I;
    const int Fx = (((W-I)>(I-1)) ? (W-I): (I-1)) + I;
    const int Wx = I + Fx;

    ap_fixed<Wx,Ix> xs = x;

    ap_fixed<Wx-Ix+2,2> outsin;
    ap_fixed<Wx-Ix+2,2> outcos;
    generic_sincospi(xs, outsin, outcos);

    ap_fixed<W,I> out;
    ap_int<1> bpoint=0;
    if(!outcos){
        bpoint = 1;
    }else{
        out = outsin / outcos;
    }




    if(I==1||bpoint){
      if( out[W-1]==1 ){
        out[W-1] = 0;
        VITIS_LOOP_475_1: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 out[i] = 1;
        }
      }
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,I> generic_tanpi(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_tanpi(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_tanpi(ap_int<I> in) {
    (void)(in);
    return ap_int<I>(0);
  };


  template<int I>
  ap_uint<I> generic_tanpi(ap_uint<I> in) {
    (void)(in);
    return ap_uint<I>(0);
  };


  template<int W, int I>
  ap_fixed<W,2> generic_atan(ap_fixed<W,I> in){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_fixed<W+1,I+1> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    ap_uint<1> sign1 = (inabs > 1) ? 1: 0;

    ap_fixed<W+2,3> x, y, z;
    if(sign1){
      x = 1;

      y = 1.0 / inabs.to_double();
      z = 0;
    }
    else{
      x = 1;
      y = inabs;
      z = 0;
    }
    cordic_circ_apfixed<W+2,3,1>(x,y,z);

    ap_fixed<W,2> out;
    if(sign1){
      const ap_fixed<W,2> pi2("0x1.921FB54442D1846");
      out = pi2 - z;
    }
    else{
      out = z;
    }


    if(sign0){
      return out;
    }
    else{
      return -out;
    }
  };


  template<int W, int I>
  ap_ufixed<W,2> generic_atan(ap_ufixed<W,I> in){
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,2> fout = generic_atan(fin);
    ap_ufixed<W,2> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<2> generic_atan(ap_int<I> in){
    if(in<-1)
      return ap_int<2>(-1);
    else if(in>1)
      return ap_int<2>(1);
    else
      return ap_int<2>(0);
  };


  template<int I>
  ap_uint<1> generic_atan(ap_uint<I> in){
    if(in>1)
      return ap_uint<1>(1);
    else
      return ap_uint<1>(0);
  };


  template<int W, int I>
  ap_fixed<W,3> generic_atan2(ap_fixed<W,I> in1,
                              ap_fixed<W,I> in2){

    const ap_fixed<W+1,3> pi("0x3.243F6A8885A308D3");
    const ap_fixed<W+2,3> pi2("0x1.921FB54442D1846");
    const ap_fixed<W+1,3> pi4("0x0.C90FDAA22168C23");
    const ap_fixed<W+1,3> pi3_("-0x2.5B2F8FE6643A469");

    ap_uint<2> signin1 = (in1 > 0) ? 2: (in1==0) ? 1: 0;
    ap_uint<2> signin2 = (in2 > 0) ? 2: (in2==0) ? 1: 0;

    ap_fixed<W,3> out;



    if(signin1==1 and signin2==2){
      out = 0;
      return out;
    }
    else if(signin1==1 and signin2==0){
      out = pi;
      return out;
    }
    else if(signin1==2 and signin2==1){
      out = pi2;
      return out;
    }
    else if(signin1==0 and signin2==1){
      out = -pi2;
      return out;
    }
    else if(in1==in2){
      if(signin1==2){
        out = pi4;
        return out;
      }
      else if(signin1==1){
        out = 0;
        return out;
      }
      else{
        out = pi3_;
        return out;
      }
    }



    ap_fixed<W+1,I+1> in1abs;
    if(signin1==0)
      in1abs = -in1;
    else
      in1abs = in1;

    ap_fixed<W+1,I+1> in2abs;
    if(signin2==0)
      in2abs = -in2;
    else
      in2abs = in2;

    ap_fixed<W+1,2> in1abs_sft;
    ap_fixed<W+1,2> in2abs_sft;
    VITIS_LOOP_655_1: for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
 in1abs_sft[i] = in1abs[i];
    }
    VITIS_LOOP_659_2: for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
 in2abs_sft[i] = in2abs[i];
    }

    ap_fixed<W+7,3> x, y, z;
    if(in1abs > in2abs){
      x = in1abs_sft;
      y = in2abs_sft;
      z = 0;
    }
    else{
      x = in2abs_sft;
      y = in1abs_sft;
      z = 0;
    }
    cordic_circ_apfixed<W+7,3,1>(x,y,z);

    if(in1abs > in2abs){
      z = pi2 - z;
    }

    if(signin2==0 and signin1==2){
      out = pi - z;
    }
    else if(signin2==0 and signin1==0){
      out = z - pi;
    }
    else if(signin2==2 and signin1==0){
      out = -z;
    }
    else{
      out = z;
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,3> generic_atan2(ap_ufixed<W,I> in1,
                               ap_ufixed<W,I> in2){
    ap_fixed<W+1,I+1> fin1 = in1;
    ap_fixed<W+1,I+1> fin2 = in2;
    ap_fixed<W+1,3> fout = generic_atan2(fin1, fin2);
    ap_ufixed<W,3> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  }


  template<int I>
  ap_int<3> generic_atan2(ap_int<I> in1,
                          ap_int<I> in2){
    ap_fixed<I+1,I+1> fin1 = in1;
    ap_fixed<I+1,I+1> fin2 = in2;
    ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
    ap_int<3> out = fout;
    return out;
  }


  template<int I>
  ap_uint<2> generic_atan2(ap_uint<I> in1,
                           ap_uint<I> in2){
    ap_fixed<I+1,I+1> fin1 = in1;
    ap_fixed<I+1,I+1> fin2 = in2;
    ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
    ap_uint<2> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  }





  template<int W, int I, int Wo>
  void hyperb_range_redux( ap_ufixed<W,I> x,
                           ap_uint<I+1> &k,
                           ap_ufixed<Wo,0> &r) {

    ap_ufixed<(Wo+I)+1,1> inv_ln2("0x1.71547652b82fe1777d0ffda0d23a7d11d6aef551cp0");
    ap_ufixed<Wo,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    ap_ufixed<Wo+(I+1),I+1> prod = x * inv_ln2;
    ap_ufixed<Wo,0> prod_dec = prod;
    k = prod;
    r = prod_dec * ln2;
  };






  template<int W, int I, int MODE>
  void cordic_hyperb_apfixed( ap_fixed<W,I> &x,
                              ap_fixed<W,I> &y,
                              ap_fixed<W,I> &z) {

    const int Nmax = W + 1;

    ap_fixed<W,I> tx, ty, tz;
    ap_fixed<W,I> x_s, y_s, z_s;
    ap_uint<1> d;

    VITIS_LOOP_769_1: for (int n=0; n<Nmax; n++){

      int k = hyperb_table_tau_128[n];

      if(MODE == 1) {
        d = ~y[W-1];
      }
      else {
        d = z[W-1];
      }

      x_s = x >> k;
      y_s = y >> k;
      z_s = hyperb_table_arctanh_128[k-1];

      if(d){
        tx = x - y_s;
        ty = y - x_s;
        tz = z + z_s;
      }
      else{
        tx = x + y_s;
        ty = y + x_s;
        tz = z - z_s;
      }

      x = tx;
      y = ty;
      z = tz;
# 806 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  }


  template <int W, int I>
  void sinh_cosh_range_redux_cordic( ap_fixed<W,I> in,
                                     ap_fixed<W,I> &s_out,
                                     ap_fixed<W,I> &c_out){

    ap_uint<1> sign0 = in[W-1];

    ap_ufixed<W,I> inabs;
    if(sign0 == 0)
      inabs = in;
    else
      inabs = -in;

    const int Fr = (W - I) + I;

    if(in==0){
      s_out = 0;
      c_out = 1;
      return;
    }


    ap_uint<I+1> k;
    ap_ufixed<Fr,0> r;
    hyperb_range_redux(inabs, k, r);

    ap_fixed<Fr+2,2> x("1.20749706776307212887772");
    ap_fixed<Fr+2,2> y(0);
    ap_fixed<Fr+2,2> z(r);




    cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);



    ap_fixed<Fr+(I+2),I+2> er, e_r;
    er = x + y;
    e_r = x - y;



    er <<= (k-1);
    e_r >>= (k+1);



    ap_fixed<W+1,I+1> s_out_tmp = er - e_r;
    ap_fixed<W+1,I+1> c_out_tmp = er + e_r;




    if(s_out_tmp[W-1]==1){
      s_out_tmp[W-1] = 0;
      VITIS_LOOP_866_1: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 s_out_tmp[i] = 1;
      }
    }


    if(sign0 == 0){
      s_out = s_out_tmp;
    }
    else{
      s_out = -s_out_tmp;
    }




    if(c_out_tmp[W-1]==1){
      c_out[W-1] = 0;
      VITIS_LOOP_885_2: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 c_out[i] = 1;
      }
    }
    else{
      c_out = c_out_tmp;
    }
  };

    template<int W, int I>
    void tanh_range_redux_cordic(ap_fixed<W,I> in, ap_fixed<W,I> &tan_out) {

        ap_uint<1> sign0 = in[W-1];

        ap_ufixed<W,I> inabs;
        if(sign0 == 0)
            inabs = in;
        else
            inabs = -in;

        const int Fr = (W - I) + I;

        if(in==0){
            tan_out = 0;
            return;
        }

        ap_uint<I+1> k;
        ap_ufixed<Fr,0> r;
        hyperb_range_redux(inabs, k, r);

        ap_fixed<Fr+2,2> x("1.20749706776307212887772");
        ap_fixed<Fr+2,2> y(0);
        ap_fixed<Fr+2,2> z(r);

        cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);
        ap_fixed<Fr+(I+2),I+2> er, e_r;
        er = x + y;
        e_r = x - y;
        er <<= k;
        e_r >>= k;
        tan_out = (er/(er+e_r))*2 - 1;
    }

    template<int W, int I>
    ap_fixed<W,I> generic_tanh(ap_fixed<W,I> in) {
        ap_fixed<W,I> tan_out;
        tanh_range_redux_cordic(in, tan_out);
        return tan_out;
    }

    template<int W, int I>
    ap_ufixed<W,I> generic_tanh(ap_ufixed<W,I> in) {
        ap_fixed<W+1,I+1> fin = in;
        ap_fixed<W+1,I+1> fout = generic_tanh(fin);
        ap_ufixed<W,I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_int<I> generic_tanh(ap_int<I> in) {
        ap_fixed<I,I> fin = in;
        ap_fixed<I,I> fout = generic_tanh(fin);
        ap_int<I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_uint<I> generic_tanh(ap_uint<I> in) {
        ap_fixed<I+1,I+1> fin = in;
        ap_fixed<I+1,I+1> fout = generic_tanh(fin);
        ap_uint<I> tan_out = fout;
        return tan_out;
    }

  template<int W, int I>
  ap_fixed<W,I> generic_sinh(ap_fixed<W,I> in) {
    ap_fixed<W,I> s_out, c_out;
    sinh_cosh_range_redux_cordic(in,s_out,c_out);
    return s_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_sinh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_sinh(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_sinh(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_sinh(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_sinh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_sinh(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };


  template<int W, int I>
  ap_fixed<W, I> generic_cosh(ap_fixed<W,I> in) {
    ap_fixed<W,I> s_out, c_out;
    sinh_cosh_range_redux_cordic(in,s_out,c_out);
    return c_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_cosh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_cosh(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_cosh(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_cosh(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_cosh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_cosh(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_asin(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0 + 6;

    const ap_fixed<W+1,I+1> cst1("0x1");
    const ap_fixed<W,I> cst0("0x0");
    const ap_fixed<W,I> cst_1("-0x1");
# 1064 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cordic_apfixed.h"
    ap_fixed<W-I+3,3> out;


    if(in==cst1){
      out = ap_fixed<W-I+3,3>("0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst_1){
      out = ap_fixed<W-I+3,3>("-0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst0){
      out = ap_fixed<W-I+3,3>("0x0");
      return out;
    }


    ap_uint<1> sign0 = (in >= 0) ? 1: 0;


    ap_fixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;

    ap_fixed<W,I> absout;


    if(inabs[W-I-1]==0){
      ap_fixed<W0,I0> x("0x1");
      ap_fixed<W0,I0> y("0x0");
      ap_fixed<W0,I0> z("0x0");
      ap_fixed<W0,I0> t = inabs;
      doublecordic_apfixed<W0,I0,0,0>(x,y,z,t);
      absout = z;
    }
    else{
      const int F1 = W - I;
      const int W1 = F1 + F1 + I;
      ap_fixed<W1,I> one("0x1");
      ap_fixed<W1,I> onex = one - inabs * inabs;
      ap_fixed<W1,I> sqrtonex = ::__builtin_sqrt(onex.to_double());
      ap_fixed<W1,I> xsqrtonex = inabs / (one + sqrtonex);
      absout = generic_atan(xsqrtonex) << 1;
    }


    if(sign0)
      out = absout;
    else
      out = -absout;

    return out;
  }



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_acos(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0;
# 1142 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cordic_apfixed.h"
    const ap_fixed<W0,I0> pi2("0x1.921FB54442D1846");
    ap_fixed<W0,I0> out = pi2 - generic_asin(in);

    if(out[W0-1]==1){
      out = -out;
    }

    return out;
  }

  template<int W, int I>
  void cordic_semi_recovery_asinh(ap_fixed<W,I> in_top, ap_fixed<W,I>& out) {

    if(in_top == 0) {
      out = 0;
      return;
    }

    ap_fixed<W,I> in;
    if(in_top >= 0) {
      in = in_top;
    }
    else {
      in = -in_top;
    }

    int m = in.countLeadingZeros();
    int k = I-m;

    if(W-I-2 >= k) {

      ap_fixed<W,I> boundk = 1.0;
      ap_fixed<W,I> bound_k_2 = 1.0;
      boundk <<= k;
      bound_k_2 >>= k;
      bound_k_2 >>= 2;

      if(in >= (boundk - bound_k_2)) {
        k+=1;
      }

    }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> y_semi_recovery;
    ap_fixed<W,I> in_s;

    VITIS_LOOP_1199_1: for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      y_semi_recovery = (xk - x_k + yk + y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(y_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    if(in_top >= 0) {
      out = z_r + k*ln2;
    }
    else {
      out = -z_r - k*ln2;
    }
  }

  template<int W, int I>
  void cordic_semi_recovery_acosh(ap_fixed<W,I> in, ap_fixed<W,I>& out) {






    if(in == 1) {
      out = 0;
      return;
    }

    int m = in.countLeadingZeros();
    int k = I-m;


    ap_fixed<W,I> boundk = 1.0;
    ap_fixed<W,I> bound_k_1 = 1.0;
    boundk <<= k;
    boundk >>= 1;
    bound_k_1 >>= k;
    bound_k_1 >>= 1;

      if(in < (boundk - bound_k_1)) {
        k-=1;
      }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> x_semi_recovery;
    ap_fixed<W,I> in_s;

    VITIS_LOOP_1282_1: for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      x_semi_recovery = (xk + x_k + yk - y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(x_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    out = z_r + k*ln2;
  }


  template<int W, int I>
  ap_fixed<W,I> generic_asinh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output; input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_asinh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_asinh(ap_int<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_asinh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_acosh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_acosh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_acosh(ap_int<I> in) {
    ap_fixed<I,I> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_acosh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_asinpi(ap_fixed<W,I> x) {
      const static int we = I < 3? 3: I;
      ap_fixed<W-I+we, we> xi = x;
      ap_fixed<W-I+3,3> asin_x = generic_asin(xi);






      static const int F = W - I;





      static const int wf = F < 1? 0: F - 1;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;





      ap_fixed<W,I> r = asin_x/pi;





      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_asinpi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_asinpi(xi);
  }
  template<int I>
  ap_int<I> generic_asinpi(ap_int<I> x) {

      if(x==-1){

        return -1;
      }else if(x==0){
        return 0;
      }else if(x==1){

        return 1;
      }else{




        return 0;
      };
  }
  template<int I>
  ap_uint<I> generic_asinpi(ap_uint<I> x) {

      if(x==0){
        return 0;

      } else if(x==1){
        return 1;
      } else{




        return 0;
      };
  }

  template<int W, int I>
  ap_fixed<W,I> generic_acospi(ap_fixed<W,I> x) {





      const static int we = I < 3? 3 : I;
      ap_fixed<W-I+we,we> xi = x;
      ap_fixed<W-I+3,3> acos_x = generic_acos(xi);





      static const int F = W - I;





      static const int wf = F;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;





      ap_fixed<W,I> r = acos_x/pi;





      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_acospi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_acospi(xi);
  }
  template<int I>
  ap_int<I> generic_acospi(ap_int<I> x) {

      if(x==-1){
        return 1;

      } else if(x==0){
        return 1;
      } else if(x==1){
        return 0;
      } else{




        return 0;
      };
  }
  template<int I>
  ap_uint<I> generic_acospi(ap_uint<I> x) {

      if(x==0){
        return 1;
      } else if(x==1){
        return 0;
      } else{




        return 0;
      };
  }

  template<int W, int I>
  ap_fixed<W,I> generic_atanpi(ap_fixed<W,I> x) {
      ap_fixed<W-I+3,3> atan_x = generic_atan(x);





      static const int F = W - I;





      static const int wf = F < 1? 0: F - 1;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;
      ap_fixed<W,I> r = atan_x/pi;






      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_atanpi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_atanpi(xi);
  }
  template<int I>
  ap_int<I> generic_atanpi(ap_int<I> x) {

      (void)(x);
      return 0;
  }
  template<int I>
  ap_uint<I> generic_atanpi(ap_uint<I> x) {

      (void)(x);
      return 0;
  }

  template<int W, int I>
  ap_fixed<W,I> generic_atan2pi(ap_fixed<W,I> y, ap_fixed<W, I> x) {
      ap_fixed<W-I+3,3> atan2_x = generic_atan2(y, x);
      static const int F = W - I;





      static const int wf = F;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;
      ap_fixed<W,I> r = atan2_x/pi;
      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_atan2pi(ap_ufixed<W,I> y, ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      ap_fixed<W+1,I+1> yi = y;
      return generic_atan2pi(yi, xi);
  }
  template<int I>
  ap_int<I> generic_atan2pi(ap_int<I> y, ap_int<I> x) {

      bool x_sig = x[I-1];
      bool y_sig = y[I-1];
      if(y==0 && x==0) return 0;


      else if(y_sig && x==0) return -1;

      else if(!y_sig && x==0) return 1;

      else if(!y_sig && x_sig) return 1;

      else if(y_sig && x_sig) return -1;
      else return 0;
  }
  template<int I>
  ap_uint<I> generic_atan2pi(ap_uint<I> y, ap_uint<I> x) {


      if(y!=0 && x==0) return 1;
      else return 0;
  }

}
# 1067 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_exp_apfixed.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_exp_apfixed.h"
namespace exp_reduce {

template<int W_, int I_>
ap_fixed<W_,I_> exp(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline

 int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;




    int I_s_;
    int M_ = (I_-1>F_) ? (I_-1) : F_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<W_,I_> r;
    if (I_s_==1) {
        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;
        if (x_l[2]!=x_l[1]) {
            if (!x_l[2]) y = "0x1.8p0";
        } else {
            if (!x_l[2]) y[1] = 1;
            if (x_l[2]|x_l[0]) y[0] = 1;
        }
        if (I_<2) {
            if (y[1]) {
                y[1] = 0;
                y[0] = 1;
            }
        }
        r = y;
    } else if (I_s_==2) {
        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if ((x_l[4]!=x_l[3])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<2,0>("0x0.8p0")))) {
            if (!x_l[4]) y = "0x3.cp0";
        } else {
            if (!x_l[4]&((x_l[1]&x_l[0])|x_l[2])) y[3] = 1;
            if (!x_l[4]&((!x_l[2]&!x_l[0])|(!x_l[1]&x_l[0]))) y[2] = 1;
            if ((!x_l[4]&x_l[1]&!x_l[0])|(!x_l[4]&x_l[2])|(x_l[2]&x_l[0])|(x_l[2]&x_l[1])) y[1] = 1;
            if ((!x_l[2]&!x_l[1]&x_l[0])|(!x_l[2]&x_l[1]&!x_l[0])|(x_l[2]&!x_l[1]&!x_l[0])|(x_l[2]&x_l[1]&x_l[0])|(x_l[4]&!x_l[3])) y[0] = 1;
        }
        if (I_<3) {
            bool overf = 0;
            VITIS_LOOP_94_1: for (int j = 3; j >= I_+1; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_100_2: for (int j = 3; j >= I_+1; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_104_3: for (int j = I_; j >= 0; j--){
#pragma HLS unroll
 y[j] = 1;
               }
            }
        }
        r = y;
    } else if (I_s_==3) {
        ap_fixed<11,6> x_l = x;
        ap_ufixed<10,5> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(7,5);
        ap_ufixed<5,0> x_l_fract;
        x_l_fract(4,0) = x_l(4,0);

        if ((x_l[10]!=x_l[9])||(x_l[10]!=x_l[8])||(x_l[10]!=x_l[7])||((x_l_int==3)&&(x_l_fract>ap_fixed<5,0>("0x0.7p0")))) {
            if (!x_l[10]) y = "0x1f.f8p0";
        } else {





            ap_uint<4> x_msb_ind;
            x_msb_ind[3] = x_l[10];
            x_msb_ind(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);
            ap_ufixed<4,-1> x_lsb = x_l;
# 153 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_exp_apfixed.h"
            const static ap_ufixed<12,0> exp_x_lsb_m_1_table[16] = {
                "0x0.0p0", "0x0.082p0", "0x0.108p0", "0x0.193p0", "0x0.221p0", "0x0.2b5p0", "0x0.34dp0", "0x0.3eap0",
                "0x0.48bp0", "0x0.532p0", "0x0.5dfp0", "0x0.69p0", "0x0.748p0", "0x0.805p0", "0x0.8c8p0", "0x0.991p0",
            };
            ap_ufixed<12, 0> exp_x_lsb_m_1 = exp_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<12,5> exp_x_msb_table[16] = {
                "0x1.0p0", "0x1.a6p0", "0x2.b8p0", "0x4.7cp0", "0x7.64p0", "0xc.2ep0", "0x14.16p0", "0x21.1ep0",
                "0x0.04p0", "0x0.08p0", "0x0.0cp0", "0x0.16p0", "0x0.22p0", "0x0.3ap0", "0x0.5ep0", "0x0.9cp0",
            };
            ap_ufixed<12,5> exp_x_msb = exp_x_msb_table[x_msb_ind];
            ap_ufixed<24,5> y_lo = exp_x_msb * exp_x_lsb_m_1;
            ap_ufixed<12,5> y_lo_s = y_lo;
            ap_ufixed<12,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;
        }
        if (I_<6) {
            bool overf = 0;
            VITIS_LOOP_171_4: for (int j = 9; j >= I_+4; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_177_5: for (int j = 9; j >= I_+4; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_181_6: for (int j = I_+3; j >= 0; j--){
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    } else if (I_s_==4) {
        ap_fixed<23,12> x_l = x;
        ap_ufixed<22,11> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(14,11);
        ap_ufixed<11,0> x_l_fract;
        x_l_fract(10,0) = x_l(10,0);
        bool overf = 0;
        VITIS_LOOP_196_7: for (int j = 14; j < 22; j++){
#pragma HLS unroll
 if (x_l[22]!=x_l[j])
                overf = 1;
        }

        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<11,0>("0x0.ap0")))) {
            if (!x_l[22]) {
                VITIS_LOOP_204_8: for (int j = 0; j < 22; j++){
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[22];
            x_msb_ind_1(3,0) = x_l(13,10);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(9,5);
            ap_ufixed<5,-1> x_msb_2 = x_l;
            ap_uint<5> x_lsb_ind;
            x_lsb_ind(4,0) = x_l(4,0);


            const static ap_ufixed<11,-13> f_x_lsb_table[32] = {
                "0x0.0p0", "0x0.000002p0", "0x0.000008p0", "0x0.000012p0",
                "0x0.00002p0", "0x0.000032p0", "0x0.000048p0", "0x0.000062p0",
                "0x0.00008p0", "0x0.0000a2p0", "0x0.0000c9p0", "0x0.0000f3p0",
                "0x0.000121p0", "0x0.000153p0", "0x0.000189p0", "0x0.0001c3p0",
                "0x0.000202p0", "0x0.000244p0", "0x0.00028ap0", "0x0.0002d4p0",
                "0x0.000323p0", "0x0.000375p0", "0x0.0003ccp0", "0x0.000426p0",
                "0x0.000485p0", "0x0.0004e7p0", "0x0.00054ep0", "0x0.0005b9p0",
                "0x0.000627p0", "0x0.00069ap0", "0x0.000711p0", "0x0.00078cp0",
            };
            ap_ufixed<11,-13> f_x_lsb = f_x_lsb_table[x_lsb_ind];
            ap_ufixed<18, -6> exp_x_lsb_m_1 = 0;
            exp_x_lsb_m_1(17,13) = x_lsb_ind(4,0);
            exp_x_lsb_m_1(10,0) = f_x_lsb(10,0);

            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<43,-6> f_x_msb_2_lsb = exp_x_msb_2_m_1 * exp_x_lsb_m_1;
            ap_ufixed<19,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp_x_lsb_m_1 + exp_x_msb_2_m_1;

            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_lsb_m_1;
            ap_ufixed<25,11> y_lo_s = y_lo;
            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<12) {
            bool overf = 0;
            VITIS_LOOP_269_9: for (int j = 21; j >= I_+10; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_275_10: for (int j = 21; j >= I_+10; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_279_11: for (int j = I_+9; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    } else if (I_s_==5) {
        ap_fixed<47,24> x_l = x;
        ap_ufixed<46,23> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(27,23);
        ap_ufixed<23,0> x_l_fract;
        x_l_fract(22,0) = x_l(22,0);
        bool overf = 0;
        VITIS_LOOP_294_12: for (int j = 27; j < 46; j++){
#pragma HLS unroll
 if (x_l[46]!=x_l[j])
                overf = 1;
        }

        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<23,0>("0x0.f14028p0")))) {
            if (!x_l[46]) {
                VITIS_LOOP_302_13: for (int j = 0; j < 46; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[46];
            x_msb_ind_1(6,0) = x_l(26,20);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(19,12);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(11,7);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<4,-19> x_lsb = x_l;

            const static ap_ufixed< 6,-33> f_x_msb_4_h_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
            const static ap_ufixed< 7,-51> f_x_msb_4_l_table[8] = {
"0x0.000000000000000p0", "0x0.000000000000000p0", "0x0.00000000000000cp0", "0x0.000000000000024p0",
"0x0.000000000000054p0", "0x0.0000000000000a8p0", "0x0.000000000000120p0", "0x0.0000000000001c8p0",
            };
            ap_ufixed< 6,-33> f_x_msb_4_h = f_x_msb_4_h_table[x_msb_ind_4];
            ap_ufixed< 7,-51> f_x_msb_4_l = f_x_msb_4_l_table[x_msb_ind_4];

            const static ap_ufixed< 8,-39> f_x_lsb_table[16] = {
"0x0.000000000000p0", "0x0.000000000002p0", "0x0.000000000008p0", "0x0.000000000012p0",
"0x0.000000000020p0", "0x0.000000000032p0", "0x0.000000000048p0", "0x0.000000000062p0",
"0x0.000000000080p0", "0x0.0000000000a2p0", "0x0.0000000000c8p0", "0x0.0000000000f2p0",
"0x0.000000000120p0", "0x0.000000000152p0", "0x0.000000000188p0", "0x0.0000000001c2p0",
            };
            ap_ufixed< 8,-39> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed< 7,-35> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<10,-32> exp_x_msb_4_lsb_m_1_m = 0;
            exp_x_msb_4_lsb_m_1_m(8,3) = f_x_msb_4_h(5,0);
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_lsb(7,5);
            exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m + f_x_msb_4_lsb;

            ap_ufixed<42,-16> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(41,35) = x_l(6,0);
            exp_x_msb_4_lsb_m_1(25,16) = exp_x_msb_4_lsb_m_1_m(9,0);
            exp_x_msb_4_lsb_m_1(15,11) = f_x_lsb(4,0);
            exp_x_msb_4_lsb_m_1( 6, 0) = f_x_msb_4_l(6,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };

            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);

            ap_ufixed<86,-27> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_lsb_m_1;
            ap_ufixed<31,-27> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<24) {
            bool overf = 0;
            VITIS_LOOP_531_14: for (int j = 45; j >= I_+22; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_537_15: for (int j = 45; j >= I_+22; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_541_16: for (int j = I_+21; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    } else {

        ap_fixed<65,33> x_l = 0;
        VITIS_LOOP_551_17: for (int j = 32-F_; j < 32+I_; j++){
#pragma HLS unroll
 x_l[j] = x[j-(32-F_)];
        }
        VITIS_LOOP_555_18: for (int j = 32+I_; j <= 64; j++){
#pragma HLS unroll
 x_l[j] = x[W_-1];
        }
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);
        bool overf = 0;
        VITIS_LOOP_565_19: for (int j = 37; j < 64; j++) {
#pragma HLS unroll
 if (x_l[64]!=x_l[j])
                overf = 1;
        }

        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<32,0>("0x0.2e42fefap0")))) {
            if (!x_l[64]) {
                VITIS_LOOP_573_20: for (int j = 0; j < 64; j++){
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[64];
            x_msb_ind_1(6,0) = x_l(36,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<6,-26> x_lsb = x_l;

            const static ap_ufixed<31,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
            ap_ufixed<31,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<12,-53> f_x_lsb_table[64] = {
"0x0.00000000000000000p0", "0x0.00000000000000008p0", "0x0.00000000000000020p0", "0x0.00000000000000048p0",
"0x0.00000000000000080p0", "0x0.000000000000000c8p0", "0x0.00000000000000120p0", "0x0.00000000000000188p0",
"0x0.00000000000000200p0", "0x0.00000000000000288p0", "0x0.00000000000000320p0", "0x0.000000000000003c8p0",
"0x0.00000000000000480p0", "0x0.00000000000000548p0", "0x0.00000000000000620p0", "0x0.00000000000000708p0",
"0x0.00000000000000800p0", "0x0.00000000000000908p0", "0x0.00000000000000a20p0", "0x0.00000000000000b48p0",
"0x0.00000000000000c80p0", "0x0.00000000000000dc8p0", "0x0.00000000000000f20p0", "0x0.00000000000001088p0",
"0x0.00000000000001200p0", "0x0.00000000000001388p0", "0x0.00000000000001520p0", "0x0.000000000000016c8p0",
"0x0.00000000000001880p0", "0x0.00000000000001a48p0", "0x0.00000000000001c20p0", "0x0.00000000000001e08p0",
"0x0.00000000000002000p0", "0x0.00000000000002208p0", "0x0.00000000000002420p0", "0x0.00000000000002648p0",
"0x0.00000000000002880p0", "0x0.00000000000002ac8p0", "0x0.00000000000002d20p0", "0x0.00000000000002f88p0",
"0x0.00000000000003200p0", "0x0.00000000000003488p0", "0x0.00000000000003720p0", "0x0.000000000000039c8p0",
"0x0.00000000000003c80p0", "0x0.00000000000003f48p0", "0x0.00000000000004220p0", "0x0.00000000000004508p0",
"0x0.00000000000004800p0", "0x0.00000000000004b08p0", "0x0.00000000000004e20p0", "0x0.00000000000005148p0",
"0x0.00000000000005480p0", "0x0.000000000000057c8p0", "0x0.00000000000005b20p0", "0x0.00000000000005e88p0",
"0x0.00000000000006200p0", "0x0.00000000000006588p0", "0x0.00000000000006920p0", "0x0.00000000000006cc8p0",
"0x0.00000000000007080p0", "0x0.00000000000007448p0", "0x0.00000000000007820p0", "0x0.00000000000007c08p0",
            };
            ap_ufixed<12,-53> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed<14,-44> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<15,-43> exp_x_msb_4_lsb_m_1_m1 = 0;
            exp_x_msb_4_lsb_m_1_m1(4,0) = f_x_lsb(11,7);
            exp_x_msb_4_lsb_m_1_m1 = exp_x_msb_4_lsb_m_1_m1 + f_x_msb_4_lsb;

            ap_ufixed<22,-43> exp_x_msb_4_lsb_m_1_m2 = exp_x_msb_4_lsb_m_1_m1;
            exp_x_msb_4_lsb_m_1_m2(6,0) = f_x_lsb(6,0);

            ap_ufixed<29,-36> exp_x_msb_4_lsb_m_1_m3 = 0;
            exp_x_msb_4_lsb_m_1_m3(27,0) = f_x_msb_4(30,3);
            exp_x_msb_4_lsb_m_1_m3 = exp_x_msb_4_lsb_m_1_m3 + exp_x_msb_4_lsb_m_1_m2;

            ap_ufixed<32,-36> exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m3;
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_msb_4(2,0);

            ap_ufixed<50,-18> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(49,36) = x_l(13,0);
            exp_x_msb_4_lsb_m_1(31, 0) = exp_x_msb_4_lsb_m_1_m(31,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;
            ap_ufixed<100,-28> f_x_msb_3_4_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_lsb_m_1;
            ap_ufixed<44,-28> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<33) {
            bool overf = 0;
            VITIS_LOOP_934_21: for (int j = 63; j >= I_+31; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_940_22: for (int j = 63; j >= I_+31; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_944_23: for (int j = I_+30; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    }
    return r;
}


template<int WO_, int I_, int WI_>
ap_fixed<WO_,I_> exp_core(ap_fixed<WI_,I_> x)
{
#pragma HLS pipeline

 const static int FO_ = WO_ - I_;
    const static int FI_ = WI_ - I_;


    if (I_>33) return 0;
    else if (FO_>32) return 0;
    else if (FI_>100) return 0;




    int I_s_;
    int M_ = (I_-1>FO_) ? (I_-1) : FO_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<WO_,I_> r = 0;

    ap_ufixed<1,-FO_> delta = 0;
    delta[0] = 1;

    if (I_s_==1) {






        const static int w = 7;
        const static int we = 2;
        const static int wf = 5;

        ap_fixed<w,we> x_l = x;
        ap_ufixed<3,2> y = 0;
        ap_ufixed<5,0> x_l_fract=0;
        x_l_fract(4,0) = x_l(4,0);


        if (x_l[6]!=x_l[5]) {
            if (!x_l[6]) y = "0x1.8p0";
        } else {
            if (!x_l[6]) y[1] = 1;

            if (!x_l[6]&(x_l[4]|(x_l[2]&x_l[3]))) y[0]=1;
            if (!x_l[6]&x_l[2]&x_l[3]) y[0]=1;
            if (x_l[6]&((x_l[4]&x_l[3])|x_l[5])) y[0] = 1;
            if (x_l[6]&x_l[5]&!x_l[4]&x_l[3]&!x_l[2]&x_l[1]) y[0] = 1;
        }
        y += delta;

            if (y[1]|y[2]) {
                y[2] = 0;
                y[1] = 0;
                y[0] = 1;
            }

        r = y;

    } else if (I_s_==2) {
        const static int w = 10;
        const static int we = 3;
        const static int wf = 7;


        ap_fixed<w,we> x_l = x;
        ap_ufixed<5,3> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(wf+1,wf);
        ap_ufixed<7,0> x_l_fract;
        x_l_fract(6,0) = x_l(6,0);

        ap_uint<5> x_msb_ind;
        x_msb_ind[3] = x_l[w-1];
        x_msb_ind(2,0) = x_l(wf,wf-3);
        ap_ufixed<4,-3> x_lsb = x_l;


        if ((x_l[w-1]!=x_l[w-2])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.54p0")))) {
            if (!x_l[w-1]) y = "0x3.cp0";
        } else {
            ap_ufixed<5,2> exp_x_msb_table[32] = {
               "0x1.00p0", "0x1.48p0", "0x1.A6p0", "0x2.1Dp0", "0x2.B7p0", "0x3.7Dp0", "0x4.7Bp0", "0x5.C1p0",
               "0x0.22p0", "0x0.2Cp0", "0x0.39p0", "0x0.49p0", "0x0.5Ep0", "0x0.78p0", "0x0.9Bp0", "0x0.C7p0",
            };
            ap_ufixed<5,2> exp_x_msb = exp_x_msb_table[x_msb_ind];


            ap_ufixed<5,0> y_lo = x_lsb * exp_x_msb;

            ap_ufixed<5,2> y_l = y_lo + exp_x_msb;

            y = y_l;
        }
        y += delta;
            bool overf = 0;
            VITIS_LOOP_1060_1: for (int j = 4; j >= I_+1; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1066_2: for (int j = 4; j >= I_+1; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1070_3: for (int j = I_; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        r = y;
    } else if (I_s_==3) {

        const static int w = 19;
        const static int we = 6;
        const static int wf = 13;

        ap_fixed<w,we> x_l = x;
        ap_ufixed<11,6> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(wf+2,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);




        if ((x_l[w-1]!=x_l[w-2])||(x_l[w-1]!=x_l[w-3])||(x_l[w-1]!=x_l[w-4])||((x_l_int==3)&&(x_l_fract>ap_ufixed<wf,0>("0x0.76FAp0")))) {
            if (!x_l[18]) y = "0x1f.f8p0";
        } else {
            const static int g = 2;
            const static int Maxprecision = FO_+we+g;
            ap_uint<4> x_msb_ind_1;
            x_msb_ind_1[3] = x_l[w-1];

            x_msb_ind_1(2,0) = x_l(wf+1,wf-1);

            ap_uint<6> x_msb_ind_2;
            x_msb_ind_2(5,0) = x_l(wf-2,wf-7);
            ap_ufixed<6,-1> x_msb_2 = x_l;

            ap_ufixed<wf-7,-7> x_lsb = x_l;

            const static ap_ufixed<Maxprecision,0> exp_x_msb_2_m_1_table[64] = {
                "0x0.0p0", "0x0.0202p0", "0x0.0408p0", "0x0.0612p0",
                "0x0.0820p0", "0x0.0A32p0", "0x0.0C49p0", "0x0.0E63p0",
                "0x0.1082p0", "0x0.12A5p0", "0x0.14CDp0", "0x0.16F9p0",
                "0x0.1929p0", "0x0.1B5Dp0", "0x0.1D96p0", "0x0.1FD4p0",
                "0x0.2216p0", "0x0.245Cp0", "0x0.26A7p0", "0x0.28F7p0",
                "0x0.2B4Bp0", "0x0.2DA4p0", "0x0.3001p0", "0x0.3264p0",
                "0x0.34CBp0", "0x0.3737p0", "0x0.39A8p0", "0x0.3C1Ep0",
                "0x0.3E98p0", "0x0.4118p0", "0x0.439Dp0", "0x0.4627p0",
                "0x0.48B5p0", "0x0.4B49p0", "0x0.4DE3p0", "0x0.5081p0",
                "0x0.5325p0", "0x0.55CEp0", "0x0.587Cp0", "0x0.5B2Fp0",
                "0x0.5DE9p0", "0x0.60A7p0", "0x0.636Bp0", "0x0.6635p0",
                "0x0.6904p0", "0x0.6BD9p0", "0x0.6EB3p0", "0x0.7194p0",
                "0x0.747Ap0", "0x0.7766p0", "0x0.7A57p0", "0x0.7D4Fp0",
                "0x0.804Dp0", "0x0.8350p0", "0x0.865Ap0", "0x0.896Ap0",
                "0x0.8C80p0", "0x0.8F9Cp0", "0x0.92BEp0", "0x0.95E7p0",
                "0x0.9916p0", "0x0.9C4Bp0", "0x0.9F87p0", "0x0.A2C9p0",
            };

            ap_ufixed<5,-8> f_x_msb_2_lsb = x_msb_2 * x_lsb;


            ap_ufixed<7,-6> f_x_msb_2_lsb_m_1_m=0;
            f_x_msb_2_lsb_m_1_m(5,0) = x_lsb(5,0);
            f_x_msb_2_lsb_m_1_m = f_x_msb_2_lsb_m_1_m + f_x_msb_2_lsb;


            ap_ufixed<Maxprecision+1,1> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<Maxprecision,1> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_m_1_m + exp_x_msb_2_m_1;


            const static ap_ufixed<Maxprecision,5> exp_x_msb_1_table[16] = {
                "0x1.0000p0", "0x1.A612p0", "0x2.B7E1p0", "0x4.7B4Fp0",
                "0x7.6399p0", "0xC.2EB7p0", "0x14.15E5p0", "0x21.1D8Ep0",
                "0x0.04B0p0", "0x0.07BBp0", "0x0.0CBEp0", "0x0.1503p0",
                "0x0.22A5p0", "0x0.391Fp0", "0x0.5E2Dp0", "0x0.9B45p0",

            };
            ap_ufixed<Maxprecision,5> exp_x_msb = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<2*Maxprecision+1,6> y_lo = exp_x_msb * exp_x_msb_2_lsb_m_1;
            ap_ufixed<Maxprecision,5> y_lo_s = y_lo;
            ap_ufixed<Maxprecision,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;

        }
        y += delta;

            bool overf = 0;
            VITIS_LOOP_1157_4: for (int j = 10; j >= I_+4; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1163_5: for (int j = 10; j >= I_+4; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1167_6: for (int j = I_+3; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    } else if (I_s_==4) {

        const static int wf = 25;
        const static int we = 12;
        const static int w = 37;
        ap_fixed<w,we> x_l = x;
        ap_ufixed<23,12> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(wf+3,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
        VITIS_LOOP_1186_7: for (int j = wf+3; j < w-1; j++) {
#pragma HLS unroll
 if (x_l[w-1]!=x_l[j])
                overf = 1;
        }
        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<wf,0>("0x0.9fe7038p0")))) {
            if (!x_l[w-1]) {
                VITIS_LOOP_1193_8: for (int j = 0; j < 22; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            const static int g = 2;
            const static int Maxprecision = 25;
            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[w-1];
            x_msb_ind_1(3,0) = x_l(wf+2,wf-1);

            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(wf-2,wf-6);
            ap_ufixed<5,-1> x_msb_2 = x_l;

            ap_uint<7> x_msb_ind_3;
            x_msb_ind_3(6,0) = x_l(wf-7,wf-13);
            ap_ufixed<7,-6> x_msb_3 = x_l;

            ap_ufixed<7,-13> x_lsb = x_l;

            const static ap_ufixed<12,-13> f_x_msb_3_m_1_table[128] = {
"0x0.0p0", "0x0.0000002p0", "0x0.0000008p0", "0x0.0000012p0",
"0x0.0000020p0", "0x0.0000032p0", "0x0.0000048p0", "0x0.0000062p0",
"0x0.0000080p0", "0x0.00000A2p0", "0x0.00000C8p0", "0x0.00000F2p0",
"0x0.0000120p0", "0x0.0000152p0", "0x0.0000188p0", "0x0.00001C2p0",
"0x0.0000200p0", "0x0.0000242p0", "0x0.0000288p0", "0x0.00002D2p0",
"0x0.0000320p0", "0x0.0000372p0", "0x0.00003C8p0", "0x0.0000422p0",
"0x0.0000481p0", "0x0.00004E3p0", "0x0.0000549p0", "0x0.00005B3p0",
"0x0.0000621p0", "0x0.0000693p0", "0x0.000070Ap0", "0x0.0000784p0",
"0x0.0000802p0", "0x0.0000884p0", "0x0.000090Bp0", "0x0.0000995p0",
"0x0.0000A23p0", "0x0.0000AB6p0", "0x0.0000B4Cp0", "0x0.0000BE6p0",
"0x0.0000C85p0", "0x0.0000D27p0", "0x0.0000DCEp0", "0x0.0000E78p0",
"0x0.0000F26p0", "0x0.0000FD9p0", "0x0.000108Fp0", "0x0.000114Ap0",
"0x0.0001209p0", "0x0.00012CBp0", "0x0.0001392p0", "0x0.000145Cp0",
"0x0.000152Bp0", "0x0.00015FEp0", "0x0.00016D4p0", "0x0.00017AFp0",
"0x0.000188Ep0", "0x0.0001971p0", "0x0.0001A57p0", "0x0.0001B42p0",
"0x0.0001C31p0", "0x0.0001D24p0", "0x0.0001E1Bp0", "0x0.0001F16p0",
"0x0.0002015p0", "0x0.0002118p0", "0x0.000221Fp0", "0x0.000232Ap0",
"0x0.0002439p0", "0x0.000254Cp0", "0x0.0002663p0", "0x0.000277Fp0",
"0x0.000289Ep0", "0x0.00029C1p0", "0x0.0002AE9p0", "0x0.0002C14p0",
"0x0.0002D43p0", "0x0.0002E77p0", "0x0.0002FAEp0", "0x0.00030EAp0",
"0x0.0003229p0", "0x0.000336Dp0", "0x0.00034B4p0", "0x0.0003600p0",
"0x0.0003750p0", "0x0.00038A4p0", "0x0.00039FBp0", "0x0.0003B57p0",
"0x0.0003CB7p0", "0x0.0003E1Bp0", "0x0.0003F83p0", "0x0.00040EFp0",
"0x0.000425Fp0", "0x0.00043D3p0", "0x0.000454Bp0", "0x0.00046C7p0",
"0x0.0004848p0", "0x0.00049CCp0", "0x0.0004B54p0", "0x0.0004CE1p0",
"0x0.0004E71p0", "0x0.0005006p0", "0x0.000519Ep0", "0x0.000533Bp0",
"0x0.00054DBp0", "0x0.0005680p0", "0x0.0005829p0", "0x0.00059D6p0",
"0x0.0005B86p0", "0x0.0005D3Bp0", "0x0.0005EF4p0", "0x0.00060B1p0",
"0x0.0006272p0", "0x0.0006437p0", "0x0.0006600p0", "0x0.00067CEp0",
"0x0.000699Fp0", "0x0.0006B74p0", "0x0.0006D4Ep0", "0x0.0006F2Bp0",
"0x0.000710Dp0", "0x0.00072F2p0", "0x0.00074DCp0", "0x0.00076CAp0",
"0x0.00078BBp0", "0x0.0007AB1p0", "0x0.0007CABp0", "0x0.0007EA9p0",
            };

            ap_ufixed<6,-19> f_x_msb_3_lsb = x_msb_3 * x_lsb;


            ap_ufixed<12,-13> f_x_msb_3 = f_x_msb_3_m_1_table[x_msb_ind_3];

            ap_ufixed<13,-12> exp_x_msb_3_lsb_m_1_m = 0;
            exp_x_msb_3_lsb_m_1_m(11,0) = f_x_msb_3(11,0);
            exp_x_msb_3_lsb_m_1_m = exp_x_msb_3_lsb_m_1_m + f_x_msb_3_lsb;


            ap_ufixed<19,-6> x_msb_3_lsb = x_l;

            ap_ufixed<20,-5> exp_x_msb_3_lsb_m_1 = 0;
            exp_x_msb_3_lsb_m_1(18,0) = x_msb_3_lsb(18,0);
            exp_x_msb_3_lsb_m_1 = exp_x_msb_3_lsb_m_1+ exp_x_msb_3_lsb_m_1_m;


            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<50,-5> f_x_msb_2_3_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_lsb_m_1;
            ap_ufixed<20,-5> f_x_msb_2_3_lsb_s = f_x_msb_2_3_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_3_lsb_m_1 = f_x_msb_2_3_lsb_s + exp_x_msb_3_lsb_m_1 + exp_x_msb_2_m_1;


            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];


            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_3_lsb_m_1;

            ap_ufixed<25,11> y_lo_s = y_lo;

            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;

            y = y_l;

        }
        y += delta;

            overf = 0;
            VITIS_LOOP_1309_9: for (int j = 22; j >= I_+10; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1315_10: for (int j = 22; j >= I_+10; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1319_11: for (int j = I_+9; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    } else if (I_s_==5) {

        if(WI_>73) return 0;
        const static int we = 24;
        const static int wf = 49;
        const static int w = 73;
        ap_fixed<w,we> x_l = x;
        ap_ufixed<47,24> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(wf+4,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
        VITIS_LOOP_1339_12: for (int j = wf+4; j < w-1; j++){
#pragma HLS unroll
 if (x_l[w-1]!=x_l[j])
                overf = 1;
        }
        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.F1402743D99F8p0")))) {
            if (!x_l[w-1]) {
                VITIS_LOOP_1346_13: for (int j = 0; j < 46; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            const static int g=4;
            const static int Maxprecision = 51;
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];
            x_msb_ind_1(6,0) = x_l(wf+3,wf-3);

            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-4,wf-11);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(wf-12,wf-16);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(wf-17,wf-19);

            ap_uint<6> x_msb_ind_5;
            x_msb_ind_5(5,0) = x_l(wf-20,wf-25);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<6,-19> x_msb_5 = x_l;

            ap_ufixed<7,-25> x_lsb = x_l;

            const static ap_ufixed<12,-39> f_x_msb_5_table[64] = {
"0x0.0000000000000p0", "0x0.0000000000002p0", "0x0.0000000000008p0", "0x0.0000000000012p0",
"0x0.0000000000020p0", "0x0.0000000000032p0", "0x0.0000000000048p0", "0x0.0000000000062p0",
"0x0.0000000000080p0", "0x0.00000000000A2p0", "0x0.00000000000C8p0", "0x0.00000000000F2p0",
"0x0.0000000000120p0", "0x0.0000000000152p0", "0x0.0000000000188p0", "0x0.00000000001C2p0",
"0x0.0000000000200p0", "0x0.0000000000242p0", "0x0.0000000000288p0", "0x0.00000000002D2p0",
"0x0.0000000000320p0", "0x0.0000000000372p0", "0x0.00000000003C8p0", "0x0.0000000000422p0",
"0x0.0000000000480p0", "0x0.00000000004E2p0", "0x0.0000000000548p0", "0x0.00000000005B2p0",
"0x0.0000000000620p0", "0x0.0000000000692p0", "0x0.0000000000708p0", "0x0.0000000000782p0",
"0x0.0000000000800p0", "0x0.0000000000882p0", "0x0.0000000000908p0", "0x0.0000000000992p0",
"0x0.0000000000A20p0", "0x0.0000000000AB2p0", "0x0.0000000000B48p0", "0x0.0000000000BE2p0",
"0x0.0000000000C80p0", "0x0.0000000000D22p0", "0x0.0000000000DC8p0", "0x0.0000000000E72p0",
"0x0.0000000000F20p0", "0x0.0000000000FD2p0", "0x0.0000000001088p0", "0x0.0000000001142p0",
"0x0.0000000001200p0", "0x0.00000000012C2p0", "0x0.0000000001388p0", "0x0.0000000001452p0",
"0x0.0000000001520p0", "0x0.00000000015F2p0", "0x0.00000000016C8p0", "0x0.00000000017A2p0",
"0x0.0000000001880p0", "0x0.0000000001962p0", "0x0.0000000001A48p0", "0x0.0000000001B32p0",
"0x0.0000000001C20p0", "0x0.0000000001D12p0", "0x0.0000000001E08p0", "0x0.0000000001F02p0",

            };
            ap_ufixed<12,-39> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            const static ap_ufixed<7,-33> f_x_msb_4_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
            ap_ufixed<7,-33> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            ap_ufixed<7,-44> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<16,-19> x_msb_5_lsb = x_l;

            ap_ufixed<19,-35> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;
            ap_ufixed<16,-35> f_x_msb_4_5_lsb_s = f_x_msb_4_5_lsb;

            ap_ufixed<13,-38> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(11,0)=f_x_msb_5(11,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m3+f_x_msb_5_lsb;

            ap_ufixed<17,-34> exp_x_msb_4_5_lsb_m_1_m4 = 0;
            exp_x_msb_4_5_lsb_m_1_m4(15,0)=f_x_msb_4_5_lsb_s(15,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + f_x_msb_4_5_lsb_s;

            ap_ufixed<8,-32> exp_x_msb_4_5_lsb_m_1_m5_s = 0;
            exp_x_msb_4_5_lsb_m_1_m5_s(5,0)=exp_x_msb_4_5_lsb_m_1_m4(16,11);
            exp_x_msb_4_5_lsb_m_1_m5_s = f_x_msb_4+exp_x_msb_4_5_lsb_m_1_m5_s;

            ap_ufixed<19,-32> exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5_s;
            exp_x_msb_4_5_lsb_m_1_m5(10,0)=exp_x_msb_4_5_lsb_m_1_m4(10,0);

            ap_ufixed<32,-15> exp_x_msb_4_5_lsb_m_1_m6 = 0;
            ap_ufixed<wf-16,-16> x_msb_4_5_lsb = x_l;
            exp_x_msb_4_5_lsb_m_1_m6(14,0) = exp_x_msb_4_5_lsb_m_1_m5(18,4);
            exp_x_msb_4_5_lsb_m_1_m6 = exp_x_msb_4_5_lsb_m_1_m6 + x_msb_4_5_lsb;
            ap_ufixed<36,-15> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_m6;
            exp_x_msb_4_5_lsb_m_1(3,0) = exp_x_msb_4_5_lsb_m_1_m5(3,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };

            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);


            ap_ufixed<80,-26> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<31,-26> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
            VITIS_LOOP_1608_14: for (int j = 46; j >= I_+22; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1614_15: for (int j = 46; j >= I_+22; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1618_16: for (int j = I_+21; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    } else {
        const static int wf = 67;
        const static int we = 33;
        const static int w = 100;
        ap_fixed<w,we> x_l = x;


        ap_ufixed<65,33> y = 0;

        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(wf+5,wf);


        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);

        bool overf = 0;
        VITIS_LOOP_1642_17: for (int j = wf+5; j < w-1; j++){
#pragma HLS unroll
 if (x_l[w-1]!=x_l[j])
                overf = 1;
        }
        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.2E42FEFA39EF35783p0")))) {
            if (!x_l[w-1]) {
                VITIS_LOOP_1649_18: for (int j = 0; j < 64; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            const static int g=4;
            const static int Maxprecision=69;
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];

            x_msb_ind_1(6,0) = x_l(wf+4,wf-2);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-3,wf-10);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(wf-11,wf-18);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(wf-19,wf-26);

            ap_uint<8> x_msb_ind_5;
            x_msb_ind_5(7,0) = x_l(wf-27,wf-34);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<8,-26> x_msb_5 = x_l;
            ap_ufixed<9,-34> x_lsb = x_l;

            const static ap_ufixed<32,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
            ap_ufixed<32,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<16,-53> f_x_msb_5_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000000008p0", "0x0.000000000000000020p0", "0x0.000000000000000048p0",
"0x0.000000000000000080p0", "0x0.0000000000000000C8p0", "0x0.000000000000000120p0", "0x0.000000000000000188p0",
"0x0.000000000000000200p0", "0x0.000000000000000288p0", "0x0.000000000000000320p0", "0x0.0000000000000003C8p0",
"0x0.000000000000000480p0", "0x0.000000000000000548p0", "0x0.000000000000000620p0", "0x0.000000000000000708p0",
"0x0.000000000000000800p0", "0x0.000000000000000908p0", "0x0.000000000000000A20p0", "0x0.000000000000000B48p0",
"0x0.000000000000000C80p0", "0x0.000000000000000DC8p0", "0x0.000000000000000F20p0", "0x0.000000000000001088p0",
"0x0.000000000000001200p0", "0x0.000000000000001388p0", "0x0.000000000000001520p0", "0x0.0000000000000016C8p0",
"0x0.000000000000001880p0", "0x0.000000000000001A48p0", "0x0.000000000000001C20p0", "0x0.000000000000001E08p0",
"0x0.000000000000002000p0", "0x0.000000000000002208p0", "0x0.000000000000002420p0", "0x0.000000000000002648p0",
"0x0.000000000000002880p0", "0x0.000000000000002AC8p0", "0x0.000000000000002D20p0", "0x0.000000000000002F88p0",
"0x0.000000000000003200p0", "0x0.000000000000003488p0", "0x0.000000000000003720p0", "0x0.0000000000000039C8p0",
"0x0.000000000000003C80p0", "0x0.000000000000003F48p0", "0x0.000000000000004220p0", "0x0.000000000000004508p0",
"0x0.000000000000004800p0", "0x0.000000000000004B08p0", "0x0.000000000000004E20p0", "0x0.000000000000005148p0",
"0x0.000000000000005480p0", "0x0.0000000000000057C8p0", "0x0.000000000000005B20p0", "0x0.000000000000005E88p0",
"0x0.000000000000006200p0", "0x0.000000000000006588p0", "0x0.000000000000006920p0", "0x0.000000000000006CC8p0",
"0x0.000000000000007080p0", "0x0.000000000000007448p0", "0x0.000000000000007820p0", "0x0.000000000000007C08p0",
"0x0.000000000000008000p0", "0x0.000000000000008408p0", "0x0.000000000000008820p0", "0x0.000000000000008C48p0",
"0x0.000000000000009080p0", "0x0.0000000000000094C8p0", "0x0.000000000000009920p0", "0x0.000000000000009D88p0",
"0x0.00000000000000A200p0", "0x0.00000000000000A688p0", "0x0.00000000000000AB20p0", "0x0.00000000000000AFC8p0",
"0x0.00000000000000B480p0", "0x0.00000000000000B948p0", "0x0.00000000000000BE20p0", "0x0.00000000000000C308p0",
"0x0.00000000000000C800p0", "0x0.00000000000000CD08p0", "0x0.00000000000000D220p0", "0x0.00000000000000D748p0",
"0x0.00000000000000DC80p0", "0x0.00000000000000E1C8p0", "0x0.00000000000000E720p0", "0x0.00000000000000EC88p0",
"0x0.00000000000000F200p0", "0x0.00000000000000F788p0", "0x0.00000000000000FD20p0", "0x0.0000000000000102C8p0",
"0x0.000000000000010880p0", "0x0.000000000000010E48p0", "0x0.000000000000011420p0", "0x0.000000000000011A08p0",
"0x0.000000000000012000p0", "0x0.000000000000012608p0", "0x0.000000000000012C20p0", "0x0.000000000000013248p0",
"0x0.000000000000013880p0", "0x0.000000000000013EC8p0", "0x0.000000000000014520p0", "0x0.000000000000014B88p0",
"0x0.000000000000015200p0", "0x0.000000000000015888p0", "0x0.000000000000015F20p0", "0x0.0000000000000165C8p0",
"0x0.000000000000016C80p0", "0x0.000000000000017348p0", "0x0.000000000000017A20p0", "0x0.000000000000018108p0",
"0x0.000000000000018800p0", "0x0.000000000000018F08p0", "0x0.000000000000019620p0", "0x0.000000000000019D48p0",
"0x0.00000000000001A480p0", "0x0.00000000000001ABC8p0", "0x0.00000000000001B320p0", "0x0.00000000000001BA88p0",
"0x0.00000000000001C200p0", "0x0.00000000000001C988p0", "0x0.00000000000001D120p0", "0x0.00000000000001D8C8p0",
"0x0.00000000000001E080p0", "0x0.00000000000001E848p0", "0x0.00000000000001F020p0", "0x0.00000000000001F808p0",
"0x0.000000000000020000p0", "0x0.000000000000020808p0", "0x0.000000000000021020p0", "0x0.000000000000021848p0",
"0x0.000000000000022080p0", "0x0.0000000000000228C8p0", "0x0.000000000000023120p0", "0x0.000000000000023988p0",
"0x0.000000000000024200p0", "0x0.000000000000024A88p0", "0x0.000000000000025320p0", "0x0.000000000000025BC8p0",
"0x0.000000000000026480p0", "0x0.000000000000026D48p0", "0x0.000000000000027620p0", "0x0.000000000000027F08p0",
"0x0.000000000000028800p0", "0x0.000000000000029108p0", "0x0.000000000000029A20p0", "0x0.00000000000002A348p0",
"0x0.00000000000002AC80p0", "0x0.00000000000002B5C8p0", "0x0.00000000000002BF20p0", "0x0.00000000000002C888p0",
"0x0.00000000000002D200p0", "0x0.00000000000002DB88p0", "0x0.00000000000002E520p0", "0x0.00000000000002EEC8p0",
"0x0.00000000000002F880p0", "0x0.000000000000030248p0", "0x0.000000000000030C20p0", "0x0.000000000000031608p0",
"0x0.000000000000032000p0", "0x0.000000000000032A08p0", "0x0.000000000000033420p0", "0x0.000000000000033E48p0",
"0x0.000000000000034880p0", "0x0.0000000000000352C8p0", "0x0.000000000000035D20p0", "0x0.000000000000036788p0",
"0x0.000000000000037200p0", "0x0.000000000000037C88p0", "0x0.000000000000038720p0", "0x0.0000000000000391C8p0",
"0x0.000000000000039C80p0", "0x0.00000000000003A748p0", "0x0.00000000000003B220p0", "0x0.00000000000003BD08p0",
"0x0.00000000000003C800p0", "0x0.00000000000003D308p0", "0x0.00000000000003DE20p0", "0x0.00000000000003E948p0",
"0x0.00000000000003F480p0", "0x0.00000000000003FFC8p0", "0x0.000000000000040B20p0", "0x0.000000000000041688p0",
"0x0.000000000000042200p0", "0x0.000000000000042D88p0", "0x0.000000000000043920p0", "0x0.0000000000000444C8p0",
"0x0.000000000000045080p0", "0x0.000000000000045C48p0", "0x0.000000000000046820p0", "0x0.000000000000047408p0",
"0x0.000000000000048000p0", "0x0.000000000000048C08p0", "0x0.000000000000049820p0", "0x0.00000000000004A448p0",
"0x0.00000000000004B080p0", "0x0.00000000000004BCC8p0", "0x0.00000000000004C920p0", "0x0.00000000000004D588p0",
"0x0.00000000000004E200p0", "0x0.00000000000004EE88p0", "0x0.00000000000004FB20p0", "0x0.0000000000000507C8p0",
"0x0.000000000000051480p0", "0x0.000000000000052148p0", "0x0.000000000000052E20p0", "0x0.000000000000053B08p0",
"0x0.000000000000054800p0", "0x0.000000000000055508p0", "0x0.000000000000056220p0", "0x0.000000000000056F48p0",
"0x0.000000000000057C80p0", "0x0.0000000000000589C8p0", "0x0.000000000000059720p0", "0x0.00000000000005A488p0",
"0x0.00000000000005B200p0", "0x0.00000000000005BF88p0", "0x0.00000000000005CD20p0", "0x0.00000000000005DAC8p0",
"0x0.00000000000005E880p0", "0x0.00000000000005F648p0", "0x0.000000000000060420p0", "0x0.000000000000061208p0",
"0x0.000000000000062000p0", "0x0.000000000000062E08p0", "0x0.000000000000063C20p0", "0x0.000000000000064A48p0",
"0x0.000000000000065880p0", "0x0.0000000000000666C8p0", "0x0.000000000000067520p0", "0x0.000000000000068388p0",
"0x0.000000000000069200p0", "0x0.00000000000006A088p0", "0x0.00000000000006AF20p0", "0x0.00000000000006BDC8p0",
"0x0.00000000000006CC80p0", "0x0.00000000000006DB48p0", "0x0.00000000000006EA20p0", "0x0.00000000000006F908p0",
"0x0.000000000000070800p0", "0x0.000000000000071708p0", "0x0.000000000000072620p0", "0x0.000000000000073548p0",
"0x0.000000000000074480p0", "0x0.0000000000000753C8p0", "0x0.000000000000076320p0", "0x0.000000000000077288p0",
"0x0.000000000000078200p0", "0x0.000000000000079188p0", "0x0.00000000000007A120p0", "0x0.00000000000007B0C8p0",
"0x0.00000000000007C080p0", "0x0.00000000000007D048p0", "0x0.00000000000007E020p0", "0x0.00000000000007F008p0",
            };

            ap_ufixed<16,-53> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            ap_ufixed<9,-60> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<25,-26> x_msb_5_lsb = x_l;

            ap_ufixed<25,-44> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;

            ap_ufixed<6,-37> f_x_msb_4_s = f_x_msb_4;
            ap_ufixed<6,-63> exp_x_msb_4_5_lsb_m_1_m1 = x_msb_5 * f_x_msb_4;

            ap_ufixed<10,-59> exp_x_msb_4_5_lsb_m_1_m2 = 0;
            exp_x_msb_4_5_lsb_m_1_m2(8,0) = f_x_msb_5_lsb(8,0);
            exp_x_msb_4_5_lsb_m_1_m2 = exp_x_msb_4_5_lsb_m_1_m1 + exp_x_msb_4_5_lsb_m_1_m2;

            ap_ufixed<17,-52> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(15,0) = f_x_msb_5(15,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m2+exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<26,-43> exp_x_msb_4_5_lsb_m_1_m4 =0;
            exp_x_msb_4_5_lsb_m_1_m4(24,0) = f_x_msb_4_5_lsb(24,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<33,-36> exp_x_msb_4_5_lsb_m_1_m5 = 0;
            exp_x_msb_4_5_lsb_m_1_m5(31,0) = f_x_msb_4(31,0);
            exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5 + exp_x_msb_4_5_lsb_m_1_m4;

            ap_ufixed<wf-18,-18> x_msb_4_5_lsb = x_l;
            ap_ufixed<wf-17,-17> exp_x_msb_4_5_lsb_m_1_s = 0;
            exp_x_msb_4_5_lsb_m_1_s(30,0) = exp_x_msb_4_5_lsb_m_1_m5(32,2);
            exp_x_msb_4_5_lsb_m_1_s = exp_x_msb_4_5_lsb_m_1_s + x_msb_4_5_lsb;

            ap_ufixed<52,-17> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_s;
            exp_x_msb_4_5_lsb_m_1(1,0) = exp_x_msb_4_5_lsb_m_1_m5(1,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;

            ap_ufixed<101,-27> f_x_msb_3_4_5_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<45,-27> f_x_msb_3_4_5_lsb_s = f_x_msb_3_4_5_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_5_lsb_m_1 = f_x_msb_3_4_5_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_5_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_5_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_5_lsb_s = f_x_msb_2_3_4_5_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_5_lsb_m_1 = f_x_msb_2_3_4_5_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_5_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_5_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
            VITIS_LOOP_2079_19: for (int j = 64; j >= I_+31; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_2085_20: for (int j = 64; j >= I_+31; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2089_21: for (int j = I_+30; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    }
    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> exp(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return exp(xf);
}

template<int I_>
ap_int<I_> exp(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return exp(xf);
}

template<int I_>
ap_uint<I_> exp(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return exp(xf);
}

template<int W, int I>
ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    ap_fixed<W,I> result, tmp;
    ap_ufixed<1,1> one = 1;
    if(I < 1) {
        result = 0;
    } else {
        ap_fixed<W,I> tmp = exp(x);
        ap_ufixed<1,1> one = 1;
        result = tmp - one;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return expm1(xf);
}

template<int I>
ap_int<I> expm1(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return expm1(xf);
}

template<int I>
ap_uint<I> expm1(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return expm1(xf);
}

template<int W, int I>
ap_fixed<W,I> exp2(ap_fixed<W,I> x) {

    int F = W - I;
    if(I > 33 || F > 32) {
        return 0;
    }

    int I_s;
    int M = ((I - 1) > F) ? (I - 1) : F;

    if(M == 1) {
        I_s = 1;
    } else if(M == 2) {
        I_s = 2;
    } else if(M <= 4) {
        I_s = 3;
    } else if(M <= 8) {
        I_s = 4;
    } else if(M <= 16) {
        I_s = 5;
    } else {
        I_s = 6;
    }

    ap_fixed<W,I> r;

    if(I_s == 1) {

        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;

        if(!x_l[2]) {
            y[1] = 1;
        }
        if(x_l[1]) {
            y[0] = 1;
        }

        if(I<2) {
            if(y[1]) {
                y[1]=0;
                y[0]=1;
            }
        }
        r = y;

    } else if(I_s == 2) {

        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if( (x_l[4]&&(!x_l[3])) || ((!x_l[4])&&x_l[3]) ) {
            if(!x_l[4]) {
                y = "0x3.cp0";
            }
        } else {
            if((!x_l[3])&(x_l[2])) y[3] = 1;
            if(((!x_l[3])&(!x_l[2])) | ((!x_l[3])&x_l[2]&x_l[1]&x_l[0])) y[2] = 1;
            if( (x_l[3]&x_l[2]) | ((!x_l[3])&( (x_l[2]&(x_l[1]^x_l[0])) | ((!x_l[2])&x_l[1]&x_l[0] )))) y[1] = 1;
            if((x_l[3]&(!x_l[2])) | (x_l[1]&((x_l[0]&x_l[2]) | ((!x_l[0])&(!x_l[3]))))) y[0] =1;
        }

        if(I<3) {
            bool overf = 0;
            VITIS_LOOP_2219_1: for(int j=3; j>=I+1; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf = 1;
                }
            }
            if (overf) {
                VITIS_LOOP_2226_2: for(int j=3; j>=I+1; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2230_3: for(int j=I; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 3) {

        ap_fixed<9,5> x_l = x;
        ap_ufixed<8,4> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(6,4);
        ap_ufixed<4,0> x_l_fract;
        x_l_fract(3,0) = x_l(3,0);

        if((x_l[8]!=x_l[7])||(x_l[8]!=x_l[6])) {
            if(!x_l[8]) {
                y = "0xf.fp0";
            }
        } else {
            ap_uint<4> x_msb_ind;
            ap_uint<3> x_lsb_ind;
            x_msb_ind[3] = x_l[8];
            x_msb_ind(2,0) = x_l(5,3);
            x_lsb_ind(2,0) = x_l(2,0);
            const static ap_ufixed<10,4> exp2_x_msb_table[16] = {
                "0x1.00p0", "0x1.6Cp0", "0x2.00p0", "0x2.D4p0",
                "0x4.00p0", "0x5.A8p0", "0x8.00p0", "0xB.50p0",
                "0x0.10p0", "0x0.18p0", "0x0.20p0", "0x0.2Cp0",
                "0x0.40p0", "0x0.5Cp0", "0x0.80p0", "0x0.B4p0"
            };
            const static ap_ufixed<10,0> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.0B4p0", "0x0.174p0", "0x0.238p0",
                "0x0.308p0", "0x0.3E0p0", "0x0.4C0p0", "0x0.5ACp0"
            };
            ap_ufixed<11,0> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];
            ap_ufixed<10,4> exp2_x_msb = exp2_x_msb_table[x_msb_ind];
            ap_ufixed<21,4> y_lo = exp2_x_msb * exp2_x_lsb_m_1;
            ap_ufixed<10,4> y_lo_s = y_lo;
            ap_ufixed<10,4> y_l = y_lo_s + exp2_x_msb;
            y = y_l;
        }

        if(I < 5) {
            bool overf = 0;
            VITIS_LOOP_2277_4: for(int j=7; j>=3+I; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf = 1;
                }
            }
            if(overf) {
                VITIS_LOOP_2284_5: for(int j=7; j>=3+I; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2288_6: for(int j=I+2; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 4) {

        ap_fixed<17,9> x_l=x;
        ap_ufixed<16,8> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(11,8);
        ap_ufixed<8,0> x_l_fract;
        x_l_fract(7,0) = x_l(7,0);

        bool overf_1 = 0;
        VITIS_LOOP_2306_7: for(int j=11; j<16; j++) {
#pragma HLS unroll
 if(x_l[16]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[16]) {
                y = "0xff.ffp0";
            }
        } else {

            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1(4,0) = x_l(11,7);
            ap_uint<4> x_msb_ind_2;
            x_msb_ind_2(3,0) = x_l(6,3);
            ap_uint<3> x_lsb_ind;
            x_lsb_ind = x_l(2,0);

            const static ap_ufixed<14,-5> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.00B1Ap0", "0x0.0163Ep0", "0x0.02168p0",
                "0x0.02C9Ap0", "0x0.037D4p0", "0x0.04316p0", "0x0.04E60p0"
            };
            ap_ufixed<14,-5> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<19,0> exp2_x_msb_2_m_1_table[16] = {
                "0x0.0p0,0", "0x0.059B0p0", "0x0.0B558p0", "0x0.11302p0",
                "0x0.172B8p0", "0x0.1D488p0", "0x0.2387Ap0", "0x0.29E9Ep0",
                "0x0.306FEp0", "0x0.371A8p0", "0x0.3DEA6p0", "0x0.44E08p0",
                "0x0.4BFDAp0", "0x0.5342Cp0", "0x0.5AB08p0", "0x0.6247Ep0"
            };
            ap_ufixed<19,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<33,-5> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,0> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<19,0> exp2_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<19,8> exp2_x_msb_1_table[32] = {
                "0x1.000p0", "0x1.6A0p0", "0x2.000p0", "0x2.D42p0",
                "0x4.000p0", "0x5.A82p0", "0x8.000p0", "0xB.504p0",
                "0x10.000p0", "0x16.A0Ap0", "0x20.000p0", "0x2D.414p0",
                "0x40.000p0", "0x5A.828p0", "0x80.000p0", "0xB5.050p0",
                "0x0.010p0", "0x0.016p0", "0x0.020p0", "0x0.02Ep0",
                "0x0.040p0", "0x0.05Ap0", "0x0.080p0", "0x0.0B6p0",
                "0x0.100p0", "0x0.16Ap0", "0x0.200p0", "0x0.2D4p0",
                "0x0.400p0", "0x0.5A8p0", "0x0.800p0", "0x0.B50p0"
            };
            ap_ufixed<19,8> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<38,8> y_lo = exp2_x_msb_1 * exp2_x_msb_2_lsb_m_1;
            ap_ufixed<19,8> y_lo_s = y_lo;
            ap_ufixed<19,8> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I < 9) {
            bool overf_2 = 0;
            VITIS_LOOP_2361_8: for(int j=15; j>=7+I; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
                VITIS_LOOP_2368_9: for(int j=15; j>=7+I; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2372_10: for(int j=6+I; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 5) {

        ap_fixed<33,17> x_l = x;
        ap_ufixed<32,16> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(20,16);
        ap_ufixed<16,0> x_l_fract;
        x_l_fract(15,0) = x_l(15,0);

        bool overf_1 = 0;
        VITIS_LOOP_2390_11: for(int j=20; j<32; j++) {
#pragma HLS unroll
 if(x_l[32]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[32]) {
                y = "0xffff.ffffp0";
            }
        } else {
            ap_uint<6> x_msb_ind_1;
            x_msb_ind_1(5,0) = x_l(20,15);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(14,10);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(9,5);
            ap_uint<5> x_lsb_ind;
            x_lsb_ind = x_l(4,0);

            const static ap_ufixed<25,-11> exp2_x_lsb_m_1_table[32] = {
                "0x0.0p0", "0x0.0000B1725p0", "0x0.000162E52p0", "0x0.000214587p0",
                "0x0.0002C5CC3p0", "0x0.000377408p0", "0x0.000428B53p0", "0x0.0004DA2A7p0",
                "0x0.00058BA02p0", "0x0.00063D165p0", "0x0.0006EE8CFp0", "0x0.0007A0042p0",
                "0x0.0008517BBp0", "0x0.000902F3Dp0", "0x0.0009B46C6p0", "0x0.000A65E57p0",
                "0x0.000B175F0p0", "0x0.000BC8D90p0", "0x0.000C7A538p0", "0x0.000D2BCE8p0",
                "0x0.000DDD4A0p0", "0x0.000E8EC5Fp0", "0x0.000F40425p0", "0x0.000FF1BF4p0",
                "0x0.0010A33CAp0", "0x0.001154BA8p0", "0x0.00120638Dp0", "0x0.0012B7B7Bp0",
                "0x0.001369370p0", "0x0.00141AB6Cp0", "0x0.0014CC371p0", "0x0.00157DB7Dp0"
            };
            ap_ufixed<25,-11> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<30,-6> exp2_x_msb_3_m_1_table[32] = {
                "0x0.0p0", "0x0.00162F390p0", "0x0.002C605E3p0", "0x0.0042936FBp0",
                "0x0.0058C86DAp0", "0x0.006EFF584p0", "0x0.0085382FBp0", "0x0.009B72F42p0",
                "0x0.00B1AFA5Bp0", "0x0.00C7EE449p0", "0x0.00DE2ED0Fp0", "0x0.00F4714AFp0",
                "0x0.010AB5B2Dp0", "0x0.0120FC08Ap0", "0x0.0137444CAp0", "0x0.014D8E7EFp0",
                "0x0.0163DA9FBp0", "0x0.017A28AF2p0", "0x0.019078AD7p0", "0x0.01A6CA9ABp0",
                "0x0.01BD1E771p0", "0x0.01D37442Dp0", "0x0.01E9CBFE1p0", "0x0.020025A8Fp0",
                "0x0.02168143Bp0", "0x0.022CDECE7p0", "0x0.02433E495p0", "0x0.02599FB48p0",
                "0x0.027003104p0", "0x0.0286685CAp0", "0x0.029CCF99Dp0", "0x0.02B338C81p0"
            };
            ap_ufixed<30,-6> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<55,-17> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,-17> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<30,-6> exp2_x_msb_3_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<36,0> exp2_x_msb_2_m_1_table[32] = {
                "0x0.0p0", "0x0.02C9A3E78p0", "0x0.059B0D316p0", "0x0.087451876p0",
                "0x0.0B5586CFAp0", "0x0.0E3EC32D4p0", "0x0.11301D012p0", "0x0.1429AAEA9p0",
                "0x0.172B83C7Dp0", "0x0.1A35BEB70p0", "0x0.1D4873169p0", "0x0.2063B8863p0",
                "0x0.2387A6E75p0", "0x0.26B4565E2p0", "0x0.29E9DF520p0", "0x0.2D285A6E4p0",
                "0x0.306FE0A32p0", "0x0.33C08B264p0", "0x0.371A7373Bp0", "0x0.3A7DB34E6p0",
                "0x0.3DEA64C12p0", "0x0.4160A21F7p0", "0x0.44E086062p0", "0x0.486A2B5C1p0",
                "0x0.4BFDAD536p0", "0x0.4F9B2769Dp0", "0x0.5342B569Dp0", "0x0.56F4736B5p0",
                "0x0.5AB07DD48p0", "0x0.5E76F15ADp0", "0x0.6247EB03Ap0", "0x0.662388255p0"
            };
            ap_ufixed<36,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<66,-6> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_lsb_m_1;
            ap_ufixed<30,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<36,0> exp2_x_msb_2_3_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_lsb_m_1;

            const static ap_ufixed<36,16> exp2_x_msb_1_table[64] = {
                "0x1.00000p0", "0x1.6A09Ep0", "0x2.00000p0", "0x2.D413Dp0",
                "0x4.00000p0", "0x5.A827Ap0", "0x8.00000p0", "0xB.504F3p0",
                "0x10.00000p0", "0x16.A09E6p0", "0x20.00000p0", "0x2D.413CDp0",
                "0x40.00000p0", "0x5A.8279Ap0", "0x80.00000p0", "0xB5.04F33p0",
                "0x100.00000p0", "0x16A.09E66p0", "0x200.00000p0", "0x2D4.13CCDp0",
                "0x400.00000p0", "0x5A8.2799Ap0", "0x800.00000p0", "0xB50.4F334p0",
                "0x1000.00000p0", "0x16A0.9E668p0", "0x2000.00000p0", "0x2D41.3CCD0p0",
                "0x4000.00000p0", "0x5A82.799A0p0", "0x8000.00000p0", "0xB504.F3340p0",
                "0x0.00010p0", "0x0.00017p0", "0x0.00020p0", "0x0.0002Dp0",
                "0x0.00040p0", "0x0.0005Bp0", "0x0.00080p0", "0x0.000B5p0",
                "0x0.00100p0", "0x0.0016Ap0", "0x0.00200p0", "0x0.002D4p0",
                "0x0.00400p0", "0x0.005A8p0", "0x0.00800p0", "0x0.00B50p0",
                "0x0.01000p0", "0x0.016A1p0", "0x0.02000p0", "0x0.02D41p0",
                "0x0.04000p0", "0x0.05A82p0", "0x0.08000p0", "0x0.0B505p0",
                "0x0.10000p0", "0x0.16A0Ap0", "0x0.20000p0", "0x0.2D414p0",
                "0x0.40000p0", "0x0.5A828p0", "0x0.80000p0", "0x0.B504Fp0"
            };
            ap_ufixed<36,16> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<72,16> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_lsb_m_1;
            ap_ufixed<36,16> y_lo_s = y_lo;
            ap_ufixed<36,16> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<17) {
            bool overf_2 = 0;
            VITIS_LOOP_2479_12: for(int j=31; j>=I+15; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
                VITIS_LOOP_2486_13: for(int j=31; j>=I+15; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2490_14: for(int j=I+14; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else {
        ap_fixed<65,33> x_l = 0;
        VITIS_LOOP_2500_15: for(int j=32-F; j<32+I; j++) {
#pragma HLS unroll
 x_l[j] = x[j-(32-F)];
        }
        VITIS_LOOP_2504_16: for(int j=32+I; j<=64; j++) {
#pragma HLS unroll
 x_l[j] = x[W-1];
        }
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);

        bool overf_1 = 0;
        VITIS_LOOP_2515_17: for(int j=37; j<64; j++) {
#pragma HLS unroll
 if(x_l[j]!=x_l[64]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[64]) {
                VITIS_LOOP_2523_18: for(int j=0; j<64; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1(7,0) = x_l(37,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            const static ap_ufixed<42,-26> exp2_x_lsb_m_1_table[64] = {
                "0x0.0p0", "0x0.00000000B17217F81p0", "0x0.0000000162E42FF0Ap0", "0x0.00000002145647E9Ap0",
                "0x0.00000002C5C85FE32p0", "0x0.00000003773A77DD2p0", "0x0.0000000428AC8FD79p0", "0x0.00000004DA1EA7D28p0",
                "0x0.000000058B90BFCDFp0", "0x0.000000063D02D7C9Dp0", "0x0.00000006EE74EFC63p0", "0x0.000000079FE707C31p0",
                "0x0.0000000851591FC07p0", "0x0.0000000902CB37BE4p0", "0x0.00000009B43D4FBC9p0", "0x0.0000000A65AF67BB6p0",
                "0x0.0000000B17217FBAAp0", "0x0.0000000BC89397BA6p0", "0x0.0000000C7A05AFBA9p0", "0x0.0000000D2B77C7BB5p0",
                "0x0.0000000DDCE9DFBC8p0", "0x0.0000000E8E5BF7BE2p0", "0x0.0000000F3FCE0FC05p0", "0x0.0000000FF14027C2Fp0",
                "0x0.00000010A2B23FC61p0", "0x0.00000011542457C9Ap0", "0x0.0000001205966FCDBp0", "0x0.00000012B70887D24p0",
                "0x0.00000013687A9FD75p0", "0x0.0000001419ECB7DCDp0", "0x0.00000014CB5ECFE2Dp0", "0x0.000000157CD0E7E94p0",
                "0x0.000000162E42FFF03p0", "0x0.00000016DFB517F7Ap0", "0x0.0000001791272FFF9p0", "0x0.0000001842994807Fp0",
                "0x0.00000018F40B6010Dp0", "0x0.00000019A57D781A3p0", "0x0.0000001A56EF90240p0", "0x0.0000001B0861A82E6p0",
                "0x0.0000001BB9D3C0392p0", "0x0.0000001C6B45D8447p0", "0x0.0000001D1CB7F0503p0", "0x0.0000001DCE2A085C7p0",
                "0x0.0000001E7F9C20692p0", "0x0.0000001F310E38765p0", "0x0.0000001FE28050840p0", "0x0.0000002093F268923p0",
                "0x0.00000021456480A0Dp0", "0x0.00000021F6D698AFFp0", "0x0.00000022A848B0BF9p0", "0x0.0000002359BAC8CFAp0",
                "0x0.000000240B2CE0E03p0", "0x0.00000024BC9EF8F14p0", "0x0.000000256E111102Cp0", "0x0.000000261F832914Cp0",
                "0x0.00000026D0F541274p0", "0x0.000000278267593A3p0", "0x0.0000002833D9714DBp0", "0x0.00000028E54B89619p0",
                "0x0.0000002996BDA1760p0", "0x0.0000002A482FB98AEp0", "0x0.0000002AF9A1D1A04p0", "0x0.0000002BAB13E9B61p0"
            };
            ap_ufixed<42,-26> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<50,-18> exp2_x_msb_4_m_1_table[256] = {
                "0x0.0p0", "0x0.0000002C5C8601CC7p0", "0x0.00000058B90C0B48Cp0", "0x0.0000008515921C751p0",
                "0x0.000000B1721835515p0", "0x0.000000DDCE9E55DD7p0", "0x0.0000010A2B247E199p0", "0x0.0000013687AAAE059p0",
                "0x0.00000162E430E5A19p0", "0x0.0000018F40B724ED7p0", "0x0.000001BB9D3D6BE95p0", "0x0.000001E7F9C3BA951p0",
                "0x0.00000214564A10F0Dp0", "0x0.00000240B2D06EFC7p0", "0x0.0000026D0F56D4B80p0", "0x0.000002996BDD42239p0",
                "0x0.000002C5C863B73F0p0", "0x0.000002F224EA340A6p0", "0x0.0000031E8170B885Cp0", "0x0.0000034ADDF744B10p0",
                "0x0.000003773A7DD88C3p0", "0x0.000003A3970474175p0", "0x0.000003CFF38B17526p0", "0x0.000003FC5011C23D6p0",
                "0x0.00000428AC9874D86p0", "0x0.00000455091F2F234p0", "0x0.0000048165A5F11E1p0", "0x0.000004ADC22CBAC8Dp0",
                "0x0.000004DA1EB38C238p0", "0x0.000005067B3A652E2p0", "0x0.00000532D7C145E8Bp0", "0x0.0000055F34482E533p0",
                "0x0.0000058B90CF1E6D9p0", "0x0.000005B7ED561637Fp0", "0x0.000005E449DD15B24p0", "0x0.00000610A6641CDC8p0",
                "0x0.0000063D02EB2BB6Bp0", "0x0.000006695F724240Dp0", "0x0.00000695BBF9607AEp0", "0x0.000006C218808664Dp0",
                "0x0.000006EE7507B3FECp0", "0x0.0000071AD18EE948Ap0", "0x0.000007472E1626427p0", "0x0.000007738A9D6AEC2p0",
                "0x0.0000079FE724B745Dp0", "0x0.000007CC43AC0B4F7p0", "0x0.000007F8A0336708Fp0", "0x0.00000824FCBACA727p0",
                "0x0.000008515942358BEp0", "0x0.0000087DB5C9A8553p0", "0x0.000008AA125122CE8p0", "0x0.000008D66ED8A4F7Bp0",
                "0x0.00000902CB602ED0Ep0", "0x0.0000092F27E7C059Fp0", "0x0.0000095B846F59930p0", "0x0.00000987E0F6FA7C0p0",
                "0x0.000009B43D7EA314Ep0", "0x0.000009E09A06535DCp0", "0x0.00000A0CF68E0B568p0", "0x0.00000A395315CAFF3p0",
                "0x0.00000A65AF9D9257Ep0", "0x0.00000A920C2561607p0", "0x0.00000ABE68AD38190p0", "0x0.00000AEAC53516817p0",
                "0x0.00000B1721BCFC99Ep0", "0x0.00000B437E44EA623p0", "0x0.00000B6FDACCDFDA7p0", "0x0.00000B9C3754DD02Bp0",
                "0x0.00000BC893DCE1DADp0", "0x0.00000BF4F064EE62Fp0", "0x0.00000C214CED029AFp0", "0x0.00000C4DA9751E82Ep0",
                "0x0.00000C7A05FD421ADp0", "0x0.00000CA662856D62Ap0", "0x0.00000CD2BF0DA05A6p0", "0x0.00000CFF1B95DB022p0",
                "0x0.00000D2B781E1D59Cp0", "0x0.00000D57D4A667615p0", "0x0.00000D84312EB918Dp0", "0x0.00000DB08DB712805p0",
                "0x0.00000DDCEA3F7397Bp0", "0x0.00000E0946C7DC5F0p0", "0x0.00000E35A3504CD65p0", "0x0.00000E61FFD8C4FD8p0",
                "0x0.00000E8E5C6144D4Ap0", "0x0.00000EBAB8E9CC5BBp0", "0x0.00000EE715725B92Cp0", "0x0.00000F1371FAF279Bp0",
                "0x0.00000F3FCE8391109p0", "0x0.00000F6C2B0C37576p0", "0x0.00000F988794E54E3p0", "0x0.00000FC4E41D9AF4Ep0",
                "0x0.00000FF140A6584B8p0", "0x0.0000101D9D2F1D521p0", "0x0.00001049F9B7EA08Ap0", "0x0.000010765640BE6F1p0",
                "0x0.000010A2B2C99A857p0", "0x0.000010CF0F527E4BCp0", "0x0.000010FB6BDB69C21p0", "0x0.00001127C8645CE84p0",
                "0x0.0000115424ED57BE6p0", "0x0.0000118081765A447p0", "0x0.000011ACDDFF647A7p0", "0x0.000011D93A8876607p0",
                "0x0.0000120597118FF65p0", "0x0.00001231F39AB13C2p0", "0x0.0000125E5023DA31Ep0", "0x0.0000128AACAD0AD7Ap0",
                "0x0.000012B70936432D4p0", "0x0.000012E365BF8332Dp0", "0x0.0000130FC248CAE85p0", "0x0.0000133C1ED21A4DDp0",
                "0x0.000013687B5B71633p0", "0x0.00001394D7E4D0288p0", "0x0.000013C1346E369DDp0", "0x0.000013ED90F7A4C30p0",
                "0x0.00001419ED811A982p0", "0x0.000014464A0A981D4p0", "0x0.00001472A6941D524p0", "0x0.0000149F031DAA373p0",
                "0x0.000014CB5FA73ECC1p0", "0x0.000014F7BC30DB10Fp0", "0x0.0000152418BA7F05Bp0", "0x0.0000155075442AAA6p0",
                "0x0.0000157CD1CDDDFF1p0", "0x0.000015A92E579903Ap0", "0x0.000015D58AE15BB83p0", "0x0.00001601E76B261CAp0",
                "0x0.0000162E43F4F8310p0", "0x0.0000165AA07ED1F56p0", "0x0.00001686FD08B369Ap0", "0x0.000016B359929C8DEp0",
                "0x0.000016DFB61C8D620p0", "0x0.0000170C12A685E62p0", "0x0.000017386F30861A2p0", "0x0.00001764CBBA8DFE1p0",
                "0x0.0000179128449D920p0", "0x0.000017BD84CEB4D5Dp0", "0x0.000017E9E158D3C9Ap0", "0x0.000018163DE2FA6D6p0",
                "0x0.000018429A6D28C10p0", "0x0.0000186EF6F75EC4Ap0", "0x0.0000189B53819C782p0", "0x0.000018C7B00BE1DBAp0",
                "0x0.000018F40C962EEF0p0", "0x0.00001920692083B26p0", "0x0.0000194CC5AAE025Bp0", "0x0.0000197922354448Ep0",
                "0x0.000019A57EBFB01C1p0", "0x0.000019D1DB4A239F3p0", "0x0.000019FE37D49ED23p0", "0x0.00001A2A945F21B53p0",
                "0x0.00001A56F0E9AC482p0", "0x0.00001A834D743E8B0p0", "0x0.00001AAFA9FED87DCp0", "0x0.00001ADC06897A208p0",
                "0x0.00001B08631423733p0", "0x0.00001B34BF9ED475Dp0", "0x0.00001B611C298D286p0", "0x0.00001B8D78B44D8ADp0",
                "0x0.00001BB9D53F159D4p0", "0x0.00001BE631C9E55FAp0", "0x0.00001C128E54BCD1Fp0", "0x0.00001C3EEADF9BF43p0",
                "0x0.00001C6B476A82C66p0", "0x0.00001C97A3F571488p0", "0x0.00001CC40080677A9p0", "0x0.00001CF05D0B655C9p0",
                "0x0.00001D1CB9966AEE8p0", "0x0.00001D49162178306p0", "0x0.00001D7572AC8D223p0", "0x0.00001DA1CF37A9C40p0",
                "0x0.00001DCE2BC2CE15Bp0", "0x0.00001DFA884DFA175p0", "0x0.00001E26E4D92DC8Ep0", "0x0.00001E534164692A6p0",
                "0x0.00001E7F9DEFAC3BEp0", "0x0.00001EABFA7AF6FD4p0", "0x0.00001ED85706496E9p0", "0x0.00001F04B391A38FEp0",
                "0x0.00001F31101D05611p0", "0x0.00001F5D6CA86EE23p0", "0x0.00001F89C933E0135p0", "0x0.00001FB625BF58F45p0",
                "0x0.00001FE2824AD9855p0", "0x0.0000200EDED661C63p0", "0x0.0000203B3B61F1B71p0", "0x0.0000206797ED8957Dp0",
                "0x0.00002093F47928A89p0", "0x0.000020C05104CFA93p0", "0x0.000020ECAD907E59Dp0", "0x0.000021190A1C34BA6p0",
                "0x0.0000214566A7F2CAEp0", "0x0.00002171C333B88B4p0", "0x0.0000219E1FBF85FBAp0", "0x0.000021CA7C4B5B1BFp0",
                "0x0.000021F6D8D737EC3p0", "0x0.0000222335631C6C6p0", "0x0.0000224F91EF089C7p0", "0x0.0000227BEE7AFC7C8p0",
                "0x0.000022A84B06F80C8p0", "0x0.000022D4A792FB4C7p0", "0x0.00002301041F063C5p0", "0x0.0000232D60AB18DC3p0",
                "0x0.00002359BD37332BFp0", "0x0.0000238619C3552BAp0", "0x0.000023B2764F7EDB4p0", "0x0.000023DED2DBB03ADp0",
                "0x0.0000240B2F67E94A5p0", "0x0.000024378BF42A09Dp0", "0x0.00002463E88072793p0", "0x0.00002490450CC2988p0",
                "0x0.000024BCA1991A67Dp0", "0x0.000024E8FE2579E70p0", "0x0.000025155AB1E1163p0", "0x0.00002541B73E4FF54p0",
                "0x0.0000256E13CAC6845p0", "0x0.0000259A705744C34p0", "0x0.000025C6CCE3CAB23p0", "0x0.000025F3297058511p0",
                "0x0.0000261F85FCED9FDp0", "0x0.0000264BE2898A9E9p0", "0x0.000026783F162F4D4p0", "0x0.000026A49BA2DBABEp0",
                "0x0.000026D0F82F8FBA7p0", "0x0.000026FD54BC4B78Fp0", "0x0.00002729B1490EE75p0", "0x0.000027560DD5DA05Bp0",
                "0x0.000027826A62ACD41p0", "0x0.000027AEC6EF87525p0", "0x0.000027DB237C69808p0", "0x0.000028078009535EAp0",
                "0x0.00002833DC9644ECBp0", "0x0.0000286039233E2ABp0", "0x0.0000288C95B03F18Bp0", "0x0.000028B8F23D47B69p0",
                "0x0.000028E54ECA58046p0", "0x0.00002911AB5770023p0", "0x0.0000293E07E48FAFEp0", "0x0.0000296A6471B70D9p0",
                "0x0.00002996C0FEE61B2p0", "0x0.000029C31D8C1CD8Bp0", "0x0.000029EF7A195B463p0", "0x0.00002A1BD6A6A1639p0",
                "0x0.00002A483333EF30Fp0", "0x0.00002A748FC144AE4p0", "0x0.00002AA0EC4EA1DB8p0", "0x0.00002ACD48DC06B8Bp0",
                "0x0.00002AF9A5697345Dp0", "0x0.00002B2601F6E782Ep0", "0x0.00002B525E84636FEp0", "0x0.00002B7EBB11E70CDp0",
                "0x0.00002BAB179F7259Bp0", "0x0.00002BD7742D05568p0", "0x0.00002C03D0BAA0035p0", "0x0.00002C302D4842600p0"
            };
            ap_ufixed<50,-18> exp2_x_msb_4_m_1 = exp2_x_msb_4_m_1_table[x_msb_ind_4];
            ap_ufixed<92,-44> f_x_msb_4_lsb = exp2_x_lsb_m_1 * exp2_x_msb_4_m_1;
            ap_ufixed<24,-44> f_x_msb_4_lsb_s = f_x_msb_4_lsb;
            ap_ufixed<50,-18> exp2_x_msb_4_lsb_m_1 = f_x_msb_4_lsb_s + exp2_x_msb_4_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<58,-10> exp2_x_msb_3_m_1_table[256] = {
                "0x0.0p0", "0x0.00002C5C89D5EC6CAp0", "0x0.000058B91B5BC9AE3p0", "0x0.00008515B4919919Ap0",
                "0x0.0000B17255775C040p0", "0x0.0000DDCEFE0D13C26p0", "0x0.00010A2BAE52C1A9Bp0", "0x0.000136886648670F0p0",
                "0x0.000162E525EE05475p0", "0x0.00018F41ED439DA7Bp0", "0x0.0001BB9EBC4931853p0", "0x0.0001E7FB92FEC234Bp0",
                "0x0.000214587164510B6p0", "0x0.000240B55779DF5E3p0", "0x0.00026D12453F6E823p0", "0x0.0002996F3AB4FFCC6p0",
                "0x0.0002C5CC37DA9491Dp0", "0x0.0002F2293CB02E278p0", "0x0.00031E864935CDE29p0", "0x0.00034AE35D6B7517Ep0",
                "0x0.000377407951251C9p0", "0x0.0003A39D9CE6DF45Bp0", "0x0.0003CFFAC82CA4E84p0", "0x0.0003FC57FB2277595p0",
                "0x0.000428B535C857EDDp0", "0x0.00045512781E47FAFp0", "0x0.0004816FC22448D5Ap0", "0x0.0004ADCD13DA5BD2Fp0",
                "0x0.0004DA2A6D408247Ep0", "0x0.00050687CE56BD89Ap0", "0x0.000532E5371D0EED1p0", "0x0.00055F42A79377C75p0",
                "0x0.00058BA01FB9F96D7p0", "0x0.0005B7FD9F9095347p0", "0x0.0005E45B27174C716p0", "0x0.000610B8B64E20794p0",
                "0x0.00063D164D3512A14p0", "0x0.00066973EBCC243E4p0", "0x0.000695D1921356A57p0", "0x0.0006C22F400AAB2BCp0",
                "0x0.0006EE8CF5B223266p0", "0x0.00071AEAB309BFEA4p0", "0x0.00074748781182CC7p0", "0x0.000773A644C96D221p0",
                "0x0.0007A004193180402p0", "0x0.0007CC61F549BD7BCp0", "0x0.0007F8BFD9122629Ep0", "0x0.0008251DC48ABB9FAp0",
                "0x0.0008517BB7B37F322p0", "0x0.00087DD9B28C72365p0", "0x0.0008AA37B51596015p0", "0x0.0008D695BF4EEBE83p0",
                "0x0.000902F3D13875400p0", "0x0.00092F51EAD2335DCp0", "0x0.00095BB00C1C2796Ap0", "0x0.0009880E3516533FAp0",
                "0x0.0009B46C65C0B7ADCp0", "0x0.0009E0CA9E1B56363p0", "0x0.000A0D28DE26302DFp0", "0x0.000A398725E146EA2p0",
                "0x0.000A65E5754C9BBFBp0", "0x0.000A9243CC683003Ep0", "0x0.000ABEA22B34050BAp0", "0x0.000AEB0091B01C2C1p0",
                "0x0.000B175EFFDC76BA4p0", "0x0.000B43BD75B9160B4p0", "0x0.000B701BF345FB742p0", "0x0.000B9C7A7883284A1p0",
                "0x0.000BC8D905709DE20p0", "0x0.000BF5379A0E5D912p0", "0x0.000C2196365C68AC6p0", "0x0.000C4DF4DA5AC0890p0",
                "0x0.000C7A538609667C0p0", "0x0.000CA6B239685BDA6p0", "0x0.000CD310F477A1F96p0", "0x0.000CFF6FB7373A2DFp0",
                "0x0.000D2BCE81A725CD4p0", "0x0.000D582D53C7662C6p0", "0x0.000D848C2D97FCA05p0", "0x0.000DB0EB0F18EA7E4p0",
                "0x0.000DDD49F84A311B4p0", "0x0.000E09A8E92BD1CC6p0", "0x0.000E3607E1BDCDE6Cp0", "0x0.000E6266E20026BF7p0",
                "0x0.000E8EC5E9F2DDAB9p0", "0x0.000EBB24F995F4003p0", "0x0.000EE78410E96B126p0", "0x0.000F13E32FED44375p0",
                "0x0.000F404256A180C40p0", "0x0.000F6CA18506220D9p0", "0x0.000F9900BB1B29692p0", "0x0.000FC55FF8E0982BDp0",
                "0x0.000FF1BF3E566FAAAp0", "0x0.00101E1E8B7CB13ACp0", "0x0.00104A7DE0535E314p0", "0x0.001076DD3CDA77E34p0",
                "0x0.0010A33CA111FFA5Dp0", "0x0.0010CF9C0CF9F6CE1p0", "0x0.0010FBFB80925EB11p0", "0x0.0011285AFBDB38A40p0",
                "0x0.001154BA7ED485FC0p0", "0x0.0011811A097E480E0p0", "0x0.0011AD799BD8802F5p0", "0x0.0011D9D935E32FB4Fp0",
                "0x0.00120638D79E57F3Fp0", "0x0.001232988109FA419p0", "0x0.00125EF8322617F2Dp0", "0x0.00128B57EAF2B25CDp0",
                "0x0.0012B7B7AB6FCAD4Bp0", "0x0.0012E417739D62AFAp0", "0x0.00131077437B7B42Ap0", "0x0.00133CD71B0A15E2Ep0",
                "0x0.00136936FA4933E58p0", "0x0.00139596E138D69F9p0", "0x0.0013C1F6CFD8FF663p0", "0x0.0013EE56C629AF8E9p0",
                "0x0.00141AB6C42AE86DBp0", "0x0.00144716C9DCAB58Dp0", "0x0.00147376D73EF9A50p0", "0x0.00149FD6EC51D4A76p0",
                "0x0.0014CC3709153DB51p0", "0x0.0014F8972D8936234p0", "0x0.001524F759ADBF46Fp0", "0x0.001551578D82DA755p0",
                "0x0.00157DB7C90889038p0", "0x0.0015AA180C3ECC46Bp0", "0x0.0015D6785725A593Fp0", "0x0.001602D8A9BD16406p0",
                "0x0.00162F3904051FA13p0", "0x0.00165B9965FDC30B7p0", "0x0.001687F9CFA701D45p0", "0x0.0016B45A4100DD50Ep0",
                "0x0.0016E0BABA0B56D66p0", "0x0.00170D1B3AC66FB9Ep0", "0x0.0017397BC33229508p0", "0x0.001765DC534E84EF7p0",
                "0x0.0017923CEB1B83EBCp0", "0x0.0017BE9D8A99279ABp0", "0x0.0017EAFE31C771515p0", "0x0.0018175EE0A66264Cp0",
                "0x0.001843BF9735FC2A3p0", "0x0.0018702055763FF6Cp0", "0x0.00189C811B672F1FAp0", "0x0.0018C8E1E908CAF9Ep0",
                "0x0.0018F542BE5B14DABp0", "0x0.001921A39B5E0E174p0", "0x0.00194E048011B804Ap0", "0x0.00197A656C7613F81p0",
                "0x0.0019A6C6608B2346Ap0", "0x0.0019D3275C50E7458p0", "0x0.0019FF885FC76149Dp0", "0x0.001A2BE96AEE92A8Cp0",
                "0x0.001A584A7DC67CB77p0", "0x0.001A84AB984F20CB1p0", "0x0.001AB10CBA888038Cp0", "0x0.001ADD6DE4729C55Ap0",
                "0x0.001B09CF160D7676Fp0", "0x0.001B36304F590FF1Dp0", "0x0.001B629190556A1B5p0", "0x0.001B8EF2D9028648Cp0",
                "0x0.001BBB54296065CF2p0", "0x0.001BE7B5816F0A03Cp0", "0x0.001C1416E12E743BBp0", "0x0.001C4078489EA5CC2p0",
                "0x0.001C6CD9B7BFA00A4p0", "0x0.001C993B2E91644B3p0", "0x0.001CC59CAD13F3E42p0", "0x0.001CF1FE3347502A4p0",
                "0x0.001D1E5FC12B7A72Bp0", "0x0.001D4AC156C07412Ap0", "0x0.001D7722F4063E5F4p0", "0x0.001DA38498FCDAADBp0",
                "0x0.001DCFE645A44A533p0", "0x0.001DFC47F9FC8EA4Dp0", "0x0.001E28A9B605A8F7Dp0", "0x0.001E550B79BF9AA16p0",
                "0x0.001E816D452A64F6Ap0", "0x0.001EADCF1846094CCp0", "0x0.001EDA30F31288F8Ep0", "0x0.001F0692D58FE5505p0",
                "0x0.001F32F4BFBE1FA82p0", "0x0.001F5F56B19D39559p0", "0x0.001F8BB8AB2D33ADCp0", "0x0.001FB81AAC6E1005Ep0",
                "0x0.001FE47CB55FCFB33p0", "0x0.002010DEC602740ACp0", "0x0.00203D40DE55FE61Ep0", "0x0.002069A2FE5A700DAp0",
                "0x0.00209605260FCA635p0", "0x0.0020C26755760EB80p0", "0x0.0020EEC98C8D3E60Fp0", "0x0.00211B2BCB555AB35p0",
                "0x0.0021478E11CE65045p0", "0x0.002173F05FF85EA93p0", "0x0.0021A052B5D348F70p0", "0x0.0021CCB5135F25430p0",
                "0x0.0021F917789BF4E26p0", "0x0.00222579E589B92A6p0", "0x0.002251DC5A2873702p0", "0x0.00227E3ED6782508Ep0",
                "0x0.0022AAA15A78CF49Cp0", "0x0.0022D703E62A73880p0", "0x0.00230366798D1318Dp0", "0x0.00232FC914A0AF516p0",
                "0x0.00235C2BB7654986Fp0", "0x0.0023888E61DAE30EAp0", "0x0.0023B4F114017D3DBp0", "0x0.0023E153CDD919695p0",
                "0x0.00240DB68F61B8E6Cp0", "0x0.00243A19589B5D0B2p0", "0x0.0024667C2986072BAp0", "0x0.002492DF0221B89D9p0",
                "0x0.0024BF41E26E72B62p0", "0x0.0024EBA4CA6C36CA7p0", "0x0.00251807BA1B062FDp0", "0x0.0025446AB17AE23B5p0",
                "0x0.002570CDB08BCC425p0", "0x0.00259D30B74DC599Fp0", "0x0.0025C993C5C0CF977p0", "0x0.0025F5F6DBE4EB900p0",
                "0x0.00262259F9BA1AD8Dp0", "0x0.00264EBD1F405EC72p0", "0x0.00267B204C77B8B03p0", "0x0.0026A783816029E92p0",
                "0x0.0026D3E6BDF9B3C74p0", "0x0.0027004A0244579FCp0", "0x0.00272CAD4E4016C7Dp0", "0x0.00275910A1ECF294Bp0",
                "0x0.00278573FD4AEC5BAp0", "0x0.0027B1D7605A0571Cp0", "0x0.0027DE3ACB1A3F2C6p0", "0x0.00280A9E3D8B9AE0Cp0",
                "0x0.00283701B7AE19E40p0", "0x0.002863653981BD8B6p0", "0x0.00288FC8C306872C3p0", "0x0.0028BC2C543C781B9p0",
                "0x0.0028E88FED2391AECp0", "0x0.002914F38DBBD53B1p0", "0x0.0029415736054415Ap0", "0x0.00296DBAE5FFDF93Cp0",
                "0x0.00299A1E9DABA90A9p0", "0x0.0029C6825D08A1CF7p0", "0x0.0029F2E62416CB378p0", "0x0.002A1F49F2D626981p0",
                "0x0.002A4BADC946B5464p0", "0x0.002A7811A76878977p0", "0x0.002AA4758D3B71E0Cp0", "0x0.002AD0D97ABFA2778p0",
                "0x0.002AFD3D6FF50BB0Ep0", "0x0.002B29A16CDBAEE23p0", "0x0.002B560571738D609p0", "0x0.002B82697DBCA8816p0",
                "0x0.002BAECD91B70199Cp0", "0x0.002BDB31AD6299FF0p0", "0x0.002C0795D0BF73066p0", "0x0.002C33F9FBCD8E052p0"
            };
            ap_ufixed<58,-10> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<108,-28> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_msb_4_lsb_m_1;
            ap_ufixed<40, -28> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<58, -10> exp2_x_msb_3_4_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_msb_4_lsb_m_1;

            const static ap_ufixed<68,0> exp2_x_msb_2_m_1_table[256] = {
                "0x0.0p0", "0x0.002C605E2E8CEC507p0", "0x0.0058C86DA1C09EA20p0", "0x0.0085382FAEF831DA9p0",
                "0x0.00B1AFA5ABCBED613p0", "0x0.00DE2ED0EE0F4F5FDp0", "0x0.010AB5B2CBD117074p0", "0x0.0137444C9B5B4ED49p0",
                "0x0.0163DA9FB33356D85p0", "0x0.019078AD6A19EEFF7p0", "0x0.01BD1E77170B415E7p0", "0x0.01E9CBFE113EEC7DCp0",
                "0x0.02168143B0280DA82p0", "0x0.02433E494B754B3ADp0", "0x0.027003103B10DEF7Dp0", "0x0.029CCF99D720A0593p0",
                "0x0.02C9A3E778060EE6Fp0", "0x0.02F67FFA765E5C8E5p0", "0x0.032363D42B0277FAAp0", "0x0.03504F75EF0716F0Cp0",
                "0x0.037D42E11BBCC0AB4p0", "0x0.03AA3E170AAFD8396p0", "0x0.03D7411915A8A6DF0p0", "0x0.04044BE896AB66771p0",
                "0x0.04315E86E7F84BD74p0", "0x0.045E78F5640B9135Cp0", "0x0.048B9B35659D8090Ep0", "0x0.04B8C54847A27E186p0",
                "0x0.04E5F72F654B12987p0", "0x0.051330EC1A03F5E6Ap0", "0x0.0540727FC1761950Dp0", "0x0.056DBBEBB786B20D9p0",
                "0x0.059B0D31585743AE8p0", "0x0.05C866520045AA948p0", "0x0.05F5C74F0BEC2665Bp0", "0x0.06233029D82164855p0",
                "0x0.0650A0E3C1F88A8D2p0", "0x0.067E197E26C140C90p0", "0x0.06AB99FA6407BCB43p0", "0x0.06D92259D794CB783p0",
                "0x0.0706B29DDF6DDC6DCp0", "0x0.07344AC7D9D50B9FCp0", "0x0.0761EAD925492C4F5p0", "0x0.078F92D32085D37A9p0",
                "0x0.07BD42B72A8362646p0", "0x0.07EAFA86A277111EFp0", "0x0.0818BA42E7D2F916Ep0", "0x0.084681ED5A461FA1Ap0",
                "0x0.0874518759BC808C3p0", "0x0.08A22912465F18AD3p0", "0x0.08D0088F8093F0774p0", "0x0.08FDF00068FE268ECp0",
                "0x0.092BDF66607DFA5FEp0", "0x0.0959D6C2C830D6B7Fp0", "0x0.0987D61701715C5F5p0", "0x0.09B5DD646DD76CB61p0",
                "0x0.09E3ECAC6F3834522p0", "0x0.0A1203F067A6359F1p0", "0x0.0A402331B97153804p0", "0x0.0A6E4A71C726DBF42p0",
                "0x0.0A9C79B1F39192BA3p0", "0x0.0ACAB0F3A1B9BBF9Fp0", "0x0.0AF8F03834E526EC8p0", "0x0.0B273781109738876p0",
                "0x0.0B5586CF9890F6299p0", "0x0.0B83DE2530D1104A2p0", "0x0.0BB23D833D93ED290p0", "0x0.0BE0A4EB2353B3818p0",
                "0x0.0C0F145E46C8553E6p0", "0x0.0C3D8BDE0CE79A306p0", "0x0.0C6C0B6BDAE52AC5Dp0", "0x0.0C9A930916329AC51p0",
                "0x0.0CC922B7247F7407Bp0", "0x0.0CF7BA776BB94138Ap0", "0x0.0D265A4B520B98932p0", "0x0.0D5502343DE026A4Bp0",
                "0x0.0D83B23395DEB90FBp0", "0x0.0DB26A4AC0ED4950Dp0", "0x0.0DE12A7B263007860p0", "0x0.0E0FF2C62D0965371p0",
                "0x0.0E3EC32D3D1A20207p0", "0x0.0E6D9BB1BE414CFFDp0", "0x0.0E9C7C55189C62628p0", "0x0.0ECB6518B4874375Bp0",
                "0x0.0EFA55FDFA9C4AD89p0", "0x0.0F294F0653B45570Ap0", "0x0.0F58503328E6CD3F5p0", "0x0.0F875985E389B439Ep0",
                "0x0.0FB66AFFED31AF232p0", "0x0.0FE584A2AFB210670p0", "0x0.1014A66F951CE2F7Ep0", "0x0.1043D06807C2F52E1p0",
                "0x0.1073028D7233E3A8Ep0", "0x0.10A23CE13F3E2431Dp0", "0x0.10D17F64D9EF10A19p0", "0x0.1100CA19AD92F1C6Bp0",
                "0x0.11301D0125B50A4ECp0", "0x0.115F781CAE1FA1B08p0", "0x0.118EDB6DB2DC0F18Dp0", "0x0.11BE46F5A032C458Fp0",
                "0x0.11EDBAB5E2AB58D6Fp0", "0x0.121D36AFE70C947FBp0", "0x0.124CBAE51A5C7ABB5p0", "0x0.127C4756E9E055631p0",
                "0x0.12ABDC06C31CBFB93p0", "0x0.12DB78F613D5B162Dp0", "0x0.130B1E264A0E8963Cp0", "0x0.133ACB98D40A191C1p0",
                "0x0.136A814F204AAF478p0", "0x0.139A3F4A9D9222FF2p0", "0x0.13CA058CBAE1DEBC9p0", "0x0.13F9D416E77AEB5F6p0",
                "0x0.1429AAEA92DDFB341p0", "0x0.14598A092CCB74FD3p0", "0x0.1489717425437EFE9p0", "0x0.14B9612CEC860A09Ep0",
                "0x0.14E95934F312DC8DCp0", "0x0.1519598DA9A99DA67p0", "0x0.154962388149E0304p0", "0x0.15797336EB332DDCAp0",
                "0x0.15A98C8A58E512481p0", "0x0.15D9AE343C1F26130p0", "0x0.1609D83606E119FBFp0", "0x0.163A0A912B6AC1FBBp0",
                "0x0.166A45471C3C2063Dp0", "0x0.169A88594C1570FE6p0", "0x0.16CAD3C92DF734306p0", "0x0.16FB279835223A1D7p0",
                "0x0.172B83C7D517ADCDFp0", "0x0.175BE85981992056Cp0", "0x0.178C554EAEA894030p0", "0x0.17BCCAA8D088877FCp0",
                "0x0.17ED48695BBC0109Ep0", "0x0.181DCE91C506999D8p0", "0x0.184E5D23816C88275p0", "0x0.187EF4200632ACB89p0",
                "0x0.18AF9388C8DE9BBBFp0", "0x0.18E03B5F3F36A92D4p0", "0x0.1910EBA4DF41F3D2Ap0", "0x0.1941A45B1F487077Ap0",
                "0x0.1972658375D2F52ABp0", "0x0.19A32F1F59AB447C4p0", "0x0.19D4013041DC18BF8p0", "0x0.1A04DBB7A5B12F4DCp0",
                "0x0.1A35BEB6FCB753CB7p0", "0x0.1A66AA2FBEBC6B6ECp0", "0x0.1A979E2363CF8048Fp0", "0x0.1AC89A936440CC90Dp0",
                "0x0.1AF99F8138A1C5EFEp0", "0x0.1B2AACEE59C528D0Dp0", "0x0.1B5BC2DC40BF03B07p0", "0x0.1B8CE14C66E4C2704p0",
                "0x0.1BBE084045CD39AB2p0", "0x0.1BEF37B95750B20C0p0", "0x0.1C206FB91588F3A67p0", "0x0.1C51B040FAD151512p0",
                "0x0.1C82F95281C6B4026p0", "0x0.1CB44AEF2547A62ECp0", "0x0.1CE5A51860745F298p0", "0x0.1D1707CFAEAECE86Cp0",
                "0x0.1D4873168B9AA7806p0", "0x0.1D79E6EE731D6C5BDp0", "0x0.1DAB6358E15E79D2Fp0", "0x0.1DDCE85752C7127E2p0",
                "0x0.1E0E75EB44026A409p0", "0x0.1E400C1631FDB1B6Ap0", "0x0.1E71AAD999E821A64p0", "0x0.1EA35236F9330670Ep0",
                "0x0.1ED5022FCD91CB882p0", "0x0.1F06BAC594FA06E38p0", "0x0.1F387BF9CDA384793p0", "0x0.1F6A45CDF60851B7Cp0",
                "0x0.1F9C18438CE4C902Bp0", "0x0.1FCDF35C11379D307p0", "0x0.1FFFD7190241E50A9p0", "0x0.2031C37BDF8726CFFp0",
                "0x0.2063B88628CD63B8Fp0", "0x0.2095B6395E1D237DAp0", "0x0.20C7BC96FFC17FDDEp0", "0x0.20F9CBA08E48302B7p0",
                "0x0.212BE3578A8194D65p0", "0x0.215E03BD7580C2FABp0", "0x0.21902CD3D09B8FF15p0", "0x0.21C25E9C1D6A9CE17p0",
                "0x0.21F49917DDC962553p0", "0x0.2226DC4893D63BCFAp0", "0x0.2259282FC1F273650p0", "0x0.228B7CCEEAC24D54Fp0",
                "0x0.22BDDA27912D13A6Ap0", "0x0.22F0403B385D21C70p0", "0x0.2322AF0B63BFF0291p0", "0x0.2355269997061FE83p0",
                "0x0.2387A6E75623866C2p0", "0x0.23BA2FF6254F390FBp0", "0x0.23ECC1C7890398C8Ap0", "0x0.241F5C5D05FE5DD26p0",
                "0x0.2451FFB82140A35A0p0", "0x0.2484ABDA600EF32CEp0", "0x0.24B760C547F15168Fp0", "0x0.24EA1E7A5EB3482F4p0",
                "0x0.251CE4FB2A63F3583p0", "0x0.254FB44931560C2A2p0", "0x0.25828C65FA1FF511Fp0", "0x0.25B56D530B9BC55D9p0",
                "0x0.25E85711ECE754F87p0", "0x0.261B49A42564482A2p0", "0x0.264E450B3CB81B573p0", "0x0.26814948BACC2EC3Ap0",
                "0x0.26B4565E27CDD257Ap0", "0x0.26E76C4D0C2E51669p0", "0x0.271A8B16F0A2FE778p0", "0x0.274DB2BD5E253F101p0",
                "0x0.2780E341DDF29781Ap0", "0x0.27B41CA5F98CB6B7Ep0", "0x0.27E75EEB3AB9820A2p0", "0x0.281AAA132B83210E1p0",
                "0x0.284DFE1F5638096CFp0", "0x0.28815B11456B0ABADp0", "0x0.28B4C0EA83F35A4FAp0", "0x0.28E82FAC9CEC9F225p0",
                "0x0.291BA7591BB6FDA67p0", "0x0.294F27F18BF723AB3p0", "0x0.2982B1777996543D0p0", "0x0.29B643EC70C273890p0",
                "0x0.29E9DF51FDEE12C26p0", "0x0.2A1D83A9ADD07C0A3p0", "0x0.2A5130F50D65BE58Dp0", "0x0.2A84E735A9EEB96A0p0",
                "0x0.2AB8A66D10F129AA3p0", "0x0.2AEC6E9CD037B426Bp0", "0x0.2B203FC675D1F27F9p0", "0x0.2B5419EB90147EDB7p0",
                "0x0.2B87FD0DAD98FFDDFp0", "0x0.2BBBE92E5D3E349F5p0", "0x0.2BEFDE4F2E2800A73p0", "0x0.2C23DC71AFBF77E86p0",
                "0x0.2C57E39771B2EABFBp0", "0x0.2C8BF3C203F5F1F3Fp0", "0x0.2CC00CF2F6C17AB8Dp0", "0x0.2CF42F2BDA93D2B35p0",
                "0x0.2D285A6E4030B4009p0", "0x0.2D5C8EBBB8A1513E7p0", "0x0.2D90CC15D53461967p0", "0x0.2DC5127E277E2CCAFp0",
                "0x0.2DF961F641589745Bp0", "0x0.2E2DBA7FB4E32E298p0", "0x0.2E621C1C148333651p0", "0x0.2E9686CCF2E3A9C88p0",
                "0x0.2ECAFA93E2F5611CAp0", "0x0.2EFF777277EF023C8p0", "0x0.2F33FD6A454D1B313p0", "0x0.2F688C7CDED22B4F1p0",
                "0x0.2F9D24ABD886AF562p0", "0x0.2FD1C5F8C6B92D937p0", "0x0.300670653DFE42058p0", "0x0.303B23F2D330AA821p0"
            };
            ap_ufixed<68,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<126,-10> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_4_lsb_m_1;
            ap_ufixed<58, -10> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<68,0> exp2_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp2_x_msb_1_table[256] = {
                "0x1.000000000p0", "0x1.306FE0A32p0", "0x1.6A09E667Fp0", "0x1.AE89F995Bp0",
                "0x2.000000000p0", "0x2.60DFC1463p0", "0x2.D413CCCFEp0", "0x3.5D13F32B6p0",
                "0x4.000000000p0", "0x4.C1BF828C7p0", "0x5.A827999FDp0", "0x6.BA27E656Bp0",
                "0x8.000000000p0", "0x9.837F0518Ep0", "0xB.504F333FAp0", "0xD.744FCCAD7p0",
                "0x10.000000000p0", "0x13.06FE0A31Bp0", "0x16.A09E667F4p0", "0x1A.E89F995ADp0",
                "0x20.000000000p0", "0x26.0DFC14637p0", "0x2D.413CCCFE7p0", "0x35.D13F32B5Ap0",
                "0x40.000000000p0", "0x4C.1BF828C6Ep0", "0x5A.827999FCFp0", "0x6B.A27E656B5p0",
                "0x80.000000000p0", "0x98.37F0518DCp0", "0xB5.04F333F9Ep0", "0xD7.44FCCAD6Ap0",
                "0x100.000000000p0", "0x130.6FE0A31B7p0", "0x16A.09E667F3Cp0", "0x1AE.89F995AD4p0",
                "0x200.000000000p0", "0x260.DFC14636Ep0", "0x2D4.13CCCFE78p0", "0x35D.13F32B5A7p0",
                "0x400.000000000p0", "0x4C1.BF828C6DCp0", "0x5A8.27999FCEFp0", "0x6BA.27E656B4Fp0",
                "0x800.000000000p0", "0x983.7F0518DB9p0", "0xB50.4F333F9DEp0", "0xD74.4FCCAD69Dp0",
                "0x1000.000000000p0", "0x1306.FE0A31B71p0", "0x16A0.9E667F3BDp0", "0x1AE8.9F995AD3Bp0",
                "0x2000.000000000p0", "0x260D.FC14636E3p0", "0x2D41.3CCCFE77Ap0", "0x35D1.3F32B5A76p0",
                "0x4000.000000000p0", "0x4C1B.F828C6DC5p0", "0x5A82.7999FCEF3p0", "0x6BA2.7E656B4EBp0",
                "0x8000.000000000p0", "0x9837.F0518DB8Bp0", "0xB504.F333F9DE6p0", "0xD744.FCCAD69D7p0",
                "0x10000.000000000p0", "0x1306F.E0A31B715p0", "0x16A09.E667F3BCDp0", "0x1AE89.F995AD3ADp0",
                "0x20000.000000000p0", "0x260DF.C14636E2Ap0", "0x2D413.CCCFE7799p0", "0x35D13.F32B5A75Bp0",
                "0x40000.000000000p0", "0x4C1BF.828C6DC55p0", "0x5A827.999FCEF32p0", "0x6BA27.E656B4EB5p0",
                "0x80000.000000000p0", "0x9837F.0518DB8A9p0", "0xB504F.333F9DE65p0", "0xD744F.CCAD69D6Bp0",
                "0x100000.000000000p0", "0x1306FE.0A31B7153p0", "0x16A09E.667F3BCC9p0", "0x1AE89F.995AD3AD6p0",
                "0x200000.000000000p0", "0x260DFC.14636E2A6p0", "0x2D413C.CCFE77992p0", "0x35D13F.32B5A75ACp0",
                "0x400000.000000000p0", "0x4C1BF8.28C6DC54Bp0", "0x5A8279.99FCEF324p0", "0x6BA27E.656B4EB58p0",
                "0x800000.000000000p0", "0x9837F0.518DB8A97p0", "0xB504F3.33F9DE648p0", "0xD744FC.CAD69D6AFp0",
                "0x1000000.000000000p0", "0x1306FE0.A31B7152Ep0", "0x16A09E6.67F3BCC91p0", "0x1AE89F9.95AD3AD5Fp0",
                "0x2000000.000000000p0", "0x260DFC1.4636E2A5Cp0", "0x2D413CC.CFE779921p0", "0x35D13F3.2B5A75ABDp0",
                "0x4000000.000000000p0", "0x4C1BF82.8C6DC54B8p0", "0x5A82799.9FCEF3242p0", "0x6BA27E6.56B4EB57Ap0",
                "0x8000000.000000000p0", "0x9837F05.18DB8A96Fp0", "0xB504F33.3F9DE6484p0", "0xD744FCC.AD69D6AF4p0",
                "0x10000000.000000000p0", "0x1306FE0A.31B7152DFp0", "0x16A09E66.7F3BCC909p0", "0x1AE89F99.5AD3AD5E8p0",
                "0x20000000.000000000p0", "0x260DFC14.636E2A5BDp0", "0x2D413CCC.FE7799211p0", "0x35D13F32.B5A75ABD1p0",
                "0x40000000.000000000p0", "0x4C1BF828.C6DC54B7Ap0", "0x5A827999.FCEF32423p0", "0x6BA27E65.6B4EB57A2p0",
                "0x80000000.000000000p0", "0x9837F051.8DB8A96F4p0", "0xB504F333.F9DE64846p0", "0xD744FCCA.D69D6AF44p0",
                "0x0.000000010p0", "0x0.000000013p0", "0x0.000000017p0", "0x0.00000001Bp0",
                "0x0.000000020p0", "0x0.000000026p0", "0x0.00000002Dp0", "0x0.000000036p0",
                "0x0.000000040p0", "0x0.00000004Cp0", "0x0.00000005Bp0", "0x0.00000006Cp0",
                "0x0.000000080p0", "0x0.000000098p0", "0x0.0000000B5p0", "0x0.0000000D7p0",
                "0x0.000000100p0", "0x0.000000130p0", "0x0.00000016Ap0", "0x0.0000001AFp0",
                "0x0.000000200p0", "0x0.000000261p0", "0x0.0000002D4p0", "0x0.00000035Dp0",
                "0x0.000000400p0", "0x0.0000004C2p0", "0x0.0000005A8p0", "0x0.0000006BAp0",
                "0x0.000000800p0", "0x0.000000983p0", "0x0.000000B50p0", "0x0.000000D74p0",
                "0x0.000001000p0", "0x0.000001307p0", "0x0.0000016A1p0", "0x0.000001AE9p0",
                "0x0.000002000p0", "0x0.00000260Ep0", "0x0.000002D41p0", "0x0.0000035D1p0",
                "0x0.000004000p0", "0x0.000004C1Cp0", "0x0.000005A82p0", "0x0.000006BA2p0",
                "0x0.000008000p0", "0x0.000009838p0", "0x0.00000B505p0", "0x0.00000D745p0",
                "0x0.000010000p0", "0x0.000013070p0", "0x0.000016A0Ap0", "0x0.00001AE8Ap0",
                "0x0.000020000p0", "0x0.0000260E0p0", "0x0.00002D414p0", "0x0.000035D14p0",
                "0x0.000040000p0", "0x0.00004C1C0p0", "0x0.00005A828p0", "0x0.00006BA28p0",
                "0x0.000080000p0", "0x0.00009837Fp0", "0x0.0000B504Fp0", "0x0.0000D7450p0",
                "0x0.000100000p0", "0x0.0001306FEp0", "0x0.00016A09Ep0", "0x0.0001AE8A0p0",
                "0x0.000200000p0", "0x0.000260DFCp0", "0x0.0002D413Dp0", "0x0.00035D13Fp0",
                "0x0.000400000p0", "0x0.0004C1BF8p0", "0x0.0005A827Ap0", "0x0.0006BA27Ep0",
                "0x0.000800000p0", "0x0.0009837F0p0", "0x0.000B504F3p0", "0x0.000D744FDp0",
                "0x0.001000000p0", "0x0.001306FE1p0", "0x0.0016A09E6p0", "0x0.001AE89FAp0",
                "0x0.002000000p0", "0x0.00260DFC1p0", "0x0.002D413CDp0", "0x0.0035D13F3p0",
                "0x0.004000000p0", "0x0.004C1BF83p0", "0x0.005A8279Ap0", "0x0.006BA27E6p0",
                "0x0.008000000p0", "0x0.009837F05p0", "0x0.00B504F33p0", "0x0.00D744FCDp0",
                "0x0.010000000p0", "0x0.01306FE0Ap0", "0x0.016A09E66p0", "0x0.01AE89F99p0",
                "0x0.020000000p0", "0x0.0260DFC14p0", "0x0.02D413CCDp0", "0x0.035D13F33p0",
                "0x0.040000000p0", "0x0.04C1BF829p0", "0x0.05A82799Ap0", "0x0.06BA27E65p0",
                "0x0.080000000p0", "0x0.09837F052p0", "0x0.0B504F334p0", "0x0.0D744FCCBp0",
                "0x0.100000000p0", "0x0.1306FE0A3p0", "0x0.16A09E668p0", "0x0.1AE89F996p0",
                "0x0.200000000p0", "0x0.260DFC146p0", "0x0.2D413CCD0p0", "0x0.35D13F32Bp0",
                "0x0.400000000p0", "0x0.4C1BF828Cp0", "0x0.5A82799A0p0", "0x0.6BA27E657p0",
                "0x0.800000000p0", "0x0.9837F0519p0", "0x0.B504F3340p0", "0x0.D744FCCADp0"
            };
            ap_ufixed<68,32> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<136,32> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<33) {
            bool overf_2 = 0;
            VITIS_LOOP_2848_19: for(int j=63; j>=I+31; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
                VITIS_LOOP_2855_20: for(int j=63; j>=I+31; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2859_21: for(int j=I+30; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    }
    return r;
}

template<int W, int I>
ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return exp2(xf);
}

template<int I>
ap_int<I> exp2(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return exp2(xf);
}

template<int I>
ap_uint<I> exp2(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return exp2(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> exp10(ap_fixed<W_,I_> x) {

 int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;

 int I_s_;
    int M_ = (I_-1>F_) ? (I_-1) : F_;
 if (M_==1) I_s_ = 0;
    else if (M_<4) I_s_ = 1;
    else if (M_<7) I_s_ = 2;
    else if (M_<14) I_s_ = 3;
    else if (M_<27) I_s_ = 4;
    else I_s_ = 5;

 ap_fixed<W_,I_> r;
 if(I_s_==0) {
  ap_fixed<3,2> x_l = x;
  ap_ufixed<2,1> y = 0;
  if(x_l[2]) {
   if(x_l[1]&x_l[0]) {
    y = ap_ufixed<2,1>("0x0.8p0");
   }
  } else {
   if(x_l[1]|x_l[0]) {
    y = ap_ufixed<2,1>("0x1.8p0");
   } else {
    y = ap_ufixed<2,1>("0x1.0p0");
   }
  }
  if(I_<2) {
   bool overf = 0;
   if(y[1]) {
    y[1] = 0;
    y[0] = 1;
   }
  }
  r = y;
 } else if (I_s_==1) {
  ap_fixed<7,4> x_l = x;
  ap_ufixed<6,3> y = 0;
  if((x_l[6]!=x_l[5])||(x_l[5]!=x_l[4])||(x_l[4]!=x_l[3])) {
   if(!x_l[6]) {
    y = ap_ufixed<6,3>("0x7.Ep0");
   }
  } else {
   ap_uint<4> x_ind;
   x_ind[3] = x_l[6];
   x_ind(2,0) = x_l(2,0);
   const static ap_ufixed<6,3> exp_x_ind_table[16] = {
    "0x1.000p0", "0x1.600p0", "0x1.C00p0", "0x2.600p0", "0x3.200p0", "0x4.400p0", "0x5.A00p0", "0x7.800p0",
    "0x0.200p0", "0x0.200p0", "0x0.200p0", "0x0.400p0", "0x0.600p0", "0x0.600p0", "0x0.800p0", "0x0.C00p0"
   };
   y = exp_x_ind_table[x_ind];
  }
  if(I_<4){
   bool overf = 0;
   VITIS_LOOP_2947_1: for(int j = 5; j>=I_+2; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_2954_2: for(int j = 5; j>=I_+2; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_2958_3: for(int j = I_+1; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==2) {
  ap_fixed<13,7> x_l = x;
  ap_ufixed<12,6> y = 0;
  ap_fixed<2,2> x_l_int;
  x_l_int(1,0) = x_l(7,6);
  ap_ufixed<6,0> x_l_fract;
  x_l_fract(5,0) = x_l(5,0);
  bool overf = 0;
  VITIS_LOOP_2973_4: for(int j = 11; j >=7; j--) {
#pragma HLS unroll
 if(x_l[12]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==1)&&(x_l_fract>ap_ufixed<5,0>("0x.D0p0")))) {
   if(!x_l[12]) {
    y = ap_ufixed<12,6>("0x3F.FCp0");
   }
  } else {
   ap_uint<4> x_msb_ind;
   x_msb_ind(3,0) = x_l(7,4);
   ap_uint<4> x_lsb_ind;
   x_lsb_ind(3,0) = x_l(3,0);
   const static ap_ufixed<14,6> exp_x_msb_table[16] = {
    "0x1.00p0", "0x1.C7p0", "0x3.2Ap0", "0x5.A0p0", "0xA.00p0", "0x11.C8p0", "0x1F.9Fp0", "0x38.3Cp0",
    "0x0.03p0", "0x0.05p0", "0x0.08p0", "0x0.0Ep0", "0x0.1Ap0", "0x0.2Ep0", "0x0.51p0", "0x0.90p0"
   };
   const static ap_ufixed<14,0> exp_x_lsb_m_1_table[16] = {
    "0x0.0p0", "0x0.0960p0", "0x0.1318p0", "0x0.1D2Cp0", "0x0.27A0p0", "0x0.3274p0", "0x0.3DB0p0", "0x0.4950p0",
    "0x0.5560p0", "0x0.61E4p0", "0x0.6ED8p0", "0x0.7C4Cp0", "0x0.8A38p0", "0x0.98A8p0", "0x0.A7A4p0", "0x0.B728p0"
   };
   ap_ufixed<14,6> exp_x_msb = exp_x_msb_table[x_msb_ind];
   ap_ufixed<14,0> exp_x_lsb_m_1 = exp_x_lsb_m_1_table[x_lsb_ind];
   ap_ufixed<28,6> y_lo = exp_x_msb * exp_x_lsb_m_1;
   ap_ufixed<14,6> y_lo_s = y_lo;
   ap_ufixed<14,6> y_l = y_lo_s + exp_x_msb;
   y = y_l;
  }
  if(I_<7) {
   bool overf = 0;
   VITIS_LOOP_3005_5: for(int j = 11; j >= I_+5; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3012_6: for(int j = 11; j>= I_+5; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3016_7: for(int j = I_+4; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==3) {
  ap_fixed<27,14> x_l = x;
  ap_ufixed<26,13> y = 0;
  ap_fixed<3,3> x_l_int;
  x_l_int(2,0) = x_l(15,13);
  ap_ufixed<13,0> x_l_fract;
  x_l_fract(12,0) = x_l(12,0);
  bool overf = 0;
  VITIS_LOOP_3031_8: for(int j = 25; j>=15; j--) {
#pragma HLS unroll
 if(x_l[26]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==3)&&(x_l_fract>ap_ufixed<12,0>("0x3.E9D0p0")))) {
   if(!x_l[26]) {
    y = ap_ufixed<26,13>("0x1FFF.FFF8p0");
   }
  } else {
   ap_uint<6> x_msb_ind_1;
   x_msb_ind_1[5] = x_l[26];
   x_msb_ind_1(4,0) = x_l(14,10);
   ap_uint<5> x_msb_ind_2;
   x_msb_ind_2(4,0) = x_l(9,5);
   ap_uint<5> x_lsb_ind;
   x_lsb_ind(4,0) = x_l(4,0);
   const static ap_ufixed<24,-6> exp_lsb_ind_m_1_table[32] = {
    "0x0p0", "0x0.00126C5Cp0", "0x0.0024DA0Cp0", "0x0.0037490Cp0", "0x0.0049B964p0", "0x0.005C2B0Cp0", "0x0.006E9E08p0", "0x0.0081125Cp0",
    "0x0.00938800p0", "0x0.00A5FEF8p0", "0x0.00B87748p0", "0x0.00CAF0E8p0", "0x0.00DD6BE0p0", "0x0.00EFE82Cp0", "0x0.010265C8p0", "0x0.0114E4BCp0",
    "0x0.01276508p0", "0x0.0139E6A4p0", "0x0.014C6998p0", "0x0.015EEDDCp0", "0x0.0171737Cp0", "0x0.0183FA6Cp0", "0x0.019682B4p0", "0x0.01A90C50p0",
    "0x0.01BB9744p0", "0x0.01CE238Cp0", "0x0.01E0B128p0", "0x0.01F3401Cp0", "0x0.0205D064p0", "0x0.02186204p0", "0x0.022AF4F8p0", "0x0.023D8944p0"
   };
   ap_ufixed<24,-6> exp_lsb_ind_m_1 = exp_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<29,-1> exp_msb_ind_2_m_1_table[32] = {
    "0x0p0", "0x0.02501EE8p0", "0x0.04A5975Cp0", "0x0.070075C0p0", "0x0.0960C68Cp0", "0x0.0BC69660p0", "0x0.0E31F1F0p0", "0x0.10A2E60Cp0",
    "0x0.13197FA8p0", "0x0.1595CBD4p0", "0x0.1817D7BCp0", "0x0.1A9FB0ACp0", "0x0.1D2D6410p0", "0x0.1FC0FF74p0", "0x0.225A9080p0", "0x0.24FA24F8p0",
    "0x0.279FCACCp0", "0x0.2A4B8FFCp0", "0x0.2CFD82BCp0", "0x0.2FB5B150p0", "0x0.32742A20p0", "0x0.3538FBC0p0", "0x0.380434D8p0", "0x0.3AD5E43Cp0",
    "0x0.3DAE18DCp0", "0x0.408CE1CCp0", "0x0.43724E48p0", "0x0.465E6DA8p0", "0x0.49514F68p0", "0x0.4C4B0330p0", "0x0.4F4B98C4p0", "0x0.5253200Cp0"
   };
   ap_ufixed<29,-1> exp_msb_ind_2_m1 = exp_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<53,-7> f_x_msb_2_lsb = exp_lsb_ind_m_1 * exp_msb_ind_2_m1;
   ap_ufixed<27,-1> exp_msb_2_lsb_m_1 = f_x_msb_2_lsb + exp_msb_ind_2_m1 + exp_lsb_ind_m_1;
   const static ap_ufixed<28,13> exp_msb_ind_1_table[64] = {
    "0x1.0000p0", "0x1.5562p0", "0x1.C73Ep0", "0x2.5F12p0", "0x3.298Cp0", "0x4.378Cp0", "0x5.9F98p0", "0x7.7FBAp0",
    "0xA.0000p0", "0xD.55D0p0", "0x11.C866p0", "0x17.B6B8p0", "0x1F.9F6Ep0", "0x2A.2B6Ep0", "0x38.3BF0p0", "0x4A.FD4Ap0",
    "0x64.0000p0", "0x85.5A26p0", "0xB1.D3F4p0", "0xED.232Ap0", "0x13C.3A4Ep0", "0x1A5.B24Ep0", "0x232.5762p0", "0x2ED.E4EAp0",
    "0x3E8.0000p0", "0x535.857Cp0", "0x6F2.4788p0", "0x943.5FACp0", "0xC5A.4714p0", "0x1078.F70Cp0", "0x15F7.69CAp0", "0x1D4A.F12Ep0",
    "0x0.0006p0", "0x0.0008p0", "0x0.000Cp0", "0x0.0010p0", "0x0.0014p0", "0x0.001Cp0", "0x0.0024p0", "0x0.0032p0",
    "0x0.0042p0", "0x0.0058p0", "0x0.0074p0", "0x0.009Cp0", "0x0.00D0p0", "0x0.0114p0", "0x0.0170p0", "0x0.01ECp0",
    "0x0.0290p0", "0x0.036Ap0", "0x0.048Ep0", "0x0.0612p0", "0x0.0818p0", "0x0.0ACCp0", "0x0.0E66p0", "0x0.1332p0",
    "0x0.199Ap0", "0x0.2224p0", "0x0.2D86p0", "0x0.3CB6p0", "0x0.50F4p0", "0x0.6BF4p0", "0x0.8FF6p0", "0x0.BFFAp0"
   };
   ap_ufixed<28,13> exp_msb_ind_1 = exp_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<28,13> f_x_msb_1_msb_2_lsb_l = exp_msb_ind_1 * exp_msb_2_lsb_m_1;
   y = f_x_msb_1_msb_2_lsb_l + exp_msb_ind_1;
  }
  if(I_<14) {
   bool overf = 0;
   VITIS_LOOP_3081_9: for(int j = 25; j>= I_+12; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3088_10: for(int j = 25; j>=I_+12; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3092_11: for(int j = I_+11; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==4) {
  ap_fixed<53,27> x_l = x;
  ap_ufixed<52,26> y = 0;
  ap_fixed<4,4> x_l_int;
  x_l_int(3,0) = x_l(29,26);
  ap_ufixed<26,0> x_l_fract;
  x_l_fract(25,0) = x_l(25,0);
  bool overf = 0;
  VITIS_LOOP_3107_12: for(int j = 51; j >= 29; j--) {
#pragma HLS unroll
 if(x_l[52]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<26,0>("0x0.D3A7D8C")))) {
   if(!x_l[52]) {
    y = ap_ufixed<52,26>("0x3FFFFFF.FFFFFFCp0");
   }
  } else {
   ap_uint<8> x_msb_ind_1;
   x_msb_ind_1[7] = x_l[52];
   x_msb_ind_1(6,0) = x_l(28,22);
   ap_uint<8> x_msb_ind_2;
   x_msb_ind_2(7,0) = x_l(21,14);
   ap_uint<7> x_msb_ind_3;
   x_msb_ind_3(6,0) = x_l(13,7);
   ap_uint<7> x_lsb_ind;
   x_lsb_ind(6,0) = x_l(6,0);
   const static ap_ufixed<41,-17> exp_lsb_ind_m_1_table[128] = {
    "0x0.0p0", "0x0.000000935D8E080p0", "0x0.00000126BB1C650p0", "0x0.000001BA18AB16Cp0", "0x0.0000024D763A1D4p0", "0x0.000002E0D3C978Cp0", "0x0.000003743159290p0", "0x0.000004078EE92E0p0",
    "0x0.0000049AEC79880p0", "0x0.0000052E4A0A368p0", "0x0.000005C1A79B3A4p0", "0x0.00000655052C928p0", "0x0.000006E862BE3FCp0", "0x0.0000077BC05041Cp0", "0x0.0000080F1DE298Cp0", "0x0.000008A27B75448p0",
    "0x0.00000935D908450p0", "0x0.000009C9369B9A4p0", "0x0.00000A5C942F448p0", "0x0.00000AEFF1C3438p0", "0x0.00000B834F57978p0", "0x0.00000C16ACEC400p0", "0x0.00000CAA0A813D8p0", "0x0.00000D3D6816900p0",
    "0x0.00000DD0C5AC370p0", "0x0.00000E642342334p0", "0x0.00000EF780D8840p0", "0x0.00000F8ADE6F29Cp0", "0x0.0000101E3C06244p0", "0x0.000010B1999D738p0", "0x0.00001144F73517Cp0", "0x0.000011D854CD10Cp0",
    "0x0.0000126BB2655E8p0", "0x0.000012FF0FFE010p0", "0x0.000013926D96F88p0", "0x0.00001425CB30450p0", "0x0.000014B928C9E60p0", "0x0.0000154C8663DC0p0", "0x0.000015DFE3FE26Cp0", "0x0.000016734198C68p0",
    "0x0.000017069F33BB0p0", "0x0.00001799FCCF044p0", "0x0.0000182D5A6AA24p0", "0x0.000018C0B806954p0", "0x0.0000195415A2DD0p0", "0x0.000019E7733F79Cp0", "0x0.00001A7AD0DC6B4p0", "0x0.00001B0E2E79B18p0",
    "0x0.00001BA18C174C8p0", "0x0.00001C34E9B53C8p0", "0x0.00001CC84753814p0", "0x0.00001D5BA4F21B0p0", "0x0.00001DEF0291094p0", "0x0.00001E8260304C8p0", "0x0.00001F15BDCFE4Cp0", "0x0.00001FA91B6FD18p0",
    "0x0.0000203C7910134p0", "0x0.000020CFD6B0AA0p0", "0x0.000021633451954p0", "0x0.000021F691F2D58p0", "0x0.00002289EF946ACp0", "0x0.0000231D4D36548p0", "0x0.000023B0AAD8934p0", "0x0.00002444087B270p0",
    "0x0.000024D7661E0F4p0", "0x0.0000256AC3C14C8p0", "0x0.000025FE2164DE8p0", "0x0.000026917F08C58p0", "0x0.00002724DCAD014p0", "0x0.000027B83A5191Cp0", "0x0.0000284B97F6774p0", "0x0.000028DEF59BB14p0",
    "0x0.000029725341408p0", "0x0.00002A05B0E7244p0", "0x0.00002A990E8D5D0p0", "0x0.00002B2C6C33EA8p0", "0x0.00002BBFC9DACD0p0", "0x0.00002C532782040p0", "0x0.00002CE68529900p0", "0x0.00002D79E2D1710p0",
    "0x0.00002E0D4079A6Cp0", "0x0.00002EA09E22314p0", "0x0.00002F33FBCB108p0", "0x0.00002FC7597444Cp0", "0x0.0000305AB71DCDCp0", "0x0.000030EE14C7AB8p0", "0x0.000031817271DE4p0", "0x0.00003214D01C65Cp0",
    "0x0.000032A82DC7420p0", "0x0.0000333B8B72734p0", "0x0.000033CEE91DF94p0", "0x0.0000346246C9D40p0", "0x0.000034F5A47603Cp0", "0x0.000035890222884p0", "0x0.0000361C5FCF618p0", "0x0.000036AFBD7C8FCp0",
    "0x0.000037431B2A12Cp0", "0x0.000037D678D7EA8p0", "0x0.00003869D686170p0", "0x0.000038FD3434988p0", "0x0.0000399091E36ECp0", "0x0.00003A23EF929A0p0", "0x0.00003AB74D421A0p0", "0x0.00003B4AAAF1EECp0",
    "0x0.00003BDE08A2188p0", "0x0.00003C71665296Cp0", "0x0.00003D04C4036A0p0", "0x0.00003D9821B4924p0", "0x0.00003E2B7F660F4p0", "0x0.00003EBEDD17E10p0", "0x0.00003F523ACA078p0", "0x0.00003FE5987C830p0",
    "0x0.00004078F62F534p0", "0x0.0000410C53E2788p0", "0x0.0000419FB195F24p0", "0x0.000042330F49C10p0", "0x0.000042C66CFDE4Cp0", "0x0.00004359CAB25D0p0", "0x0.000043ED28672A4p0", "0x0.00004480861C4C8p0",
    "0x0.00004513E3D1C34p0", "0x0.000045A741878F0p0", "0x0.0000463A9F3DAFCp0", "0x0.000046CDFCF4250p0", "0x0.000047615AAAEF4p0", "0x0.000047F4B8620E8p0", "0x0.000048881619824p0", "0x0.0000491B73D14B0p0"
   };
   ap_ufixed<41,-17> exp_lsb_ind_m_1 = exp_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<48,-10> exp_msb_ind_3_m_1_table[128] = {
    "0x0.0p0", "0x0.000049AED18968Cp0", "0x0.0000935DB847FC4p0", "0x0.0000DD0CB43BC10p0", "0x0.000126BBC564BCCp0", "0x0.0001706AEBC2F58p0", "0x0.0001BA1A275671Cp0", "0x0.000203C9781F374p0",
    "0x0.00024D78DE1D4C8p0", "0x0.000297285950B74p0", "0x0.0002E0D7E9B97D8p0", "0x0.00032A878F57A5Cp0", "0x0.000374374A2B360p0", "0x0.0003BDE71A34344p0", "0x0.00040796FF72A68p0", "0x0.00045146F9E6930p0",
    "0x0.00049AF70990000p0", "0x0.0004E4A72E6EF34p0", "0x0.00052E576883734p0", "0x0.00057807B7CD85Cp0", "0x0.0005C1B81C4D314p0", "0x0.00060B6896027B4p0", "0x0.0006551924ED6A8p0", "0x0.00069EC9C90E04Cp0",
    "0x0.0006E87A8264500p0", "0x0.0007322B50F052Cp0", "0x0.00077BDC34B2130p0", "0x0.0007C58D2DA9968p0", "0x0.00080F3E3BD6E3Cp0", "0x0.000858EF5F3A008p0", "0x0.0008A2A097D2F34p0", "0x0.0008EC51E5A1C1Cp0",
    "0x0.0009360348A6724p0", "0x0.00097FB4C0E10B0p0", "0x0.0009C9664E51920p0", "0x0.000A1317F0F80D4p0", "0x0.000A5CC9A8D4830p0", "0x0.000AA67B75E6F94p0", "0x0.000AF02D582F764p0", "0x0.000B39DF4FADFFCp0",
    "0x0.000B83915C629C4p0", "0x0.000BCD437E4D51Cp0", "0x0.000C16F5B56E268p0", "0x0.000C60A801C5200p0", "0x0.000CAA5A6352450p0", "0x0.000CF40CDA159B8p0", "0x0.000D3DBF660F294p0", "0x0.000D8772073EF4Cp0",
    "0x0.000DD124BDA5040p0", "0x0.000E1AD789415CCp0", "0x0.000E648A6A1405Cp0", "0x0.000EAE3D601D048p0", "0x0.000EF7F06B5C5F8p0", "0x0.000F41A38BD21CCp0", "0x0.000F8B56C17E424p0", "0x0.000FD50A0C60D64p0",
    "0x0.00101EBD6C79DECp0", "0x0.00106870E1C9620p0", "0x0.0010B2246C4F660p0", "0x0.0010FBD80C0BF0Cp0", "0x0.0011458BC0FF088p0", "0x0.00118F3F8B28B34p0", "0x0.0011D8F36A88F74p0", "0x0.001222A75F1FDA8p0",
    "0x0.00126C5B68ED630p0", "0x0.0012B60F87F1974p0", "0x0.0012FFC3BC2C7D0p0", "0x0.00134978059E1A8p0", "0x0.0013932C644675Cp0", "0x0.0013DCE0D82594Cp0", "0x0.00142695613B7E0p0", "0x0.00147049FF88374p0",
    "0x0.0014B9FEB30BC70p0", "0x0.001503B37BC632Cp0", "0x0.00154D6859B7810p0", "0x0.0015971D4CDFB80p0", "0x0.0015E0D2553EDD8p0", "0x0.00162A8772D4F7Cp0", "0x0.0016743CA5A20D0p0", "0x0.0016BDF1EDA6230p0",
    "0x0.001707A74AE1404p0", "0x0.0017515CBD536ACp0", "0x0.00179B1244FCA88p0", "0x0.0017E4C7E1DCFF8p0", "0x0.00182E7D93F4760p0", "0x0.001878335B43124p0", "0x0.0018C1E937C8DA4p0", "0x0.00190B9F2985D40p0",
    "0x0.00195555307A05Cp0", "0x0.00199F0B4CA5758p0", "0x0.0019E8C17E08294p0", "0x0.001A3277C4A2278p0", "0x0.001A7C2E2073760p0", "0x0.001AC5E4917C1ACp0", "0x0.001B0F9B17BC1C4p0", "0x0.001B5951B333808p0",
    "0x0.001BA30863E24D8p0", "0x0.001BECBF29C8894p0", "0x0.001C367604E63A4p0", "0x0.001C802CF53B664p0", "0x0.001CC9E3FAC8134p0", "0x0.001D139B158C47Cp0", "0x0.001D5D52458809Cp0", "0x0.001DA7098ABB5F4p0",
    "0x0.001DF0C0E5264E4p0", "0x0.001E3A7854C8DD0p0", "0x0.001E842FD9A311Cp0", "0x0.001ECDE773B4F24p0", "0x0.001F179F22FE850p0", "0x0.001F6156E77FCFCp0", "0x0.001FAB0EC138D90p0", "0x0.001FF4C6B029A68p0",
    "0x0.00203E7EB4523E8p0", "0x0.00208836CDB2A70p0", "0x0.0020D1EEFC4AE68p0", "0x0.00211BA7401B028p0", "0x0.0021655F9923018p0", "0x0.0021AF180762E98p0", "0x0.0021F8D08ADAC0Cp0", "0x0.00224289238A8D4p0",
    "0x0.00228C41D172550p0", "0x0.0022D5FA94921E4p0", "0x0.00231FB36CE9EF0p0", "0x0.0023696C5A79CD8p0", "0x0.0023B3255D41BFCp0", "0x0.0023FCDE7541CC0p0", "0x0.00244697A279F80p0", "0x0.00249050E4EA4A4p0"
   };
   ap_ufixed<48,-10> exp_msb_ind_3_m_1 = exp_msb_ind_3_m_1_table[x_msb_ind_3];
   ap_ufixed<89,-27> f_x_msb_ind_3_lsb = exp_lsb_ind_m_1 * exp_msb_ind_3_m_1;
   ap_ufixed<46,-10> exp_msb_ind_3_lsb_ind_m_1 = f_x_msb_ind_3_lsb + exp_lsb_ind_m_1 + exp_msb_ind_3_m_1;
   const static ap_ufixed<54,-2> exp_msb_ind_2_m_1_table[256] = {
    "0x0.0p0", "0x0.0024DA0A3C92C9p0", "0x0.0049B96285BC0Ap0", "0x0.006E9E099EFA37p0", "0x0.009388004BE7E5p0", "0x0.00B87747503BD4p0", "0x0.00DD6BDF6FC8EEp0", "0x0.010265C96E7E4Fp0",
    "0x0.01276506106748p0", "0x0.014C699619AB60p0", "0x0.0171737A4E8E5Ep0", "0x0.019682B3737048p0", "0x0.01BB97424CCD67p0", "0x0.01E0B1279F3E51p0", "0x0.0205D0642F77E5p0", "0x0.022AF4F8C24B54p0",
    "0x0.02501EE61CA626p0", "0x0.02754E2D03923Bp0", "0x0.029A82CE3C35CEp0", "0x0.02BFBCCA8BD37Fp0", "0x0.02E4FC22B7CA50p0", "0x0.030A40D78595AFp0", "0x0.032F8AE9BACD76p0", "0x0.0354DA5A1D25F2p0",
    "0x0.037A2F29726FE5p0", "0x0.039F895880988Ap0", "0x0.03C4E8E80DA99Bp0", "0x0.03EA4DD8DFC955p0", "0x0.040FB82BBD3A78p0", "0x0.043527E16C5C51p0", "0x0.045A9CFAB3AABBp0", "0x0.0480177859BE22p0",
    "0x0.04A5975B254B8Bp0", "0x0.04CB1CA3DD2493p0", "0x0.04F0A753483778p0", "0x0.0516376A2D8F1Ap0", "0x0.053BCCE95452FFp0", "0x0.056167D183C75Bp0", "0x0.05870823834D0Ep0", "0x0.05ACADE01A61AEp0",
    "0x0.05D25908109F88p0", "0x0.05F8099C2DBDA3p0", "0x0.061DBF9D398FC8p0", "0x0.06437B0BFC0683p0", "0x0.06693BE93D2F28p0", "0x0.068F0235C533D7p0", "0x0.06B4CDF25C5B83p0", "0x0.06DA9F1FCB09EFp0",
    "0x0.070075BED9BFBBp0", "0x0.072651D0511A61p0", "0x0.074C3354F9D43Dp0", "0x0.07721A4D9CC491p0", "0x0.079806BB02DF87p0", "0x0.07BDF89DF53637p0", "0x0.07E3EFF73CF6ACp0", "0x0.0809ECC7A36BE3p0",
    "0x0.082FEF0FF1FDD7p0", "0x0.0855F6D0F23180p0", "0x0.087C040B6DA8D8p0", "0x0.08A216C02E22DFp0", "0x0.08C82EEFFD7BA0p0", "0x0.08EE4C9BA5AC35p0", "0x0.09146FC3F0CACCp0", "0x0.093A9869A90AA9p0",
    "0x0.0960C68D98BC2Cp0", "0x0.0986FA308A4CD4p0", "0x0.09AD3353484744p0", "0x0.09D371F69D5348p0", "0x0.09F9B61B5435D7p0", "0x0.0A1FFFC237D119p0", "0x0.0A464EEC13246Bp0", "0x0.0A6CA399B14C61p0",
    "0x0.0A92FDCBDD82CEp0", "0x0.0AB95D83631EC5p0", "0x0.0ADFC2C10D94A0p0", "0x0.0B062D85A87601p0", "0x0.0B2C9DD1FF71D8p0", "0x0.0B5313A6DE5467p0", "0x0.0B798F05110749p0", "0x0.0BA00FED63916Fp0",
    "0x0.0BC69660A2172Dp0", "0x0.0BED225F98DA36p0", "0x0.0C13B3EB1439A8p0", "0x0.0C3A4B03E0B20Ap0", "0x0.0C60E7AACADD54p0", "0x0.0C8789E09F72F1p0", "0x0.0CAE31A62B47C4p0", "0x0.0CD4DEFC3B4E2Dp0",
    "0x0.0CFB91E39C960Dp0", "0x0.0D224A5D1C4CC9p0", "0x0.0D49086987BD4Fp0", "0x0.0D6FCC09AC501Cp0", "0x0.0D96953E578B3Ep0", "0x0.0DBD6408571257p0", "0x0.0DE4386878A6A5p0", "0x0.0E0B125F8A2704p0",
    "0x0.0E31F1EE598FF3p0", "0x0.0E58D715B4FB98p0", "0x0.0E7FC1D66AA1C4p0", "0x0.0EA6B23148D7F6p0", "0x0.0ECDA8271E1164p0", "0x0.0EF4A3B8B8DEF8p0", "0x0.0F1BA4E6E7EF5Dp0", "0x0.0F42ABB27A0EFAp0",
    "0x0.0F69B81C3E27FEp0", "0x0.0F90CA25034260p0", "0x0.0FB7E1CD9883E5p0", "0x0.0FDEFF16CD3022p0", "0x0.1006220170A885p0", "0x0.102D4A8E526C53p0", "0x0.105478BE4218B3p0", "0x0.107BAC920F68ACp0",
    "0x0.10A2E60A8A352Ep0", "0x0.10CA2528827515p0", "0x0.10F169ECC83D2Ap0", "0x0.1118B4582BC02Dp0", "0x0.1140046B7D4ED5p0", "0x0.11675A278D57D7p0", "0x0.118EB58D2C67E8p0", "0x0.11B6169D2B29C2p0",
    "0x0.11DD7D585A662Bp0", "0x0.1204E9BF8B03F4p0", "0x0.122C5BD38E0803p0", "0x0.1253D395349553p0", "0x0.127B51054FECFBp0", "0x0.12A2D424B16E31p0", "0x0.12CA5CF42A964Fp0", "0x0.12F1EB748D00D7p0",
    "0x0.13197FA6AA6777p0", "0x0.1341198B54A20Dp0", "0x0.1368B9235DA6AEp0", "0x0.13905E6F9789A8p0", "0x0.13B80970D47D86p0", "0x0.13DFBA27E6D314p0", "0x0.14077095A0F967p0", "0x0.142F2CBAD57DDEp0",
    "0x0.1456EE98570C27p0", "0x0.147EB62EF86E43p0", "0x0.14A6837F8C8C8Cp0", "0x0.14CE568AE66DB7p0", "0x0.14F62F51D936DBp0", "0x0.151E0DD5382B74p0", "0x0.1545F215D6AD66p0", "0x0.156DDC14883D04p0",
    "0x0.1595CBD2207913p0", "0x0.15BDC14F731ECFp0", "0x0.15E5BC8D5409EEp0", "0x0.160DBD8C9734A6p0", "0x0.1635C44E10B7B0p0", "0x0.165DD0D294CA4Ep0", "0x0.1685E31AF7C24Ep0", "0x0.16ADFB280E140Fp0",
    "0x0.16D618FAAC5286p0", "0x0.16FE3C93A72F41p0", "0x0.172665F3D37A6Cp0", "0x0.174E951C0622D6p0", "0x0.1776CA0D1435F4p0", "0x0.179F04C7D2DFE7p0", "0x0.17C7454D176B81p0", "0x0.17EF8B9DB74247p0",
    "0x0.1817D7BA87EC75p0", "0x0.184029A45F1107p0", "0x0.1868815C1275B9p0", "0x0.1890DEE277FF0Dp0", "0x0.18B9423865B04Fp0", "0x0.18E1AB5EB1AB9Ap0", "0x0.190A1A563231DCp0", "0x0.19328F1FBDA2DCp0",
    "0x0.195B09BC2A7D3Ap0", "0x0.19838A2C4F5E7Ap0", "0x0.19AC1071030303p0", "0x0.19D49C8B1C4625p0", "0x0.19FD2E7B722220p0", "0x0.1A25C642DBB023p0", "0x0.1A4E63E2302857p0", "0x0.1A77075A46E1DEp0",
    "0x0.1A9FB0ABF752DBp0", "0x0.1AC85FD8191074p0", "0x0.1AF114DF83CED8p0", "0x0.1B19CFC30F6145p0", "0x0.1B42908393BA07p0", "0x0.1B6B5721E8EA82p0", "0x0.1B94239EE72334p0", "0x0.1BBCF5FB66B3BCp0",
    "0x0.1BE5CE38400AD8p0", "0x0.1C0EAC564BB672p0", "0x0.1C37905662639Fp0", "0x0.1C607A395CDEA5p0", "0x0.1C896A001412FEp0", "0x0.1CB25FAB610B61p0", "0x0.1CDB5B3C1CF1BFp0", "0x0.1D045CB3210F50p0",
    "0x0.1D2D641146CC91p0", "0x0.1D56715767B14Cp0", "0x0.1D7F84865D649Ap0", "0x0.1DA89D9F01ACEBp0", "0x0.1DD1BCA22E7006p0", "0x0.1DFAE190BDB311p0", "0x0.1E240C6B899A96p0", "0x0.1E4D3D336C6A83p0",
    "0x0.1E7673E9408633p0", "0x0.1E9FB08DE07072p0", "0x0.1EC8F32226CB7Ep0", "0x0.1EF23BA6EE590Fp0", "0x0.1F1B8A1D11FA5Cp0", "0x0.1F44DE856CB01Dp0", "0x0.1F6E38E0D99A90p0", "0x0.1F97993033F980p0",
    "0x0.1FC0FF74572C45p0", "0x0.1FEA6BAE1EB1CEp0", "0x0.2013DDDE6628A0p0", "0x0.203D5606094EE1p0", "0x0.2066D425E40256p0", "0x0.2090583ED2406Ap0", "0x0.20B9E251B02636p0", "0x0.20E3725F59F080p0",
    "0x0.210D0868ABFBC3p0", "0x0.2136A46E82C433p0", "0x0.21604671BAE5C1p0", "0x0.2189EE73311C20p0", "0x0.21B39C73C242C8p0", "0x0.21DD50744B54FDp0", "0x0.22070A75A96DD4p0", "0x0.2230CA78B9C835p0",
    "0x0.225A907E59BEDFp0", "0x0.22845C8766CC70p0", "0x0.22AE2E94BE8B69p0", "0x0.22D806A73EB62Fp0", "0x0.2301E4BFC52713p0", "0x0.232BC8DF2FD857p0", "0x0.2355B3065CE42Fp0", "0x0.237FA3362A84CAp0",
    "0x0.23A9996F771453p0", "0x0.23D395B3210CF7p0", "0x0.23FD98020708EAp0", "0x0.2427A05D07C26Dp0", "0x0.2451AEC50213CEp0", "0x0.247BC33AD4F771p0", "0x0.24A5DDBF5F87D3p0", "0x0.24CFFE5380FF8Fp0",
    "0x0.24FA24F818B962p0", "0x0.252451AE063030p0", "0x0.254E847628FF09p0", "0x0.2578BD5160E12Cp0", "0x0.25A2FC408DB20Fp0", "0x0.25CD41448F6D5Fp0", "0x0.25F78C5E462F0Ap0", "0x0.2621DD8E92333Fp0",
    "0x0.264C34D653D674p0", "0x0.267692366B956Dp0", "0x0.26A0F5AFBA0D3Cp0", "0x0.26CB5F431FFB4Cp0", "0x0.26F5CEF17E3D5Fp0", "0x0.272044BBB5D196p0", "0x0.274AC0A2A7D678p0", "0x0.277542A7358AF1p0"
   };
   ap_ufixed<54,-2> exp_msb_ind_2_m_1 = exp_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<100,-12> f_x_msb_ind_2_msb_ind3_lsb = exp_msb_ind_3_lsb_ind_m_1 * exp_msb_ind_2_m_1;
   ap_ufixed<52,-2> exp_msb_ind2_msb_ind3_lsb_ind_m_1 = f_x_msb_ind_2_msb_ind3_lsb + exp_msb_ind_3_lsb_ind_m_1 + exp_msb_ind_2_m_1;
   const static ap_ufixed<54,26> exp_msb_ind_1_table[256] = {
    "0x1.0000000p0", "0x1.279FCADp0", "0x1.5561A92p0", "0x1.8A389FFp0", "0x1.C73D51Cp0", "0x2.0DB3D0Fp0", "0x2.5F1258Ep0", "0x2.BD0911Bp0",
    "0x3.298B076p0", "0x3.A6D8842p0", "0x4.378B054p0", "0x4.DEA3099p0", "0x5.9F9802Dp0", "0x6.7E6ABF0p0", "0x7.7FBAAB4p0", "0x8.A8DE610p0",
    "0xA.0000000p0", "0xB.8C3DEBEp0", "0xD.55D09B1p0", "0xF.66363F8p0", "0x11.C86531Bp0", "0x14.8906295p0", "0x17.B6B778Cp0", "0x1B.625AB10p0",
    "0x1F.9F6E499p0", "0x24.8475291p0", "0x2A.2B6E347p0", "0x30.B25E5F8p0", "0x38.3BF01BEp0", "0x40.F02B75Fp0", "0x4A.FD4AB0Bp0", "0x56.98AFCA2p0",
    "0x64.0000000p0", "0x73.7A6B370p0", "0x85.5A260EDp0", "0x99.FE1E7B3p0", "0xB1.D3F3F11p0", "0xCD.5A3D9D0p0", "0xED.232AB7Bp0", "0x111.D78AEA4p0",
    "0x13C.3A4EDFBp0", "0x16D.2C939A9p0", "0x1A5.B24E0C7p0", "0x1E6.F7AFBABp0", "0x232.5761167p0", "0x289.61B29B6p0", "0x2ED.E4EAE72p0", "0x361.F6DDE55p0",
    "0x3E8.0000000p0", "0x482.C830261p0", "0x535.857C941p0", "0x603.ED30CFDp0", "0x6F2.47876A9p0", "0x805.8668224p0", "0x943.5FAB2CAp0", "0xAB2.6B6D26Bp0",
    "0xC5A.4714BCAp0", "0xE43.BDC409Bp0", "0x1078.F70C7CBp0", "0x1305.ACDD4AFp0", "0x15F7.69CAE07p0", "0x195D.D0FA11Ep0", "0x1D4A.F12D073p0", "0x21D3.A4AAF51p0",
    "0x2710.0000000p0", "0x2D1B.D1E17C7p0", "0x3417.36DDC85p0", "0x3C27.43E81E5p0", "0x4576.CB4A29Cp0", "0x5037.401156Cp0", "0x5CA1.BCAFBE1p0", "0x6AF8.324382Fp0",
    "0x7B86.C6CF5E3p0", "0x8EA5.69A8609p0", "0xA4B9.A67CDEAp0", "0xBE38.C0A4ED5p0", "0xDBAA.21ECC48p0", "0xFDAA.29C4B2Ap0", "0x124ED.6BC2480p0", "0x15244.6EAD929p0",
    "0x186A0.0000000p0", "0x1C316.32CEDC6p0", "0x208E8.24A9D35p0", "0x25988.A7112F0p0", "0x2B6A3.F0E5A19p0", "0x32228.80AD63Cp0", "0x39E51.5EDD6CAp0", "0x42DB1.F6A31D7p0",
    "0x4D343.C419ADFp0", "0x59276.2093C5Ep0", "0x66F40.80E0B21p0", "0x76E37.8671452p0", "0x894A5.533FACCp0", "0x9E8A5.A1AEFA8p0", "0xB7146.3596CFDp0", "0xD36AC.52C7B9Bp0",
    "0xF4240.0000000p0", "0x119EDD.FC149BCp0", "0x145911.6EA2417p0", "0x177F56.86ABD5Cp0", "0x1B2267.68F84F9p0", "0x1F5595.06C5E54p0", "0x242F2D.B4A63E0p0", "0x29C8F3.A25F263p0",
    "0x3040A5.A900CB8p0", "0x37B89D.45C5BB0p0", "0x405885.08C6F4Ap0", "0x4A4E2B.406CB33p0", "0x55CE75.407CBF4p0", "0x631678.50D5C93p0", "0x726CBE.17E41E4p0", "0x8422BB.3BCD40Ap0",
    "0x989680.0000000p0", "0xB034AB.D8CE155p0", "0xCB7AAE.52568E6p0", "0xEAF961.42B6594p0", "0x10F580A.19B31BCp0", "0x13957D2.43BAF49p0", "0x169D7C9.0E7E6C2p0", "0x1A1D984.57B77DEp0",
    "0x1E28678.9A07F2Fp0", "0x22D3624.B9B94DFp0", "0x2837532.57C58E8p0", "0x2E70DB0.843F002p0", "0x35A1094.84DF78Cp0", "0x3DEE0B3.2859DBCp0", "0x4783F6C.EEE92ECp0", "0x5295B50.5604864p0",
    "0x0.0000003p0", "0x0.0000003p0", "0x0.0000004p0", "0x0.0000004p0", "0x0.0000005p0", "0x0.0000006p0", "0x0.0000006p0", "0x0.0000007p0",
    "0x0.0000008p0", "0x0.000000Ap0", "0x0.000000Bp0", "0x0.000000Dp0", "0x0.000000Fp0", "0x0.0000011p0", "0x0.0000014p0", "0x0.0000017p0",
    "0x0.000001Bp0", "0x0.000001Fp0", "0x0.0000024p0", "0x0.0000029p0", "0x0.0000030p0", "0x0.0000037p0", "0x0.0000040p0", "0x0.000004Ap0",
    "0x0.0000055p0", "0x0.0000062p0", "0x0.0000071p0", "0x0.0000083p0", "0x0.0000097p0", "0x0.00000AEp0", "0x0.00000C9p0", "0x0.00000E8p0",
    "0x0.000010Cp0", "0x0.0000136p0", "0x0.0000166p0", "0x0.000019Dp0", "0x0.00001DDp0", "0x0.0000227p0", "0x0.000027Dp0", "0x0.00002DFp0",
    "0x0.0000351p0", "0x0.00003D4p0", "0x0.000046Cp0", "0x0.000051Bp0", "0x0.00005E6p0", "0x0.00006CFp0", "0x0.00007DDp0", "0x0.0000915p0",
    "0x0.0000A7Cp0", "0x0.0000C1Cp0", "0x0.0000DFCp0", "0x0.0001026p0", "0x0.00012A6p0", "0x0.0001588p0", "0x0.00018DEp0", "0x0.0001CB7p0",
    "0x0.0002129p0", "0x0.000264Bp0", "0x0.0002C38p0", "0x0.0003310p0", "0x0.0003AF7p0", "0x0.0004418p0", "0x0.0004EA2p0", "0x0.0005ACEp0",
    "0x0.00068DCp0", "0x0.0007916p0", "0x0.0008BD4p0", "0x0.000A179p0", "0x0.000BA77p0", "0x0.000D754p0", "0x0.000F8A8p0", "0x0.0011F25p0",
    "0x0.0014B97p0", "0x0.0017EEAp0", "0x0.001BA2Ep0", "0x0.001FE9Fp0", "0x0.0024DA8p0", "0x0.002A8EDp0", "0x0.0031252p0", "0x0.0038C08p0",
    "0x0.0041893p0", "0x0.004BAE0p0", "0x0.005764Cp0", "0x0.0064EBBp0", "0x0.00748A9p0", "0x0.0086947p0", "0x0.009B691p0", "0x0.00B3771p0",
    "0x0.00CF3E3p0", "0x0.00EF521p0", "0x0.01145CFp0", "0x0.013F239p0", "0x0.0170894p0", "0x0.01A9943p0", "0x0.01EB736p0", "0x0.023784Bp0",
    "0x0.028F5C3p0", "0x0.02F4CC4p0", "0x0.0369EFCp0", "0x0.03F134Dp0", "0x0.048D69Cp0", "0x0.0541CC5p0", "0x0.06121A8p0", "0x0.0702A69p0",
    "0x0.08186E2p0", "0x0.0959348p0", "0x0.0ACBA15p0", "0x0.0C7763Fp0", "0x0.0E655C3p0", "0x0.109FC99p0", "0x0.133281Bp0", "0x0.162B2F1p0",
    "0x0.199999Ap0", "0x0.1D8FFABp0", "0x0.22235DBp0", "0x0.276C100p0", "0x0.2D8621Cp0", "0x0.3491FB5p0", "0x0.3CB508Ep0", "0x0.461A81Cp0",
    "0x0.50F44D9p0", "0x0.5D7C0D3p0", "0x0.6BF44D5p0", "0x0.7CA9E76p0", "0x0.8FF599Ep0", "0x0.A63DDFEp0", "0x0.BFF9112p0", "0x0.DDAFD68p0"
   };
   ap_ufixed<54,26> exp_msb_ind_1 = exp_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<106,24> f_x_msb_ind_1_ind_2_ind_1_lsb = exp_msb_ind_1 * exp_msb_ind2_msb_ind3_lsb_ind_m_1;
   y = f_x_msb_ind_1_ind_2_ind_1_lsb + exp_msb_ind_1;
  }
  if(I_<27) {
   bool overf = 0;
   VITIS_LOOP_3244_13: for(int j = 51; j >= 25 + I_; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3251_14: for(int j = 51; j>=25 + I_; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3255_15: for(int j = 24 + I_; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else {
  ap_fixed<65,33> x_l = x;
  ap_ufixed<64,32> y = 0;
  ap_fixed<5,5> x_l_int;
  x_l_int(4,0) = x_l(36,32);
  ap_ufixed<32,0> x_l_fract;
  x_l_fract(31,0) = x_l(31,0);
  bool overf = 0;
  VITIS_LOOP_3270_16: for(int j = 63; j >= 36; j--) {
#pragma HLS unroll
 if(x_l[64]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||(x_l_int >= 10)||((x_l_int==9)&&(x_l_fract>ap_fixed<32,0>("0x0.A209A84F")))) {
   if(!x_l[64]) {
    y = ap_ufixed<64,32>("0xFFFFFFFF.FFFFFFFFp0");
   }
  } else {
   ap_uint<8> x_msb_ind_1;
   x_msb_ind_1[7] = x_l[64];
   x_msb_ind_1(6,0) = x_l(35,29);
   ap_uint<8> x_msb_ind_2;
   x_msb_ind_2(7,0) = x_l(28,21);
   ap_uint<7> x_msb_ind_3;
   x_msb_ind_3(6,0) = x_l(20,14);
   ap_uint<7> x_msb_ind_4;
   x_msb_ind_4(6,0) = x_l(13,7);
   ap_uint<7> x_lsb_ind;
   x_lsb_ind(6,0) = x_l(6,0);
   const static ap_ufixed<49,-23> exp_x_lsb_ind_m_1_table[128] = {
    "0x0.0p0", "0x0.000000024D76377927p0", "0x0.000000049AEC6EF79Cp0", "0x0.00000006E862A67B5Dp0", "0x0.0000000935D8DE046Dp0", "0x0.0000000B834F1592C9p0", "0x0.0000000DD0C54D2672p0", "0x0.000000101E3B84BF69p0",
    "0x0.000000126BB1BC5DAEp0", "0x0.00000014B927F4013Fp0", "0x0.00000017069E2BAA1Ep0", "0x0.00000019541463584Ap0", "0x0.0000001BA18A9B0BC3p0", "0x0.0000001DEF00D2C48Ap0", "0x0.000000203C770A829Ep0", "0x0.0000002289ED4245FFp0",
    "0x0.00000024D7637A0EAEp0", "0x0.0000002724D9B1DCA9p0", "0x0.00000029724FE9AFF2p0", "0x0.0000002BBFC6218889p0", "0x0.0000002E0D3C59666Cp0", "0x0.000000305AB291499Dp0", "0x0.00000032A828C9321Bp0", "0x0.00000034F59F011FE7p0",
    "0x0.000000374315391300p0", "0x0.00000039908B710B66p0", "0x0.0000003BDE01A90919p0", "0x0.0000003E2B77E10C1Ap0", "0x0.0000004078EE191468p0", "0x0.00000042C664512203p0", "0x0.0000004513DA8934EBp0", "0x0.000000476150C14D21p0",
    "0x0.00000049AEC6F96AA4p0", "0x0.0000004BFC3D318D75p0", "0x0.0000004E49B369B592p0", "0x0.000000509729A1E2FDp0", "0x0.00000052E49FDA15B5p0", "0x0.000000553216124DBBp0", "0x0.000000577F8C4A8B0Ep0", "0x0.00000059CD0282CDAEp0",
    "0x0.0000005C1A78BB159Bp0", "0x0.0000005E67EEF362D6p0", "0x0.00000060B5652BB55Ep0", "0x0.0000006302DB640D33p0", "0x0.0000006550519C6A55p0", "0x0.000000679DC7D4CCC5p0", "0x0.00000069EB3E0D3482p0", "0x0.0000006C38B445A18Dp0",
    "0x0.0000006E862A7E13E4p0", "0x0.00000070D3A0B68B89p0", "0x0.000000732116EF087Bp0", "0x0.000000756E8D278ABBp0", "0x0.00000077BC03601248p0", "0x0.0000007A0979989F22p0", "0x0.0000007C56EFD13149p0", "0x0.0000007EA46609C8BEp0",
    "0x0.00000080F1DC426580p0", "0x0.000000833F527B078Fp0", "0x0.000000858CC8B3AEEBp0", "0x0.00000087DA3EEC5B95p0", "0x0.0000008A27B5250D8Cp0", "0x0.0000008C752B5DC4D1p0", "0x0.0000008EC2A1968162p0", "0x0.000000911017CF4341p0",
    "0x0.000000935D8E080A6Dp0", "0x0.00000095AB0440D6E7p0", "0x0.00000097F87A79A8AEp0", "0x0.0000009A45F0B27FC2p0", "0x0.0000009C9366EB5C23p0", "0x0.0000009EE0DD243DD2p0", "0x0.000000A12E535D24CEp0", "0x0.000000A37BC9961117p0",
    "0x0.000000A5C93FCF02ADp0", "0x0.000000A816B607F991p0", "0x0.000000AA642C40F5C2p0", "0x0.000000ACB1A279F741p0", "0x0.000000AEFF18B2FE0Cp0", "0x0.000000B14C8EEC0A25p0", "0x0.000000B39A05251B8Bp0", "0x0.000000B5E77B5E323Fp0",
    "0x0.000000B834F1974E40p0", "0x0.000000BA8267D06F8Ep0", "0x0.000000BCCFDE099629p0", "0x0.000000BF1D5442C212p0", "0x0.000000C16ACA7BF348p0", "0x0.000000C3B840B529CBp0", "0x0.000000C605B6EE659Bp0", "0x0.000000C8532D27A6B9p0",
    "0x0.000000CAA0A360ED24p0", "0x0.000000CCEE199A38DDp0", "0x0.000000CF3B8FD389E2p0", "0x0.000000D189060CE035p0", "0x0.000000D3D67C463BD5p0", "0x0.000000D623F27F9CC3p0", "0x0.000000D87168B902FEp0", "0x0.000000DABEDEF26E86p0",
    "0x0.000000DD0C552BDF5Bp0", "0x0.000000DF59CB65557Ep0", "0x0.000000E1A7419ED0EEp0", "0x0.000000E3F4B7D851ABp0", "0x0.000000E6422E11D7B6p0", "0x0.000000E88FA44B630Dp0", "0x0.000000EADD1A84F3B2p0", "0x0.000000ED2A90BE89A5p0",
    "0x0.000000EF7806F824E4p0", "0x0.000000F1C57D31C571p0", "0x0.000000F412F36B6B4Cp0", "0x0.000000F66069A51673p0", "0x0.000000F8ADDFDEC6E8p0", "0x0.000000FAFB56187CAAp0", "0x0.000000FD48CC5237B9p0", "0x0.000000FF96428BF816p0",
    "0x0.00000101E3B8C5BDC0p0", "0x0.00000104312EFF88B7p0", "0x0.000001067EA53958FCp0", "0x0.00000108CC1B732E8Ep0", "0x0.0000010B1991AD096Dp0", "0x0.0000010D6707E6E999p0", "0x0.0000010FB47E20CF13p0", "0x0.0000011201F45AB9DAp0",
    "0x0.000001144F6A94A9EEp0", "0x0.000001169CE0CE9F4Fp0", "0x0.00000118EA570899FEp0", "0x0.0000011B37CD4299FAp0", "0x0.0000011D85437C9F44p0", "0x0.0000011FD2B9B6A9DAp0", "0x0.00000122202FF0B9BEp0", "0x0.000001246DA62ACEEFp0"
   };
   ap_ufixed<49,-23> exp_x_lsb_ind_m_1 = exp_x_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<56,-16> exp_x_msb_ind_4_m_1_table[128] = {
    "0x0.0p0", "0x0.00000126BB1C64FE3Ep0", "0x0.0000024D763A1D4ECAp0", "0x0.00000374315928F1A6p0", "0x0.0000049AEC7987E6D2p0", "0x0.000005C1A79B3A2E51p0", "0x0.000006E862BE3FC825p0", "0x0.0000080F1DE298B44Dp0",
    "0x0.00000935D90844F2CDp0", "0x0.00000A5C942F4483A6p0", "0x0.00000B834F579766D9p0", "0x0.00000CAA0A813D9C67p0", "0x0.00000DD0C5AC372453p0", "0x0.00000EF780D883FE9Ep0", "0x0.0000101E3C06242B48p0", "0x0.00001144F73517AA55p0",
    "0x0.0000126BB2655E7BC5p0", "0x0.000013926D96F89F9Ap0", "0x0.000014B928C9E615D5p0", "0x0.000015DFE3FE26DE78p0", "0x0.000017069F33BAF985p0", "0x0.0000182D5A6AA266FCp0", "0x0.0000195415A2DD26E0p0", "0x0.00001A7AD0DC6B3932p0",
    "0x0.00001BA18C174C9DF4p0", "0x0.00001CC84753815527p0", "0x0.00001DEF0291095ECCp0", "0x0.00001F15BDCFE4BAE6p0", "0x0.0000203C7910136975p0", "0x0.000021633451956A7Bp0", "0x0.00002289EF946ABDFAp0", "0x0.000023B0AAD89363F3p0",
    "0x0.000024D7661E0F5C68p0", "0x0.000025FE2164DEA75Ap0", "0x0.00002724DCAD0144CCp0", "0x0.0000284B97F67734BDp0", "0x0.000029725341407730p0", "0x0.00002A990E8D5D0C27p0", "0x0.00002BBFC9DACCF3A2p0", "0x0.00002CE68529902DA4p0",
    "0x0.00002E0D4079A6BA2Ep0", "0x0.00002F33FBCB109942p0", "0x0.0000305AB71DCDCAE0p0", "0x0.000031817271DE4F0Bp0", "0x0.000032A82DC74225C5p0", "0x0.000033CEE91DF94F0Dp0", "0x0.000034F5A47603CAE7p0", "0x0.0000361C5FCF619954p0",
    "0x0.000037431B2A12BA54p0", "0x0.00003869D686172DEBp0", "0x0.0000399091E36EF418p0", "0x0.00003AB74D421A0CDFp0", "0x0.00003BDE08A218783Fp0", "0x0.00003D04C4036A363Cp0", "0x0.00003E2B7F660F46D5p0", "0x0.00003F523ACA07AA0Ep0",
    "0x0.00004078F62F535FE7p0", "0x0.0000419FB195F26862p0", "0x0.000042C66CFDE4C380p0", "0x0.000043ED28672A7144p0", "0x0.00004513E3D1C371ADp0", "0x0.0000463A9F3DAFC4BFp0", "0x0.000047615AAAEF6A7Ap0", "0x0.0000488816198262E1p0",
    "0x0.000049AED18968ADF4p0", "0x0.00004AD58CFAA24BB5p0", "0x0.00004BFC486D2F3C26p0", "0x0.00004D2303E10F7F48p0", "0x0.00004E49BF5643151Cp0", "0x0.00004F707ACCC9FDA5p0", "0x0.000050973644A438E4p0", "0x0.000051BDF1BDD1C6DAp0",
    "0x0.000052E4AD3852A788p0", "0x0.0000540B68B426DAF1p0", "0x0.0000553224314E6116p0", "0x0.00005658DFAFC939F8p0", "0x0.0000577F9B2F976599p0", "0x0.000058A656B0B8E3FBp0", "0x0.000059CD12332DB51Ep0", "0x0.00005AF3CDB6F5D905p0",
    "0x0.00005C1A893C114FB1p0", "0x0.00005D4144C2801924p0", "0x0.00005E68004A42355Fp0", "0x0.00005F8EBBD357A463p0", "0x0.000060B5775DC06632p0", "0x0.000061DC32E97C7ACEp0", "0x0.00006302EE768BE238p0", "0x0.00006429AA04EE9C72p0",
    "0x0.000065506594A4A97Dp0", "0x0.000066772125AE095Ap0", "0x0.0000679DDCB80ABC0Cp0", "0x0.000068C4984BBAC194p0", "0x0.000069EB53E0BE19F3p0", "0x0.00006B120F7714C52Bp0", "0x0.00006C38CB0EBEC33Ep0", "0x0.00006D5F86A7BC142Cp0",
    "0x0.00006E8642420CB7F8p0", "0x0.00006FACFDDDB0AEA2p0", "0x0.000070D3B97AA7F82Dp0", "0x0.000071FA7518F2949Ap0", "0x0.0000732130B89083EBp0", "0x0.00007447EC5981C621p0", "0x0.0000756EA7FBC65B3Dp0", "0x0.00007695639F5E4341p0",
    "0x0.000077BC1F44497E2Fp0", "0x0.000078E2DAEA880C08p0", "0x0.00007A09969219ECCEp0", "0x0.00007B30523AFF2082p0", "0x0.00007C570DE537A726p0", "0x0.00007D7DC990C380BBp0", "0x0.00007EA4853DA2AD43p0", "0x0.00007FCB40EBD52CBFp0",
    "0x0.000080F1FC9B5AFF31p0", "0x0.00008218B84C34249Ap0", "0x0.0000833F73FE609CFCp0", "0x0.000084662FB1E06859p0", "0x0.0000858CEB66B386B2p0", "0x0.000086B3A71CD9F808p0", "0x0.000087DA62D453BC5Dp0", "0x0.000089011E8D20D3B2p0",
    "0x0.00008A27DA47413E0Ap0", "0x0.00008B4E9602B4FB65p0", "0x0.00008C7551BF7C0BC5p0", "0x0.00008D9C0D7D966F2Cp0", "0x0.00008EC2C93D04259Bp0", "0x0.00008FE984FDC52F14p0", "0x0.0000911040BFD98B98p0", "0x0.00009236FC83413B29p0"
   };
   ap_ufixed<56,-16> exp_x_msb_ind_4_m_1 = exp_x_msb_ind_4_m_1_table[x_msb_ind_4];
   ap_ufixed<105,-39> f_x_msb_ind_4_lsb_ind = exp_x_msb_ind_4_m_1 * exp_x_lsb_ind_m_1;
   ap_ufixed<54,-16> exp_x_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_4_lsb_ind + exp_x_msb_ind_4_m_1 + exp_x_lsb_ind_m_1;
   const static ap_ufixed<61,-9> exp_x_msb_ind_3_m_1_table[128] = {
    "0x0.0p0", "0x0.0000935DB847FC5AA8p0", "0x0.000126BBC564BCA768p0", "0x0.0001BA1A275671BB78p0", "0x0.00024D78DE1D4C6C2Cp0", "0x0.0002E0D7E9B97D8EFCp0", "0x0.000374374A2B35F970p0", "0x0.00040796FF72A6813Cp0",
    "0x0.00049AF7098FFFFC24p0", "0x0.00052E57688373400Cp0", "0x0.0005C1B81C4D3122F0p0", "0x0.0006551924ED6A7AF0p0", "0x0.0006E87A8264501E44p0", "0x0.00077BDC34B212E340p0", "0x0.00080F3E3BD6E3A04Cp0", "0x0.0008A2A097D2F32C00p0",
    "0x0.0009360348A6725D00p0", "0x0.0009C9664E51920A0Cp0", "0x0.000A5CC9A8D4830A0Cp0", "0x0.000AF02D582F7633F4p0", "0x0.000B83915C629C5EE4p0", "0x0.000C16F5B56E266210p0", "0x0.000CAA5A63524514C8p0", "0x0.000D3DBF660F294E74p0",
    "0x0.000DD124BDA503E6A8p0", "0x0.000E648A6A1405B500p0", "0x0.000EF7F06B5C5F9140p0", "0x0.000F8B56C17E425348p0", "0x0.00101EBD6C79DED310p0", "0x0.0010B2246C4F65E8ACp0", "0x0.0011458BC0FF086C50p0", "0x0.0011D8F36A88F7364Cp0",
    "0x0.00126C5B68ED631F08p0", "0x0.0012FFC3BC2C7CFF0Cp0", "0x0.0013932C644675AEF4p0", "0x0.00142695613B7E0788p0", "0x0.0014B9FEB30BC6E19Cp0", "0x0.00154D6859B7811628p0", "0x0.0015E0D2553EDD7E44p0", "0x0.0016743CA5A20CF314p0",
    "0x0.001707A74AE1404DF0p0", "0x0.00179B1244FCA86834p0", "0x0.00182E7D93F4761B6Cp0", "0x0.0018C1E937C8DA4134p0", "0x0.00195555307A05B348p0", "0x0.0019E8C17E08294B7Cp0", "0x0.001A7C2E207375E3C8p0", "0x0.001B0F9B17BC1C563Cp0",
    "0x0.001BA30863E24D7D04p0", "0x0.001C367604E63A3268p0", "0x0.001CC9E3FAC81350CCp0", "0x0.001D5D52458809B2ACp0", "0x0.001DF0C0E5264E32ACp0", "0x0.001E842FD9A311AB84p0", "0x0.001F179F22FE84F804p0", "0x0.001FAB0EC138D8F320p0",
    "0x0.00203E7EB4523E77E4p0", "0x0.0020D1EEFC4AE66178p0", "0x0.0021655F9923018B24p0", "0x0.0021F8D08ADAC0D048p0", "0x0.00228C41D172550C64p0", "0x0.00231FB36CE9EF1B0Cp0", "0x0.0023B3255D41BFD7FCp0", "0x0.00244697A279F81F04p0",
    "0x0.0024DA0A3C92C8CC10p0", "0x0.00256D7D2B8C62BB2Cp0", "0x0.002600F06F66F6C880p0", "0x0.002694640822B5D04Cp0", "0x0.002727D7F5BFD0AEECp0", "0x0.0027BB4C383E7840E0p0", "0x0.00284EC0CF9EDD62C0p0", "0x0.0028E235BBE130F138p0",
    "0x0.002975AAFD05A3C918p0", "0x0.002A0920930C66C754p0", "0x0.002A9C967DF5AAC8E8p0", "0x0.002B300CBDC1A0AB00p0", "0x0.002BC3835270794AD4p0", "0x0.002C56FA3C026585C8p0", "0x0.002CEA717A77963950p0", "0x0.002D7DE90DD03C4300p0",
    "0x0.002E1160F60C888084p0", "0x0.002EA4D9332CABCFB0p0", "0x0.002F3851C530D70E68p0", "0x0.002FCBCAAC193B1AB0p0", "0x0.00305F43E7E608D2ACp0", "0x0.0030F2BD7897711494p0", "0x0.003186375E2DA4BEC4p0", "0x0.003219B198A8D4AFB0p0",
    "0x0.0032AD2C280931C5ECp0", "0x0.003340A70C4EECE020p0", "0x0.0033D422457A36DD1Cp0", "0x0.0034679DD38B409BBCp0", "0x0.0034FB19B6823AFB0Cp0", "0x0.00358E95EE5F56DA24p0", "0x0.003622127B22C51840p0", "0x0.0036B58F5CCCB694B4p0",
    "0x0.0037490C935D5C2EF8p0", "0x0.0037DC8A1ED4E6C690p0", "0x0.00387007FF33873B30p0", "0x0.0039038634796E6C9Cp0", "0x0.00399704BEA6CD3AB4p0", "0x0.003A2A839DBBD48578p0", "0x0.003ABE02D1B8B52D04p0", "0x0.003B51825A9DA01190p0",
    "0x0.003BE502386AC6136Cp0", "0x0.003C78826B2058130Cp0", "0x0.003D0C02F2BE86F0F8p0", "0x0.003D9F83CF45838DD8p0", "0x0.003E330500B57ECA74p0", "0x0.003EC686870EA987A4p0", "0x0.003F5A08625134A66Cp0", "0x0.003FED8A927D5107E4p0",
    "0x0.0040810D17932F8D38p0", "0x0.0041148FF1930117C0p0", "0x0.0041A813207CF688E8p0", "0x0.00423B96A45140C234p0", "0x0.0042CF1A7D1010A550p0", "0x0.0043629EAAB99713F8p0", "0x0.0043F6232D4E04F00Cp0", "0x0.004489A804CD8B1B80p0",
    "0x0.00451D2D31385A7870p0", "0x0.0045B0B2B28EA3E90Cp0", "0x0.0046443888D0984FA0p0", "0x0.0046D7BEB3FE688E98p0", "0x0.00476B453418458878p0", "0x0.0047FECC091E601FE4p0", "0x0.004892533310E93798p0", "0x0.004925DAB1F011B270p0"
   };
   ap_ufixed<61,-9> exp_x_msb_ind_3_m_1 = exp_x_msb_ind_3_m_1_table[x_msb_ind_3];
   ap_ufixed<115,-25> f_x_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_3_m_1 * exp_x_msb_ind_4_lsb_ind_m_1;
   ap_ufixed<59,-9> exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_3_m_1 + exp_x_msb_ind_4_lsb_ind_m_1;
   const static ap_ufixed<67,-1> exp_x_msb_ind_2_m_1_table[256] = {
    "0x0.0p0", "0x0.0049B96285BC0A736p0", "0x0.009388004BE7E5593p0", "0x0.00DD6BDF6FC8EDEABp0", "0x0.01276506106747AA4p0", "0x0.0171737A4E8E5E346p0", "0x0.01BB97424CCD67360p0", "0x0.0205D0642F77E4885p0",
    "0x.02501EE61CA62671Ep0", "0x0.029A82CE3C35CE0DBp0", "0x0.02E4FC22B7CA4FD73p0", "0x0.032F8AE9BACD765C6p0", "0x0.037A2F29726FE5154p0", "0x0.03C4E8E80DA99B612p0", "0x0.040FB82BBD3A77A9Ap0", "0x0.045A9CFAB3AABAAB4p0",
    "0x.04A5975B254B8AE40p0", "0x0.04F0A75348377827Fp0", "0x0.053BCCE95452FF5B2p0", "0x0.05870823834D0E520p0", "0x0.05D25908109F87D7Ap0", "0x0.061DBF9D398FC7D9Dp0", "0x0.06693BE93D2F27BB7p0", "0x0.06B4CDF25C5B82CCDp0",
    "0x.070075BED9BFBAEA4p0", "0x0.074C3354F9D43D40Ap0", "0x0.079806BB02DF8738Ap0", "0x0.07E3EFF73CF6AB87Ap0", "0x0.082FEF0FF1FDD767Bp0", "0x0.087C040B6DA8D7F50p0", "0x0.08C82EEFFD7B9FB28p0", "0x0.09146FC3F0CACC34Cp0",
    "0x.0960C68D98BC2BF2Ep0", "0x0.09AD33534847443EAp0", "0x0.09F9B61B5435D762Cp0", "0x0.0A464EEC13246AE7Ep0", "0x0.0A92FDCBDD82CE006p0", "0x0.0ADFC2C10D94A01AAp0", "0x0.0B2C9DD1FF71D79A4p0", "0x0.0B798F05110748B7Fp0",
    "0x.0BC69660A2172C887p0", "0x0.0C13B3EB1439A82A1p0", "0x0.0C60E7AACADD54194p0", "0x0.0CAE31A62B47C3AC7p0", "0x0.0CFB91E39C960CB66p0", "0x0.0D49086987BD4F4FEp0", "0x0.0D96953E578B3DC88p0", "0x0.0DE4386878A6A4BEAp0",
    "0x.0E31F1EE598FF35E7p0", "0x0.0E7FC1D66AA1C3C87p0", "0x0.0ECDA8271E11639EAp0", "0x0.0F1BA4E6E7EF5CBA0p0", "0x0.0F69B81C3E27FE069p0", "0x0.0FB7E1CD9883E4871p0", "0x0.1006220170A884803p0", "0x0.105478BE4218B2CB7p0",
    "0x.10A2E60A8A352E513p0", "0x0.10F169ECC83D29AA6p0", "0x0.1140046B7D4ED4EA6p0", "0x0.118EB58D2C67E78FCp0", "0x0.11DD7D585A662A9D7p0", "0x0.122C5BD38E0802DB1p0", "0x0.127B51054FECFB3DBp0", "0x0.12CA5CF42A964F780p0",
    "0x.13197FA6AA6776B28p0", "0x0.1368B9235DA6AE6BAp0", "0x0.13B80970D47D85804p0", "0x0.14077095A0F9675B6p0", "0x0.1456EE98570C274EEp0", "0x0.14A6837F8C8C8C138p0", "0x0.14F62F51D936DB71Dp0", "0x0.1545F215D6AD6612Fp0",
    "0x.1595CBD2207913796p0", "0x0.15E5BC8D5409EE22Bp0", "0x0.1635C44E10B7AFD11p0", "0x0.1685E31AF7C24DFD9p0", "0x0.16D618FAAC528672Ap0", "0x0.172665F3D37A6C0F3p0", "0x0.1776CA0D1435F3B24p0", "0x0.17C7454D176B814F4p0",
    "0x.1817D7BA87EC752AAp0", "0x0.1868815C1275B93F8p0", "0x0.18B9423865B04ECDCp0", "0x0.190A1A563231DC114p0", "0x0.195B09BC2A7D3A217p0", "0x0.19AC1071030302FA1p0", "0x0.19FD2E7B72221FACBp0", "0x0.1A4E63E2302856BB6p0",
    "0x.1A9FB0ABF752DA9BEp0", "0x0.1AF114DF83CED8647p0", "0x0.1B42908393BA06A18p0", "0x0.1B94239EE72334542p0", "0x0.1BE5CE38400AD81A5p0", "0x0.1C37905662639F7FEp0", "0x0.1C896A001412FE793p0", "0x0.1CDB5B3C1CF1BF06Bp0",
    "0x.1D2D641146CC91022p0", "0x0.1D7F84865D649A153p0", "0x0.1DD1BCA22E7005D96p0", "0x0.1E240C6B899A96219p0", "0x0.1E7673E94086336D2p0", "0x0.1EC8F32226CB7D849p0", "0x0.1F1B8A1D11FA5C3FAp0", "0x0.1F6E38E0D99A9075Cp0",
    "0x.1FC0FF74572C45177p0", "0x0.2013DDDE6628A071Cp0", "0x0.2066D425E402559C1p0", "0x0.20B9E251B026360EFp0", "0x0.210D0868ABFBC3658p0", "0x0.21604671BAE5C1485p0", "0x0.21B39C73C242C7830p0", "0x0.22070A75A96DD4433p0",
    "0x.225A907E59BEDE81Cp0", "0x0.22AE2E94BE8B6896Ap0", "0x0.2301E4BFC52712F67p0", "0x0.2355B3065CE42F1A7p0", "0x0.23A9996F77145292Cp0", "0x0.23FD98020708EA434p0", "0x0.2451AEC50213CDCA7p0", "0x0.24A5DDBF5F87D312Ep0",
    "0x.24FA24F818B9620F7p0", "0x0.254E847628FF08A1Bp0", "0x0.25A2FC408DB20EAB1p0", "0x0.25F78C5E462F0A48Bp0", "0x0.264C34D653D67439Bp0", "0x0.26A0F5AFBA0D3C70Bp0", "0x0.26F5CEF17E3D5ECF9p0", "0x0.274AC0A2A7D6780E4p0",
    "0x.279FCACA404E5ACCBp0", "0x0.27F4ED6F5321A4CF5p0", "0x0.284A2898EDD45466Ap0", "0x0.289F7C4E1FF25E01Ep0", "0x0.28F4E895FB1041ECEp0", "0x0.294A6D7792CBA238Bp0", "0x0.29A00AF9FCCBD8CFCp0", "0x0.29F5C12450C28DB50p0",
    "0x.2A4B8FFDA86C4D6E8p0", "0x0.2AA1778D1F911F9B4p0", "0x0.2AF777D9D4051DB44p0", "0x0.2B4D90EAE5A909F93p0", "0x0.2BA3C2C7766AE6888p0", "0x0.2BFA0D76AA468CA2Fp0", "0x0.2C5070FFA746441ACp0", "0x0.2CA6ED6995835AEE4p0",
    "0x.2CFD82BB9F26BD0EAp0", "0x0.2D5430FCF0698C518p0", "0x0.2DAAF834B795B88F5p0", "0x0.2E01D86A250697ECCp0", "0x0.2E58D1A46B297F504p0", "0x0.2EAFE3EABE7E5B03Bp0", "0x0.2F070F44559847819p0", "0x0.2F5E53B8691E2A6E5p0",
    "0x.2FB5B14E33CB4BBE3p0", "0x0.300D280CF26FEF065p0", "0x0.3064B7FBE3F1ECFAEp0", "0x0.30BC6122494D4D18Bp0", "0x0.311423876594DF7B7p0", "0x0.316BFF327DF2D6E06p0", "0x0.31C3F42AD9A962D4Ep0", "0x0.321C0277C2134A11Dp0",
    "0x.32742A2082A485035p0", "0x0.32CC6B2C68EAD87CAp0", "0x0.3324C5A2C48E70995p0", "0x0.337D398AE7527BCA2p0", "0x0.33D5C6EC2515C60F8p0", "0x0.342E6DCDD3D3545FDp0", "0x0.34872E374BA3003AFp0", "0x0.34E0082FE6BA136ADp0",
    "0x.3538FBBF016BE3F00p0", "0x0.359208EBFA2A701C4p0", "0x0.35EB2FBE3186FAD90p0", "0x0.3644703D0A32A81BDp0", "0x0.369DCA6FE8FF1986Fp0", "0x0.36F73E5E34DF0B37Bp0", "0x0.3750CC0F56E6F0C1Ep0", "0x0.37AA738ABA4D92580p0",
    "0x.380434D7CC6CAA213p0", "0x0.385E0FFDFCC181BC3p0", "0x0.38B80504BCED8FF00p0", "0x0.391213F380B716895p0", "0x0.396C3CD1BE09C0665p0", "0x0.39C67FA6ECF73FAF1p0", "0x0.3A20DC7A87B7EC3C5p0", "0x0.3A7B53540AAB622AFp0",
    "0x.3AD5E43AF459209E5p0", "0x0.3B308F36C57128AF1p0", "0x0.3B8B544F00CC9C88Ap0", "0x0.3BE6338B2B6E5EB41p0", "0x0.3C412CF2CC83B1910p0", "0x0.3C9C408D6D64D6FC5p0", "0x0.3CF76E629995B0251p0", "0x0.3D52B679DEC65D8F1p0",
    "0x.3DAE18DACCD3DF440p0", "0x0.3E09958CF5C8B5321p0", "0x0.3E652C97EDDD7FB9Bp0", "0x0.3EC0DE034B79A0686p0", "0x0.3F1CA9D6A733DAE2Ep0", "0x0.3F7890199BD2F5FCFp0", "0x0.3FD490D3C64E5D001p0", "0x0.4030AC0CC5CEC11FFp0",
    "0x.408CE1CC3BAEBB1E6p0", "0x0.40E93219CB7B6D1CCp0", "0x0.41459CFD1AF5249CFp0", "0x0.41A2227DD20FFCB02p0", "0x0.41FEC2A39AF480553p0", "0x0.425B7D7622004D04Dp0", "0x0.42B852FD15C6B56D6p0", "0x0.431543402711645D2p0",
    "0x.43724E4708E0FFDB7p0", "0x0.43CF7419706DCC711p0", "0x0.442CB4BF1528509F4p0", "0x0.448A103FB0B9F8866p0", "0x0.44E786A2FF05B9BB0p0", "0x0.454517F0BE28B74ACp0", "0x0.45A2C430AE7AE5F03p0", "0x0.46008B6A928FB075Ep0",
    "0x.465E6DA62F369C48Ep0", "0x0.46BC6AEB4B7BEE3AAp0", "0x0.471A8341B0A94F727p0", "0x0.4778B6B12A46728E1p0", "0x0.47D705418619B8F25p0", "0x0.48356EFA9428D84B1p0", "0x0.4893F3E426B9803ABp0", "0x0.48F2940612520039Ap0",
    "0x.49514F682DB9EDA59p0", "0x0.49B0261251FACA004p0", "0x0.4A0F180C5A60A95E7p0", "0x0.4A6E255E247AD906Ap0", "0x0.4ACD4E0F901C863FEp0", "0x0.4B2C92287F5D65507p0", "0x0.4B8BF1B0D69A58AD0p0", "0x0.4BEB6CB07C7618574p0",
    "0x.4C4B032F59D9D96D8p0", "0x0.4CAAB53559F5F5E9Fp0", "0x0.4D0A82CA6A429492Bp0", "0x0.4D6A6BF67A8051199p0", "0x0.4DCA70C17CB8E46D2p0", "0x0.4E2A9133653FCD395p0", "0x0.4E8ACD542AB2F8995p0", "0x0.4EEB252BC5FB6AF99p0",
    "0x.4F4B98C2324DE92ACp0", "0x0.4FAC281F6D2BA1A4Fp0", "0x0.500CD34B7662D5FC3p0", "0x0.506D9A4E500F84855p0", "0x0.50CE7D2FFE9C122BEp0", "0x0.512F7BF888C1F4791p0", "0x0.519096AFF78A5BCB5p0", "0x0.51F1CD5E564EDDBF2p0",
    "0x.5253200BB2BA1FC90p0", "0x0.52B48EC01CC882005p0", "0x0.53161983A6C8CA1BBp0", "0x0.5377C05E655CCE9E1p0", "0x0.53D983586F7A2235Ep0", "0x0.543B6279DE6ABF4CAp0", "0x0.549D5DCACDCDB3C8Dp0", "0x0.54FF75535B97CD007p0"
   };
   ap_ufixed<67,-1> exp_x_msb_ind_2_m_1 = exp_x_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<126,-10> f_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_2_m_1 * exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   ap_ufixed<65,-1> exp_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_2_m_1 + exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   const static ap_ufixed<66,32> exp_x_msb_ind_1_table[256] = {
    "0x1.000000000p0", "0x1.5561A91BCp0", "0x1.C73D51C54p0", "0x2.5F1258E08p0", "0x3.298B075B4p0", "0x4.378B053ECp0", "0x5.9F9802C8Cp0", "0x7.7FBAAB458p0",
    "0xA.000000000p0", "0xD.55D09B148p0", "0x11.C86531B4Cp0", "0x17.B6B778C40p0", "0x1F.9F6E49910p0", "0x2A.2B6E34724p0", "0x38.3BF01BD84p0", "0x4A.FD4AB0B64p0",
    "0x64.000000000p0", "0x85.5A260ECDCp0", "0xB1.D3F3F10ECp0", "0xED.232AB7A90p0", "0x13C.3A4EDFA98p0", "0x1A5.B24E0C774p0", "0x232.57611671Cp0", "0x2ED.E4EAE71ECp0",
    "0x3E8.000000000p0", "0x535.857C94088p0", "0x6F2.47876A934p0", "0x943.5FAB2C9B4p0", "0xC5A.4714BC9E8p0", "0x1078.F70C7CA94p0", "0x15F7.69CAE0728p0", "0x1D4A.F12D0732Cp0",
    "0x2710.000000000p0", "0x3417.36DDC8558p0", "0x4576.CB4A29C18p0", "0x5CA1.BCAFBE0F8p0", "0x7B86.C6CF5E320p0", "0xA4B9.A67CDE9B4p0", "0xDBAA.21ECC4790p0", "0x124ED.6BC247FB8p0",
    "0x186A0.000000000p0", "0x208E8.24A9D3580p0", "0x2B6A3.F0E5A18ECp0", "0x39E51.5EDD6C9A0p0", "0x4D343.C419ADF30p0", "0x66F40.80E0B210Cp0", "0x894A5.533FACBA4p0", "0xB7146.3596CFD3Cp0",
    "0xF4240.000000000p0", "0x145911.6EA2416F4p0", "0x1B2267.68F84F938p0", "0x242F2D.B4A63E038p0", "0x3040A5.A900CB7F0p0", "0x405885.08C6F4A64p0", "0x55CE75.407CBF46Cp0", "0x726CBE.17E41E45Cp0",
    "0x989680.000000000p0", "0xCB7AAE.52568E584p0", "0x10F580A.19B31BC34p0", "0x169D7C9.0E7E6C220p0", "0x1E28678.9A07F2F6Cp0", "0x2837532.57C58E7F0p0", "0x35A1094.84DF78C38p0", "0x4783F6C.EEE92EB90p0",
    "0x5F5E100.000000000p0", "0x7F2CACF.37618F720p0", "0xA997065.00FF159FCp0", "0xE226DDA.90F039530p0", "0x12D940B6.044F7DA48p0", "0x192293F7.6DB790F54p0", "0x2184A5CD.30BAB7A30p0", "0x2CB27A41.551BD339Cp0",
    "0x3B9ACA00.000000000p0", "0x4F7BEC18.29CF9A750p0", "0x69FE63F2.09F6D83E4p0", "0x8D584A89.A9623D3E0p0", "0xBC7C871C.2B1AE86C4p0", "0xFB59C7AA.492BA9948p0", "0x14F2E7A03.E74B2C5F4p0", "0x1BEF8C68D.531640404p0",
    "0x2540BE400.000000000p0", "0x31AD738F1.A21C08914p0", "0x423EFE774.63A4726F4p0", "0x58572E960.9DD6646C4p0", "0x75CDD4719.AF0D143A8p0", "0x9D181CCA6.DBB49FCD0p0", "0xD17D0C427.08EFBBB80p0", "0x1175B7C185.3EDE8282Cp0",
    "0x174876E800.000000000p0", "0x1F0C683970.551855AD0p0", "0x29675F0A8B.E46C78594p0", "0x37367D1DC6.2A5FEC3A0p0", "0x49A0A4C700.D682CA49Cp0", "0x622F11FE84.950E3E020p0", "0x82EE27A986.595D55300p0", "0xAE992D8F34.74B1191B8p0",
    "0xE8D4A51000.000000000p0", "0x1367C123E63.52F358C14p0", "0x19E09B66976.EC3CB37C0p0", "0x22820E329BD.A7BF3A448p0", "0x2E0466FC608.611BE6E18p0", "0x3D5D6B3F12D.D28E6C148p0", "0x51D4D8C9F3F.7DA553E00p0", "0x6D1FBC7980C.8EEAFB130p0",
    "0x9184E72A000.000000000p0", "0xC20D8B66FE1.3D81778C0p0", "0x102C61201EA5.3A5F02D70p0", "0x159148DFA168.8D7846AE0p0", "0x1CC2C05DBC53.CB1704CFCp0", "0x265A63076BCA.399038CD8p0", "0x3325077E387A.E87546BF0p0", "0x4433D5CBF07D.952DCEBE8p0",
    "0x5AF3107A4000.000000000p0", "0x794877205ECC.670EAB770p0", "0xA1BBCB413274.47B61C654p0", "0xD7ACD8BC4E15.86B2C2CC0p0", "0x11F9B83A95B45.EEE6301D8p0", "0x17F87DE4A35E6.3FA238074p0", "0x1FF724AEE34CD.1494C3758p0", "0x2AA0659F764E7.D3CA13714p0",
    "0x38D7EA4C68000.000000000p0", "0x4BCD4A743B3FC.0692B2A70p0", "0x65155F08BF88A.CD1D1BF4Cp0", "0x86CC0775B0CD7.42FB9BF90p0", "0xB3C13249D90BB.54FDE1260p0", "0xEFB4EAEE61AFE.7C563047Cp0", "0x13FA76ED4E1002.CDCFA296Cp0", "0x1AA43F83A9F10E.45E4C26DCp0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x.000000004p0", "0x.000000004p0", "0x.000000004p0", "0x.000000004p0",
    "0x0.000000008p0", "0x.000000008p0", "0x.00000000Cp0", "0x.000000010p0", "0x.000000014p0", "0x.00000001Cp0", "0x.000000028p0", "0x.000000034p0",
    "0x0.000000044p0", "0x.00000005Cp0", "0x.00000007Cp0", "0x.0000000A4p0", "0x.0000000D8p0", "0x.000000120p0", "0x.000000184p0", "0x.000000204p0",
    "0x0.0000002B0p0", "0x.000000394p0", "0x.0000004C8p0", "0x.00000065Cp0", "0x.00000087Cp0", "0x.000000B50p0", "0x.000000F18p0", "0x.000001420p0",
    "0x0.000001AD8p0", "0x.0000023CCp0", "0x.000002FBCp0", "0x.000003FA8p0", "0x.0000054E4p0", "0x.000007134p0", "0x.0000096F4p0", "0x.00000C94Cp0",
    "0x0.000010C70p0", "0x.0000165F8p0", "0x.00001DD5Cp0", "0x.000027C90p0", "0x.0000350E0p0", "0x.000046BFCp0", "0x.00005E588p0", "0x.00007DCFCp0",
    "0x0.0000A7C5Cp0", "0x.0000DFBA4p0", "0x.00012A588p0", "0x.00018DD9Cp0", "0x.0002128ACp0", "0x.0002C37D4p0", "0x.0003AF73Cp0", "0x.0004EA1D0p0",
    "0x0.00068DB8Cp0", "0x.0008BD470p0", "0x.000BA7754p0", "0x.000F8A814p0", "0x.0014B96C0p0", "0x.001BA2E4Cp0", "0x.0024DA858p0", "0x.003125230p0",
    "0x0.004189374p0", "0x.005764C70p0", "0x.00748A940p0", "0x.009B690C8p0", "0x.00CF3E374p0", "0x.01145CEF0p0", "0x.017089380p0", "0x.01EB735F0p0",
    "0x0.028F5C290p0", "0x.0369EFC58p0", "0x.048D69C70p0", "0x.06121A7D0p0", "0x.08186E274p0", "0x.0ACBA1550p0", "0x.0E655C300p0", "0x.133281B68p0",
    "0x0.199999998p0", "0x.22235DB60p0", "0x.2D8621C70p0", "0x.3CB508E34p0", "0x.50F44D894p0", "0x.6BF44D530p0", "0x.8FF599E10p0", "0x.BFF911208p0"
   };
   ap_ufixed<66,32> exp_x_msb_ind_1 = exp_x_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<131,31> f_x_msb_ind_1_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_1 * exp_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   y = f_x_msb_ind_1_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_1;
  }
  if(I_<33) {
   bool overf = 0;
   VITIS_LOOP_3430_17: for(int j = 63; j >= 31 + I_; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3437_18: for(int j = 63; j >= 31 + I_; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3441_19: for(int j = 30 + I_; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 }
 return r;
}

template<int W, int I>
ap_ufixed<W,I> exp10(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return exp10(xf);
}

template<int I>
ap_int<I> exp10(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return exp10(xf);
}

template<int I>
ap_uint<I> exp10(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return exp10(xf);
}

}
# 1068 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_log_apfixed.h" 1
# 39 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_log_apfixed.h"
namespace log_apfixed_reduce {


template <typename T, int p, int alpha, int size> class log_lut_table { public:
log_lut_table<T,p,alpha,size>();
static const T array [size];};
template <> class log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};

template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <typename T, int p, int alpha, int size> class log0_lut_table { public:
log0_lut_table<T,p,alpha,size>();
static const T array[size];};
template <> class log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();

static const ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

class log_inverse_lut_table { public:
log_inverse_lut_table();
static const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array[64];};


template <typename LOG_TYPE, int p, int alpha, int size, int sizeout>
void range_reduce(ap_ufixed<size, -p> zN, LOG_TYPE &log, ap_ufixed<sizeout, -(p+alpha-1)> &zN1)
{

    const int T1size = 1 << alpha;




    ap_ufixed<alpha, -p> a = zN;
    ap_ufixed<size-alpha, -p-alpha> b = zN;
    ap_ufixed<size+p+2*p+1, 1> zNext = 1+zN;
    int e_shift = (p!=4 || a[a.wl()-1]==1) ? 2*p : 2*p+1;
    ap_ufixed<size+p+1, 1-2*p> eZ = zNext >> e_shift;

    zN1 = ((b + eZ) - a*zN);
    ap_uint<alpha> index = a(alpha-1,0);
    log = log_lut_table<LOG_TYPE, p,alpha,T1size>::array[index];


}




const int p0 = 0;
const int alpha0 = 5;
const int p1 = (alpha0 == 5) ? 4 : (alpha0-2);
const int alpha1 = 4;
const int p2 = p1 + alpha1 - 1;
const int alpha2 = 6;
const int p3 = p2 + alpha2 - 1;
const int alpha3 = 6;
const int p4 = p3 + alpha3 - 1;
const int alpha4 = 6;
const int p5 = p4 + alpha4 - 1;
const int alpha5 = 6;
const int p6 = p5 + alpha5 - 1;
const int alpha6 = 6;
const int p7 = p6 + alpha6 - 1;
const int alpha7 = 6;
const int p8 = p7 + alpha7 - 1;

template <int W_s_> class log_traits{};

template <>
class log_traits<1>{
public:
    const static int we = 6;
    const static int wf = 11;
    const static int org_wf = wf;

    const static int gbits = 1;
    const static int p_generic = p1;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        (void)(log_sum);
        return z1;
    }
};

template <>
class log_traits<2>{
public:
    const static int we = 6;
    const static int wf = 19;
    const static int org_wf = wf;

    const static int gbits = 2;
    const static int p_generic = p2;
    const static int MaxPrecision =wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        return z2;
    }
};

template <>
class log_traits<3>{
public:
    const static int we = 6;
    const static int wf = 33;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p3;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        return z3;
    }
};

template <>
class log_traits<4>{
public:
    const static int we = 6;
    const static int wf = 48;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p4;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        return z4;
    }
};

template <>
class log_traits<5>{
public:
    const static int we = 6;
    const static int wf = 63;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p5;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        return z5;
    }
};

template <>
class log_traits<6>{
public:
    const static int we = 6;
    const static int wf = 76;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p6;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        return z6;
    }
};

template <>
class log_traits<7>{
public:
    const static int we = 6;
    const static int wf = 91;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p7;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        return z7;
    }
};

template <>
class log_traits<8>{
public:
    const static int we = 6;
    const static int wf = 106;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p8;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);
    const static int w8 = w7+2*p7+1-(alpha7-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        ap_ufixed<(w8 < MaxPrecision-p8) ? w8 : (MaxPrecision-p8), -p8> z8;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        range_reduce<LOG_TYPE, p7, alpha7> (z7, logn, z8);
        log_sum += logn;
        return z8;
    }
};
template<int W_, int I_>
ap_fixed<W_,I_> log(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
    if (I_>34) return 0;
    else if (F_>100) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=7) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else r = 4;
        } else if (I_<=10) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else r = 6;
        } else if (I_<=13) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else r = 8;
        } else if (I_<=17) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else r = 11;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else r = 12;
        } else if (I_<=26) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else r = 17;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else r = 21;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x819a1801p0")) r = 21;
            else r = 22;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x2.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x2.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x1.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x1.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.dp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ap0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "-0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1p0")) r = "0x0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.2p0")) r = "0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.9p0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.bp0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.7p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.ap0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.cp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.9p0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.dp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.1p0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.5p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.9p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.9p0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.ep0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.5p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.2p0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.9p0")) r = "0x2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.cp0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.6p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.1p0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.cp0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.9p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.6p0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.3p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.2p0")) r = "0x2.bp0";
            else r = "0x2.cp0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {


            const static int W_s_ = (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;
# 717 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_log_apfixed.h"
            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;




            ap_int<7> b_exp;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
            VITIS_LOOP_729_1: for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
#pragma HLS unroll
 if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }



            const ap_ufixed<MaxPrecision,0> LOG2 = "0x0.B17217F7D1CF79ABC9E3B39803p0";
            ap_fixed<MaxPrecision,6> Elog2 = LOG2 * b_exp;



            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;


            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];


            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;





            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;


            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);


            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base;
            log_base = Elog2 + log_sum + sum;



            ap_fixed<2 + F_, 1> delta = 0;
            delta[delta.wl()-1] = log_base[log_base.wl()-1];
            delta[delta.wl()-delta.iwl()-1] = 1;
            log_base = log_base + ( delta >> F_ );

            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log(xf);
}

template<int I_>
ap_int<I_> log(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log(xf);
}

template<int I_>
ap_uint<I_> log(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> log10(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=9) {
            if (x<=0) {r[W_-1] = 1;}
            else {
                ap_ufixed<8,8> x_s_l = x_s;
                if (x_s_l(7,2)==0) r = 0;
                else if (x_s_l(7,5)==0) r = 1;
                else r = 2;
            }
        } else if (I_<=15) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else r = 4;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else r = 5;
        } else if (I_<=25) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else r = 7;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else r = 9;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xbc7c871cp0")) r = 9;
            else r = 10;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x0.ep0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x0.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x0.ap0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.3p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.8p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.fp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.4p0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.bp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.6p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.5p0")) r = "0x1.2p0";
            else r = "0x1.3p0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {
            const static int W_s_= (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;






            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;





            ap_int<7> b_exp=0;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
            VITIS_LOOP_947_1: for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
#pragma HLS unroll
 if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }

            const ap_ufixed<25,0> LOG1_35_s = 0.3010300099849700927734375;
            const ap_ufixed<43,0> LOG1_35_l = 0.30102999566395283181918784976006;
            ap_fixed<30,5> Elog2_s = LOG1_35_s * b_exp;
            ap_fixed<48,5> Elog2_l = LOG1_35_l * b_exp;


            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;

            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];

            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;




            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;

            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);

            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base = log_sum + sum;

            const ap_ufixed<25,0> LOG1_54_s = 0.4342944920063018798828125;
            const ap_ufixed<43,0> LOG1_54_l = 0.43429448190329367207596078515053;

            if (F_<=16) log_base = Elog2_s + log_base * LOG1_54_s;
            else log_base = Elog2_l + log_base * LOG1_54_l;
# 1005 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_log_apfixed.h"
            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log10(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log10(xf);
}

template<int I_>
ap_int<I_> log10(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log10(xf);
}

template<int I_>
ap_uint<I_> log10(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log10(xf);
}

template<int W, int I>
ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    ap_ufixed<1,1> inc = 1;
    ap_fixed<W+1,I+1> xp1 = x + inc;
    return log(xp1);
}

template<int W, int I>
ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return log1p(xf);
}

template<int I>
ap_int<I> log1p(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return log1p(xf);
}

template<int I>
ap_uint<I> log1p(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return log1p(xf);
}

template<int W,int I>
ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    int F = W - I;
    if(F>32 || I>33) {
        return 0;
    }
    ap_fixed<W+1,I+1> xf;
    if(x>0) {
        xf = x;
    }
    else {
        xf = -x;
    }
    return I + 1 - xf.countLeadingZeros() - 1;
}

template<int W,int I>
ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return ilogb(xf);
}

template<int I>
ap_int<I> ilogb(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return ilogb(xf);
}

template<int I>
ap_uint<I> ilogb(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return ilogb(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> log2(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
            else r = 4;
  } else if (I_<=9) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
            else r = 8;
        } else if (I_<=13) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
            else r = 12;
  } else if (I_<=17) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
            else r = 16;
        } else if (I_<=21) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
            else r = 20;
        } else if (I_<=25) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
            else r = 24;
        } else if (I_<=29) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E6p0")) r = 24;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCp0")) r = 25;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82799p0")) r = 26;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F33p0")) r = 27;
            else r = 28;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E6p0")) r = 24;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCp0")) r = 25;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82799p0")) r = 26;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F33p0")) r = 27;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E66p0")) r = 28;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCCp0")) r = 29;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827999p0")) r = 30;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F333p0")) r = 31;
            else r = 32;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x4.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x3.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x2.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x2.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x1.Bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x1.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x1.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.Dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.Ap0")) r = "-0x0.Bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Bp0")) r = "-0x0.9p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Cp0")) r = "-0x0.7p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Dp0")) r = "-0x0.5p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Ep0")) r = "-0x0.3p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Fp0")) r = "-0x0.1p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.0p0")) r = "0x0.0p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0.1p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.2p0")) r = "0x0.3p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.4p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.4p0")) r = "0x0.5p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x0.6p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.7p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.7p0")) r = "0x0.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.8p0")) r = "0x0.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.9p0")) r = "0x0.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Ap0")) r = "0x0.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Bp0")) r = "0x0.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Cp0")) r = "0x0.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Dp0")) r = "0x0.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Fp0")) r = "0x0.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.0p0")) r = "0x1.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x1.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.3p0")) r = "0x1.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x1.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.6p0")) r = "0x1.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x1.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Ap0")) r = "0x1.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Cp0")) r = "0x1.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Ep0")) r = "0x1.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.0p0")) r = "0x1.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.4p0")) r = "0x1.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.9p0")) r = "0x1.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.Bp0")) r = "0x1.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.Ep0")) r = "0x1.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.1p0")) r = "0x2.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.4p0")) r = "0x2.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.7p0")) r = "0x2.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.Ap0")) r = "0x2.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.Dp0")) r = "0x2.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.1p0")) r = "0x2.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.4p0")) r = "0x2.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.8p0")) r = "0x2.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.Cp0")) r = "0x2.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.0p0")) r = "0x2.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.4p0")) r = "0x2.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.9p0")) r = "0x2.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.Dp0")) r = "0x2.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.2p0")) r = "0x2.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.7p0")) r = "0x2.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.Dp0")) r = "0x2.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.2p0")) r = "0x3.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.8p0")) r = "0x3.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.Ep0")) r = "0x3.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.4p0")) r = "0x3.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.Bp0")) r = "0x3.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xA.2p0")) r = "0x3.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xA.9p0")) r = "0x3.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB.1p0")) r = "0x3.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB.8p0")) r = "0x3.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xC.1p0")) r = "0x3.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xC.9p0")) r = "0x3.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xD.2p0")) r = "0x3.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xD.Bp0")) r = "0x3.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xE.5p0")) r = "0x3.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xE.Fp0")) r = "0x3.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xF.Ap0")) r = "0x3.Fp0";
            else r = "0x4.0p0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {
            const static int W_s_= (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;

            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;

            ap_int<7> b_exp=0;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
            VITIS_LOOP_1371_1: for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
#pragma HLS unroll
 if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }

            ap_fixed<30,5> Elog2_s = b_exp;
            ap_fixed<48,5> Elog2_l = b_exp;


            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;

            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];

            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;




            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;

            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);

            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base = log_sum + sum;

            const ap_ufixed<26,1> LOG1_54_s = "0x1.7154765p0";
            const ap_ufixed<44,1> LOG1_54_l = "0x1.71547652B82Fp0";

            if (F_<=16) log_base = Elog2_s + log_base * LOG1_54_s;
            else log_base = Elog2_l + log_base * LOG1_54_l;



            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log2(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log2(xf);
}

template<int I_>
ap_int<I_> log2(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log2(xf);
}

template<int I_>
ap_uint<I_> log2(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log2(xf);
}

template<int W_, int I_>
ap_fixed<W_,I_> logb(ap_fixed<W_,I_> x) {
 return log2(x);
}

template<int W_, int I_>
ap_ufixed<W_,I_> logb(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return logb(xf);
}

template<int I_>
ap_int<I_> logb(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return logb(xf);
}

template<int I_>
ap_uint<I_> logb(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return logb(xf);
}

}
# 1069 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_sqrt_apfixed.h" 1
# 34 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_sqrt_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 35 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_sqrt_apfixed.h" 2






template <int W_, int I_>
ap_fixed<W_,I_> sqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const int F_ = W_ - I_;
    if (I_>34) return 0;
    else if (F_>32) return 0;


    ap_ufixed<F_+(I_+1)/2,(I_+1)/2> r;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if ((F_==0)&&(I_==2)) {
            r = x_s;
    } else if ((F_==0)&&(I_<=13)) {
        ap_ufixed<W_,I_> x_s_l = x_s + 1;
        ap_ufixed<W_-1,I_-1> x_s_1;
        x_s_1(W_-2,0) = x_s_l(W_-1,1);
        if (I_<=8) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else r = 11;
        } else if (I_<=9) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else r = 16;
        } else {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x88p0")) r = 16;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x99p0")) r = 17;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xabp0")) r = 18;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xbep0")) r = 19;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xd2p0")) r = 20;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xe7p0")) r = 21;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfdp0")) r = 22;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x114p0")) r = 23;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x12cp0")) r = 24;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x145p0")) r = 25;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15fp0")) r = 26;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x17ap0")) r = 27;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x196p0")) r = 28;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1b3p0")) r = 29;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1d1p0")) r = 30;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1f0p0")) r = 31;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x210p0")) r = 32;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x231p0")) r = 33;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x253p0")) r = 34;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x276p0")) r = 35;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x29ap0")) r = 36;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2bfp0")) r = 37;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2e5p0")) r = 38;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x30cp0")) r = 39;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x334p0")) r = 40;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x35dp0")) r = 41;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x387p0")) r = 42;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3b2p0")) r = 43;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3dep0")) r = 44;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x40bp0")) r = 45;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x439p0")) r = 46;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x468p0")) r = 47;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x498p0")) r = 48;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4c9p0")) r = 49;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4fbp0")) r = 50;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x52ep0")) r = 51;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x562p0")) r = 52;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x597p0")) r = 53;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5cdp0")) r = 54;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x604p0")) r = 55;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x63cp0")) r = 56;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x675p0")) r = 57;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6afp0")) r = 58;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6eap0")) r = 59;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x726p0")) r = 60;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x763p0")) r = 61;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7a1p0")) r = 62;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7e0p0")) r = 63;
            else r = 64;
        }
    } else if (F_<=4 && I_<=5) {
            if (x_s==ap_ufixed<W_-1,I_-1>("0x0.0p0")) r = "0x0.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "0x0.4p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x1.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.7p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.fp0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.bp0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ap0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.2p0")) r = "0x2.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.6p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.7p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.cp0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.1p0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.6p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.0p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.6p0")) r = "0x2.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.bp0")) r = "0x2.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.7p0")) r = "0x2.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.dp0")) r = "0x2.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x3.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.9p0")) r = "0x3.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.fp0")) r = "0x3.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.5p0")) r = "0x3.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.cp0")) r = "0x3.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.2p0")) r = "0x3.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.9p0")) r = "0x3.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.0p0")) r = "0x3.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.7p0")) r = "0x3.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.ep0")) r = "0x3.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.5p0")) r = "0x3.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.dp0")) r = "0x3.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.4p0")) r = "0x3.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.cp0")) r = "0x3.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.4p0")) r = "0x3.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.cp0")) r = "0x3.fp0";
            else r = "0x4.0p0";
    } else {

        if (x[W_-1]) return 0;
        if (I_<=0) {
            const static int lsbx = (-I_+2<=W_) ? (W_+I_-2) : 0;
            if ( x(W_-1,lsbx) != 0 ) return 0;
        }

        const static int prcs = (F_+1)*2;
        const static int msbr = (I_>0) ? (I_+1)/2 : 1;
        const static int msbx = (I_>0) ? I_+3 : 4;
        const static int msbm = (I_>0) ? I_+1 : 2;


        ap_ufixed<msbx , msbx> x_l_I = x;
        ap_ufixed< prcs/2, 0> x_l_FH = x;
        ap_ufixed< prcs/2, -prcs/2> x_l_FL = 0;
        ap_ufixed<msbr + prcs , msbr> res = 0;
        ap_ufixed<msbr , msbr> res_I = 0;
        ap_ufixed< prcs/2, 0> res_FH = 0;
# 265 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_sqrt_apfixed.h"
    if (I_>0)
        VITIS_LOOP_266_1: for ( int pos = msbr-1; pos >= 0; pos-- ) {
#pragma HLS unroll
 ap_ufixed<msbm , msbm> mul_I = 0;



            mul_I ( msbr+pos , pos*2+1 ) = res_I ( msbr-1 , pos );



            mul_I [ pos*2 ] = 1;




            if ( x_l_I ( msbr+pos+1 , pos*2 ) >= mul_I ( msbr+pos , pos*2 ) ) {



                ap_ufixed<msbx,msbx> x_l_I_ = x_l_I;
                x_l_I ( msbr+pos+1 , pos*2 ) = x_l_I ( msbr+pos+1 , pos*2 ) - mul_I ( msbr+pos , pos*2 );




                res_I [ pos ] = 1;
            }
        }
        VITIS_LOOP_294_2: for ( int pos = -1; pos >= -F_-1; pos-- ) {
#pragma HLS unroll
 ap_ufixed<msbm + prcs , msbm> mul = 0;




            mul ( msbr+pos + prcs , pos +1 + prcs ) = res_I ( msbr-1 , 0 );
            mul ( pos + prcs , pos*2+1 + prcs ) = res_FH ( -1+prcs/2 , pos+prcs/2 );



            mul [ pos*2 + prcs ] = 1;
            ap_ufixed<msbm , msbm> mul_I = mul;
            ap_ufixed< prcs/2, 0> mul_FH = mul;
            ap_ufixed< prcs/2, -prcs/2> mul_FL = mul;

            ap_ufixed<msbx + prcs , msbx> x_l;
            x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
            x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
            x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );



            if ( (x_l_I>mul_I) || ((x_l_I==mul_I)&&(x_l_FH>mul_FH)) || ((x_l_I==mul_I)&&(x_l_FH==mul_FH)&&(x_l_FL>=mul_FL)) ) {




                ap_ufixed< prcs/2+1 , -prcs/2+1 > x_l_FL_l = x_l_FL;
                if ( x_l_FL < mul_FL ) x_l_FL_l[prcs/2] = 1;
                                                  x_l_FL_l -= mul_FL;




                ap_ufixed< prcs/2+1 , 1 > x_l_FH_l = x_l_FH;
                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_FH_l[prcs/2] = 1;
                ap_ufixed< 1 , -prcs/2+1 > delta = 0;
                if ( x_l_FL < mul_FL ) delta[0] = 1;
                                                                             x_l_FH_l -= delta;
                                                                             x_l_FH_l -= mul_FH;



                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_I --;
                                                                             x_l_I -= mul_I;

                                                                             x_l_FH = x_l_FH_l;
                                                                             x_l_FL = x_l_FL_l;

                ap_ufixed<msbx + prcs , msbx> x_l_ = x_l;
                x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
                x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
                x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );



                res_FH [ pos+prcs/2 ] = 1;
            }
        }



        ap_ufixed< prcs/2+1 , 1 > res_FH_l = res_FH;
        ap_ufixed< prcs/2 , 0 > delta;
                                  delta[delta.wl()-1] = 1;
                                  res_FH_l += ( delta >> F_ );
                                  res_FH = res_FH_l;
        if (res_FH_l[prcs/2]) res_I ++;

        res ( msbr-1 + prcs , prcs ) = res_I ( msbr-1 , 0 );
        res ( -1 + prcs , prcs/2 ) = res_FH ( -1+prcs/2 , 0 );

        r = res;
    }

    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> sqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_int<I_> sqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> sqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}


template <int W_, int I_>
ap_fixed<W_,I_> rsqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 ap_ufixed<W_-1,I_-1> xs = x;
    const int Ix = ( I_ > 1 )? I_-1 : 1;
    ap_ufixed<Ix,Ix> xs_I = xs;
    ap_ufixed<W_-1,I_-1> r;
    const int I = ( I_-1 > W_-I_+1 ) ? I_-1 : W_-I_+1;
    ap_ufixed<I+W_-I_,I> y1;
    ap_ufixed<I+W_-I_,I> y2;
    if ( xs == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        y1 = xs;
    } else {
        y1 = 1;
        y1 = y1/xs;
    }
    y2 = sqrt_fixed(y1);
    if ( y2 == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        r = 1;
        r = r/y2;
    } else {
        r = y2;
    }
    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> rsqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_int<I_> rsqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> rsqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> recip_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if ( x == 0 ) return 0;
    ap_fixed<W_,I_> r = 1;
    return r/x;
}
template<int W_, int I_>
ap_ufixed<W_,I_> recip_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_int<I_> recip_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_uint<I_> recip_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
# 1070 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_round_copysign_apfixed.h" 1
# 35 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_round_copysign_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_round_copysign_apfixed.h" 2

template <int W_, int I_>
ap_fixed<W_,I_> ceil_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    } else {
        if(I_<0) return 0;
        else {
           if ( x(W_-I_-1,0) != 0 ) {
               x(W_-I_-1,0) = 0;
               x += 1;
           }
           return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> ceil_fixed(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_ < 0) return 0;
        else {
           if ( x(W_-I_-1,0) != 0 ) {
               x(W_-I_-1,0) = 0;
               x += 1;
           }
           return x;
        }
    }
}
template <int I_>
ap_int<I_> ceil_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> ceil_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> floor_fixed(ap_fixed<W_,I_> x)
{
    if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            if ( x(W_-I_-1,0) != 0 ) x(W_-I_-1,0) = 0;
            return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> floor_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return floor_fixed(xi);
}
template <int I_>
ap_int<I_> floor_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> floor_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> trunc_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            if ( x(W_-I_-1,0) != 0 ) {
                x(W_-I_-1,0) = 0;
                if ( x[W_-1] )
                    x += 1;
            }
            return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> trunc_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return trunc_fixed(xi);
}
template <int I_>
ap_int<I_> trunc_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> trunc_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> copysign_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y)
{
    x[W_-1] = y[W_-1];
    return x;
}
template <int W_, int I_>
ap_ufixed<W_,I_> copysign_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    (void)(y);
    return x;
}
template <int I_>
ap_int<I_> copysign_fixed(ap_int<I_> x, ap_int<I_> y)
{
    x[I_-1] = y[I_-1];
    return x;
}
template <int I_>
ap_uint<I_> copysign_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    (void)(y);
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> fabs_fixed(ap_fixed<W_,I_> x)
{
    ap_fixed<W_,I_> xs = -x;
                    xs[W_-1] = 0;
    return ( ( x[W_-1] ) ? xs : x );
}
template <int W_, int I_>
ap_ufixed<W_,I_> fabs_fixed(ap_ufixed<W_,I_> x)
{
    return x;
}
template <int I_>
ap_int<I_> fabs_fixed(ap_int<I_> x)
{
    ap_int<I_> xs = -x;
               xs[I_-1] = 0;
    return ( ( x[I_-1] ) ? xs : x );
}
template <int I_>
ap_uint<I_> fabs_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> round_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            ap_ufixed<1, 0> half_val = 0.5;
            ap_ufixed<W_,I_> x_pos = fabs_fixed(x);
            ap_ufixed<W_+1,I_+1> r = x_pos + half_val;
            r(W_-I_-1,0) = 0;
            if(x[W_-1]) return -r;
            else return r;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> round_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return round_fixed(xi);
}
template <int I_>
ap_int<I_> round_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> round_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> rint_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            ap_ufixed<W_, I_> x_p = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
            ap_ufixed<1,0> half_val = 0.5;
            ap_ufixed<W_+1,I_+1> xUp = x_p + half_val;

            if(xUp(W_-I_-1,0) == 0) {

               xUp[W_-I_] = 0;
            } else {
               xUp(W_-I_-1,0) = 0;
            }
            if(x[W_-1]) return -xUp;
            else return xUp;
        }
# 289 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_round_copysign_apfixed.h"
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> rint_fixed(ap_ufixed<W_,I_> x)
{
   ap_fixed<W_+1, I_+1> xi = x;
   return rint_fixed(xi);
}
template <int I_>
ap_int<I_> rint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> rint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> nearbyint_fixed(ap_fixed<W_,I_> x)
{

    return rint_fixed(x);
}
template <int W_, int I_>
ap_ufixed<W_,I_> nearbyint_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return nearbyint_fixed(xi);
}
template <int I_>
ap_int<I_> nearbyint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> nearbyint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
bool signbit_fixed(ap_fixed<W_, I_> x){
    if(x[W_-1]) return true;
    else return false;
}
template <int W_, int I_>
bool signbit_fixed(ap_ufixed<W_, I_> x){
    (void)(x);
    return false;
}

template <int I_>
bool signbit_fixed(ap_int<I_> x){
    if(x[I_-1]) return true;
    else return false;
}

template <int I_>
bool signbit_fixed(ap_uint<I_> x){
    (void)(x);
    return false;
}
namespace fp_internal {
  template<int W, int I>
  ap_fixed<W, I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y){
     const static int F = W - I;
     ap_ufixed<1, -F+1> ulp = 0;
     ulp[0] = 1;
     ap_fixed<W, I> r = 0;
     if(x == y) r = y;
     else if(x < y) r = x + ulp;
     else r = x - ulp;
     return r;
  }
  template<int W, int I>
  ap_ufixed<W, I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
     ap_fixed<W+1, I+1> xi = x;
     ap_fixed<W+1, I+1> yi = y;
     return nextafter(xi, yi);

  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
     ap_fixed<I, I> xi = x;
     ap_fixed<I, I> yi = y;
     return nextafter(xi, yi);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
     ap_fixed<I+1, I+1> xi = x;
     ap_fixed<I+1, I+1> yi = y;
     return nextafter(xi, yi);
  }
  template<int W, int I>
  ap_fixed<W, I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y){
     return nextafter(x,y);
  }
  template<int W, int I>
  ap_ufixed<W, I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y){
     return nextafter(x,y);
  }
}


template <int W, int I>
long long int llround_fixed(ap_fixed<W,I> x){
    return round_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
}


template <int W, int I>
long long int llround_fixed(ap_ufixed<W,I> x){
    return round_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
}


template <int I>
long long int llround_fixed(ap_int<I> x){
    return x;
}


template <int I>
long long int llround_fixed(ap_uint<I> x){
    return x;
}


template <int W, int I>
long int lround_fixed(ap_fixed<W,I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[W-1])? minval : maxval;
    }
    else {
        return round_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
    }
}


template <int W, int I>
long int lround_fixed(ap_ufixed<W,I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) ) {
        return maxval;
    }
    else {
        return round_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
    }
}


template <int I>
long int lround_fixed(ap_int<I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[I-1])? minval : maxval;
    }
    else {
        return x;
    }
}


template <int I>
long int lround_fixed(ap_uint<I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) ) {
        return maxval;
    }
    else {
        return x;
    }
}


template <int W, int I>
long long int llrint_fixed(ap_fixed<W,I> x){
    return rint_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
}


template <int W, int I>
long long int llrint_fixed(ap_ufixed<W,I> x){
    return rint_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
}


template <int I>
long long int llrint_fixed(ap_int<I> x){
    return x;
}


template <int I>
long long int llrint_fixed(ap_uint<I> x){
    return x;
}


template <int W, int I>
long int lrint_fixed(ap_fixed<W,I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[W-1])? minval : maxval;
    }
    else {
        return rint_fixed<W+1, I+1>(ap_fixed<W+1,I+1> (x));
    }
}



template <int W, int I>
long int lrint_fixed(ap_ufixed<W,I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if(x>maxval){
        return maxval;
    }
    else {
        return rint_fixed<W+1, I+1>(ap_ufixed<W+1,I+1> (x));
    }
}


template <int I>
long int lrint_fixed(ap_int<I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x>minval)) {
        return (x[I-1])? minval : maxval;
    }
    else {
        return x;
    }
}


template <int I>
long int lrint_fixed(ap_uint<I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if(x>maxval) {
        return maxval;
    }
    else {
        return x;
    }
}
# 1071 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_pow_apfixed.h" 1
# 37 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_pow_apfixed.h"
namespace pow_apfixed_reduce{
# 52 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_,int I_>
ap_fixed<W_,I_> pow(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y) {
    const static int F_ = W_ - I_;

    if (I_>34) return 0;
    else if (F_>33) return 0;
    ap_fixed<W_,I_> r = 0;

    bool r_is_neg = 0;
    bool y_is_frac = 0;

    if (F_>0&&y(F_-1,0)>0)
        y_is_frac =1;
    if (x==0) {

        if (y==0&&I_>1) {
            return 1;

        } else if (y>0) {
            return 0;
        } else {

            VITIS_LOOP_74_1: for (int j = 0; j < W_-1; j++){
#pragma HLS unroll
 r[j] = 1;
            }
               r[W_-1] = 0;
            return r;
        }
    } else if (x<0) {

        if (y_is_frac) return 0;

        else {
            if (y==0||(I_>1&&y[F_]==0))
                r_is_neg = 0;
            else
                r_is_neg = 1;
        }
    }

    ap_fixed<W_+1,I_+1> x_e_1 = x;

    ap_fixed<W_+1,I_+1> x_p = 0;
    x_p = fabs_fixed(x_e_1);


    const static int E_l = I_+2;
    const static int F_l = W_+E_l;

    const static int I_l = I_+1>6?I_+1:6;
    const static int W_l = F_l + I_l;

    ap_fixed<W_l,I_l> x_l = x_p;


    ap_fixed<W_l,I_l> ln_x = log_apfixed_reduce::log(x_l);


    ap_fixed<F_l+6,6> ln_x_s = ln_x;


    const static int FI_m = W_+2;

    const static int I_m = I_>6 ? I_ : 6;
    const static int WI_m = FI_m + I_m;
    const static int WO_m = F_ + I_m;
    ap_fixed<F_l+W_+6,6+I_> mul_y_ln = ln_x_s * y;
# 129 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_pow_apfixed.h"
    ap_fixed<WO_m,I_m> exp_r = 0;
    ap_fixed<W_,I_> r_1 = 0;
    bool m_overf = 0;
    bool e_overf = 0;
    bool overf = 0;

    VITIS_LOOP_135_2: for (int j = F_l+F_+I_m-1; j < F_l+W_+5; j++){
#pragma HLS unroll
 if (mul_y_ln[F_l+W_+5]!=mul_y_ln[j])
            m_overf = 1;
    }

    if (!m_overf) {

        ap_fixed<WI_m,I_m> mul_y_ln_s = mul_y_ln;

        exp_r = exp_reduce::exp_core<WO_m,I_m,WI_m>(mul_y_ln_s);


        if (I_<I_m) {
            VITIS_LOOP_149_3: for (int j = WO_m-1; j >= W_-1; j--) {
#pragma HLS unroll
 if (exp_r[j])
                    e_overf=1;
            }
        }
        r_1 = exp_r;
    }

    if (e_overf||(m_overf&&!mul_y_ln[F_l+W_+5])) {
        overf = 1;
    }

    if (r_is_neg) {

        if (overf) {
            r=0;
            r[W_-1]=1;

        } else {
            if (r_1!=0) {
                r = -r_1;
                r[W_-1] = 1;
            }
        }

    } else {

        if(overf) {
            r[W_-1] = 0;
            VITIS_LOOP_179_4: for (int j = W_-2; j >= 0; j--){
#pragma HLS unroll
 r[j] = 1;
            }

        } else {
            r = r_1;
        }
    }

    return r;
}
# 210 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_, int I_>
ap_fixed<W_,I_> pown(ap_fixed<W_,I_> x, int n) {






    const static int F_ = W_ - I_;

    if (I_>34) return 0;
    else if (F_>33) return 0;

    ap_fixed<W_,I_> r = 0;
    ap_fixed<32,32> n_fix = n;

    bool x_sig = x[W_-1];
    bool n_sig = n_fix[31];
    bool n_is_odd = n_fix[0];
    bool x_gt_0 = 0;

    if (x == 0 && n_fix != 0) r = 0;
    else if(n_fix == 0) r = 1;
    else if(n_fix == 1) r = x;

    else if(x == 1) r = 1;
    else if(x == -1) {
        if(n_is_odd) r = -1;
        else r = 1;
    }else {
# 266 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_pow_apfixed.h"
       const static int we_n = F_ > 26? 32 : 6 + F_;

       const static int wf_log = I_ == F_>26 ? (31+F_+I_) : (we_n-1+F_+I_);
       const static int I_e = I_>6 ? I_ : 6;
       const static int WI_e = I_e + wf_log - we_n;
       const static int WO_e = F_ + I_e;
       ap_fixed<33,33> max_n = 0;
       max_n[we_n-1] = 1;
       ap_ufixed<32,32> n_pos = fabs_fixed(ap_fixed<33,33>(n));
       ap_ufixed<WO_e,I_e> exp_r=0;
       bool ovf = 0;
       ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
       if(x_pos>1) x_gt_0 = 1;
       ap_fixed<32,32> min_n = -max_n;
       if(n_fix != -1 && ((n >= max_n) || (n < min_n))){

           ovf = 1;
       }else {
           ap_fixed<we_n, we_n> n_s = n;





           const static int I_l = I_+1 < 6? 6 : I_+1;
           ap_fixed<wf_log+I_l,I_l> x_e = x_pos;
           const static int we_log = 6;
           ap_fixed<wf_log+we_log,we_log> x_log = log_apfixed_reduce::log(x_e);






           ap_fixed<wf_log+we_log, we_log+we_n> x_log_mul_n = n_s * x_log;






           VITIS_LOOP_307_1: for(int i = wf_log+we_log-2; i > WI_e - 2; --i) {
#pragma HLS unroll
 if(x_log_mul_n[i] != x_log_mul_n[wf_log+we_log-1]){

                    ovf = 1;
                }
           }
           ap_fixed<WI_e, I_e> x_log_mul_n_1 = x_log_mul_n ;





           exp_r = exp_reduce::exp_core<WO_e,I_e,WI_e>(x_log_mul_n_1);





           if (I_<I_e) {
               VITIS_LOOP_327_2: for (int j = WO_e-1; j >= W_-1; j--) {
#pragma HLS unroll

 if (exp_r[j])
                       ovf=1;
               }
           }
       }
       if(ovf) {
           if(x_gt_0 ^ n_sig) {

               if(x_sig && !n_is_odd) {
                   r[W_-1] = 1;
               } else {
                   VITIS_LOOP_341_3: for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[W_-1] = 1;
                   }
               }
           }
       } else {
           if(x_sig && n_is_odd) r = -exp_r;
           else r = exp_r;
       }
   }
   return r;
}
# 380 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_,int I_>
ap_fixed<W_,I_> rootn(ap_fixed<W_,I_> x, int n) {






    const static int F_ = W_ - I_;

    if (I_ > 34) return 0;
    else if (F_ > 33) return 0;

    ap_fixed<W_,I_> r = 0;
    ap_fixed<32,32> n_fix = n;
    bool n_is_odd = 0;
    if(n_fix[0]) n_is_odd = 1;

    if (x == 0) r = 0;
    else if(n_fix == 0) r = 0;
    else if(n_fix == 1) r = x;
    else if(n_fix == -1) r = ap_fixed<W_, I_>(1)/x;
    else if(x<0 && !n_is_odd) r = 0;
    else if(x==1) r = 1;
    else if(x==-1 && n_is_odd) r = -1;
    else {

        ap_ufixed<W_,I_> x_p = fabs_fixed((ap_fixed<W_+1,I_+1>)x);


        const static int m_we = (F_+1)/2 > (I_+1)/2? (F_+1)/2:(I_+1)/2;
        const static int we = I_ > m_we ? m_we : I_;
        const static int E_l = we - 1;
        const static int F_l = F_ + E_l;

        const static int I_l = I_ + 1 > 6 ? I_ + 1 : 6;
        const static int W_l = F_l + I_l;

        ap_fixed<W_l,I_l> x_l = x_p;


        ap_fixed<W_l,I_l> ln_x = log_apfixed_reduce::log(x_l);






        ap_fixed<F_l+6,6> ln_x_s = ln_x;


        const static int FI_d = F_l + 1;

        const static int I_d = we+1 > 5? we+1 : 5;
        const static int WI_d = FI_d + I_d;
        const static int WO_d = F_ + I_d;
        ap_fixed<F_l+6,5> divd_n_ln = ln_x_s / n_fix;







        ap_fixed<WI_d,I_d> divd_n_ln_s = divd_n_ln;





        ap_ufixed<WO_d, I_d> exp_r = exp_reduce::exp_core<WO_d,I_d,WI_d>(divd_n_ln_s);





        bool ovf = 0;

        if(I_ < I_d) {
           VITIS_LOOP_459_1: for (int j =WO_d-1; j >= W_-1; j--) {
#pragma HLS unroll

 if (exp_r[j])
                   ovf=1;
           }
        }
        if(!ovf) {
           if(x[W_-1]&&n_is_odd) r = -exp_r;
           else r = exp_r;
        }else {
           if(x[W_-1]&&n_is_odd) {
              r[W_-1] = 1;
           } else {
              VITIS_LOOP_473_2: for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[i] = 1;
              }
           }
        }
   }
   return r;
}


template<int W_, int I_>
ap_ufixed<W_,I_> pow(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y) {
    ap_fixed<W_+1,I_+1> xf = x;
    ap_fixed<W_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_int<I_> pow(ap_int<I_> x, ap_int<I_> y) {
    ap_fixed<I_,I_> xf = x;
    ap_fixed<I_,I_> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_uint<I_> pow(ap_uint<I_> x,ap_uint<I_> y) {
    ap_fixed<I_+1,I_+1> xf = x;
    ap_fixed<I_+1,I_+1> yf = y;
    return pow(xf,yf);
}


template<int W_, int I_>
ap_fixed<W_,I_> powr(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y) {
    return pow(x,y);
}

template<int W_, int I_>
ap_ufixed<W_,I_> powr(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y) {
    ap_fixed<W_+1,I_+1> xf = x;
    ap_fixed<W_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_int<I_> powr(ap_int<I_> x, ap_int<I_> y) {
    ap_fixed<I_,I_> xf = x;
    ap_fixed<I_,I_> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_uint<I_> powr(ap_uint<I_> x,ap_uint<I_> y) {
    ap_fixed<I_+1,I_+1> xf = x;
    ap_fixed<I_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int W_, int I_>
ap_ufixed<W_,I_> pown(ap_ufixed<W_, I_> x, int n) {
    ap_fixed<W_+1,I_+1> xi = x;
    return pown(xi, n);
}

template<int I_>
ap_int<I_> pown(ap_int<I_> x, int n) {
   ap_fixed<I_, I_> xi = x;
   return pown(xi, n);
}

template<int I_>
ap_uint<I_> pown(ap_uint<I_> x, int n) {
   ap_fixed<I_+1, I_+1> xi = x;
   return pown(xi, n);
}
template<int W_, int I_>
ap_ufixed<W_,I_> rootn(ap_ufixed<W_, I_> x, int n) {
    ap_fixed<W_+1,I_+1> xi = x;
    return rootn(xi, n);
}

template<int I_>
ap_int<I_> rootn(ap_int<I_> x, int n) {
   ap_fixed<I_, I_> xi = x;
   return rootn(xi, n);
}

template<int I_>
ap_uint<I_> rootn(ap_uint<I_> x, int n) {
   ap_fixed<I_+1, I_+1> xi = x;
   return rootn(xi, n);
}
}
# 1072 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_diff_apfixed.h" 1
# 35 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_diff_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_diff_apfixed.h" 2
# 46 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fdim_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> x_overf = 0;
    ap_fixed<W_ ,I_ > xs = 0;
        bool overf = 0;

    if(x > y)
    {
        x_overf = x - y;
        overf = x_overf[W_-1];
        if(overf) {
            VITIS_LOOP_59_1: for (int i = 0; i < W_-1; i++){
#pragma HLS UNROLL
 xs[i] = 1;
            }
            xs[W_-1] = 0;
        }
        else{
            x_overf[W_] = 0;
            xs = x_overf;
        }
    }
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fdim_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x > y){ xs = x - y; }
    return xs;
}
template <int I_>
ap_int<I_> fdim_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return fdim_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> fdim_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x > y) { xs = x - y; }
    return xs;
}
# 102 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmax_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmax_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmax_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmax_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
# 143 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmin_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmin_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmin_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmin_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
# 186 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> maxmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs >= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }

    if(xs_t[W_-1])
    {
            VITIS_LOOP_209_1: for (int i = 0; i < W_-1; i++){
#pragma HLS UNROLL
 xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> maxmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> maxmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return maxmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> maxmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
# 252 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> minmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs <= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }
    if(xs_t[W_-1])
    {
            VITIS_LOOP_274_1: for (int i = 0; i < W_-1; i++){
#pragma HLS UNROLL
 xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> minmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> minmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return minmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> minmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
# 1073 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_comparison_apfixed.h" 1
# 35 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_comparison_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_comparison_apfixed.h" 2



template<int W, int I>
bool isgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isgreaterequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreaterequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isless_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isless_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
# 1074 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_frexp_apfixed.h" 1
# 41 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_frexp_apfixed.h"
namespace frexp_internal {

template<int W, int I>
ap_fixed<W,I> frexp(ap_fixed<W,I> x,
                    ap_fixed<W,I>* exp){
    if(I<0) {
           *exp = 0;
           return x;
    }
    static const int F = W - I;
    static const int we = W > 5 ? W/2 : 3;

    ap_int<we> e = 0;
    ap_ufixed<W, I> r_p = 0;

    ap_fixed<W+1, I+1> xi = x;
    ap_ufixed<W, I> x_p = fabs_fixed(xi);

    static const ap_uint<3> clz_table_6bit[64] = {7, 6, 5, 5, 4, 4, 4, 4,
                                                  3, 3, 3, 3, 3, 3, 3, 3,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1};
    int pos = 0;

    static const int loop_nm = W > 6 ? (W + 5)/6 : 1;
    CLZ_LOOP:
    for(int l = loop_nm; l > 0; --l){
#pragma HLS pipeline II=1
 ap_uint<6> t = 0;
       if(l*6 > W) t = x_p(W - 1, (l - 1) * 6);
       else t = x_p(l * 6 - 1, (l - 1) * 6);
       if((t & 0x3f) != 0) {
          pos = l * 6 - clz_table_6bit[t];
          break;
       }
    }
    if(pos >= 0) {
        e = pos + 1 - F;
        if(F > 0) {
           ap_uint<we> w_f = (pos + 1) < F ? (pos + 1) : F;
           r_p(F - 1,F - w_f) = x_p(pos, pos + 1 - w_f);
        }
    } else {
        e = 0;
        r_p = 0;
    }
    ap_fixed<W, I> r = 0;
    if(xi[W-1]) r = -r_p;
    else r = r_p;



    *exp = e;
    return r;
}
template<int W, int I>
ap_ufixed<W,I> frexp(ap_ufixed<W,I> x,
                     ap_ufixed<W,I>* exp){
    ap_fixed<W+1, I+1> xe = x;
    ap_fixed<W+1, I+1> ee = 0;
    ap_fixed<W+1, I+1> r = frexp(xe,&ee);
    *exp = ee;
    return r;
}
template<int I>
ap_uint<I> frexp(ap_uint<I> x,
                 ap_uint<I>* exp) {
   ap_fixed<I, I> xe = x;
   ap_fixed<I, I> ee = 0;
   ap_fixed<I, I> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
template<int I>
ap_int<I> frexp(ap_int<I> x,
                ap_int<I>* exp) {
   ap_fixed<I+1, I+1> xe = x;
   ap_fixed<I+1, I+1> ee = 0;
   ap_fixed<I+1, I+1> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
}
# 1075 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_modf_apfixed.h" 1
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_modf_apfixed.h"
namespace modf_internal {
template<int W, int I>
ap_fixed<W,I> modf(ap_fixed<W, I> x,
                   ap_fixed<W, I>* int_part){
    ap_fixed<W, I> frac_part = 0;
    if(W == I) {
        *int_part = x;
        frac_part = 0;
    } else if(I > 0) {
        ap_fixed<W+1, I+1> xi = x;
        ap_ufixed<W, I> x_p = fabs_fixed(xi);
        frac_part(W - I - 1,0) = x_p(W - I - 1,0);
        if(xi[W-1]) frac_part = - frac_part;
        *int_part = x_p(W-1, W-I);
        if(xi[W-1]) *int_part = -*int_part;
    } else {
       *int_part = 0;
       frac_part = x;
    }
    return frac_part;
}
template<int W, int I>
ap_ufixed<W,I> modf(ap_ufixed<W, I> x,
                    ap_ufixed<W, I>* int_part){
    ap_fixed<W+1, I+1> xi = x;
    ap_fixed<W+1, I+1> ii = 0;
    ap_fixed<W+1, I+1> r = modf(xi, &ii);
    *int_part = ii;
    return r;
}
template<int I>
ap_int<I> modf(ap_int<I> x,
               ap_int<I>* int_part){
    *int_part = x;
    return 0;
}
template<int I>
ap_uint<I> modf(ap_uint<I> x,
                ap_uint<I>* int_part){
    *int_part = x;
    return 0;
}
}
# 1076 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_isequal_isnotequal_apfixed.h" 1
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_isequal_isnotequal_apfixed.h"
template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}



template <int I_>
bool generic_isequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}
# 1077 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_all_any_apfixed.h" 1
# 35 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_all_any_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_all_any_apfixed.h" 2


template <int W_, int I_>
bool generic_all(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_42_1: for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_all(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_53_1: for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_int<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_64_1: for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_75_1: for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_any(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_86_1: for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int W_, int I_>
bool generic_any(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_97_1: for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_int<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_108_1: for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_119_1: for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}
# 1078 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_select_bitselect_apfixed.h" 1
# 35 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_select_bitselect_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_select_bitselect_apfixed.h" 2
# 62 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_select_bitselect_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> generic_bitselect(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y, ap_fixed<W_,I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}


template <int W_, int I_>
ap_ufixed<W_,I_> generic_bitselect(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}


template <int I_>
ap_int<I_> generic_bitselect(ap_int<I_> x,ap_int<I_> y, ap_int<I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}

template <int I_>
ap_uint<I_> generic_bitselect(ap_uint<I_> x,ap_uint<I_> y, ap_uint<I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}
# 1079 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_erf_apfixed.h" 1
# 35 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_erf_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_erf_apfixed.h" 2



namespace erf_erfc_fixed {

    namespace {
 template <typename T> class coeff { };

 template <> class coeff<double> {

 public:
   static const double tiny;
   static const double one_over_two;
   static const double one;
   static const double two;
   static const double erx;
   static const double efx;
   static const double efx8;
   static const double pp[5];
   static const double qq[6];
   static const double pa[7];
   static const double qa[7];
   static const double ra[8];
   static const double sa[9];
   static const double rb[7];
   static const double sb[8];
 };
 const double coeff<double>::tiny = 1e-300;
 const double coeff<double>::one_over_two= 5.00000000000000000000e-01;
 const double coeff<double>::one = 1.00000000000000000000e+00;
 const double coeff<double>::two = 2.00000000000000000000e+00;

 const double coeff<double>::erx = 8.45062911510467529297e-01;



 const double coeff<double>::efx = 1.28379167095512586316e-01;
 const double coeff<double>::efx8= 1.02703333676410069053e+00;
 const double coeff<double>::pp[] =
   {1.28379167095512558561e-01,
    -3.25042107247001499370e-01,
    -2.84817495755985104766e-02,
    -5.77027029648944159157e-03,
    -2.37630166566501626084e-05};
 const double coeff<double>::qq[] =
   {0.0, 3.97917223959155352819e-01,
    6.50222499887672944485e-02,
    5.08130628187576562776e-03,
    1.32494738004321644526e-04,
    -3.96022827877536812320e-06};



 const double coeff<double>::pa[] =
   {-2.36211856075265944077e-03,
    4.14856118683748331666e-01,
    -3.72207876035701323847e-01,
    3.18346619901161753674e-01,
    -1.10894694282396677476e-01,
    3.54783043256182359371e-02,
    -2.16637559486879084300e-03};
 const double coeff<double>::qa[] =
   {0.0, 1.06420880400844228286e-01,
    5.40397917702171048937e-01,
    7.18286544141962662868e-02,
    1.26171219808761642112e-01,
    1.36370839120290507362e-02,
    1.19844998467991074170e-02};



 const double coeff<double>::ra[] =
   {-9.86494403484714822705e-03,
    -6.93858572707181764372e-01,
    -1.05586262253232909814e+01,
    -6.23753324503260060396e+01,
    -1.62396669462573470355e+02,
    -1.84605092906711035994e+02,
    -8.12874355063065934246e+01,
    -9.81432934416914548592e+00};
 const double coeff<double>::sa[] =
   {0.0,1.96512716674392571292e+01,
    1.37657754143519042600e+02,
    4.34565877475229228821e+02,
    6.45387271733267880336e+02,
    4.29008140027567833386e+02,
    1.08635005541779435134e+02,
    6.57024977031928170135e+00,
    -6.04244152148580987438e-02};



 const double coeff<double>::rb[] =
   {-9.86494292470009928597e-03,
    -7.99283237680523006574e-01,
    -1.77579549177547519889e+01,
    -1.60636384855821916062e+02,
    -6.37566443368389627722e+02,
    -1.02509513161107724954e+03,
    -4.83519191608651397019e+02};
 const double coeff<double>::sb[] =
   {0.0,3.03380607434824582924e+01,
    3.25792512996573918826e+02,
    1.53672958608443695994e+03,
    3.19985821950859553908e+03,
    2.55305040643316442583e+03,
    4.74528541206955367215e+02,
    -2.24409524465858183362e+01};
# 245 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_erf_apfixed.h"
 template<typename T> class erf_traits{ };
# 267 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_erf_apfixed.h"
 template<> class erf_traits<double> {
 public:
   static const uint64_t mask;
   static const uint32_t segment[10];
 };
 const uint64_t erf_traits<double>::mask = 0xffffffff00000000;
 const uint32_t erf_traits<double>::segment[10] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3e300000,
  0x00800000,
  0x3ff40000,
  0x40180000,
  0x4006DB6E,
  63,
  32
   };

 template<typename T> class erfc_traits{};
# 308 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_erf_apfixed.h"
 template<> class erfc_traits<double>{
 public:
   static const uint32_t segment[11];
 };
 const uint32_t erfc_traits<double>::segment[11] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3c700000,
  0x3fd00000,
  0x3ff40000,
  0x403c0000,
  0x4006DB6D,
  0x40180000,
  63,
  32
   };
  }
# 346 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erf(ap_fixed<W_,I_> x_fixed )
{
    int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
 int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
      fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erf_traits<double>::segment[8],erf_traits<double>::segment[9]);
    hx = tmp.to_int();
 ix = hx & erf_traits<double>::segment[0];






    if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
 }

 if(ix>=erf_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>((double)1.0 +coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::one/x-(double)1.0);
 }

 if(ix < erf_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erf_traits<double>::segment[3]) {
  if (ix < erf_traits<double>::segment[2])
    return ap_fixed<W_,I_>(((double)0.125)*((double)8.0*x+coeff<double>::efx8*x));
  return ap_fixed<W_,I_>(x + coeff<double>::efx*x);
   }
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z* coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   return ap_fixed<W_,I_>(x + x*y);
 }
 if(ix < erf_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;

      s = fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::erx + P/Q);
      else return ap_fixed<W_,I_>(-coeff<double>::erx - P/Q);
 }
 if (ix >= erf_traits<double>::segment[6]) {
   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::tiny-coeff<double>::one);
 }
 x = fp_abs.to_ieee();
  s = coeff<double>::one/(x*x);
 if(ix< erf_traits<double>::segment[7]) {






   double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
   R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sa[1]; s4 = s2*s2;
   R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
   S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
   R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
   S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
   R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
   S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
   R = R1 + s2*R2 + s4*R3 + s6*R4;
   S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

 } else {






   double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
   R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sb[1]; s4 = s2*s2;
   R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
   S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
   R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
   S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
   S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
   R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
   S = S1 + s2*S2 + s4*S3 + s6*S4;

 }
 z = x;

    fp_struct<double> fp_z(z);
    ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
    fp_struct<double> fp_z_new(data);
    z = fp_z_new.to_ieee();


    ap_fixed<W_, I_> r_fixed = exp_reduce::exp(ap_fixed<W_, I_>(-z*z-(double)0.5625))*exp_reduce::exp(ap_fixed<W_, I_>((z-x)*(z+x)+R/S));
 r = r_fixed.to_double();

 if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-r/x);
    else return ap_fixed<W_,I_>(r/x-coeff<double>::one);
  }


template <int W_, int I_>
ap_ufixed<W_,I_> erf(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erf(xs);
}

template <int I_>
ap_int<I_> erf(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erf(xs);
}

template <int I_>
ap_uint<I_> erf(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erf(xs);
}
# 513 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erfc(ap_fixed<W_,I_> x_fixed)
{
#pragma HLS PIPELINE II=1
 int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
    int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
    fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erfc_traits<double>::segment[9],erfc_traits<double>::segment[10]);
    hx = tmp.to_int();
 ix = hx & erfc_traits<double>::segment[0];
 if(ix>=erfc_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>(coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::two + coeff<double>::one/x);

 }

 if(ix < erfc_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erfc_traits<double>::segment[3])
  return ap_fixed<W_,I_>(coeff<double>::one-x);
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z*coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   if(ix < erfc_traits<double>::segment[4]) {
  return ap_fixed<W_,I_>(coeff<double>::one-(x+x*y));
   } else {
  r = x*y;
  r += (x-coeff<double>::one_over_two);
  return ap_fixed<W_,I_>(coeff<double>::one_over_two - r) ;
   }
 }
 if(ix < erfc_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;
   s =fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) {
  z = coeff<double>::one-coeff<double>::erx;
        return ap_fixed<W_,I_>(z - P/Q);
   } else {
  z = coeff<double>::erx+P/Q; return ap_fixed<W_,I_>(coeff<double>::one+z);
   }
 }
 if (ix < erfc_traits<double>::segment[6]) {
   x = fp_abs.to_ieee();
   s = coeff<double>::one/(x*x);
   if(ix< erfc_traits<double>::segment[7]) {






  double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
     R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
     S1 = coeff<double>::one+s*coeff<double>::sa[1]; s4 = s2*s2;
     R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
     S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
     R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
     S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
     R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
     S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
     R = R1 + s2*R2 + s4*R3 + s6*R4;
     S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

   } else {
  double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
  if(hx<0&&ix>=erfc_traits<double>::segment[8]) return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);






  R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
  S1 = coeff<double>::one+s*coeff<double>::sb[1]; s4 = s2*s2;
  R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
  S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
  R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
  S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
  S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
  R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
  S = S1 + s2*S2 + s4*S3 + s6*S4;

   }
   z = x;

   fp_struct<double> fp_z(z);
   ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
   fp_struct<double> fp_z_new(data);
   z = fp_z_new.to_ieee();


   ap_fixed<W_, I_> r_fixed = exp_reduce::exp((ap_fixed<W_, I_>)(-z*z-(double)0.5625))*exp_reduce::exp((ap_fixed<W_, I_>)((z-x)*(z+x)+R/S));
   double r = r_fixed.to_double();
   double r_x = r/x;
   if(hx>0) {





        if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
        }
  return ap_fixed<W_,I_>(r_x);
   } else
  return ap_fixed<W_,I_>(coeff<double>::two-r_x);
 } else {
   if(hx>0) return ap_fixed<W_,I_>(coeff<double>::tiny*coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);
 }

}
template <int W_, int I_>
ap_ufixed<W_,I_> erfc(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erfc(xs);
}

template <int I_>
ap_int<I_> erfc(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erfc(xs);
}

template <int I_>
ap_uint<I_> erfc(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erfc(xs);
}

}
# 1080 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h" 1
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 41 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h" 2



namespace hls_internal{

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_divide(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        if(y==0){




                return 0;

        } else{
     return(x/y);
        }
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_divide(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
     ap_fixed<W_+1,I_+1> x1 = x;
     ap_fixed<W_+1,I_+1> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int I_>
    ap_int<I_> generic_divide(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> x1 = x;
     ap_fixed<I_,I_> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int I_>
    ap_uint<I_> generic_divide(ap_uint<I_> x, ap_uint<I_> y){
     ap_ufixed<I_,I_> x1 = x;
     ap_ufixed<I_,I_> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_fmod(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
        ap_ufixed<W_,I_> y_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)y);


        if(x_pos==0 || y_pos==0) return 0;
     else if(x_pos == y_pos) return 0;
        else if(x_pos < y_pos) return x;
        else {
            ap_uint<W_> x_int = 0;
            ap_uint<W_> y_int = 0;
            x_int(W_-1,0) = x_pos(W_-1,0);
            y_int(W_-1,0) = y_pos(W_-1,0);






            ap_uint<W_> d = x_int/y_int;

            ap_uint<W_> rem = x_int - d*y_int;

            ap_fixed<W_,I_> r = 0;
            r(W_-1,0) = rem(W_-1,0);
            if(x[W_-1]) return -r;
            else return r;
        }
    }


    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_fmod(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
        ap_fixed<W_+1,I_+1> xi = x;
        ap_fixed<W_+1,I_+1> yi = y;
        return generic_fmod(xi,yi);
    }

    template <int I_>
    ap_int<I_> generic_fmod(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_fmod(xi,yi);
    }

    template <int I_>
    ap_uint<I_> generic_fmod(ap_uint<I_> x, ap_uint<I_> y){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_fmod(xi,yi);
    }


    template <int W_, int I_>
    ap_fixed<W_,I_> generic_remquo(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, int* quo){
        ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
        ap_ufixed<W_,I_> y_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)y);
        if(x_pos==0 || y_pos==0) {
           *quo = 0;
           return 0;
        } else if(x_pos == y_pos) {
           if(x[W_-1]==y[W_-1]) *quo = 1;
           else *quo = -1;
           return 0;
        }

        else {
            ap_uint<W_> x_int = 0;
            ap_uint<W_> y_int = 0;
            x_int(W_-1,0) = x_pos(W_-1,0);
            y_int(W_-1,0) = y_pos(W_-1,0);





            ap_uint<W_> d = x_int/y_int;
            ap_uint<W_> rem = x_int - d*y_int;

            ap_uint<W_> y_half = 0;
            y_half(W_-2,0) = y_int(W_-1,1);
            ap_uint<1> r_sig = x[W_-1];
            if(rem > y_half) {
                rem = y_int - rem;
                d++;
                if(x[W_-1]) r_sig = 0;
                else r_sig = 1;
            }

            if(x[W_-1]==y[W_-1]) *quo = d;
            else *quo = -d;
            ap_fixed<W_,I_> r = 0;
            r(W_-1,0) = rem(W_-1,0);
            if(r_sig) return -r;
            else return r;
        }
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_remquo(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, int* quo){
     ap_fixed<W_+1,I_+1> xi = x;
     ap_fixed<W_+1,I_+1> yi = y;
     return generic_remquo(xi,yi,quo);
    }

    template <int I_>
    ap_int<I_> generic_remquo(ap_int<I_> x, ap_int<I_> y, int* quo){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_remquo(xi,yi,quo);
    }

    template <int I_>
    ap_uint<I_> generic_remquo(ap_uint<I_> x, ap_uint<I_> y, int* quo){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_remquo(xi,yi,quo);
    }


    template <int W_, int I_>
    ap_fixed<W_,I_> generic_remainder(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        int quo = 0;
        return generic_remquo(x, y, &quo);
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_remainder(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
        ap_fixed<W_+1, I_+1> xi = x;
        ap_fixed<W_+1, I_+1> yi = y;
        return generic_remainder(xi,yi);
    }

    template <int I_>
    ap_int<I_> generic_remainder(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_remainder(xi,yi);
    }

    template <int I_>
    ap_uint<I_> generic_remainder(ap_uint<I_> x, ap_uint<I_> y){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_remainder(xi,yi);
    }
}
# 1081 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_lgamma_apfixed.h" 1
# 35 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_lgamma_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_lgamma_apfixed.h" 2

# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_traits.h" 1
# 37 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_traits.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 38 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_traits.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_x_complex.h" 1
# 42 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_x_complex.h"
namespace std {
template<typename _Tp> class complex;
}

namespace hls {
# 59 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_x_complex.h"
template<typename T> class x_complex {

  private:
    T re, im;

  public:

    typedef x_complex<T> MULT_RT;

    x_complex() {};
    x_complex(const T& r, const T& i) { re = r; im = i; };
    x_complex(const T& r) { re = r; im = 0; };
    x_complex(const std::complex<T> &z) : re(z.real()),im(z.imag()) {}
    template<typename T2>
    x_complex(const x_complex<T2> &z) : re(z.real()),im(z.imag()) {};


    inline T real() const { return(re); };
    inline T& real() { return(re); };

    inline void real(const T& r) { re = r; };

    inline T imag() const { return(im); };
    inline T& imag() { return(im); };

    inline void imag(const T& i) { im = i; };


    inline x_complex<T>& operator= (const T& rhs) {
      re = rhs; im = 0; return *this; };
    inline x_complex<T>& operator= (const x_complex<T>& rhs) {
      re = rhs.real(); im = rhs.imag(); return *this; };
    template<typename T2>
    inline x_complex<T>& operator= (const x_complex<T2>& rhs) {
      re = rhs.real(); im = rhs.imag(); return *this; };


    inline x_complex<T>& operator*= (const T& rhs) {
      re *= rhs;
      im *= rhs;
      return *this;
    };
    inline x_complex<T>& operator*= (const x_complex<T>& rhs) {
      T tmp1 = re*rhs.real();
      T tmp2 = im*rhs.imag();
      T tmp3 = re*rhs.imag();
      T tmp4 = im*rhs.real();
      re = tmp1 - tmp2;
      im = tmp3 + tmp4;
      return *this;
    };
    template<typename T2>
    inline x_complex<T>& operator*= (const x_complex<T2>& rhs) {
      x_complex<T> tmp(rhs.real(), rhs.imag());
      *this *= tmp;
      return *this;
    };

    inline MULT_RT operator* (const T& rhs) {
      x_complex_mult_real:;
      x_complex<T> tmp(*this);
      tmp *= rhs;
      return tmp;
    };
    inline MULT_RT operator* (const x_complex<T>& rhs) {
      x_complex_mult_complex:;
      x_complex<T> tmp(*this);
      tmp *= rhs;
      return tmp;
    }
    template<typename T2>
    inline MULT_RT operator* (const x_complex<T2>& rhs) {
      x_complex_mult_complex:;
      x_complex<T> tmp(rhs.real(), rhs.imag());
      MULT_RT res = *this * tmp;
      return res;
    };


    inline x_complex<T>& operator/= (const T& rhs) {;
      re /= rhs;
      im /= rhs;
      return *this;
    };
    inline x_complex<T>& operator/= (const x_complex<T>& rhs) {
      x_complex<T> conj ( rhs.real(), -rhs.imag());
      x_complex<T> a = (*this)*conj;
      x_complex<T> b = conj*rhs;
      re = a.real() / b.real();
      im = a.imag() / b.real();
      return *this;
    };
    template<typename T2>
    inline x_complex<T>& operator/= (const x_complex<T2>& rhs) {
      x_complex<T> tmp(rhs.real(), rhs.imag());
      *this /= tmp;
      return *this;
    };

    inline x_complex<T> operator/ (const T& rhs) {
      x_complex<T> tmp(*this);
      tmp /= rhs; return tmp;
    };
    inline x_complex<T> operator/ (const x_complex<T>& rhs) {
      x_complex<T> tmp(*this);
      tmp /= rhs;
      return tmp;
    };
    template<typename T2>
    inline x_complex<T> operator/ (const x_complex<T2>& rhs) {
      x_complex<T> tmp(*this);
      tmp /= rhs;
      return tmp;
    };


    inline x_complex<T>& operator+= (const T& rhs) {
      re += rhs;
      return *this;
    };
    inline x_complex<T> operator+= (const x_complex<T>& rhs) {
      re += rhs.real();
      im += rhs.imag();
      return *this;
    };
    template<typename T2>
    inline x_complex<T> operator+= (const x_complex<T2>& rhs) {
      re += rhs.real();
      im += rhs.imag();
      return *this; };

    inline x_complex<T> operator+ (const T& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp += rhs;
      return tmp;
    };
    inline x_complex<T> operator+ (const x_complex<T>& rhs) {
       x_complex<T> tmp ;
       tmp = *this;
       tmp += rhs;
       return tmp;
    };
    template<typename T2>
    inline x_complex<T> operator+ (const x_complex<T2>& rhs) {
       x_complex<T> tmp ;
       tmp = *this;
       tmp += rhs;
       return tmp;
    };



    inline x_complex<T>& operator-= (const T& rhs) {
      re -= rhs;
      return *this;
    }
    inline x_complex<T>& operator-= (const x_complex<T>& rhs) {
      re -= rhs.real();
      im -= rhs.imag();
      return *this;
    };
    template<typename T2>
    inline x_complex<T>& operator-= (const x_complex<T2>& rhs) {
      re -= rhs.real();
      im -= rhs.imag();
      return *this;
    };

    inline x_complex<T> operator- (const T& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp -= rhs;
      return tmp;
    };
    inline x_complex<T> operator- (const x_complex<T>& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp -= rhs;
      return tmp;
    };
    template<typename T2>
    inline x_complex<T> operator- (const x_complex<T2>& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp -= rhs;
      return tmp;
    };

    inline x_complex<T> operator- () {
      x_complex<T> tmp(*this);
      tmp.real(-real());
      tmp.imag(-imag());
      return tmp;
    };


  x_complex<T> &operator=(const std::complex<T> &t) {
    re = t.real();
    im = t.imag();
    return *this;
  }

  operator std::complex<T> () const {
    return std::complex<T>(re, im);
  }

  std::complex<T> to_std_complex(){
     return std::complex<T>(re ,im);
  }
# 281 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_x_complex.h"
  };


  template<typename T>
  inline bool operator== (const T& lhs, const x_complex<T>& rhs) {
    return (lhs == rhs.real()) && (0 == rhs.imag());
  }
  template<typename T>
  inline bool operator== (const x_complex<T>& lhs, const T& rhs) {
    return (lhs.real() == rhs) && (lhs.imag() == 0);
  }
  template<typename T>
  inline bool operator== (const x_complex<T>& lhs, const x_complex<T>& rhs) {
    return (lhs.real() == rhs.real()) && (lhs.imag() == rhs.imag());
  }

  template<typename T>
  inline bool operator!= (const T& lhs, const x_complex<T>& rhs) {
    return (lhs != rhs.real()) || (0 != rhs.imag());
  }
  template<typename T>
  inline bool operator!= (const x_complex<T>& lhs, const T& rhs) {
    return (lhs.real() != rhs) || (lhs.imag() != 0);
  }
  template<typename T>
  inline bool operator!= (const x_complex<T>& lhs, const x_complex<T>& rhs) {
    return (lhs.real() != rhs.real()) || (lhs.imag() != rhs.imag());
  }

  template<typename T>
  x_complex<T> x_neg(x_complex<T> &din) {
    x_complex<T> tmp;
    tmp.real(-din.real());
    tmp.imag(-din.imag());
    return(tmp);
  }

  template<typename T>
  x_complex<T> x_conj_sq(x_complex<T> &din) {
    x_conj_sq_complex:;
    return ( (din.real()*din.real()) + (din.imag()*din.imag()));
  }

  template<typename T>
  x_complex<T> x_conj(const x_complex<T> &din) {
    x_conj_complex:;
    x_complex<T> tmp;
    tmp.real(din.real());
    tmp.imag(-din.imag());
    return(tmp);
  }



  template<typename T>
  x_complex<T> x_conj(x_complex<T> &din) {
    const x_complex<T> tmp = din;
    return(x_conj(tmp));
  }

  template<int W, int I> void set_to_one(x_complex<ap_fixed<W,I> > &a) {
    ap_int<W> tmp_sat = ((ap_int<W-I+1>)1<<(W-I)) - 1;
    ap_fixed<W,I> tmp;
    tmp.range() = tmp_sat;
    a = tmp;
  }

  template<typename T>
  T x_real(const x_complex<T> &din) {
    return(din.real());
  }

  template<typename T>
  T x_imag(const x_complex<T> &din) {
    return(din.imag());
  }

  template<typename T1>
  typename x_complex<T1>::MULT_RT operator* (const T1& lhs, x_complex<T1>& rhs) {
    return (rhs*lhs);
  }

}
# 39 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_traits.h" 2





namespace hls
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
# 69 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_traits.h"
};
template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };
# 102 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_traits.h"
template<>
struct x_traits< char , char > : public x_traits_default< char > {};

template<>
struct x_traits< char , signed char > : public x_traits_default< signed char > {};

template<>
struct x_traits< char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< char , short > : public x_traits_default< short > {};

template<>
struct x_traits< char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< char , int > : public x_traits_default< int > {};

template<>
struct x_traits< char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< char , long > : public x_traits_default< long > {};

template<>
struct x_traits< char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< char , half > : public x_traits_default< float > {};

template<>
struct x_traits< char , float > : public x_traits_default< float > {};

template<>
struct x_traits< char , double > : public x_traits_default< double > {};

template<>
struct x_traits< signed char , char > : public x_traits_default< signed char > {};

template<>
struct x_traits< signed char , signed char > : public x_traits_default< signed char > {};

template<>
struct x_traits< signed char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< signed char , short > : public x_traits_default< short > {};

template<>
struct x_traits< signed char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< signed char , int > : public x_traits_default< int > {};

template<>
struct x_traits< signed char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< signed char , long > : public x_traits_default< long > {};

template<>
struct x_traits< signed char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< signed char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< signed char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< signed char , half > : public x_traits_default< float > {};

template<>
struct x_traits< signed char , float > : public x_traits_default< float > {};

template<>
struct x_traits< signed char , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned char , char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , signed char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , short > : public x_traits_default< short > {};

template<>
struct x_traits< unsigned char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned char , int > : public x_traits_default< int > {};

template<>
struct x_traits< unsigned char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned char , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned char , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned char , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned char , double > : public x_traits_default< double > {};

template<>
struct x_traits< short , char > : public x_traits_default< short > {};

template<>
struct x_traits< short , signed char > : public x_traits_default< short > {};

template<>
struct x_traits< short , unsigned char > : public x_traits_default< short > {};

template<>
struct x_traits< short , short > : public x_traits_default< short > {};

template<>
struct x_traits< short , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< short , int > : public x_traits_default< int > {};

template<>
struct x_traits< short , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< short , long > : public x_traits_default< long > {};

template<>
struct x_traits< short , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< short , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< short , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< short , half > : public x_traits_default< float > {};

template<>
struct x_traits< short , float > : public x_traits_default< float > {};

template<>
struct x_traits< short , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned short , char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , signed char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , unsigned char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , int > : public x_traits_default< int > {};

template<>
struct x_traits< unsigned short , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned short , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned short , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned short , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned short , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned short , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned short , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned short , double > : public x_traits_default< double > {};

template<>
struct x_traits< int , char > : public x_traits_default< int > {};

template<>
struct x_traits< int , signed char > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned char > : public x_traits_default< int > {};

template<>
struct x_traits< int , short > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned short > : public x_traits_default< int > {};

template<>
struct x_traits< int , int > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< int , long > : public x_traits_default< long > {};

template<>
struct x_traits< int , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< int , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< int , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< int , half > : public x_traits_default< float > {};

template<>
struct x_traits< int , float > : public x_traits_default< float > {};

template<>
struct x_traits< int , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned int , char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , signed char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , short > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned short > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned int , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned int , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned int , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned int , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned int , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned int , double > : public x_traits_default< double > {};

template<>
struct x_traits< long , char > : public x_traits_default< long > {};

template<>
struct x_traits< long , signed char > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned char > : public x_traits_default< long > {};

template<>
struct x_traits< long , short > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned short > : public x_traits_default< long > {};

template<>
struct x_traits< long , int > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned int > : public x_traits_default< long > {};

template<>
struct x_traits< long , long > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< long , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< long , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< long , half > : public x_traits_default< float > {};

template<>
struct x_traits< long , float > : public x_traits_default< float > {};

template<>
struct x_traits< long , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned long , char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , signed char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , short > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned short > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , int > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned int > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned long , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned long , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned long , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned long , double > : public x_traits_default< double > {};

template<>
struct x_traits< ap_slong , char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , signed char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , short > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned short > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , int > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned int > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , long > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned long > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_slong , half > : public x_traits_default< float > {};

template<>
struct x_traits< ap_slong , float > : public x_traits_default< float > {};

template<>
struct x_traits< ap_slong , double > : public x_traits_default< double > {};

template<>
struct x_traits< ap_ulong , char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , signed char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , short > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned short > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , int > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned int > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , long > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned long > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , ap_slong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , half > : public x_traits_default< float > {};

template<>
struct x_traits< ap_ulong , float > : public x_traits_default< float > {};

template<>
struct x_traits< ap_ulong , double > : public x_traits_default< double > {};

template<>
struct x_traits< half , char > : public x_traits_default< float > {};

template<>
struct x_traits< half , signed char > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned char > : public x_traits_default< float > {};

template<>
struct x_traits< half , short > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned short > : public x_traits_default< float > {};

template<>
struct x_traits< half , int > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned int > : public x_traits_default< float > {};

template<>
struct x_traits< half , long > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned long > : public x_traits_default< float > {};

template<>
struct x_traits< half , ap_slong > : public x_traits_default< float > {};

template<>
struct x_traits< half , ap_ulong > : public x_traits_default< float > {};

template<>
struct x_traits< half , half > : public x_traits_default< half > {};

template<>
struct x_traits< half , float > : public x_traits_default< float > {};

template<>
struct x_traits< half , double > : public x_traits_default< double > {};

template<>
struct x_traits< float , char > : public x_traits_default< float > {};

template<>
struct x_traits< float , signed char > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned char > : public x_traits_default< float > {};

template<>
struct x_traits< float , short > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned short > : public x_traits_default< float > {};

template<>
struct x_traits< float , int > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned int > : public x_traits_default< float > {};

template<>
struct x_traits< float , long > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned long > : public x_traits_default< float > {};

template<>
struct x_traits< float , ap_slong > : public x_traits_default< float > {};

template<>
struct x_traits< float , ap_ulong > : public x_traits_default< float > {};

template<>
struct x_traits< float , half > : public x_traits_default< float > {};

template<>
struct x_traits< float , float > : public x_traits_default< float > {};

template<>
struct x_traits< float , double > : public x_traits_default< double > {};

template<>
struct x_traits< double , char > : public x_traits_default< double > {};

template<>
struct x_traits< double , signed char > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned char > : public x_traits_default< double > {};

template<>
struct x_traits< double , short > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned short > : public x_traits_default< double > {};

template<>
struct x_traits< double , int > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned int > : public x_traits_default< double > {};

template<>
struct x_traits< double , long > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned long > : public x_traits_default< double > {};

template<>
struct x_traits< double , ap_slong > : public x_traits_default< double > {};

template<>
struct x_traits< double , ap_ulong > : public x_traits_default< double > {};

template<>
struct x_traits< double , half > : public x_traits_default< double > {};

template<>
struct x_traits< double , float > : public x_traits_default< double > {};

template<>
struct x_traits< double , double > : public x_traits_default< double > {};





template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <int,DIM>:x_traits_d_default<int, DIM> {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<typename T>
struct x_traits<x_complex<T>, x_complex<T> > {
    typedef x_complex<T> ADD_T;
    typedef x_complex<T> SAT_T;
    typedef x_complex<T> MULT_T;
    typedef x_complex<T> MADD_T;
    typedef x_complex<int> INT_T;
    typedef x_complex<float_struct<24,8> > FLOAT_STRUCT_T;
};



template<int W1, int I1, int W2, int I2>
struct x_traits<x_complex<ap_fixed<W1,I1> >,x_complex<ap_fixed<W2,I2> > > {
    typedef x_complex<ap_fixed<((I1) > (I2) ? (I1) : (I2))+1+((W1-I1) > (W2-I2) ? (W1-I1) : (W2-I2)),((I1) > (I2) ? (I1) : (I2))+1> > ADD_T;
    typedef x_complex<ap_fixed<W1,I1,AP_RND,AP_SAT> > SAT_T;
    typedef x_complex<ap_fixed<W1+W2+1,I1+I2+1> > MULT_T;
    typedef x_complex<ap_fixed<W1+W2+2,I1+I2+2> > MADD_T;
    typedef x_complex<ap_fixed<(2*W1)+1,(2*I1)+1> > CONJ_SQ_T;
    typedef x_complex<int> INT_T;
    typedef x_complex<float_struct<24,8> > FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<x_complex<ap_int<W1> >,x_complex<ap_int<W2> > > {
    typedef x_complex<ap_int<((W1) > (W2) ? (W1) : (W2))+1> > ADD_T;
    typedef x_complex<ap_int<W1> > SAT_T;
    typedef x_complex<ap_int<W1+W2+1> > MULT_T;
    typedef x_complex<ap_int<W1+W2+2> > MADD_T;
    typedef x_complex<ap_int<(2*W1)+1> > CONJ_SQ_T;
    typedef x_complex<int> INT_T;
    typedef x_complex<float_struct<24,8> > FLOAT_STRUCT_T;
};



template<int DIM, typename T>
struct x_traits_d <x_complex<T>,DIM> {
    typedef x_complex<T> ACCUM_T;
    typedef x_complex<T> ACCUM2_T;
    typedef x_complex<ap_int<25+DIM> > ADD_TREE_T;
};

template<int DIM, int W, int I>
struct x_traits_d <x_complex<ap_fixed<W,I> >,DIM> {
    typedef x_complex<ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value> > ACCUM_T;
    typedef x_complex<ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value> > ACCUM2_T;
};

}



namespace hlstmp
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
# 944 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/utils/x_hls_traits.h"
};

template<>
struct x_traits<double, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<>
struct x_traits<float, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<>
struct x_traits<half, half> : public x_traits_default<half> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };

template<>
struct x_traits<double, float> : public x_traits_default<double> { };

template<>
struct x_traits<float, double> : public x_traits_default<double> { };

template<>
struct x_traits<double, half> : public x_traits_default<double> { };

template<>
struct x_traits<half, double> : public x_traits_default<double> { };

template<>
struct x_traits<int, int> : public x_traits_default<int> { };

template<>
struct x_traits<unsigned int, unsigned int> : public x_traits_default<unsigned int> { };

template<>
struct x_traits<int64_t, int64_t> : public x_traits_default<int64_t> { };

template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<typename T>
struct x_traits<std::complex<T>, std::complex<T> > {
    typedef std::complex<T> ADD_T;
    typedef std::complex<T> SAT_T;
    typedef std::complex<T> MULT_T;
    typedef std::complex<T> MADD_T;
    typedef std::complex<int> INT_T;
    typedef std::complex<float_struct<24,8> > FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <int,DIM>:x_traits_d_default<int, DIM> {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int DIM, typename T>
struct x_traits_d <std::complex<T>, DIM> {
    typedef std::complex<T> ACCUM_T;
    typedef std::complex<T> ACCUM2_T;
    typedef std::complex<ap_int<25+DIM> > ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

}
# 38 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_lgamma_apfixed.h" 2


namespace lgamma_fixed {

template <int W, int I> ap_fixed<W, I> lgamma_generic(ap_fixed<W, I> x_fixed) {
#pragma HLS pipeline

 double x = x_fixed.to_double();
  double r = hls::lgamma(x);
  fp_struct<double> out(r);
  ap_ufixed<W+1, I+1> ret = 1;
  int F = W - I;
  if (F > 52) F = 52;
  if (W > I) ret(F - 1, 0) = out.sig(52 - 1, 52 - F);
  ret = (ret << (out.exp - fp_struct<double>::EXP_BIAS));
  return ap_fixed<W, I>(ret);
}

template <int W, int I> ap_ufixed<W, I> lgamma_generic(ap_ufixed<W, I> x) {
  ap_fixed<W + 1, I + 1> xf = x;
  return lgamma_generic(xf);
}
template <int I_> ap_int<I_> lgamma_generic(ap_int<I_> x) {
  ap_fixed<I_, I_> xf = x;
  return lgamma_generic(xf);
}
template <int I_> ap_uint<I_> lgamma_generic(ap_uint<I_> x) {
  ap_fixed<I_ + 1, I_ + 1> xf = x;
  return lgamma_generic(xf);
}


template <int W, int I> ap_fixed<W, I> lgamma_r_generic(ap_fixed<W, I> x, int *signgamp) {
  *signgamp = 1;
  return lgamma_generic(x);
}

template <int W, int I> ap_ufixed<W, I> lgamma_r_generic(ap_ufixed<W, I> x, int *signgamp) {
  ap_fixed<W + 1, I + 1> xf = x;
  return lgamma_r_generic(xf, signgamp);
}

template <int I_> ap_int<I_> lgamma_r_generic(ap_int<I_> x, int *signgamp) {
  ap_fixed<I_, I_> xf = x;
  return lgamma_r_generic(xf, signgamp);
}

template <int I_> ap_uint<I_> lgamma_r_generic(ap_uint<I_> x, int *signgamp) {
  ap_fixed<I_ + 1, I_ + 1> xf = x;
  return lgamma_r_generic(xf, signgamp);
}

}
# 1082 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_tgamma_apfixed.h" 1
# 35 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_tgamma_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_tgamma_apfixed.h" 2





namespace tgamma_fixed {

template <int W, int I> ap_fixed<W, I> tgamma_generic(ap_fixed<W, I> x_fixed) {
#pragma HLS pipeline

 double x = x_fixed.to_double();
  double r = hls::tgamma(x);
  fp_struct<double> out(r);
  ap_ufixed<W+1, I+1> ret = 1;
  int F = W - I;
  if (F > 52) F = 52;
  if (W > I) ret(F - 1, 0) = out.sig(52 - 1, 52 - F);
  ret = (ret << (out.exp - fp_struct<double>::EXP_BIAS));
  return ap_fixed<W, I>(ret);
}

template <int W, int I> ap_ufixed<W, I> tgamma_generic(ap_ufixed<W, I> x) {
  ap_fixed<W + 1, I + 1> xf = x;
  return tgamma_generic(xf);
}
template <int I_> ap_int<I_> tgamma_generic(ap_int<I_> x) {
  ap_fixed<I_, I_> xf = x;
  return tgamma_generic(xf);
}
template <int I_> ap_uint<I_> tgamma_generic(ap_uint<I_> x) {
  ap_fixed<I_ + 1, I_ + 1> xf = x;
  return tgamma_generic(xf);
}

}
# 1083 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_fract_apfixed.h" 1








namespace hls_fract {

template <int W_, int I_>
ap_fixed<W_,I_> generic_fract(ap_fixed<W_,I_> x){
 if (W_==I_)return 0;
 ap_fixed<W_-I_+1,1> x1=x;
 ap_fixed<W_-I_+1,1> x2=x1+ap_int<2>(1);
 return x[W_-1]?x2:x1;
}

template <int W_, int I_>
ap_ufixed<W_,I_> generic_fract(ap_ufixed<W_,I_> x){
 ap_fixed<W_+1,I_+1> x1=x;
 return generic_fract(x1);
}

template <int I_>
ap_int<I_> generic_fract(ap_int<I_> x){
 ap_fixed<I_,I_> x1 = x;
 return generic_fract(x1);
}

template <int I_>
ap_uint<I_> generic_fract(ap_uint<I_> x){
 ap_ufixed<I_,I_> x1 = x;
 return generic_fract(x1);
}
}
# 1084 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_mad_apfixed.h" 1




namespace hls_mad {

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_mad(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, ap_fixed<W_,I_> z){
        const int F_ = W_ - I_;
        ap_fixed<2*W_, 2*I_> mul = x * y;

        ap_fixed<2, -F_> delta = 0;
        delta[0] = 1;
        delta[1] = mul[2*W_-1];

        mul += delta;

        ap_fixed<W_+1, I_+1> mul_s = mul;
        ap_fixed<W_+1, I_+1> sum = mul_s + z;
        ap_fixed<W_,I_> r = 0;

        if(sum[W_-1]!=sum[W_]) {
           VITIS_LOOP_23_1: for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[i] = !sum[W_];
           }
           r[W_-1] = sum[W_];
        } else {
           r = sum;
        }
        return r;
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_mad(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z){
        ap_fixed<W_+1, I_+1> xi = x;
        ap_fixed<W_+1, I_+1> yi = y;
        ap_fixed<W_+1, I_+1> zi = z;
        return generic_mad(xi, yi, zi);
    }

    template <int I_>
    ap_int<I_> generic_mad(ap_int<I_> x, ap_int<I_> y, ap_int<I_> z){
        ap_fixed<I_, I_> xi = x;
        ap_fixed<I_, I_> yi = y;
        ap_fixed<I_, I_> zi = z;
        return generic_mad(xi, yi, zi);
    }

    template <int I_>
    ap_uint<I_> generic_mad(ap_uint<I_> x, ap_uint<I_> y, ap_uint<I_> z){
        ap_fixed<I_+1,I_+1> xi = x;
        ap_fixed<I_+1,I_+1> yi = y;
        ap_fixed<I_+1,I_+1> zi = z;
        return generic_mad(xi,yi,zi);
    }
}
# 1085 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cbrt_apfixed.h" 1
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cbrt_apfixed.h"
namespace cbrt_internal{
template <int W, int I>
ap_fixed<W, I> cbrt_fixed(ap_fixed<W,I> x) {






   const int F = W - I;
   if(I > 33) return 0;
   else if(F > 32) return 0;

   ap_fixed<W+1, I+1> xi = x;
   ap_ufixed<W, I> x_p = fabs_fixed(xi);





   ap_ufixed<F +(I+2)/3, (I+2)/3> r = 0;;
      const static int prcs = (F+1)*3;
      const static int msbr = (I>0)? (I+2)/3 : 1;
      ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq = 0;
      ap_ufixed<msbr+prcs+1, msbr+1> res = 0;
      ap_ufixed<3*msbr+prcs+4, 3*msbr+4> x_rem = x_p;
      VITIS_LOOP_66_1: for(int pos = msbr - 1 ; pos >= -F-1; pos--) {
          ap_ufixed<3*msbr+prcs+2, 3*msbr+2> mul1a = 0;
          ap_ufixed<3*msbr+prcs+1, 3*msbr+1> mul1b = 0;




          mul1a(pos+2*msbr+prcs+2, prcs+3*pos+3) = resq(prcs+2*msbr+1, prcs+2*pos+2);

          mul1b(pos+2*msbr+prcs+1, prcs+3*pos+2) = resq(prcs+2*msbr+1, prcs+2*pos+2);



          ap_ufixed<3*msbr+prcs, 3*msbr> mul2a = 0;
          ap_ufixed<3*msbr+prcs-1, 3*msbr-1> mul2b = 0;

          mul2a(pos*2+msbr+prcs+1, pos*3+2+prcs) = res(msbr+prcs, pos+1+prcs);

          mul2b(pos*2+msbr+prcs, pos*3+1+prcs) = res(msbr+prcs, pos+1+prcs);

          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulL = 0;
          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulH = 0;


          mulL(pos*2+msbr+prcs+3, pos*3+1+prcs) = mul2b(pos*2+msbr+prcs, pos*3+1+prcs) + mul2a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1b(pos*2+msbr+prcs+1,pos*3+1+prcs);

          mulH(pos+2*msbr+prcs+3, pos*2+msbr+prcs+2) = mulL(pos*2+msbr+prcs+3, pos*2+msbr+prcs+2) + mul1a(pos+2*msbr+prcs+2,pos*2+msbr+prcs+2) + mul1b(pos+2*msbr+prcs+1,pos*2+msbr+prcs+2);
          mulL[3*pos+prcs] = 1;







          bool cond1 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) > mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond2 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) == mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond3 = (x_rem(pos*2+msbr+prcs+1,pos*3+prcs) >= mulL(pos*2+msbr+prcs+1,pos*3+prcs));
          if(cond1 | (cond2 & cond3)) {
             ap_ufixed<3*msbr+prcs+3,3*msbr+3> x_rem_L = 0;
             x_rem_L(pos*2+msbr+prcs+1, pos*3+prcs) = x_rem(pos*2+msbr+prcs+1, pos*3+prcs);

             x_rem_L[pos*2+msbr+prcs+2] = cond3? 0 : 1;
             x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) = x_rem(pos+2*msbr+prcs+4, pos*2+msbr+prcs+2) - mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2) - x_rem_L(pos*2+msbr+prcs+2,pos*2+msbr+prcs+2);
             x_rem(pos*2+msbr+prcs+1,pos*3+prcs) = x_rem_L(pos*2+msbr+prcs+2, pos*3+prcs) - mulL(pos*2+msbr+prcs+1,pos*3+prcs);





             ap_ufixed<2*msbr+prcs+1,2*msbr+1> mul1 = 0;
             mul1(pos+msbr+prcs+1, 2*pos+2+prcs) = res(msbr+prcs, pos+1+prcs);
             ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq_L = 0;
             resq_L(pos+msbr+prcs+2,2*pos+2+prcs) = resq(pos+msbr+prcs+1,2*pos+2+prcs) + mul1(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(pos+msbr+prcs+1,2*pos+2+prcs) = resq_L(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(2*msbr+prcs+1,pos+msbr+2+prcs) = resq(2*msbr+prcs+1,pos+msbr+2+prcs) + resq_L(pos+msbr+2+prcs,pos+msbr+2+prcs);
             resq[2*pos+prcs] = 1;
             res[pos+prcs] = 1;
         }
# 133 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_cbrt_apfixed.h"
      }





      ap_ufixed<1,-F-1> delta;
      delta[0] = 1;
      ap_ufixed<msbr+F+1,msbr> res_s = res;
      res_s += delta;
      r = res_s;
      if(x[W-1]) return -r;
      else return r;
}

template<int W, int I>
ap_ufixed<W, I> cbrt_fixed(ap_ufixed<W, I> x) {
   ap_fixed<W+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_int<I> cbrt_fixed(ap_int<I> x) {
   ap_fixed<I,I> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_uint<I> cbrt_fixed(ap_uint<I> x) {
   ap_fixed<I+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
}
# 1086 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hypot_apfixed.h" 1
# 39 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hypot_apfixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 40 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hypot_apfixed.h" 2

namespace hypot_internal {
template<int W, int I>
ap_fixed<W, I> hypot_fixed(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    const static int F = W - I;
    if(I > 33) return 0;
    else if(F > 32) return 0;
# 55 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hypot_apfixed.h"
    if(x==0) return fabs_fixed(y);
    if(y==0) return fabs_fixed(x);

    ap_ufixed<2*W, I*2> x_sq = x * x;
    ap_ufixed<2*W, I*2> y_sq = y * y;
    ap_ufixed<2*W, I*2> xy_sq = x_sq + y_sq;
# 69 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hypot_apfixed.h"
    const static int prcs = (F+1)*2;
    const static int msbr = I > 0? I : 1;
    ap_ufixed<msbr, msbr> res_I = 0;
    ap_ufixed<2*msbr+1,2*msbr+1> x_l_I = 0;
    if(I>0) {
        x_l_I = xy_sq(2*W-1, 2*W-2*I);
        VITIS_LOOP_75_1: for(int pos = msbr - 1; pos >= 0; pos--) {
            ap_ufixed<2*msbr,2*msbr> mul_I = 0;



            mul_I(msbr+pos, 2*pos+1) = res_I(msbr-1, pos);
            mul_I[2*pos] = 1;
            if(x_l_I(msbr+pos+1, 2*pos) >= mul_I(msbr+pos, 2*pos)){



                ap_ufixed<2*msbr+1, 2*msbr+1> x_l_I_ = x_l_I;
                x_l_I(msbr+pos+1, 2*pos) = x_l_I(msbr+pos+1,2*pos) - mul_I(msbr+pos, 2*pos);



                res_I[pos] = 1;
           }
       }
    }
    ap_ufixed<msbr+1, msbr+1> x_l_I_s = x_l_I;
# 104 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hypot_apfixed.h"
    ap_ufixed<prcs/2,0> res_F = 0;
    ap_ufixed<prcs/2,0> x_l_FH = xy_sq;
    ap_ufixed<prcs/2, -prcs/2> x_l_FL = xy_sq;
    VITIS_LOOP_107_2: for(int pos = -1; pos >= -F-1; pos--) {
        ap_ufixed<msbr+prcs, msbr> mul = 0;



        mul(msbr+pos+prcs, pos+1+prcs) = res_I(msbr-1, 0);
        mul(pos+prcs, 2*pos+1+prcs) = res_F(prcs/2-1,pos+prcs/2);
        mul[2*pos+prcs] = 1;

        ap_ufixed<msbr, msbr> mul_I = 0;
        mul_I = mul;
        ap_ufixed<prcs/2, 0> mul_FH = mul;
        ap_ufixed<prcs/2, -prcs/2> mul_FL = mul;
# 139 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_hypot_apfixed.h"
        if((x_l_I_s > mul_I) || ((x_l_I_s == mul_I) && (x_l_FH > mul_FH)) || ((x_l_I_s == mul_I) && (x_l_FH == mul_FH) && (x_l_FL >= mul_FL))) {







           ap_ufixed<prcs/2+1, -prcs/2+1> x_l_FL_1 = x_l_FL;

           if(x_l_FL < mul_FL) x_l_FL_1[prcs/2] = 1;
           x_l_FL_1 -= mul_FL;



           ap_ufixed<prcs/2+1,1> x_l_FH_1 = x_l_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_FH_1[prcs/2] = 1;
           ap_ufixed<1, -prcs/2+1> delta = 0;
           if(x_l_FL < mul_FL) delta[0] = 1;

           x_l_FH_1 -= delta;
           x_l_FH_1 -= mul_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_I_s--;
           x_l_I_s -= mul_I;
           x_l_FH = x_l_FH_1;
           x_l_FL = x_l_FL_1;







           res_F[pos+prcs/2] = 1;
       }
    }
    ap_ufixed<prcs/2+1, 1> res_F_1 = res_F;

    ap_ufixed<1, -prcs/2+1> delta = 0;
    delta[0] = 1;
    res_F_1 += delta;
    if(res_F_1[prcs/2]) res_I++;
    ap_ufixed<msbr+prcs/2, msbr> res = 0;
    res(msbr+prcs/2-1, prcs/2) = res_I(msbr-1,0);
    res(prcs/2-1, 0) = res_F(prcs/2-1, 0);






    ap_fixed<W,I> r = 0;
    if(res[msbr+prcs/2-1]) {

       VITIS_LOOP_195_3: for(int i = 0; i < W - 1; ++i) {
#pragma HLS unroll
 r[i] = 1;
       }
    } else {
       r = res;
    }





    return r;
}
template<int W, int I>
ap_ufixed<W, I> hypot_fixed(ap_ufixed<W, I> x, ap_fixed<W, I> y) {
   ap_fixed<W+1, I+1> xi = x;
   ap_fixed<W+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_int<I> hypot_fixed(ap_int<I> x, ap_int<I> y) {
   ap_fixed<I, I> xi = x;
   ap_fixed<I, I> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_uint<I> hypot_fixed(ap_uint<I> x, ap_uint<I> y) {
   ap_fixed<I+1, I+1> xi = x;
   ap_fixed<I+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
}
# 1087 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_ldexp_apfixed.h" 1
# 36 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_ldexp_apfixed.h"
namespace hls_ldexp {

template<int W, int I>
ap_fixed<W,I> ldexp(ap_fixed<W,I> x, int exp) {
    ap_fixed<W,I> result;
    if(exp >= W || exp <= -W) {
        result = 0;
    } else {
        result = x << exp;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> ldexp(ap_ufixed<W,I> x, int exp) {
    ap_fixed<W+1,I+1> xf = x;
    return ldexp(xf, exp);
}

template<int I>
ap_int<I> ldexp(ap_int<I> x, int exp) {
    ap_fixed<I,I> xf = x;
    return ldexp(xf, exp);
}

template<int I>
ap_uint<I> ldexp(ap_uint<I> x, int exp) {
    ap_fixed<I+1,I+1> xf = x;
    return ldexp(xf, exp);
}

template<int W, int I>
ap_fixed<W,I> scalbn(ap_fixed<W,I> x, int n) {
    ap_fixed<W,I> result;
    if(n >= W || n <= -W) {
        result = 0;
    } else {
        result = x << n;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> scalbn(ap_ufixed<W,I> x, int n) {
    ap_fixed<W+1,I+1> xf = x;
    return scalbn(xf, n);
}

template<int I>
ap_int<I> scalbn(ap_int<I> x, int n) {
    ap_fixed<I,I> xf = x;
    return scalbn(xf, n);
}

template<int I>
ap_uint<I> scalbn(ap_uint<I> x, int n) {
    ap_fixed<I+1,I+1> xf = x;
    return scalbn(xf, n);
}

template<int W, int I>
ap_fixed<W,I> scalbln(ap_fixed<W,I> x, long int n) {
    ap_fixed<W,I> result;
    if(n >= W || n <= -W) {
        result = 0;
    } else {
        result = x << n;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> scalbln(ap_ufixed<W,I> x, long int n) {
    ap_fixed<W+1,I+1> xf = x;
    return scalbln(xf, n);
}

template<int I>
ap_int<I> scalbln(ap_int<I> x, long int n) {
    ap_fixed<I,I> xf = x;
    return scalbln(xf, n);
}

template<int I>
ap_uint<I> scalbln(ap_uint<I> x, long int n) {
    ap_fixed<I+1,I+1> xf = x;
    return scalbln(xf, n);
}

}
# 1088 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h" 2

namespace hls {
# 1112 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h"
  template<int W, int I>
  ap_fixed<W, 2> sinpi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 0, 1);
  }




  template<int W, int I>
  ap_ufixed<W, 2> sinpi(ap_ufixed<W,I> x){
      ap_fixed<W+1, I+1> xin = x;
      ap_fixed<W+1, 3> xout = hls::sinpi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }

  template<int W, int I>
  ap_fixed<W, 2> cospi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 1, 1);
  }
  template<int W, int I>
  ap_ufixed<W, 2> cospi(ap_ufixed<W,I> x){
   ap_fixed<W+1, I+1> xin = x;
   ap_fixed<W+1, 3> xout = hls::cospi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }





  template<int I>
  ap_int<I> sinpi(ap_int<I> in){
        (void)(in);
 return ap_int<I>(0);
  }

  template<int I>
  ap_int<I> cospi(ap_int<I> in){
        (void)(in);
 return ap_int<I>(0);
  }

  template<int I>
  ap_uint<I> sinpi(ap_uint<I> in){
        (void)(in);
 return ap_uint<I>(0);
  }

  template<int I>
  ap_uint<I> cospi(ap_uint<I> in){
        (void)(in);
 return ap_uint<I>(0);
  }
  int8_t sinpi(int8_t);
  uint8_t sinpi(uint8_t);
  int16_t sinpi(int16_t);
  uint16_t sinpi(uint16_t);
  int32_t sinpi(int32_t);
  uint32_t sinpi(uint32_t);

  int8_t cospi(int8_t);
  uint8_t cospi(uint8_t);
  int16_t cospi(int16_t);
  uint16_t cospi(uint16_t);
  int32_t cospi(int32_t);
  uint32_t cospi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> exp(ap_fixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> exp(ap_ufixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_int<I> exp(ap_int<I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_uint<I> exp(ap_uint<I> x){
    return exp_reduce::exp(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log(ap_fixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_int<I> log(ap_int<I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_uint<I> log(ap_uint<I> x){
    return log_apfixed_reduce::log(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log10(ap_fixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log10(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_int<I> log10(ap_int<I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_uint<I> log10(ap_uint<I> x){
 return log_apfixed_reduce::log10(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log2(ap_fixed<W,I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log2(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int I>
  ap_int<I> log2(ap_int<I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int I>
  ap_uint<I> log2(ap_uint<I> x){
 return log_apfixed_reduce::log2(x);
  }


  template<int W, int I>
  ap_fixed<W,I> logb(ap_fixed<W,I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> logb(ap_ufixed<W,I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int I>
  ap_int<I> logb(ap_int<I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int I>
  ap_uint<I> logb(ap_uint<I> x){
 return log_apfixed_reduce::logb(x);
  }


  template<int W, int I>
  ap_fixed<W,I> sqrt(ap_fixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> sqrt(ap_ufixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_int<I> sqrt(ap_int<I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> sqrt(ap_uint<I> x){
    return sqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> rsqrt(ap_fixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rsqrt(ap_ufixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_int<I> rsqrt(ap_int<I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> rsqrt(ap_uint<I> x){
    return rsqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> recip(ap_fixed<W,I> x){
    return recip_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> recip(ap_ufixed<W,I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_int<I> recip(ap_int<I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_uint<I> recip(ap_uint<I> x){
    return recip_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> ceil(ap_fixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> ceil(ap_ufixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_int<I> ceil(ap_int<I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_uint<I> ceil(ap_uint<I> x){
    return ceil_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> floor(ap_fixed<W,I> x){
    return floor_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> floor(ap_ufixed<W,I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_int<I> floor(ap_int<I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_uint<I> floor(ap_uint<I> x){
    return floor_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> trunc(ap_fixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> trunc(ap_ufixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_int<I> trunc(ap_int<I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_uint<I> trunc(ap_uint<I> x){
    return trunc_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> copysign(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> copysign(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_int<I> copysign(ap_int<I> x, ap_int<I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_uint<I> copysign(ap_uint<I> x, ap_uint<I> y){
    return copysign_fixed(x,y);
  }


  template<int W, int I>
  ap_fixed<W,I> fabs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fabs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> fabs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> fabs(ap_uint<I> x){
    return fabs_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> abs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> abs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> abs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> abs(ap_uint<I> x){
    return fabs_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> fdim(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fdim(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_int<I> fdim(ap_int<I> x, ap_int<I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fdim(ap_uint<I> x, ap_uint<I> y){
    return fdim_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmax(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmax(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmax(ap_int<I> x, ap_int<I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmax(ap_uint<I> x, ap_uint<I> y){
    return fmax_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmin(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmin(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmin(ap_int<I> x, ap_int<I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmin(ap_uint<I> x, ap_uint<I> y){
    return fmin_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> maxmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> maxmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> maxmag(ap_int<I> x, ap_int<I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> maxmag(ap_uint<I> x, ap_uint<I> y){
    return maxmag_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> minmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> minmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> minmag(ap_int<I> x, ap_int<I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> minmag(ap_uint<I> x, ap_uint<I> y){
    return minmag_fixed(x,y);
  }



  template<int W, int I>
  ap_fixed<W,I> sinh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> sinh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_int<I> sinh(ap_int<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_uint<I> sinh(ap_uint<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> cosh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> cosh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_int<I> cosh(ap_int<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_uint<I> cosh(ap_uint<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> tanh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> tanh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_int<I> tanh(ap_int<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_uint<I> tanh(ap_uint<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> atanh(ap_fixed<W,I> x){
    ap_fixed<W,I> one_plus_x = 1 + x;
    ap_fixed<W,I> one_minus_x = 1 - x;
    ap_fixed<W,I> input = one_plus_x / one_minus_x ;
    ap_fixed<W,I> result = log_apfixed_reduce::log(input);
    result >>= 1;
    return result;
  }


  template<int W, int I>
  ap_ufixed<W,I> atanh(ap_ufixed<W,I> x){
  ap_fixed<W+1,I+1> input = x;
    ap_fixed<W+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_int<I> atanh(ap_int<I> x){
    ap_fixed<I,I> input = x;
    ap_fixed<I,I> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_uint<I> atanh(ap_uint<I> x){
    ap_fixed<I+1,I+1> input = x;
    ap_fixed<I+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int W, int I>
  ap_fixed<W,I> asinh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> asinh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_int<I> asinh(ap_int<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_uint<I> asinh(ap_uint<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> acosh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> acosh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_int<I> acosh(ap_int<I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_uint<I> acosh(ap_uint<I> x){
    return cordic_apfixed::generic_acosh(x);
  }

  int8_t sinh(int8_t);
  uint8_t sinh(uint8_t);
  int16_t sinh(int16_t);
  uint16_t sinh(uint16_t);
  int32_t sinh(int32_t);
  uint32_t sinh(uint32_t);

  int8_t cosh(int8_t);
  uint8_t cosh(uint8_t);
  int16_t cosh(int16_t);
  uint16_t cosh(uint16_t);
  int32_t cosh(int32_t);
  uint32_t cosh(uint32_t);

  int8_t tanh(int8_t);
  uint8_t tanh(uint8_t);
  int16_t tanh(int16_t);
  uint16_t tanh(uint16_t);
  int32_t tanh(int32_t);
  uint32_t tanh(uint32_t);

  int8_t atanh(int8_t);
  uint8_t atanh(uint8_t);
  int16_t atanh(int16_t);
  uint16_t atanh(uint16_t);
  int32_t atanh(int32_t);
  uint32_t atanh(uint32_t);

  int8_t asinh(int8_t);
  uint8_t asinh(uint8_t);
  int16_t asinh(int16_t);
  uint16_t asinh(uint16_t);
  int32_t asinh(int32_t);
  uint32_t asinh(uint32_t);

  int8_t acosh(int8_t);
  uint8_t acosh(uint8_t);
  int16_t acosh(int16_t);
  uint16_t acosh(uint16_t);
  int32_t acosh(int32_t);
  uint32_t acosh(uint32_t);


  template<int W, int I>
  ap_fixed<W-I+3,3> asin(ap_fixed<W,I> x){
 return cordic_apfixed::generic_asin(x);
  }


  template<int W, int I>
  ap_fixed<W-I+3,3> acos(ap_fixed<W,I> x){
 return cordic_apfixed::generic_acos(x);
  }


  template<int W, int I>
  ap_fixed<W,2> atan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int W, int I>
  ap_ufixed<W,2> atan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_int<2> atan(ap_int<I> x){
   return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_uint<1> atan(ap_uint<I> x){
   return cordic_apfixed::generic_atan(x);
  }

  int8_t asin(int8_t);
  uint8_t asin(uint8_t);
  int16_t asin(int16_t);
  uint16_t asin(uint16_t);
  int32_t asin(int32_t);
  uint32_t asin(uint32_t);

  int8_t acos(int8_t);
  uint8_t acos(uint8_t);
  int16_t acos(int16_t);
  uint16_t acos(uint16_t);
  int32_t acos(int32_t);
  uint32_t acos(uint32_t);

  int8_t atan(int8_t);
  uint8_t atan(uint8_t);
  int16_t atan(int16_t);
  uint16_t atan(uint16_t);
  int32_t atan(int32_t);
  uint32_t atan(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> asinpi(ap_fixed<W,I> x){
      return cordic_apfixed::generic_asinpi(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> asinpi(ap_ufixed<W,I> x){
      return cordic_apfixed::generic_asinpi(x);
  }

  template<int I>
  ap_int<I> asinpi(ap_int<I> x){
     return cordic_apfixed::generic_asinpi(x);
  }

  template<int I>
  ap_uint<I> asinpi(ap_uint<I> x){
     return cordic_apfixed::generic_asinpi(x);
  }


  int8_t asinpi(int8_t);
  uint8_t asinpi(uint8_t);
  int16_t asinpi(int16_t);
  uint16_t asinpi(uint16_t);
  int32_t asinpi(int32_t);
  uint32_t asinpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> acospi(ap_fixed<W,I> x){
      return cordic_apfixed::generic_acospi(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> acospi(ap_ufixed<W,I> x){
      return cordic_apfixed::generic_acospi(x);
  }

  template<int I>
  ap_int<I> acospi(ap_int<I> x){
     return cordic_apfixed::generic_acospi(x);
  }

  template<int I>
  ap_uint<I> acospi(ap_uint<I> x){
     return cordic_apfixed::generic_acospi(x);
  }

  int8_t acospi(int8_t);
  uint8_t acospi(uint8_t);
  int16_t acospi(int16_t);
  uint16_t acospi(uint16_t);
  int32_t acospi(int32_t);
  uint32_t acospi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> atanpi(ap_fixed<W,I> x){
 return cordic_apfixed::generic_atanpi(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> atanpi(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_atanpi(x);
  }


  template<int I>
  ap_int<2> atanpi(ap_int<I> x){
   return cordic_apfixed::generic_atanpi(x);
  }


  template<int I>
  ap_uint<1> atanpi(ap_uint<I> x){
   return cordic_apfixed::generic_atanpi(x);
  }

  int8_t atanpi(int8_t);
  uint8_t atanpi(uint8_t);
  int16_t atanpi(int16_t);
  uint16_t atanpi(uint16_t);
  int32_t atanpi(int32_t);
  uint32_t atanpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,3> atan2(ap_fixed<W,I> x, ap_fixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int W, int I>
  ap_ufixed<W,3> atan2(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_int<3> atan2(ap_int<I> x, ap_int<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_uint<2> atan2(ap_uint<I> x, ap_uint<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }

  int8_t atan2(int8_t, int8_t);
  uint8_t atan2(uint8_t, uint8_t);
  int16_t atan2(int16_t, int16_t);
  uint16_t atan2(uint16_t, uint16_t);
  int32_t atan2(int32_t, int32_t);
  uint32_t atan2(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> atan2pi(ap_fixed<W,I> x, ap_fixed<W,I> y){
 return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int W, int I>
  ap_ufixed<W,I> atan2pi(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
 return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int I>
  ap_int<I> atan2pi(ap_int<I> x, ap_int<I> y){
   return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int I>
  ap_uint<I> atan2pi(ap_uint<I> x, ap_uint<I> y){
   return cordic_apfixed::generic_atan2pi(x,y);
  }

  int8_t atan2pi(int8_t, int8_t);
  uint8_t atan2pi(uint8_t, uint8_t);
  int16_t atan2pi(int16_t, int16_t);
  uint16_t atan2pi(uint16_t, uint16_t);
  int32_t atan2pi(int32_t, int32_t);
  uint32_t atan2pi(uint32_t, uint32_t);
  template<int W, int I>
  void sincos(ap_fixed<W,I> in,
       ap_fixed<W-I+2,2>* outsin, ap_fixed<W-I+2,2>* outcos){
   cordic_apfixed::generic_sincos(in, *outsin, *outcos);
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> sin(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outsin;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> sin(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::sin(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> cos(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outcos;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> cos(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::cos(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }
# 1988 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/hls_math.h"
  template<int I>
  ap_int<I> sin(ap_int<I> in) {
        (void)(in);
 return ap_int<I>(0);
  };
  template<int I>
  ap_int<I> cos(ap_int<I> in) {
        (void)(in);
 return ap_int<I>(0);
  };


  template<int I>
  ap_uint<I> sin(ap_uint<I> in) {
        (void)(in);
 return ap_uint<I>(0);
  };
  template<int I>
  ap_uint<I> cos(ap_uint<I> in) {
        (void)(in);
 return ap_uint<I>(0);
  };

  void sincos(int8_t, int8_t*, int8_t*);
  void sincos(uint8_t, uint8_t*, uint8_t*);
  void sincos(int16_t, int16_t*, int16_t*);
  void sincos(uint16_t, uint16_t*, uint16_t*);
  void sincos(int32_t, int32_t*, int32_t*);
  void sincos(uint32_t, uint32_t*, uint32_t*);

  int8_t sin(int8_t);
  uint8_t sin(uint8_t);
  int16_t sin(int16_t);
  uint16_t sin(uint16_t);
  int32_t sin(int32_t);
  uint32_t sin(uint32_t);

  int8_t cos(int8_t);
  uint8_t cos(uint8_t);
  int16_t cos(int16_t);
  uint16_t cos(uint16_t);
  int32_t cos(int32_t);
  uint32_t cos(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_int<I> tan(ap_int<I> x){
   return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_uint<I> tan(ap_uint<I> x){
   return cordic_apfixed::generic_tan(x);
  }

  int8_t tan(int8_t);
  uint8_t tan(uint8_t);
  int16_t tan(int16_t);
  uint16_t tan(uint16_t);
  int32_t tan(int32_t);
  uint32_t tan(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tanpi(ap_fixed<W,I> x){
 return cordic_apfixed::generic_tanpi(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tanpi(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_tanpi(x);
  }
  template<int I>
  ap_int<I> tanpi(ap_int<I> x){
   return cordic_apfixed::generic_tanpi(x);
  }
  template<int I>
  ap_uint<I> tanpi(ap_uint<I> x){
   return cordic_apfixed::generic_tanpi(x);
  }

  int8_t tanpi(int8_t);
  uint8_t tanpi(uint8_t);
  int16_t tanpi(int16_t);
  uint16_t tanpi(uint16_t);
  int32_t tanpi(int32_t);
  uint32_t tanpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> pow(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return pow_apfixed_reduce::pow(x,y);
  }

  template<int W, int I>
  ap_ufixed<W,I> pow(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_int<I> pow(ap_int<I> x, ap_int<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_uint<I> pow(ap_uint<I> x,ap_uint<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> pown(ap_fixed<W,I> x, int n) {
    return pow_apfixed_reduce::pown(x,n);
  }

  template<int W, int I>
  ap_ufixed<W,I> pown(ap_ufixed<W,I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  template<int I>
  ap_int<I> pown(ap_int<I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  template<int I>
  ap_uint<I> pown(ap_uint<I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  int8_t pown(int8_t, int n);
  uint8_t pown(uint8_t, int n);
  int16_t pown(int16_t, int n);
  uint16_t pown(uint16_t, int n);
  int32_t pown(int32_t, int n);
  uint32_t pown(uint32_t, int n);

  template<int W, int I>
  ap_fixed<W,I> rootn(ap_fixed<W,I> x, int n) {
    return pow_apfixed_reduce::rootn(x,n);
  }

  template<int W, int I>
  ap_ufixed<W,I> rootn(ap_ufixed<W,I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  template<int I>
  ap_int<I> rootn(ap_int<I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  template<int I>
  ap_uint<I> rootn(ap_uint<I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  int8_t rootn(int8_t, int n);
  uint8_t rootn(uint8_t, int n);
  int16_t rootn(int16_t, int n);
  uint16_t rootn(uint16_t, int n);
  int32_t rootn(int32_t, int n);
  uint32_t rootn(uint32_t, int n);

  template<int W, int I>
  ap_fixed<W,I> powr(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return pow_apfixed_reduce::powr(x,y);
  }

  template<int W, int I>
  ap_ufixed<W,I> powr(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return pow_apfixed_reduce::powr(x,y);
  }
  template<int I>
  ap_int<I> powr(ap_int<I> x, ap_int<I> y){
    return pow_apfixed_reduce::powr(x,y);
  }
  template<int I>
  ap_uint<I> powr(ap_uint<I> x,ap_uint<I> y){
    return pow_apfixed_reduce::powr(x,y);
  }



  template<int W, int I>
  ap_fixed<W,I> round(ap_fixed<W,I> x){
    return round_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> round(ap_ufixed<W,I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_int<I> round(ap_int<I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_uint<I> round(ap_uint<I> x){
    return round_fixed(x);
  }
  int8_t round(int8_t);
  uint8_t round(uint8_t);
  int16_t round(int16_t);
  uint16_t round(uint16_t);
  int32_t round(int32_t);
  uint32_t round(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> rint(ap_fixed<W,I> x){
    return rint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rint(ap_ufixed<W,I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_int<I> rint(ap_int<I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_uint<I> rint(ap_uint<I> x){
    return rint_fixed(x);
  }
  int8_t rint(int8_t);
  uint8_t rint(uint8_t);
  int16_t rint(int16_t);
  uint16_t rint(uint16_t);
  int32_t rint(int32_t);
  uint32_t rint(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nearbyint(ap_fixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> nearbyint(ap_ufixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_int<I> nearbyint(ap_int<I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_uint<I> nearbyint(ap_uint<I> x){
    return nearbyint_fixed(x);
  }
  int8_t nearbyint(int8_t);
  uint8_t nearbyint(uint8_t);
  int16_t nearbyint(int16_t);
  uint16_t nearbyint(uint16_t);
  int32_t nearbyint(int32_t);
  uint32_t nearbyint(uint32_t);


  template<int W, int I>
  long long int llround(ap_fixed<W,I> x){
    return llround_fixed(x);
  }
  template<int W, int I>
  long long int llround(ap_ufixed<W,I> x){
    return llround_fixed(x);
  }
  template<int I>
  long long int llround(ap_int<I> x){
    return llround_fixed(x);
  }
  template<int I>
  long long int llround(ap_uint<I> x){
    return llround_fixed(x);
  }


  long long int llround(int8_t);
  long long int llround(uint8_t);
  long long int llround(int16_t);
  long long int llround(uint16_t);
  long long int llround(int32_t);
  long long int llround(uint32_t);


  template<int W, int I>
  long int lround(ap_fixed<W,I> x){
    return lround_fixed(x);
  }
  template<int W, int I>
  long int lround(ap_ufixed<W,I> x){
    return lround_fixed(x);
  }
  template<int I>
  long int lround(ap_int<I> x){
    return lround_fixed(x);
  }
  template<int I>
  long int lround(ap_uint<I> x){
    return lround_fixed(x);
  }


  long int lround(int8_t);
  long int lround(uint8_t);
  long int lround(int16_t);
  long int lround(uint16_t);
  long int lround(int32_t);
  long int lround(uint32_t);


  template<int W, int I>
  long long int llrint(ap_fixed<W,I> x){
    return llrint_fixed(x);
  }
  template<int W, int I>
  long long int llrint(ap_ufixed<W,I> x){
    return llrint_fixed(x);
  }
  template<int I>
  long long int llrint(ap_int<I> x){
    return llrint_fixed(x);
  }
  template<int I>
  long long int llrint(ap_uint<I> x){
    return llrint_fixed(x);
  }


  long long int llrint(int8_t);
  long long int llrint(uint8_t);
  long long int llrint(int16_t);
  long long int llrint(uint16_t);
  long long int llrint(int32_t);
  long long int llrint(uint32_t);


  template<int W, int I>
  long int lrint(ap_fixed<W,I> x){
    return lrint_fixed(x);
  }
  template<int W, int I>
  long int lrint(ap_ufixed<W,I> x){
    return lrint_fixed(x);
  }
  template<int I>
  long int lrint(ap_int<I> x){
    return lrint_fixed(x);
  }
  template<int I>
  long int lrint(ap_uint<I> x){
    return lrint_fixed(x);
  }


  long int lrint(int8_t);
  long int lrint(uint8_t);
  long int lrint(int16_t);
  long int lrint(uint16_t);
  long int lrint(int32_t);
  long int lrint(uint32_t);


  template<int W, int I>
  bool isgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_int<I> x1, ap_int<I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_uint<I> x1, ap_uint<I> x2){
    return isgreater_fixed(x1, x2);
  }
  bool isgreater(int8_t, int8_t);
  bool isgreater(uint8_t, uint8_t);
  bool isgreater(int16_t, int16_t);
  bool isgreater(uint16_t, uint16_t);
  bool isgreater(int32_t, int32_t);
  bool isgreater(uint32_t, uint32_t);


  template<int W, int I>
  bool isgreaterequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreaterequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_int<I> x1, ap_int<I> x2){
    return isgreaterequal_int(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_uint<I> x1, ap_uint<I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  bool isgreaterequal(int8_t, int8_t);
  bool isgreaterequal(uint8_t, uint8_t);
  bool isgreaterequal(int16_t, int16_t);
  bool isgreaterequal(uint16_t, uint16_t);
  bool isgreaterequal(int32_t, int32_t);
  bool isgreaterequal(uint32_t, uint32_t);


  template<int W, int I>
  bool isless(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int W, int I>
  bool isless(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_int<I> x1, ap_int<I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_uint<I> x1, ap_uint<I> x2){
    return isless_fixed(x1, x2);
  }
  bool isless(int8_t, int8_t);
  bool isless(uint8_t, uint8_t);
  bool isless(int16_t, int16_t);
  bool isless(uint16_t, uint16_t);
  bool isless(int32_t, int32_t);
  bool isless(uint32_t, uint32_t);


  template<int W, int I>
  bool islessequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_int<I> x1, ap_int<I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_uint<I> x1, ap_uint<I> x2){
    return islessequal_fixed(x1, x2);
  }
  bool islessequal(int8_t, int8_t);
  bool islessequal(uint8_t, uint8_t);
  bool islessequal(int16_t, int16_t);
  bool islessequal(uint16_t, uint16_t);
  bool islessequal(int32_t, int32_t);
  bool islessequal(uint32_t, uint32_t);


  template<int W, int I>
  bool islessgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_int<I> x1, ap_int<I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_uint<I> x1, ap_uint<I> x2){
    return islessgreater_fixed(x1, x2);
  }

  bool islessgreater(int8_t, int8_t);
  bool islessgreater(uint8_t, uint8_t);
  bool islessgreater(int16_t, int16_t);
  bool islessgreater(uint16_t, uint16_t);
  bool islessgreater(int32_t, int32_t);
  bool islessgreater(uint32_t, uint32_t);

  int8_t frexp(int8_t,int8_t*);
  uint8_t frexp(uint8_t, uint8_t*);
  int16_t frexp(int16_t, int16_t*);
  uint16_t frexp(uint16_t, uint16_t*);
  int32_t frexp(int32_t, int32_t*);
  uint32_t frexp(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> frexp(ap_fixed<W,I> x, ap_fixed<W,I>* exp) {
    return frexp_internal::frexp(x,exp);
  }

  template<int W, int I>
  ap_ufixed<W,I> frexp(ap_ufixed<W,I> x, ap_ufixed<W,I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_int<I> frexp(ap_int<I> x, ap_int<I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_uint<I> frexp(ap_uint<I> x,ap_uint<I>* exp){
    return frexp_internal::frexp(x,exp);
  }

  int8_t modf(int8_t, int8_t*);
  uint8_t modf(uint8_t, uint8_t*);
  int16_t modf(int16_t, int16_t*);
  uint16_t modf(uint16_t, uint16_t*);
  int32_t modf(int32_t, int32_t*);
  uint32_t modf(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> modf(ap_fixed<W,I> x, ap_fixed<W,I>* intpart) {
    return modf_internal::modf(x,intpart);
  }

  template<int W, int I>
  ap_ufixed<W,I> modf(ap_ufixed<W,I> x, ap_ufixed<W,I>* intpart){
    return modf_internal::modf(x,intpart);
  }
  template<int I>
  ap_int<I> modf(ap_int<I> x, ap_int<I>* intpart){
    return modf_internal::modf(x,intpart);
  }
  template<int I>
  ap_uint<I> modf(ap_uint<I> x,ap_uint<I>* intpart){
    return modf_internal::modf(x,intpart);
  }


  bool isequal(int8_t,int8_t);
  bool isequal(uint8_t,uint8_t);
  bool isequal(int16_t,int16_t);
  bool isequal(uint16_t,uint16_t);
  bool isequal(int32_t,int32_t);
  bool isequal(uint32_t,uint32_t);

  bool isnotequal(int8_t,int8_t);
  bool isnotequal(uint8_t,uint8_t);
  bool isnotequal(int16_t,int16_t);
  bool isnotequal(uint16_t,uint16_t);
  bool isnotequal(int32_t,int32_t);
  bool isnotequal(uint32_t,uint32_t);

  template<int W,int I>
  bool isequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int W,int I>
  bool isequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_int<I> x,ap_int<I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isequal(x,y);
  };

  template<int W,int I>
  bool isnotequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int W,int I>
  bool isnotequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_int<I> x,ap_int<I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isnotequal(x,y);
  };

  template<int W,int I>
  bool any(ap_fixed<W,I> x){
    return generic_any(x);
  };
  template<int W,int I>
  bool any(ap_ufixed<W,I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_int<I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_uint<I> x){
    return generic_any(x);
  };

  template<int W,int I>
  bool all(ap_fixed<W,I> x){
    return generic_all(x);
  };
  template<int W,int I>
  bool all(ap_ufixed<W,I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_int<I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_uint<I> x){
    return generic_all(x);
  };

  template<int W,int I>
  ap_fixed<W,I> bitselect(ap_fixed<W,I> x,ap_fixed<W,I> y, ap_fixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int W,int I>
  ap_ufixed<W,I> bitselect(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_int<I> bitselect(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_uint<I> bitselect(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return generic_bitselect(x,y,z);
  };

  template<int W, int I>
  ap_fixed<W,I> erf(ap_fixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erf(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_int<I> erf(ap_int<I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_uint<I> erf(ap_uint<I> x){
    return erf_erfc_fixed::erf(x);
  }

  template<int W, int I>
  ap_fixed<W,I> erfc(ap_fixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erfc(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_int<I> erfc(ap_int<I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_uint<I> erfc(ap_uint<I> x){
    return erf_erfc_fixed::erfc(x);
  }

  int8_t divide(int8_t,int8_t);
  int16_t divide(int16_t,int16_t);
  int32_t divide(int32_t,int32_t);
  uint8_t divide(uint8_t,uint8_t);
  uint16_t divide(uint16_t,uint16_t);
  uint32_t divide(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> divide(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> divide(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int I>
  ap_int<I> divide(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int I>
  ap_uint<I> divide(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_divide(x, y);
  }

  int8_t fmod(int8_t,int8_t);
  int16_t fmod(int16_t,int16_t);
  int32_t fmod(int32_t,int32_t);
  uint8_t fmod(uint8_t,uint8_t);
  uint16_t fmod(uint16_t,uint16_t);
  uint32_t fmod(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fmod(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmod(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int I>
  ap_int<I> fmod(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int I>
  ap_uint<I> fmod(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_fmod(x, y);
  }

  int8_t remainder(int8_t,int8_t);
  int16_t remainder(int16_t,int16_t);
  int32_t remainder(int32_t,int32_t);
  uint8_t remainder(uint8_t,uint8_t);
  uint16_t remainder(uint16_t,uint16_t);
  uint32_t remainder(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> remainder(ap_fixed<W,I> x, ap_fixed<W, I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> remainder(ap_ufixed<W,I> x, ap_ufixed<W, I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int I>
  ap_int<I> remainder(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int I>
  ap_uint<I> remainder(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_remainder(x, y);
  }

  int8_t remquo(int8_t,int8_t,int*);
  int16_t remquo(int16_t,int16_t,int*);
  int32_t remquo(int32_t,int32_t,int*);
  uint8_t remquo(uint8_t,uint8_t,int*);
  uint16_t remquo(uint16_t,uint16_t,int*);
  uint32_t remquo(uint32_t,uint32_t,int*);

  template<int W, int I>
  ap_fixed<W,I> remquo(ap_fixed<W,I> x, ap_fixed<W,I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int W, int I>
  ap_ufixed<W,I> remquo(ap_ufixed<W,I> x, ap_ufixed<W, I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int I>
  ap_int<I> remquo(ap_int<I> x, ap_int<I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int I>
  ap_uint<I> remquo(ap_uint<I> x, ap_uint<I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }

  template<int W, int I>
  bool signbit(ap_fixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int W, int I>
  bool signbit(ap_ufixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_int<I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_uint<I> x) {
    return signbit_fixed(x);
  }
  bool signbit(int8_t);
  bool signbit(uint8_t);
  bool signbit(int16_t);
  bool signbit(uint16_t);
  bool signbit(int32_t);
  bool signbit(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> lgamma_r(ap_fixed<W,I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int W, int I>
  ap_ufixed<W,I> lgamma_r(ap_ufixed<W,I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int I>
  ap_int<I> lgamma_r(ap_int<I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int I>
  ap_uint<I> lgamma_r(ap_uint<I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }

  template<int W, int I>
  ap_fixed<W,I> lgamma(ap_fixed<W,I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> lgamma(ap_ufixed<W,I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int I>
  ap_int<I> lgamma(ap_int<I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int I>
  ap_uint<I> lgamma(ap_uint<I> x){
    return lgamma_fixed::lgamma_generic(x);
  }

  int8_t mad(int8_t,int8_t,int8_t);
  int16_t mad(int16_t,int16_t,int16_t);
  int32_t mad(int32_t,int32_t,int32_t);
  uint8_t mad(uint8_t,uint8_t,uint8_t);
  uint16_t mad(uint16_t,uint16_t,uint16_t);
  uint32_t mad(uint32_t,uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> mad(ap_fixed<W,I> x,ap_fixed<W,I> y,ap_fixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int W, int I>
  ap_ufixed<W,I> mad(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_int<I> mad(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_uint<I> mad(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return hls_mad::generic_mad(x,y,z);
  }

  int8_t fma(int8_t,int8_t,int8_t);
  int16_t fma(int16_t,int16_t,int16_t);
  int32_t fma(int32_t,int32_t,int32_t);
  uint8_t fma(uint8_t,uint8_t,uint8_t);
  uint16_t fma(uint16_t,uint16_t,uint16_t);
  uint32_t fma(uint32_t,uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fma(ap_fixed<W,I> x,ap_fixed<W,I> y,ap_fixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int W, int I>
  ap_ufixed<W,I> fma(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_int<I> fma(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_uint<I> fma(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return hls_mad::generic_mad(x,y,z);
  }

  int8_t fract(int8_t);
  int16_t fract(int16_t);
  int32_t fract(int32_t);
  uint8_t fract(uint8_t);
  uint16_t fract(uint16_t);
  uint32_t fract(uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fract(ap_fixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fract(ap_ufixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_int<I> fract(ap_int<I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_uint<I> fract(ap_uint<I> x){
    return hls_fract::generic_fract(x);
  }

  template<int W, int I>
  ap_fixed<W,I> cbrt(ap_fixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> cbrt(ap_ufixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_int<I> cbrt(ap_int<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_uint<I> cbrt(ap_uint<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  int8_t cbrt(int8_t);
  uint8_t cbrt(uint8_t);
  int16_t cbrt(int16_t);
  uint16_t cbrt(uint16_t);
  int32_t cbrt(int32_t);
  uint32_t cbrt(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tgamma(ap_fixed<W,I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tgamma(ap_ufixed<W,I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int I>
  ap_int<I> tgamma(ap_int<I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int I>
  ap_uint<I> tgamma(ap_uint<I> x){
    return tgamma_fixed::tgamma_generic(x);
  }


  template<int W, int I>
  ap_fixed<W,I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nextafter(x, y);
  }
  int8_t nextafter(int8_t, int8_t);
  uint8_t nextafter(uint8_t, uint8_t);
  int16_t nextafter(int16_t, int16_t);
  uint16_t nextafter(uint16_t, uint16_t);
  int32_t nextafter(int32_t, int32_t);
  uint32_t nextafter(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  int8_t nexttoward(int8_t, int8_t);
  uint8_t nexttoward(uint8_t, uint8_t);
  int16_t nexttoward(int16_t, int16_t);
  uint16_t nexttoward(uint16_t, uint16_t);
  int32_t nexttoward(int32_t, int32_t);
  uint32_t nexttoward(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> hypot(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> hypot(ap_ufixed<W,I> x, ap_ufixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_int<I> hypot(ap_int<I> x, ap_int<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_uint<I> hypot(ap_uint<I> x, ap_uint<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  int8_t hypot(int8_t, int8_t);
  uint8_t hypot(uint8_t, uint8_t);
  int16_t hypot(int16_t, int16_t);
  uint16_t hypot(uint16_t, uint16_t);
  int32_t hypot(int32_t, int32_t);
  uint32_t hypot(uint32_t, uint32_t);

  template<int W, int I>
  ap_fixed<W,I> exp2(ap_fixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_int<I> exp2(ap_int<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_uint<I> exp2(ap_uint<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_fixed<W,I> exp10(ap_fixed<W,I> x) {
    return exp_reduce::exp10(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> exp10(ap_ufixed<W,I> x) {
    return exp_reduce::exp10(x);
  }

  template<int I>
  ap_int<I> exp10(ap_int<I> x) {
    return exp_reduce::exp10(x);
  }

  template<int I>
  ap_uint<I> exp10(ap_uint<I> x) {
    return exp_reduce::exp10(x);
  }

  template<int W, int I>
  ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_int<I> expm1(ap_int<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_uint<I> expm1(ap_uint<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_int<I> log1p(ap_int<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_uint<I> log1p(ap_uint<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_int<I> ilogb(ap_int<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_uint<I> ilogb(ap_uint<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int W, int I>
  ap_fixed<W,I> ldexp(ap_fixed<W,I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int W, int I>
  ap_ufixed<W,I> ldexp(ap_ufixed<W,I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int I>
  ap_int<I> ldexp(ap_int<I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int I>
  ap_uint<I> ldexp(ap_uint<I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int W, int I>
  ap_fixed<W,I> scalbn(ap_fixed<W,I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int W, int I>
  ap_ufixed<W,I> scalbn(ap_ufixed<W,I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int I>
  ap_int<I> scalbn(ap_int<I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int I>
  ap_uint<I> scalbn(ap_uint<I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int W, int I>
  ap_fixed<W,I> scalbln(ap_fixed<W,I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int W, int I>
  ap_ufixed<W,I> scalbln(ap_ufixed<W,I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int I>
  ap_int<I> scalbln(ap_int<I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int I>
  ap_uint<I> scalbln(ap_uint<I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

    int8_t ldexp(int8_t x, int exp);
    int16_t ldexp(int16_t x, int exp);
    int32_t ldexp(int32_t x, int exp);
    uint8_t ldexp(uint8_t x, int exp);
    uint16_t ldexp(uint16_t x, int exp);
    uint32_t ldexp(uint32_t x, int exp);

    int8_t scalbn(int8_t x, int n);
    int16_t scalbn(int16_t x, int n);
    int32_t scalbn(int32_t x, int n);
    uint8_t scalbn(uint8_t x, int n);
    uint16_t scalbn(uint16_t x, int n);
    uint32_t scalbn(uint32_t x, int n);

    int8_t scalbln(int8_t x, int n);
    int16_t scalbln(int16_t x, int n);
    int32_t scalbln(int32_t x, int n);
    uint8_t scalbln(uint8_t x, int n);
    uint16_t scalbln(uint16_t x, int n);
    uint32_t scalbln(uint32_t x, int n);

    int8_t exp2(int8_t x);
    int16_t exp2(int16_t x);
    int32_t exp2(int32_t x);
    uint8_t exp2(uint8_t x);
    uint16_t exp2(uint16_t x);
    uint32_t exp2(uint32_t x);

    int8_t exp10(int8_t x);
    int16_t exp10(int16_t x);
    int32_t exp10(int32_t x);
    uint8_t exp10(uint8_t x);
    uint16_t exp10(uint16_t x);
    uint32_t exp10(uint32_t x);

    int8_t expm1(int8_t x);
    int16_t expm1(int16_t x);
    int32_t expm1(int32_t x);
    uint8_t expm1(uint8_t x);
    uint16_t expm1(uint16_t x);
    uint32_t expm1(uint32_t x);

    int8_t ilogb(int8_t x);
    int16_t ilogb(int16_t x);
    int32_t ilogb(int32_t x);
    uint8_t ilogb(uint8_t x);
    uint16_t ilogb(uint16_t x);
    uint32_t ilogb(uint32_t x);

    int8_t log1p(int8_t x);
    int16_t log1p(int16_t x);
    int32_t log1p(int32_t x);
    uint8_t log1p(uint8_t x);
    uint16_t log1p(uint16_t x);
    uint32_t log1p(uint32_t x);

    int8_t log2(int8_t);
    uint8_t log2(uint8_t);
    int16_t log2(int16_t);
    uint16_t log2(uint16_t);
    int32_t log2(int32_t);
    uint32_t log2(uint32_t);

    int8_t logb(int8_t);
    uint8_t logb(uint8_t);
    int16_t logb(int16_t);
    uint16_t logb(uint16_t);
    int32_t logb(int32_t);
    uint32_t logb(uint32_t);

};
# 26 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_ltm.hpp" 2


namespace xf {
namespace cv {

template <int BLK_ROWS, int BLK_COLS, int ROWS, int COLS, int NPC>
class LTMTile {
   public:
    static constexpr int BLK_COLS_NPC_ALIGNED = BLK_COLS >> xfNPixelsPerCycle<NPC>::datashift;
    static constexpr int COLS_NPC_ALIGNED = (COLS + NPC - 1) >> xfNPixelsPerCycle<NPC>::datashift;

    static constexpr int MinMaxVArrSize =
        ((ROWS % BLK_ROWS) == 0) ? (ROWS / BLK_ROWS) + 1 : (((ROWS + BLK_ROWS - 1) / BLK_ROWS) + 1) + 1;
    static constexpr int MinMaxHArrSize =
        ((COLS_NPC_ALIGNED % BLK_COLS_NPC_ALIGNED) == 0)
            ? (COLS_NPC_ALIGNED / BLK_COLS_NPC_ALIGNED) + 1
            : (((COLS_NPC_ALIGNED + BLK_COLS_NPC_ALIGNED - 1) / BLK_COLS_NPC_ALIGNED) + 1) + 1;

    int mRows;
    int mCols;
    int mColsNPCAligned;

    int mBlkRows;
    int mBlkCols;
    int mBlkColsNPCAligned;

    int mVBlkCount;
    int mHBlkCount;

    int mVBlkSize[2];
    int mHBlkSize[2];


    LTMTile(int r, int c) : mRows(r), mCols(c), mBlkRows(BLK_ROWS), mBlkCols(BLK_COLS) {
        (__builtin_assume(static_cast <bool> (BLK_ROWS >= 32)));
        (__builtin_assume(static_cast <bool> (BLK_COLS >= 32)));
        (__builtin_assume(static_cast <bool> (BLK_COLS > NPC)));
        (__builtin_assume(static_cast <bool> ((BLK_ROWS & (BLK_ROWS - 1)) == 0)));
        (__builtin_assume(static_cast <bool> ((BLK_COLS & (BLK_COLS - 1)) == 0)));
        (__builtin_assume(static_cast <bool> (mBlkRows < r)));
        (__builtin_assume(static_cast <bool> (mBlkCols < c)));
        mColsNPCAligned = (mCols + NPC - 1) >> xfNPixelsPerCycle<NPC>::datashift;
        mBlkColsNPCAligned = BLK_COLS_NPC_ALIGNED;

        mHBlkCount = ((mColsNPCAligned + (BLK_COLS_NPC_ALIGNED - 1)) >> xf::cv::log2<BLK_COLS_NPC_ALIGNED>::cvalue);
        int th = (mHBlkCount << xf::cv::log2<BLK_COLS_NPC_ALIGNED>::cvalue);
        mHBlkSize[0] = mHBlkSize[1] = BLK_COLS_NPC_ALIGNED;
        if (mColsNPCAligned < th) {

            int t = mColsNPCAligned - ((mColsNPCAligned >> xf::cv::log2<BLK_COLS_NPC_ALIGNED>::cvalue)
                                       << xf::cv::log2<BLK_COLS_NPC_ALIGNED>::cvalue);
            mHBlkSize[0] = t >> 1;
            mHBlkCount++;
        }

        mVBlkCount = ((mRows + (BLK_ROWS - 1)) >> xf::cv::log2<BLK_ROWS>::cvalue);
        int tv = (mVBlkCount << xf::cv::log2<BLK_ROWS>::cvalue);
        mVBlkSize[0] = mVBlkSize[1] = BLK_ROWS;
        if (mRows < tv) {

            int t = mRows - ((mRows >> xf::cv::log2<BLK_ROWS>::cvalue) << xf::cv::log2<BLK_ROWS>::cvalue);
            mVBlkSize[0] = t >> 1;
            mVBlkCount++;
        }
    }



    LTMTile(int r, int c, int blk_r, int blk_c) : mRows(r), mCols(c), mBlkRows(blk_r), mBlkCols(blk_c) {
        (__builtin_assume(static_cast <bool> (BLK_ROWS >= 32)));
        (__builtin_assume(static_cast <bool> (BLK_COLS >= 32)));
        (__builtin_assume(static_cast <bool> (BLK_COLS > NPC)));
        (__builtin_assume(static_cast <bool> ((BLK_ROWS & (BLK_ROWS - 1)) == 0)));
        (__builtin_assume(static_cast <bool> ((BLK_COLS & (BLK_COLS - 1)) == 0)));

        (__builtin_assume(static_cast <bool> (mBlkRows >= BLK_ROWS)));
        (__builtin_assume(static_cast <bool> (mBlkCols >= BLK_COLS)));
        (__builtin_assume(static_cast <bool> ((mBlkRows & (mBlkRows - 1)) == 0)));
        (__builtin_assume(static_cast <bool> ((mBlkCols & (mBlkCols - 1)) == 0)));

        (__builtin_assume(static_cast <bool> (mBlkRows < r)));
        (__builtin_assume(static_cast <bool> (mBlkCols < c)));

        mColsNPCAligned = (mCols + NPC - 1) >> xfNPixelsPerCycle<NPC>::datashift;
        int blkColsLog2;
        VITIS_LOOP_111_1: for (blkColsLog2 = xf::cv::log2<BLK_COLS>::cvalue; blkColsLog2 <= xf::cv::log2<COLS>::cvalue; blkColsLog2++) {

#pragma HLS PIPELINE

 if ((1 << blkColsLog2) >= mBlkCols) break;
        }
        mBlkColsNPCAligned = 1 << (blkColsLog2 - xfNPixelsPerCycle<NPC>::datashift);

        mHBlkCount = ((mColsNPCAligned + (mBlkColsNPCAligned - 1)) >> blkColsLog2);
        int th = (mHBlkCount << blkColsLog2);
        mHBlkSize[0] = mHBlkSize[1] = mBlkColsNPCAligned;
        if (mColsNPCAligned < th) {

            int t = mColsNPCAligned - ((mColsNPCAligned >> blkColsLog2) << blkColsLog2);
            mHBlkSize[0] = t >> 1;
            mHBlkCount++;
        }

        int blkRowsLog2;
        VITIS_LOOP_130_2: for (blkRowsLog2 = xf::cv::log2<BLK_ROWS>::cvalue; blkRowsLog2 <= xf::cv::log2<ROWS>::cvalue; blkRowsLog2++) {

#pragma HLS PIPELINE

 if ((1 << blkRowsLog2) >= mBlkRows) break;
        }

        mVBlkCount = ((mRows + (mBlkRows - 1)) >> blkRowsLog2);
        int tv = (mVBlkCount << blkRowsLog2);
        mVBlkSize[0] = mVBlkSize[1] = mBlkRows;
        if (mRows < tv) {

            int t = mRows - ((mRows >> blkRowsLog2) << blkRowsLog2);
            mVBlkSize[0] = t >> 1;
            mVBlkCount++;
        }
    }

    int getVBlkSize(int index) {
        if (index == 0)
            return mVBlkSize[0];
        else if (index == (mVBlkCount - 1))
            return mVBlkSize[0];
        else
            return mVBlkSize[1];
    }


    int getMinMaxVBlkSize(int index) {
        if (index == 0) return (mVBlkSize[0] >> 1);
        if (index == mVBlkCount) return (mVBlkSize[0] >> 1);
        if (index == 1) return (mVBlkSize[0] + mVBlkSize[1]) >> 1;
        if (index == (mVBlkCount - 1)) return (mVBlkSize[0] + mVBlkSize[1]) >> 1;
        if (index < (mVBlkCount - 1)) return mVBlkSize[1];
        return 0;
    }


    int getHBlkSize(int addr) {
        if (addr < mHBlkSize[0]) return mHBlkSize[0];
        if (addr >= (mCols - mHBlkSize[0])) return mHBlkSize[0];
        return mHBlkSize[1];
    }

    inline int getInputRows() { return mRows; }
    inline int getInputCols() { return mCols; }
    inline int getInputColsAlignedNPC() { return mColsNPCAligned; }

    inline int getVBlkCount() { return mVBlkCount; }
    inline int getHBlkCount() { return mHBlkCount; }
};

template <int T>
class is_floating_point {
   public:
    static constexpr bool value = false;
};

template <>
class is_floating_point<XF_32FC1> {
   public:
    static constexpr bool value = true;
};

template <>
class is_floating_point<XF_32FC3> {
   public:
    static constexpr bool value = true;
};

template <int IN_TYPE, int OUT_TYPE, int BLK_ROWS, int BLK_COLS, int ROWS, int COLS, int NPC>
class LTM {
   public:
    static constexpr int BILINEAR_INTERPOLATE_TYPE = XF_32FC1;
    static constexpr float OUT_DEPTH = (1 << DataType<OUT_TYPE, NPC>::bitdepth) - 1;
    static constexpr int COLS_NPC_ALIGNED = LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>::COLS_NPC_ALIGNED;
    static constexpr int MinMaxVArrSize = LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>::MinMaxVArrSize;
    static constexpr int MinMaxHArrSize = LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>::MinMaxHArrSize;

    LTM() { (__builtin_assume(static_cast <bool> (!is_floating_point<OUT_TYPE>::value))); }


    template <int T = IN_TYPE, typename std::enable_if<!is_floating_point<T>::value>::type* = nullptr>
    static constexpr typename DataType<IN_TYPE, NPC>::cname LOW() {
        return 0;
    }

    template <int T = IN_TYPE, typename std::enable_if<is_floating_point<T>::value>::type* = nullptr>
    static constexpr typename DataType<IN_TYPE, NPC>::cname LOW() {
        return floatToRawBits(0.0);
    }

    template <int T = IN_TYPE, typename std::enable_if<!is_floating_point<T>::value>::type* = nullptr>
    static constexpr typename DataType<IN_TYPE, NPC>::cname HIGH() {
        return std::numeric_limits<unsigned int>::max();
    }

    template <int T = IN_TYPE, typename std::enable_if<is_floating_point<T>::value>::type* = nullptr>
    static constexpr typename DataType<IN_TYPE, NPC>::cname HIGH() {
        return floatToRawBits(std::numeric_limits<float>::max());
    }



    template <int T = IN_TYPE, typename std::enable_if<!is_floating_point<T>::value>::type* = nullptr>
    static float to_float(typename DataType<T, NPC>::cname & a) {
        float f = a;
        return f;
    }

    template <int T = IN_TYPE, typename std::enable_if<is_floating_point<T>::value>::type* = nullptr>
    static float to_float(typename DataType<T, NPC>::cname & a) {
        float f = rawBitsToFloat((unsigned long)a);
        return f;
    }



    template <int T = IN_TYPE, typename std::enable_if<!is_floating_point<T>::value>::type* = nullptr>
    static inline bool is_less(typename DataType<T, NPC>::cname a, typename DataType<T, NPC>::cname b) {
        return (a < b) ? true : false;
    }

    template <int T = IN_TYPE, typename std::enable_if<is_floating_point<T>::value>::type* = nullptr>
    static inline bool is_less(typename DataType<T, NPC>::cname a, typename DataType<T, NPC>::cname b) {
        return (rawBitsToFloat((unsigned long)a) < rawBitsToFloat((unsigned long)b)) ? true : false;
    }


    static typename DataType<IN_TYPE, NPC>::cname max(typename DataType<IN_TYPE, NPC>::uname in) {
        typename DataType<IN_TYPE, NPC>::cname ret = LOW();
    CH0:
        for (int i = 0; i < DataType<IN_TYPE, NPC>::channel; i++) {
            typename DataType<IN_TYPE, NPC>::cname
            val = in.range((i + 1) * DataType<IN_TYPE, NPC>::bitdepth - 1, i * DataType<IN_TYPE, NPC>::bitdepth);
            if (is_less(ret, val)) ret = val;
        }
        return ret;
    }

    static void getMaxImage(xf::cv::Mat<IN_TYPE, ROWS, COLS, NPC>& in,
                            LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>& Tile,
                            xf::cv::Mat<IN_TYPE, ROWS, COLS, NPC>& in_copy,
                            hls::stream<ap_uint<DataType<IN_TYPE, NPC>::bitdepth * xfNPixelsPerCycle<NPC>::nppc> >& in_max) {
        int addr = 0;
    R:
        for (int i = 0; i < Tile.getInputRows(); i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 C:
            for (int j = 0; j < Tile.getInputColsAlignedNPC(); j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS_NPC_ALIGNED max=COLS_NPC_ALIGNED
#pragma HLS PIPELINE

 typename DataType<IN_TYPE, NPC>::name val = in.read(addr);
                in_copy.write(addr, val);
                addr++;
                ap_uint<DataType<IN_TYPE, NPC>::bitdepth * xfNPixelsPerCycle<NPC>::nppc> valMax;
            N:
                for (int l = 0; l < xfNPixelsPerCycle<NPC>::nppc; l++) {
                    typename DataType<IN_TYPE, NPC>::uname
                    pinVal = val.range((l + 1) * DataType<IN_TYPE, NPC>::pixelwidth - 1, l * DataType<IN_TYPE, NPC>::pixelwidth);
                    valMax.range((l + 1) * DataType<IN_TYPE, NPC>::bitdepth - 1, l * DataType<IN_TYPE, NPC>::bitdepth) =
                        max(pinVal);
                }
                in_max.write(valMax);
            }
        }
    }

    static void getMinMax(hls::stream<ap_uint<DataType<IN_TYPE, NPC>::bitdepth * xfNPixelsPerCycle<NPC>::nppc> >& in_max,
                          int vBlkSize,
                          int vBlkIndex,
                          LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>& Tile,
                          typename DataType<IN_TYPE, NPC>::cname omin[MinMaxVArrSize][MinMaxHArrSize],
                          typename DataType<IN_TYPE, NPC>::cname omax[MinMaxVArrSize][MinMaxHArrSize]) {
        typename DataType<IN_TYPE, NPC>::cname omin_l[MinMaxHArrSize];
        typename DataType<IN_TYPE, NPC>::cname omax_l[MinMaxHArrSize];
        bool bStart = true;

#pragma HLS ARRAY_PARTITION variable=omin_l dim=1 complete
#pragma HLS ARRAY_PARTITION variable=omax_l dim=1 complete

 R0:
        for (int i = 0; i < vBlkSize; i++) {

#pragma HLS LOOP_TRIPCOUNT min=BLK_ROWS max=BLK_ROWS

 C0:
            for (int j = 0, blk = 0, offset = 0; j < Tile.getInputColsAlignedNPC(); j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS_NPC_ALIGNED max=COLS_NPC_ALIGNED
#pragma HLS PIPELINE II=1

 ap_uint<DataType<IN_TYPE, NPC>::bitdepth * xfNPixelsPerCycle<NPC>::nppc> val = in_max.read();
                int hBlkSize = Tile.getHBlkSize(j);

                typename DataType<IN_TYPE, NPC>::cname pinValMin = HIGH();
                typename DataType<IN_TYPE, NPC>::cname pinValMax = LOW();
            N0:
                for (int l = 0; l < xfNPixelsPerCycle<NPC>::nppc; l++) {
                    typename DataType<IN_TYPE, NPC>::cname
                    pinVal = val.range((l + 1) * DataType<IN_TYPE, NPC>::bitdepth - 1, l * DataType<IN_TYPE, NPC>::bitdepth);


                    if (is_less(pinVal, pinValMin)) pinValMin = pinVal;


                    if (is_less(pinValMax, pinVal)) pinValMax = pinVal;
                }

                typename DataType<IN_TYPE, NPC>::cname min = omin_l[blk];
                typename DataType<IN_TYPE, NPC>::cname max = omax_l[blk];
                if (bStart) {
                    min = pinValMin;
                    max = pinValMin;
                } else {
                    min = (is_less(pinValMin, min)) ? pinValMin : min;
                    max = (is_less(max, pinValMax)) ? pinValMax : max;
                }

                offset++;
                bStart = false;
                if (offset == (hBlkSize >> 1)) {
                    blk++;
                    bStart = (i == 0);
                }
                if (offset == hBlkSize) offset = 0;

                omin_l[blk] = min;
                omax_l[blk] = max;

                omin[vBlkIndex][blk] = min;
                omax[vBlkIndex][blk] = max;
            }
        }
    }

    static void processMinMax(hls::stream<ap_uint<DataType<IN_TYPE, NPC>::bitdepth * xfNPixelsPerCycle<NPC>::nppc> >& in_max,
                              LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>& Tile,
                              typename DataType<IN_TYPE, NPC>::cname omin[MinMaxVArrSize][MinMaxHArrSize],
                              typename DataType<IN_TYPE, NPC>::cname omax[MinMaxVArrSize][MinMaxHArrSize]) {
    R1:
        for (int i = 0; i <= Tile.getVBlkCount(); i++) {

#pragma HLS LOOP_TRIPCOUNT min=MinMaxVArrSize max=MinMaxVArrSize

 getMinMax(in_max, Tile.getMinMaxVBlkSize(i), i, Tile, omin, omax);
        }
    }

    template <int I_T,
              int O_T = BILINEAR_INTERPOLATE_TYPE,
              typename std::enable_if<!is_floating_point<O_T>::value>::type* = nullptr>
    static typename DataType<O_T, NPC>::cname
        bilinear(typename DataType<I_T, NPC>::cname & in1, typename DataType<I_T, NPC>::cname & in2, float blkSize, float offset) {
        (__builtin_assume(static_cast <bool> (is_floating_point<I_T>::value == false)));

        typename DataType<O_T, NPC>::cname op1 = in1;
        typename DataType<O_T, NPC>::cname op2 = (in2 - in1);
        typename DataType<O_T, NPC>::cname op3 = offset / blkSize;
        typename DataType<O_T, NPC>::cname op4 = op3 * op2;
        typename DataType<O_T, NPC>::cname ret = op1 + op4;
        return ret;
    }

    template <int I_T,
              int O_T = BILINEAR_INTERPOLATE_TYPE,
              typename std::enable_if<is_floating_point<O_T>::value>::type* = nullptr>
    static typename DataType<O_T, NPC>::cname
        bilinear(typename DataType<I_T, NPC>::cname & in1, typename DataType<I_T, NPC>::cname & in2, float blkSize, float offset) {
        float op1 = to_float<I_T>(in1);
        float op2 = (to_float<I_T>(in2) - to_float<I_T>(in1));
        float op3 = offset / blkSize;
        float op4 = op3 * op2;
        typename DataType<O_T, NPC>::cname ret = floatToRawBits(op1 + op4);
        return ret;
    }

    static void interpolate(typename DataType<IN_TYPE, NPC>::cname arr[MinMaxVArrSize][MinMaxHArrSize],
                            int vBlkSize,
                            int vBlkIndex,
                            LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>& Tile,
                            hls::stream<typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::name>& interpolateOut) {
    R2:
        for (int i = 0; i < vBlkSize; i++) {

#pragma HLS LOOP_TRIPCOUNT min=BLK_ROWS max=BLK_ROWS

 C2:
            for (int j = 0, blk = 0, offset = 0; j < Tile.getInputColsAlignedNPC(); j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS_NPC_ALIGNED max=COLS_NPC_ALIGNED
#pragma HLS PIPELINE II=1

 typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::name out;
                int hBlkSize = Tile.getHBlkSize(j);
                typename DataType<IN_TYPE, NPC>::cname a[4];
                VITIS_LOOP_430_1: for (int m = 0; m < 2; m++) {
                    VITIS_LOOP_431_2: for (int n = 0; n < 2; n++) {
                        a[(m << 1) + n] = arr[vBlkIndex + m][blk + n];
                    }
                }

            N2:
                for (int l = 0; l < xfNPixelsPerCycle<NPC>::nppc; l++) {
                    typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::cname x1 = bilinear<IN_TYPE>(a[0], a[1], hBlkSize, offset);
                    typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::cname x2 = bilinear<IN_TYPE>(a[2], a[3], hBlkSize, offset);
                    typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::cname
                    y = bilinear<BILINEAR_INTERPOLATE_TYPE>(x1, x2, vBlkSize, i);
                    out.range((l + 1) * DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::pixelwidth - 1,
                              l * DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::pixelwidth) = y;
                }

                offset++;
                if (offset == hBlkSize) {
                    offset = 0;
                    blk++;
                }
                interpolateOut.write(out);
            }
        }
    }

    static void processInterpolate(typename DataType<IN_TYPE, NPC>::cname arr[MinMaxVArrSize][MinMaxHArrSize],
                                   LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>& Tile,
                                   hls::stream<typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::name>& interpolateOut) {
    R3:
        for (int i = 0; i < Tile.getVBlkCount(); i++) {

#pragma HLS LOOP_TRIPCOUNT min=MinMaxVArrSize max=MinMaxVArrSize

 interpolate(arr, Tile.getVBlkSize(i), i, Tile, interpolateOut);
        }
    }

    static inline float compute(float val, float min, float max) {

        float op1 = std::log(val + std::numeric_limits<float>::epsilon());
        float op2 = std::log(min + std::numeric_limits<float>::epsilon());
        float op3 = std::log(max + std::numeric_limits<float>::epsilon());
        float ret = (op1 - op2) / ((op3 - op2) + std::numeric_limits<float>::epsilon());
        return ret;
    }

    static void compute(xf::cv::Mat<IN_TYPE, ROWS, COLS, NPC>& in,
                        LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>& Tile,
                        hls::stream<typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::name>& interpolateMin,
                        hls::stream<typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::name>& interpolateMax,
                        xf::cv::Mat<OUT_TYPE, ROWS, COLS, NPC>& out) {
        int addr = 0;
    R4:
        for (int i = 0; i < Tile.getInputRows(); i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 C4:
            for (int j = 0; j < Tile.getInputColsAlignedNPC(); j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS_NPC_ALIGNED max=COLS_NPC_ALIGNED
#pragma HLS PIPELINE II=1

 typename DataType<IN_TYPE, NPC>::name val = in.read(addr);
                typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::name interpolateMinVal = interpolateMin.read();
                typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::name interpolateMaxVal = interpolateMax.read();
                typename DataType<OUT_TYPE, NPC>::name valF;
            N4:
                for (int l = 0; l < xfNPixelsPerCycle<NPC>::nppc; l++) {
                    typename DataType<IN_TYPE, NPC>::uname
                    vali = val.range((l + 1) * DataType<IN_TYPE, NPC>::pixelwidth - 1, l * DataType<IN_TYPE, NPC>::pixelwidth);

                    typename DataType<IN_TYPE, NPC>::cname maxVal = max(vali);
                    typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::uname
                    iMin = interpolateMinVal.range((l + 1) * DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::pixelwidth - 1,
                                                   l * DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::pixelwidth);
                    typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::uname
                    iMax = interpolateMaxVal.range((l + 1) * DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::pixelwidth - 1,
                                                   l * DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::pixelwidth);


                    float computeVal = compute(to_float<IN_TYPE>(maxVal), to_float<BILINEAR_INTERPOLATE_TYPE>(iMin),
                                               to_float<BILINEAR_INTERPOLATE_TYPE>(iMax));
                    float ratio = computeVal / to_float<IN_TYPE>(maxVal);

                    typename DataType<OUT_TYPE, NPC>::uname valO;
                CH4:
                    for (int m = 0; m < DataType<OUT_TYPE, NPC>::channel; m++) {
                        typename DataType<IN_TYPE, NPC>::cname
                        valiC =
                            vali.range((m + 1) * DataType<IN_TYPE, NPC>::bitdepth - 1, m * DataType<IN_TYPE, NPC>::bitdepth);
                        float finalValue = (to_float<IN_TYPE>(valiC) * ratio * OUT_DEPTH);

                        typename DataType<OUT_TYPE, NPC>::cname valiCOut;
                        if (finalValue < 0)
                            valiCOut = 0;
                        else if (finalValue > 255)
                            valiCOut = 255;
                        else
                            valiCOut = finalValue;

                        valO.range((m + 1) * DataType<OUT_TYPE, NPC>::bitdepth - 1, m * DataType<OUT_TYPE, NPC>::bitdepth) =
                            valiCOut;
                    }
                    valF.range((l + 1) * DataType<OUT_TYPE, NPC>::pixelwidth - 1, l * DataType<OUT_TYPE, NPC>::pixelwidth) = valO;
                }
                out.write(addr, valF);
                addr++;
            }
        }
    }

    static void process_i(xf::cv::Mat<IN_TYPE, ROWS, COLS, NPC>& in,
                          LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC>& Tile,
                          typename DataType<IN_TYPE, NPC>::cname omin_r[MinMaxVArrSize][MinMaxHArrSize],
                          typename DataType<IN_TYPE, NPC>::cname omax_r[MinMaxVArrSize][MinMaxHArrSize],
                          typename DataType<IN_TYPE, NPC>::cname omin_w[MinMaxVArrSize][MinMaxHArrSize],
                          typename DataType<IN_TYPE, NPC>::cname omax_w[MinMaxVArrSize][MinMaxHArrSize],
                          xf::cv::Mat<OUT_TYPE, ROWS, COLS, NPC>& out) {
        xf::cv::Mat<IN_TYPE, ROWS, COLS, NPC> in_copy(in.rows, in.cols);
        hls::stream<ap_uint<DataType<IN_TYPE, NPC>::bitdepth * xfNPixelsPerCycle<NPC>::nppc> > in_max;
        hls::stream<typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::name> interpolateMin;
        hls::stream<typename DataType<BILINEAR_INTERPOLATE_TYPE, NPC>::name> interpolateMax;


#pragma HLS DATAFLOW

 getMaxImage(in, Tile, in_copy, in_max);
        processMinMax(in_max, Tile, omin_w, omax_w);
        processInterpolate(omin_r, Tile, interpolateMin);
        processInterpolate(omax_r, Tile, interpolateMax);
        compute(in_copy, Tile, interpolateMin, interpolateMax, out);
    }

    static void process(xf::cv::Mat<IN_TYPE, ROWS, COLS, NPC>& in,
                        typename DataType<IN_TYPE, NPC>::cname omin_r[MinMaxVArrSize][MinMaxHArrSize],
                        typename DataType<IN_TYPE, NPC>::cname omax_r[MinMaxVArrSize][MinMaxHArrSize],
                        typename DataType<IN_TYPE, NPC>::cname omin_w[MinMaxVArrSize][MinMaxHArrSize],
                        typename DataType<IN_TYPE, NPC>::cname omax_w[MinMaxVArrSize][MinMaxHArrSize],
                        xf::cv::Mat<OUT_TYPE, ROWS, COLS, NPC>& out) {
        LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC> Tile(in.rows, in.cols);

#pragma HLS ARRAY_PARTITION variable=Tile.mVBlkSize dim=1 complete
#pragma HLS ARRAY_PARTITION variable=Tile.mHBlkSize dim=1 complete

 process_i(in, Tile, omin_r, omax_r, omin_w, omax_w, out);
    }

    static void process(xf::cv::Mat<IN_TYPE, ROWS, COLS, NPC>& in,
                        int block_rows,
                        int block_cols,
                        typename DataType<IN_TYPE, NPC>::cname omin_r[MinMaxVArrSize][MinMaxHArrSize],
                        typename DataType<IN_TYPE, NPC>::cname omax_r[MinMaxVArrSize][MinMaxHArrSize],
                        typename DataType<IN_TYPE, NPC>::cname omin_w[MinMaxVArrSize][MinMaxHArrSize],
                        typename DataType<IN_TYPE, NPC>::cname omax_w[MinMaxVArrSize][MinMaxHArrSize],
                        xf::cv::Mat<OUT_TYPE, ROWS, COLS, NPC>& out) {
        LTMTile<BLK_ROWS, BLK_COLS, ROWS, COLS, NPC> Tile(in.rows, in.cols, block_rows, block_cols);

#pragma HLS ARRAY_PARTITION variable=Tile.mVBlkSize dim=1 complete
#pragma HLS ARRAY_PARTITION variable=Tile.mHBlkSize dim=1 complete

 process_i(in, Tile, omin_r, omax_r, omin_w, omax_w, out);
    }
};

}
}
# 36 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_quantizationdithering.hpp" 1
# 20 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_quantizationdithering.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 21 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_quantizationdithering.hpp" 2


# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/core/xf_math.h" 1
# 20 "../../../../../overlays/Vitis_Libraries/vision//L1/include/core/xf_math.h"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 21 "../../../../../overlays/Vitis_Libraries/vision//L1/include/core/xf_math.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 23 "../../../../../overlays/Vitis_Libraries/vision//L1/include/core/xf_math.h" 2








namespace xf {
namespace cv {

static unsigned int division_lut32[32768] = {
    131068, 131070, 131068, 131064, 131060, 131056, 131052, 131048, 131044, 131040, 131036, 131032, 131028, 131024,
    131020, 131016, 131012, 131008, 131004, 131000, 130996, 130992, 130988, 130984, 130980, 130976, 130972, 130968,
    130964, 130960, 130956, 130952, 130948, 130944, 130940, 130936, 130932, 130928, 130924, 130920, 130916, 130912,
    130908, 130904, 130900, 130896, 130892, 130888, 130884, 130880, 130876, 130872, 130868, 130864, 130860, 130856,
    130852, 130848, 130844, 130840, 130836, 130832, 130828, 130824, 130820, 130816, 130812, 130808, 130804, 130800,
    130796, 130792, 130788, 130784, 130780, 130776, 130772, 130768, 130764, 130760, 130756, 130752, 130748, 130744,
    130740, 130736, 130732, 130728, 130724, 130720, 130716, 130712, 130709, 130705, 130701, 130697, 130693, 130689,
    130685, 130681, 130677, 130673, 130669, 130665, 130661, 130657, 130653, 130649, 130645, 130641, 130637, 130633,
    130629, 130625, 130621, 130617, 130613, 130609, 130605, 130601, 130597, 130593, 130589, 130585, 130581, 130577,
    130573, 130569, 130565, 130561, 130558, 130554, 130550, 130546, 130542, 130538, 130534, 130530, 130526, 130522,
    130518, 130514, 130510, 130506, 130502, 130498, 130494, 130490, 130486, 130482, 130478, 130474, 130470, 130466,
    130462, 130458, 130454, 130450, 130446, 130443, 130439, 130435, 130431, 130427, 130423, 130419, 130415, 130411,
    130407, 130403, 130399, 130395, 130391, 130387, 130383, 130379, 130375, 130371, 130367, 130363, 130359, 130355,
    130351, 130348, 130344, 130340, 130336, 130332, 130328, 130324, 130320, 130316, 130312, 130308, 130304, 130300,
    130296, 130292, 130288, 130284, 130280, 130276, 130272, 130268, 130265, 130261, 130257, 130253, 130249, 130245,
    130241, 130237, 130233, 130229, 130225, 130221, 130217, 130213, 130209, 130205, 130201, 130197, 130193, 130189,
    130186, 130182, 130178, 130174, 130170, 130166, 130162, 130158, 130154, 130150, 130146, 130142, 130138, 130134,
    130130, 130126, 130122, 130118, 130115, 130111, 130107, 130103, 130099, 130095, 130091, 130087, 130083, 130079,
    130075, 130071, 130067, 130063, 130059, 130055, 130052, 130048, 130044, 130040, 130036, 130032, 130028, 130024,
    130020, 130016, 130012, 130008, 130004, 130000, 129996, 129992, 129989, 129985, 129981, 129977, 129973, 129969,
    129965, 129961, 129957, 129953, 129949, 129945, 129941, 129937, 129933, 129930, 129926, 129922, 129918, 129914,
    129910, 129906, 129902, 129898, 129894, 129890, 129886, 129882, 129878, 129875, 129871, 129867, 129863, 129859,
    129855, 129851, 129847, 129843, 129839, 129835, 129831, 129827, 129824, 129820, 129816, 129812, 129808, 129804,
    129800, 129796, 129792, 129788, 129784, 129780, 129776, 129773, 129769, 129765, 129761, 129757, 129753, 129749,
    129745, 129741, 129737, 129733, 129729, 129725, 129722, 129718, 129714, 129710, 129706, 129702, 129698, 129694,
    129690, 129686, 129682, 129678, 129675, 129671, 129667, 129663, 129659, 129655, 129651, 129647, 129643, 129639,
    129635, 129632, 129628, 129624, 129620, 129616, 129612, 129608, 129604, 129600, 129596, 129592, 129588, 129585,
    129581, 129577, 129573, 129569, 129565, 129561, 129557, 129553, 129549, 129545, 129542, 129538, 129534, 129530,
    129526, 129522, 129518, 129514, 129510, 129506, 129503, 129499, 129495, 129491, 129487, 129483, 129479, 129475,
    129471, 129467, 129463, 129460, 129456, 129452, 129448, 129444, 129440, 129436, 129432, 129428, 129424, 129421,
    129417, 129413, 129409, 129405, 129401, 129397, 129393, 129389, 129385, 129382, 129378, 129374, 129370, 129366,
    129362, 129358, 129354, 129350, 129347, 129343, 129339, 129335, 129331, 129327, 129323, 129319, 129315, 129311,
    129308, 129304, 129300, 129296, 129292, 129288, 129284, 129280, 129276, 129273, 129269, 129265, 129261, 129257,
    129253, 129249, 129245, 129241, 129238, 129234, 129230, 129226, 129222, 129218, 129214, 129210, 129206, 129203,
    129199, 129195, 129191, 129187, 129183, 129179, 129175, 129171, 129168, 129164, 129160, 129156, 129152, 129148,
    129144, 129140, 129136, 129133, 129129, 129125, 129121, 129117, 129113, 129109, 129105, 129102, 129098, 129094,
    129090, 129086, 129082, 129078, 129074, 129071, 129067, 129063, 129059, 129055, 129051, 129047, 129043, 129040,
    129036, 129032, 129028, 129024, 129020, 129016, 129012, 129008, 129005, 129001, 128997, 128993, 128989, 128985,
    128981, 128978, 128974, 128970, 128966, 128962, 128958, 128954, 128950, 128947, 128943, 128939, 128935, 128931,
    128927, 128923, 128919, 128916, 128912, 128908, 128904, 128900, 128896, 128892, 128888, 128885, 128881, 128877,
    128873, 128869, 128865, 128861, 128858, 128854, 128850, 128846, 128842, 128838, 128834, 128830, 128827, 128823,
    128819, 128815, 128811, 128807, 128803, 128800, 128796, 128792, 128788, 128784, 128780, 128776, 128773, 128769,
    128765, 128761, 128757, 128753, 128749, 128746, 128742, 128738, 128734, 128730, 128726, 128722, 128719, 128715,
    128711, 128707, 128703, 128699, 128695, 128692, 128688, 128684, 128680, 128676, 128672, 128668, 128665, 128661,
    128657, 128653, 128649, 128645, 128641, 128638, 128634, 128630, 128626, 128622, 128618, 128614, 128611, 128607,
    128603, 128599, 128595, 128591, 128587, 128584, 128580, 128576, 128572, 128568, 128564, 128561, 128557, 128553,
    128549, 128545, 128541, 128537, 128534, 128530, 128526, 128522, 128518, 128514, 128511, 128507, 128503, 128499,
    128495, 128491, 128487, 128484, 128480, 128476, 128472, 128468, 128464, 128461, 128457, 128453, 128449, 128445,
    128441, 128438, 128434, 128430, 128426, 128422, 128418, 128414, 128411, 128407, 128403, 128399, 128395, 128391,
    128388, 128384, 128380, 128376, 128372, 128368, 128365, 128361, 128357, 128353, 128349, 128345, 128342, 128338,
    128334, 128330, 128326, 128322, 128319, 128315, 128311, 128307, 128303, 128299, 128296, 128292, 128288, 128284,
    128280, 128276, 128273, 128269, 128265, 128261, 128257, 128253, 128250, 128246, 128242, 128238, 128234, 128230,
    128227, 128223, 128219, 128215, 128211, 128207, 128204, 128200, 128196, 128192, 128188, 128185, 128181, 128177,
    128173, 128169, 128165, 128162, 128158, 128154, 128150, 128146, 128142, 128139, 128135, 128131, 128127, 128123,
    128120, 128116, 128112, 128108, 128104, 128100, 128097, 128093, 128089, 128085, 128081, 128077, 128074, 128070,
    128066, 128062, 128058, 128055, 128051, 128047, 128043, 128039, 128035, 128032, 128028, 128024, 128020, 128016,
    128013, 128009, 128005, 128001, 127997, 127994, 127990, 127986, 127982, 127978, 127974, 127971, 127967, 127963,
    127959, 127955, 127952, 127948, 127944, 127940, 127936, 127933, 127929, 127925, 127921, 127917, 127913, 127910,
    127906, 127902, 127898, 127894, 127891, 127887, 127883, 127879, 127875, 127872, 127868, 127864, 127860, 127856,
    127853, 127849, 127845, 127841, 127837, 127834, 127830, 127826, 127822, 127818, 127814, 127811, 127807, 127803,
    127799, 127795, 127792, 127788, 127784, 127780, 127776, 127773, 127769, 127765, 127761, 127757, 127754, 127750,
    127746, 127742, 127738, 127735, 127731, 127727, 127723, 127719, 127716, 127712, 127708, 127704, 127700, 127697,
    127693, 127689, 127685, 127682, 127678, 127674, 127670, 127666, 127663, 127659, 127655, 127651, 127647, 127644,
    127640, 127636, 127632, 127628, 127625, 127621, 127617, 127613, 127609, 127606, 127602, 127598, 127594, 127590,
    127587, 127583, 127579, 127575, 127572, 127568, 127564, 127560, 127556, 127553, 127549, 127545, 127541, 127537,
    127534, 127530, 127526, 127522, 127518, 127515, 127511, 127507, 127503, 127500, 127496, 127492, 127488, 127484,
    127481, 127477, 127473, 127469, 127466, 127462, 127458, 127454, 127450, 127447, 127443, 127439, 127435, 127431,
    127428, 127424, 127420, 127416, 127413, 127409, 127405, 127401, 127397, 127394, 127390, 127386, 127382, 127379,
    127375, 127371, 127367, 127363, 127360, 127356, 127352, 127348, 127345, 127341, 127337, 127333, 127329, 127326,
    127322, 127318, 127314, 127311, 127307, 127303, 127299, 127296, 127292, 127288, 127284, 127280, 127277, 127273,
    127269, 127265, 127262, 127258, 127254, 127250, 127246, 127243, 127239, 127235, 127231, 127228, 127224, 127220,
    127216, 127213, 127209, 127205, 127201, 127197, 127194, 127190, 127186, 127182, 127179, 127175, 127171, 127167,
    127164, 127160, 127156, 127152, 127149, 127145, 127141, 127137, 127133, 127130, 127126, 127122, 127118, 127115,
    127111, 127107, 127103, 127100, 127096, 127092, 127088, 127085, 127081, 127077, 127073, 127070, 127066, 127062,
    127058, 127055, 127051, 127047, 127043, 127039, 127036, 127032, 127028, 127024, 127021, 127017, 127013, 127009,
    127006, 127002, 126998, 126994, 126991, 126987, 126983, 126979, 126976, 126972, 126968, 126964, 126961, 126957,
    126953, 126949, 126946, 126942, 126938, 126934, 126931, 126927, 126923, 126919, 126916, 126912, 126908, 126904,
    126901, 126897, 126893, 126889, 126886, 126882, 126878, 126874, 126871, 126867, 126863, 126859, 126856, 126852,
    126848, 126844, 126841, 126837, 126833, 126829, 126826, 126822, 126818, 126814, 126811, 126807, 126803, 126799,
    126796, 126792, 126788, 126784, 126781, 126777, 126773, 126769, 126766, 126762, 126758, 126755, 126751, 126747,
    126743, 126740, 126736, 126732, 126728, 126725, 126721, 126717, 126713, 126710, 126706, 126702, 126698, 126695,
    126691, 126687, 126683, 126680, 126676, 126672, 126669, 126665, 126661, 126657, 126654, 126650, 126646, 126642,
    126639, 126635, 126631, 126627, 126624, 126620, 126616, 126613, 126609, 126605, 126601, 126598, 126594, 126590,
    126586, 126583, 126579, 126575, 126571, 126568, 126564, 126560, 126557, 126553, 126549, 126545, 126542, 126538,
    126534, 126530, 126527, 126523, 126519, 126516, 126512, 126508, 126504, 126501, 126497, 126493, 126489, 126486,
    126482, 126478, 126475, 126471, 126467, 126463, 126460, 126456, 126452, 126449, 126445, 126441, 126437, 126434,
    126430, 126426, 126422, 126419, 126415, 126411, 126408, 126404, 126400, 126396, 126393, 126389, 126385, 126382,
    126378, 126374, 126370, 126367, 126363, 126359, 126356, 126352, 126348, 126344, 126341, 126337, 126333, 126330,
    126326, 126322, 126318, 126315, 126311, 126307, 126303, 126300, 126296, 126292, 126289, 126285, 126281, 126278,
    126274, 126270, 126266, 126263, 126259, 126255, 126252, 126248, 126244, 126240, 126237, 126233, 126229, 126226,
    126222, 126218, 126214, 126211, 126207, 126203, 126200, 126196, 126192, 126188, 126185, 126181, 126177, 126174,
    126170, 126166, 126163, 126159, 126155, 126151, 126148, 126144, 126140, 126137, 126133, 126129, 126125, 126122,
    126118, 126114, 126111, 126107, 126103, 126100, 126096, 126092, 126088, 126085, 126081, 126077, 126074, 126070,
    126066, 126063, 126059, 126055, 126051, 126048, 126044, 126040, 126037, 126033, 126029, 126026, 126022, 126018,
    126014, 126011, 126007, 126003, 126000, 125996, 125992, 125989, 125985, 125981, 125977, 125974, 125970, 125966,
    125963, 125959, 125955, 125952, 125948, 125944, 125941, 125937, 125933, 125929, 125926, 125922, 125918, 125915,
    125911, 125907, 125904, 125900, 125896, 125893, 125889, 125885, 125881, 125878, 125874, 125870, 125867, 125863,
    125859, 125856, 125852, 125848, 125845, 125841, 125837, 125834, 125830, 125826, 125822, 125819, 125815, 125811,
    125808, 125804, 125800, 125797, 125793, 125789, 125786, 125782, 125778, 125775, 125771, 125767, 125764, 125760,
    125756, 125752, 125749, 125745, 125741, 125738, 125734, 125730, 125727, 125723, 125719, 125716, 125712, 125708,
    125705, 125701, 125697, 125694, 125690, 125686, 125683, 125679, 125675, 125672, 125668, 125664, 125661, 125657,
    125653, 125649, 125646, 125642, 125638, 125635, 125631, 125627, 125624, 125620, 125616, 125613, 125609, 125605,
    125602, 125598, 125594, 125591, 125587, 125583, 125580, 125576, 125572, 125569, 125565, 125561, 125558, 125554,
    125550, 125547, 125543, 125539, 125536, 125532, 125528, 125525, 125521, 125517, 125514, 125510, 125506, 125503,
    125499, 125495, 125492, 125488, 125484, 125481, 125477, 125473, 125470, 125466, 125462, 125459, 125455, 125451,
    125448, 125444, 125440, 125437, 125433, 125429, 125426, 125422, 125418, 125415, 125411, 125407, 125404, 125400,
    125396, 125393, 125389, 125385, 125382, 125378, 125374, 125371, 125367, 125363, 125360, 125356, 125352, 125349,
    125345, 125341, 125338, 125334, 125330, 125327, 125323, 125320, 125316, 125312, 125309, 125305, 125301, 125298,
    125294, 125290, 125287, 125283, 125279, 125276, 125272, 125268, 125265, 125261, 125257, 125254, 125250, 125246,
    125243, 125239, 125235, 125232, 125228, 125225, 125221, 125217, 125214, 125210, 125206, 125203, 125199, 125195,
    125192, 125188, 125184, 125181, 125177, 125173, 125170, 125166, 125162, 125159, 125155, 125152, 125148, 125144,
    125141, 125137, 125133, 125130, 125126, 125122, 125119, 125115, 125111, 125108, 125104, 125100, 125097, 125093,
    125090, 125086, 125082, 125079, 125075, 125071, 125068, 125064, 125060, 125057, 125053, 125050, 125046, 125042,
    125039, 125035, 125031, 125028, 125024, 125020, 125017, 125013, 125009, 125006, 125002, 124999, 124995, 124991,
    124988, 124984, 124980, 124977, 124973, 124969, 124966, 124962, 124959, 124955, 124951, 124948, 124944, 124940,
    124937, 124933, 124929, 124926, 124922, 124919, 124915, 124911, 124908, 124904, 124900, 124897, 124893, 124890,
    124886, 124882, 124879, 124875, 124871, 124868, 124864, 124860, 124857, 124853, 124850, 124846, 124842, 124839,
    124835, 124831, 124828, 124824, 124821, 124817, 124813, 124810, 124806, 124802, 124799, 124795, 124792, 124788,
    124784, 124781, 124777, 124773, 124770, 124766, 124763, 124759, 124755, 124752, 124748, 124744, 124741, 124737,
    124734, 124730, 124726, 124723, 124719, 124715, 124712, 124708, 124705, 124701, 124697, 124694, 124690, 124686,
    124683, 124679, 124676, 124672, 124668, 124665, 124661, 124658, 124654, 124650, 124647, 124643, 124639, 124636,
    124632, 124629, 124625, 124621, 124618, 124614, 124611, 124607, 124603, 124600, 124596, 124592, 124589, 124585,
    124582, 124578, 124574, 124571, 124567, 124564, 124560, 124556, 124553, 124549, 124545, 124542, 124538, 124535,
    124531, 124527, 124524, 124520, 124517, 124513, 124509, 124506, 124502, 124499, 124495, 124491, 124488, 124484,
    124480, 124477, 124473, 124470, 124466, 124462, 124459, 124455, 124452, 124448, 124444, 124441, 124437, 124434,
    124430, 124426, 124423, 124419, 124416, 124412, 124408, 124405, 124401, 124398, 124394, 124390, 124387, 124383,
    124380, 124376, 124372, 124369, 124365, 124362, 124358, 124354, 124351, 124347, 124344, 124340, 124336, 124333,
    124329, 124326, 124322, 124318, 124315, 124311, 124308, 124304, 124300, 124297, 124293, 124290, 124286, 124282,
    124279, 124275, 124272, 124268, 124264, 124261, 124257, 124254, 124250, 124246, 124243, 124239, 124236, 124232,
    124228, 124225, 124221, 124218, 124214, 124210, 124207, 124203, 124200, 124196, 124193, 124189, 124185, 124182,
    124178, 124175, 124171, 124167, 124164, 124160, 124157, 124153, 124149, 124146, 124142, 124139, 124135, 124132,
    124128, 124124, 124121, 124117, 124114, 124110, 124106, 124103, 124099, 124096, 124092, 124088, 124085, 124081,
    124078, 124074, 124071, 124067, 124063, 124060, 124056, 124053, 124049, 124045, 124042, 124038, 124035, 124031,
    124028, 124024, 124020, 124017, 124013, 124010, 124006, 124002, 123999, 123995, 123992, 123988, 123985, 123981,
    123977, 123974, 123970, 123967, 123963, 123960, 123956, 123952, 123949, 123945, 123942, 123938, 123935, 123931,
    123927, 123924, 123920, 123917, 123913, 123909, 123906, 123902, 123899, 123895, 123892, 123888, 123884, 123881,
    123877, 123874, 123870, 123867, 123863, 123859, 123856, 123852, 123849, 123845, 123842, 123838, 123834, 123831,
    123827, 123824, 123820, 123817, 123813, 123809, 123806, 123802, 123799, 123795, 123792, 123788, 123784, 123781,
    123777, 123774, 123770, 123767, 123763, 123760, 123756, 123752, 123749, 123745, 123742, 123738, 123735, 123731,
    123727, 123724, 123720, 123717, 123713, 123710, 123706, 123702, 123699, 123695, 123692, 123688, 123685, 123681,
    123678, 123674, 123670, 123667, 123663, 123660, 123656, 123653, 123649, 123645, 123642, 123638, 123635, 123631,
    123628, 123624, 123621, 123617, 123613, 123610, 123606, 123603, 123599, 123596, 123592, 123589, 123585, 123581,
    123578, 123574, 123571, 123567, 123564, 123560, 123557, 123553, 123549, 123546, 123542, 123539, 123535, 123532,
    123528, 123525, 123521, 123517, 123514, 123510, 123507, 123503, 123500, 123496, 123493, 123489, 123486, 123482,
    123478, 123475, 123471, 123468, 123464, 123461, 123457, 123454, 123450, 123446, 123443, 123439, 123436, 123432,
    123429, 123425, 123422, 123418, 123415, 123411, 123407, 123404, 123400, 123397, 123393, 123390, 123386, 123383,
    123379, 123376, 123372, 123368, 123365, 123361, 123358, 123354, 123351, 123347, 123344, 123340, 123337, 123333,
    123330, 123326, 123322, 123319, 123315, 123312, 123308, 123305, 123301, 123298, 123294, 123291, 123287, 123283,
    123280, 123276, 123273, 123269, 123266, 123262, 123259, 123255, 123252, 123248, 123245, 123241, 123237, 123234,
    123230, 123227, 123223, 123220, 123216, 123213, 123209, 123206, 123202, 123199, 123195, 123192, 123188, 123184,
    123181, 123177, 123174, 123170, 123167, 123163, 123160, 123156, 123153, 123149, 123146, 123142, 123139, 123135,
    123132, 123128, 123124, 123121, 123117, 123114, 123110, 123107, 123103, 123100, 123096, 123093, 123089, 123086,
    123082, 123079, 123075, 123072, 123068, 123064, 123061, 123057, 123054, 123050, 123047, 123043, 123040, 123036,
    123033, 123029, 123026, 123022, 123019, 123015, 123012, 123008, 123005, 123001, 122998, 122994, 122990, 122987,
    122983, 122980, 122976, 122973, 122969, 122966, 122962, 122959, 122955, 122952, 122948, 122945, 122941, 122938,
    122934, 122931, 122927, 122924, 122920, 122917, 122913, 122910, 122906, 122902, 122899, 122895, 122892, 122888,
    122885, 122881, 122878, 122874, 122871, 122867, 122864, 122860, 122857, 122853, 122850, 122846, 122843, 122839,
    122836, 122832, 122829, 122825, 122822, 122818, 122815, 122811, 122808, 122804, 122801, 122797, 122794, 122790,
    122787, 122783, 122780, 122776, 122772, 122769, 122765, 122762, 122758, 122755, 122751, 122748, 122744, 122741,
    122737, 122734, 122730, 122727, 122723, 122720, 122716, 122713, 122709, 122706, 122702, 122699, 122695, 122692,
    122688, 122685, 122681, 122678, 122674, 122671, 122667, 122664, 122660, 122657, 122653, 122650, 122646, 122643,
    122639, 122636, 122632, 122629, 122625, 122622, 122618, 122615, 122611, 122608, 122604, 122601, 122597, 122594,
    122590, 122587, 122583, 122580, 122576, 122573, 122569, 122566, 122562, 122559, 122555, 122552, 122548, 122545,
    122541, 122538, 122534, 122531, 122527, 122524, 122520, 122517, 122513, 122510, 122506, 122503, 122499, 122496,
    122492, 122489, 122485, 122482, 122478, 122475, 122471, 122468, 122464, 122461, 122457, 122454, 122450, 122447,
    122443, 122440, 122436, 122433, 122430, 122426, 122423, 122419, 122416, 122412, 122409, 122405, 122402, 122398,
    122395, 122391, 122388, 122384, 122381, 122377, 122374, 122370, 122367, 122363, 122360, 122356, 122353, 122349,
    122346, 122342, 122339, 122335, 122332, 122328, 122325, 122321, 122318, 122314, 122311, 122307, 122304, 122301,
    122297, 122294, 122290, 122287, 122283, 122280, 122276, 122273, 122269, 122266, 122262, 122259, 122255, 122252,
    122248, 122245, 122241, 122238, 122234, 122231, 122227, 122224, 122220, 122217, 122214, 122210, 122207, 122203,
    122200, 122196, 122193, 122189, 122186, 122182, 122179, 122175, 122172, 122168, 122165, 122161, 122158, 122154,
    122151, 122147, 122144, 122141, 122137, 122134, 122130, 122127, 122123, 122120, 122116, 122113, 122109, 122106,
    122102, 122099, 122095, 122092, 122088, 122085, 122082, 122078, 122075, 122071, 122068, 122064, 122061, 122057,
    122054, 122050, 122047, 122043, 122040, 122036, 122033, 122029, 122026, 122023, 122019, 122016, 122012, 122009,
    122005, 122002, 121998, 121995, 121991, 121988, 121984, 121981, 121978, 121974, 121971, 121967, 121964, 121960,
    121957, 121953, 121950, 121946, 121943, 121939, 121936, 121932, 121929, 121926, 121922, 121919, 121915, 121912,
    121908, 121905, 121901, 121898, 121894, 121891, 121887, 121884, 121881, 121877, 121874, 121870, 121867, 121863,
    121860, 121856, 121853, 121849, 121846, 121843, 121839, 121836, 121832, 121829, 121825, 121822, 121818, 121815,
    121811, 121808, 121805, 121801, 121798, 121794, 121791, 121787, 121784, 121780, 121777, 121773, 121770, 121767,
    121763, 121760, 121756, 121753, 121749, 121746, 121742, 121739, 121735, 121732, 121729, 121725, 121722, 121718,
    121715, 121711, 121708, 121704, 121701, 121698, 121694, 121691, 121687, 121684, 121680, 121677, 121673, 121670,
    121667, 121663, 121660, 121656, 121653, 121649, 121646, 121642, 121639, 121636, 121632, 121629, 121625, 121622,
    121618, 121615, 121611, 121608, 121605, 121601, 121598, 121594, 121591, 121587, 121584, 121580, 121577, 121574,
    121570, 121567, 121563, 121560, 121556, 121553, 121549, 121546, 121543, 121539, 121536, 121532, 121529, 121525,
    121522, 121518, 121515, 121512, 121508, 121505, 121501, 121498, 121494, 121491, 121488, 121484, 121481, 121477,
    121474, 121470, 121467, 121464, 121460, 121457, 121453, 121450, 121446, 121443, 121439, 121436, 121433, 121429,
    121426, 121422, 121419, 121415, 121412, 121409, 121405, 121402, 121398, 121395, 121391, 121388, 121385, 121381,
    121378, 121374, 121371, 121367, 121364, 121361, 121357, 121354, 121350, 121347, 121343, 121340, 121337, 121333,
    121330, 121326, 121323, 121319, 121316, 121313, 121309, 121306, 121302, 121299, 121295, 121292, 121289, 121285,
    121282, 121278, 121275, 121271, 121268, 121265, 121261, 121258, 121254, 121251, 121247, 121244, 121241, 121237,
    121234, 121230, 121227, 121224, 121220, 121217, 121213, 121210, 121206, 121203, 121200, 121196, 121193, 121189,
    121186, 121182, 121179, 121176, 121172, 121169, 121165, 121162, 121159, 121155, 121152, 121148, 121145, 121141,
    121138, 121135, 121131, 121128, 121124, 121121, 121118, 121114, 121111, 121107, 121104, 121100, 121097, 121094,
    121090, 121087, 121083, 121080, 121077, 121073, 121070, 121066, 121063, 121060, 121056, 121053, 121049, 121046,
    121042, 121039, 121036, 121032, 121029, 121025, 121022, 121019, 121015, 121012, 121008, 121005, 121002, 120998,
    120995, 120991, 120988, 120984, 120981, 120978, 120974, 120971, 120967, 120964, 120961, 120957, 120954, 120950,
    120947, 120944, 120940, 120937, 120933, 120930, 120927, 120923, 120920, 120916, 120913, 120910, 120906, 120903,
    120899, 120896, 120893, 120889, 120886, 120882, 120879, 120876, 120872, 120869, 120865, 120862, 120859, 120855,
    120852, 120848, 120845, 120842, 120838, 120835, 120831, 120828, 120825, 120821, 120818, 120814, 120811, 120808,
    120804, 120801, 120797, 120794, 120791, 120787, 120784, 120780, 120777, 120774, 120770, 120767, 120763, 120760,
    120757, 120753, 120750, 120746, 120743, 120740, 120736, 120733, 120729, 120726, 120723, 120719, 120716, 120712,
    120709, 120706, 120702, 120699, 120696, 120692, 120689, 120685, 120682, 120679, 120675, 120672, 120668, 120665,
    120662, 120658, 120655, 120651, 120648, 120645, 120641, 120638, 120634, 120631, 120628, 120624, 120621, 120618,
    120614, 120611, 120607, 120604, 120601, 120597, 120594, 120590, 120587, 120584, 120580, 120577, 120574, 120570,
    120567, 120563, 120560, 120557, 120553, 120550, 120546, 120543, 120540, 120536, 120533, 120530, 120526, 120523,
    120519, 120516, 120513, 120509, 120506, 120502, 120499, 120496, 120492, 120489, 120486, 120482, 120479, 120475,
    120472, 120469, 120465, 120462, 120459, 120455, 120452, 120448, 120445, 120442, 120438, 120435, 120432, 120428,
    120425, 120421, 120418, 120415, 120411, 120408, 120405, 120401, 120398, 120394, 120391, 120388, 120384, 120381,
    120378, 120374, 120371, 120367, 120364, 120361, 120357, 120354, 120351, 120347, 120344, 120340, 120337, 120334,
    120330, 120327, 120324, 120320, 120317, 120313, 120310, 120307, 120303, 120300, 120297, 120293, 120290, 120286,
    120283, 120280, 120276, 120273, 120270, 120266, 120263, 120260, 120256, 120253, 120249, 120246, 120243, 120239,
    120236, 120233, 120229, 120226, 120223, 120219, 120216, 120212, 120209, 120206, 120202, 120199, 120196, 120192,
    120189, 120186, 120182, 120179, 120175, 120172, 120169, 120165, 120162, 120159, 120155, 120152, 120149, 120145,
    120142, 120138, 120135, 120132, 120128, 120125, 120122, 120118, 120115, 120112, 120108, 120105, 120101, 120098,
    120095, 120091, 120088, 120085, 120081, 120078, 120075, 120071, 120068, 120065, 120061, 120058, 120054, 120051,
    120048, 120044, 120041, 120038, 120034, 120031, 120028, 120024, 120021, 120018, 120014, 120011, 120008, 120004,
    120001, 119997, 119994, 119991, 119987, 119984, 119981, 119977, 119974, 119971, 119967, 119964, 119961, 119957,
    119954, 119951, 119947, 119944, 119941, 119937, 119934, 119930, 119927, 119924, 119920, 119917, 119914, 119910,
    119907, 119904, 119900, 119897, 119894, 119890, 119887, 119884, 119880, 119877, 119874, 119870, 119867, 119864,
    119860, 119857, 119853, 119850, 119847, 119843, 119840, 119837, 119833, 119830, 119827, 119823, 119820, 119817,
    119813, 119810, 119807, 119803, 119800, 119797, 119793, 119790, 119787, 119783, 119780, 119777, 119773, 119770,
    119767, 119763, 119760, 119757, 119753, 119750, 119747, 119743, 119740, 119737, 119733, 119730, 119727, 119723,
    119720, 119717, 119713, 119710, 119706, 119703, 119700, 119696, 119693, 119690, 119686, 119683, 119680, 119676,
    119673, 119670, 119666, 119663, 119660, 119656, 119653, 119650, 119646, 119643, 119640, 119636, 119633, 119630,
    119626, 119623, 119620, 119616, 119613, 119610, 119606, 119603, 119600, 119596, 119593, 119590, 119587, 119583,
    119580, 119577, 119573, 119570, 119567, 119563, 119560, 119557, 119553, 119550, 119547, 119543, 119540, 119537,
    119533, 119530, 119527, 119523, 119520, 119517, 119513, 119510, 119507, 119503, 119500, 119497, 119493, 119490,
    119487, 119483, 119480, 119477, 119473, 119470, 119467, 119463, 119460, 119457, 119453, 119450, 119447, 119444,
    119440, 119437, 119434, 119430, 119427, 119424, 119420, 119417, 119414, 119410, 119407, 119404, 119400, 119397,
    119394, 119390, 119387, 119384, 119380, 119377, 119374, 119370, 119367, 119364, 119361, 119357, 119354, 119351,
    119347, 119344, 119341, 119337, 119334, 119331, 119327, 119324, 119321, 119317, 119314, 119311, 119307, 119304,
    119301, 119298, 119294, 119291, 119288, 119284, 119281, 119278, 119274, 119271, 119268, 119264, 119261, 119258,
    119254, 119251, 119248, 119245, 119241, 119238, 119235, 119231, 119228, 119225, 119221, 119218, 119215, 119211,
    119208, 119205, 119202, 119198, 119195, 119192, 119188, 119185, 119182, 119178, 119175, 119172, 119168, 119165,
    119162, 119159, 119155, 119152, 119149, 119145, 119142, 119139, 119135, 119132, 119129, 119125, 119122, 119119,
    119116, 119112, 119109, 119106, 119102, 119099, 119096, 119092, 119089, 119086, 119083, 119079, 119076, 119073,
    119069, 119066, 119063, 119059, 119056, 119053, 119050, 119046, 119043, 119040, 119036, 119033, 119030, 119026,
    119023, 119020, 119017, 119013, 119010, 119007, 119003, 119000, 118997, 118993, 118990, 118987, 118984, 118980,
    118977, 118974, 118970, 118967, 118964, 118960, 118957, 118954, 118951, 118947, 118944, 118941, 118937, 118934,
    118931, 118928, 118924, 118921, 118918, 118914, 118911, 118908, 118904, 118901, 118898, 118895, 118891, 118888,
    118885, 118881, 118878, 118875, 118872, 118868, 118865, 118862, 118858, 118855, 118852, 118849, 118845, 118842,
    118839, 118835, 118832, 118829, 118826, 118822, 118819, 118816, 118812, 118809, 118806, 118803, 118799, 118796,
    118793, 118789, 118786, 118783, 118780, 118776, 118773, 118770, 118766, 118763, 118760, 118757, 118753, 118750,
    118747, 118743, 118740, 118737, 118734, 118730, 118727, 118724, 118720, 118717, 118714, 118711, 118707, 118704,
    118701, 118697, 118694, 118691, 118688, 118684, 118681, 118678, 118675, 118671, 118668, 118665, 118661, 118658,
    118655, 118652, 118648, 118645, 118642, 118638, 118635, 118632, 118629, 118625, 118622, 118619, 118616, 118612,
    118609, 118606, 118602, 118599, 118596, 118593, 118589, 118586, 118583, 118579, 118576, 118573, 118570, 118566,
    118563, 118560, 118557, 118553, 118550, 118547, 118543, 118540, 118537, 118534, 118530, 118527, 118524, 118521,
    118517, 118514, 118511, 118508, 118504, 118501, 118498, 118494, 118491, 118488, 118485, 118481, 118478, 118475,
    118472, 118468, 118465, 118462, 118458, 118455, 118452, 118449, 118445, 118442, 118439, 118436, 118432, 118429,
    118426, 118423, 118419, 118416, 118413, 118409, 118406, 118403, 118400, 118396, 118393, 118390, 118387, 118383,
    118380, 118377, 118374, 118370, 118367, 118364, 118361, 118357, 118354, 118351, 118348, 118344, 118341, 118338,
    118334, 118331, 118328, 118325, 118321, 118318, 118315, 118312, 118308, 118305, 118302, 118299, 118295, 118292,
    118289, 118286, 118282, 118279, 118276, 118273, 118269, 118266, 118263, 118260, 118256, 118253, 118250, 118246,
    118243, 118240, 118237, 118233, 118230, 118227, 118224, 118220, 118217, 118214, 118211, 118207, 118204, 118201,
    118198, 118194, 118191, 118188, 118185, 118181, 118178, 118175, 118172, 118168, 118165, 118162, 118159, 118155,
    118152, 118149, 118146, 118142, 118139, 118136, 118133, 118129, 118126, 118123, 118120, 118116, 118113, 118110,
    118107, 118103, 118100, 118097, 118094, 118090, 118087, 118084, 118081, 118077, 118074, 118071, 118068, 118064,
    118061, 118058, 118055, 118051, 118048, 118045, 118042, 118039, 118035, 118032, 118029, 118026, 118022, 118019,
    118016, 118013, 118009, 118006, 118003, 118000, 117996, 117993, 117990, 117987, 117983, 117980, 117977, 117974,
    117970, 117967, 117964, 117961, 117957, 117954, 117951, 117948, 117945, 117941, 117938, 117935, 117932, 117928,
    117925, 117922, 117919, 117915, 117912, 117909, 117906, 117902, 117899, 117896, 117893, 117889, 117886, 117883,
    117880, 117877, 117873, 117870, 117867, 117864, 117860, 117857, 117854, 117851, 117847, 117844, 117841, 117838,
    117834, 117831, 117828, 117825, 117822, 117818, 117815, 117812, 117809, 117805, 117802, 117799, 117796, 117792,
    117789, 117786, 117783, 117780, 117776, 117773, 117770, 117767, 117763, 117760, 117757, 117754, 117750, 117747,
    117744, 117741, 117738, 117734, 117731, 117728, 117725, 117721, 117718, 117715, 117712, 117709, 117705, 117702,
    117699, 117696, 117692, 117689, 117686, 117683, 117680, 117676, 117673, 117670, 117667, 117663, 117660, 117657,
    117654, 117651, 117647, 117644, 117641, 117638, 117634, 117631, 117628, 117625, 117622, 117618, 117615, 117612,
    117609, 117605, 117602, 117599, 117596, 117593, 117589, 117586, 117583, 117580, 117576, 117573, 117570, 117567,
    117564, 117560, 117557, 117554, 117551, 117547, 117544, 117541, 117538, 117535, 117531, 117528, 117525, 117522,
    117519, 117515, 117512, 117509, 117506, 117502, 117499, 117496, 117493, 117490, 117486, 117483, 117480, 117477,
    117474, 117470, 117467, 117464, 117461, 117457, 117454, 117451, 117448, 117445, 117441, 117438, 117435, 117432,
    117429, 117425, 117422, 117419, 117416, 117412, 117409, 117406, 117403, 117400, 117396, 117393, 117390, 117387,
    117384, 117380, 117377, 117374, 117371, 117368, 117364, 117361, 117358, 117355, 117352, 117348, 117345, 117342,
    117339, 117336, 117332, 117329, 117326, 117323, 117319, 117316, 117313, 117310, 117307, 117303, 117300, 117297,
    117294, 117291, 117287, 117284, 117281, 117278, 117275, 117271, 117268, 117265, 117262, 117259, 117255, 117252,
    117249, 117246, 117243, 117239, 117236, 117233, 117230, 117227, 117223, 117220, 117217, 117214, 117211, 117207,
    117204, 117201, 117198, 117195, 117191, 117188, 117185, 117182, 117179, 117175, 117172, 117169, 117166, 117163,
    117159, 117156, 117153, 117150, 117147, 117143, 117140, 117137, 117134, 117131, 117128, 117124, 117121, 117118,
    117115, 117112, 117108, 117105, 117102, 117099, 117096, 117092, 117089, 117086, 117083, 117080, 117076, 117073,
    117070, 117067, 117064, 117060, 117057, 117054, 117051, 117048, 117045, 117041, 117038, 117035, 117032, 117029,
    117025, 117022, 117019, 117016, 117013, 117009, 117006, 117003, 117000, 116997, 116994, 116990, 116987, 116984,
    116981, 116978, 116974, 116971, 116968, 116965, 116962, 116958, 116955, 116952, 116949, 116946, 116943, 116939,
    116936, 116933, 116930, 116927, 116923, 116920, 116917, 116914, 116911, 116908, 116904, 116901, 116898, 116895,
    116892, 116888, 116885, 116882, 116879, 116876, 116873, 116869, 116866, 116863, 116860, 116857, 116853, 116850,
    116847, 116844, 116841, 116838, 116834, 116831, 116828, 116825, 116822, 116819, 116815, 116812, 116809, 116806,
    116803, 116799, 116796, 116793, 116790, 116787, 116784, 116780, 116777, 116774, 116771, 116768, 116765, 116761,
    116758, 116755, 116752, 116749, 116745, 116742, 116739, 116736, 116733, 116730, 116726, 116723, 116720, 116717,
    116714, 116711, 116707, 116704, 116701, 116698, 116695, 116692, 116688, 116685, 116682, 116679, 116676, 116673,
    116669, 116666, 116663, 116660, 116657, 116654, 116650, 116647, 116644, 116641, 116638, 116635, 116631, 116628,
    116625, 116622, 116619, 116616, 116612, 116609, 116606, 116603, 116600, 116597, 116593, 116590, 116587, 116584,
    116581, 116578, 116574, 116571, 116568, 116565, 116562, 116559, 116555, 116552, 116549, 116546, 116543, 116540,
    116536, 116533, 116530, 116527, 116524, 116521, 116517, 116514, 116511, 116508, 116505, 116502, 116498, 116495,
    116492, 116489, 116486, 116483, 116480, 116476, 116473, 116470, 116467, 116464, 116461, 116457, 116454, 116451,
    116448, 116445, 116442, 116438, 116435, 116432, 116429, 116426, 116423, 116420, 116416, 116413, 116410, 116407,
    116404, 116401, 116397, 116394, 116391, 116388, 116385, 116382, 116379, 116375, 116372, 116369, 116366, 116363,
    116360, 116356, 116353, 116350, 116347, 116344, 116341, 116338, 116334, 116331, 116328, 116325, 116322, 116319,
    116315, 116312, 116309, 116306, 116303, 116300, 116297, 116293, 116290, 116287, 116284, 116281, 116278, 116275,
    116271, 116268, 116265, 116262, 116259, 116256, 116253, 116249, 116246, 116243, 116240, 116237, 116234, 116230,
    116227, 116224, 116221, 116218, 116215, 116212, 116208, 116205, 116202, 116199, 116196, 116193, 116190, 116186,
    116183, 116180, 116177, 116174, 116171, 116168, 116164, 116161, 116158, 116155, 116152, 116149, 116146, 116142,
    116139, 116136, 116133, 116130, 116127, 116124, 116121, 116117, 116114, 116111, 116108, 116105, 116102, 116099,
    116095, 116092, 116089, 116086, 116083, 116080, 116077, 116073, 116070, 116067, 116064, 116061, 116058, 116055,
    116051, 116048, 116045, 116042, 116039, 116036, 116033, 116030, 116026, 116023, 116020, 116017, 116014, 116011,
    116008, 116004, 116001, 115998, 115995, 115992, 115989, 115986, 115983, 115979, 115976, 115973, 115970, 115967,
    115964, 115961, 115957, 115954, 115951, 115948, 115945, 115942, 115939, 115936, 115932, 115929, 115926, 115923,
    115920, 115917, 115914, 115911, 115907, 115904, 115901, 115898, 115895, 115892, 115889, 115886, 115882, 115879,
    115876, 115873, 115870, 115867, 115864, 115861, 115857, 115854, 115851, 115848, 115845, 115842, 115839, 115836,
    115832, 115829, 115826, 115823, 115820, 115817, 115814, 115811, 115807, 115804, 115801, 115798, 115795, 115792,
    115789, 115786, 115782, 115779, 115776, 115773, 115770, 115767, 115764, 115761, 115757, 115754, 115751, 115748,
    115745, 115742, 115739, 115736, 115733, 115729, 115726, 115723, 115720, 115717, 115714, 115711, 115708, 115704,
    115701, 115698, 115695, 115692, 115689, 115686, 115683, 115680, 115676, 115673, 115670, 115667, 115664, 115661,
    115658, 115655, 115651, 115648, 115645, 115642, 115639, 115636, 115633, 115630, 115627, 115623, 115620, 115617,
    115614, 115611, 115608, 115605, 115602, 115599, 115595, 115592, 115589, 115586, 115583, 115580, 115577, 115574,
    115571, 115567, 115564, 115561, 115558, 115555, 115552, 115549, 115546, 115543, 115539, 115536, 115533, 115530,
    115527, 115524, 115521, 115518, 115515, 115512, 115508, 115505, 115502, 115499, 115496, 115493, 115490, 115487,
    115484, 115480, 115477, 115474, 115471, 115468, 115465, 115462, 115459, 115456, 115453, 115449, 115446, 115443,
    115440, 115437, 115434, 115431, 115428, 115425, 115421, 115418, 115415, 115412, 115409, 115406, 115403, 115400,
    115397, 115394, 115390, 115387, 115384, 115381, 115378, 115375, 115372, 115369, 115366, 115363, 115359, 115356,
    115353, 115350, 115347, 115344, 115341, 115338, 115335, 115332, 115329, 115325, 115322, 115319, 115316, 115313,
    115310, 115307, 115304, 115301, 115298, 115294, 115291, 115288, 115285, 115282, 115279, 115276, 115273, 115270,
    115267, 115264, 115260, 115257, 115254, 115251, 115248, 115245, 115242, 115239, 115236, 115233, 115229, 115226,
    115223, 115220, 115217, 115214, 115211, 115208, 115205, 115202, 115199, 115195, 115192, 115189, 115186, 115183,
    115180, 115177, 115174, 115171, 115168, 115165, 115162, 115158, 115155, 115152, 115149, 115146, 115143, 115140,
    115137, 115134, 115131, 115128, 115124, 115121, 115118, 115115, 115112, 115109, 115106, 115103, 115100, 115097,
    115094, 115091, 115087, 115084, 115081, 115078, 115075, 115072, 115069, 115066, 115063, 115060, 115057, 115054,
    115050, 115047, 115044, 115041, 115038, 115035, 115032, 115029, 115026, 115023, 115020, 115017, 115013, 115010,
    115007, 115004, 115001, 114998, 114995, 114992, 114989, 114986, 114983, 114980, 114977, 114973, 114970, 114967,
    114964, 114961, 114958, 114955, 114952, 114949, 114946, 114943, 114940, 114937, 114933, 114930, 114927, 114924,
    114921, 114918, 114915, 114912, 114909, 114906, 114903, 114900, 114897, 114893, 114890, 114887, 114884, 114881,
    114878, 114875, 114872, 114869, 114866, 114863, 114860, 114857, 114854, 114850, 114847, 114844, 114841, 114838,
    114835, 114832, 114829, 114826, 114823, 114820, 114817, 114814, 114811, 114808, 114804, 114801, 114798, 114795,
    114792, 114789, 114786, 114783, 114780, 114777, 114774, 114771, 114768, 114765, 114761, 114758, 114755, 114752,
    114749, 114746, 114743, 114740, 114737, 114734, 114731, 114728, 114725, 114722, 114719, 114716, 114712, 114709,
    114706, 114703, 114700, 114697, 114694, 114691, 114688, 114685, 114682, 114679, 114676, 114673, 114670, 114667,
    114663, 114660, 114657, 114654, 114651, 114648, 114645, 114642, 114639, 114636, 114633, 114630, 114627, 114624,
    114621, 114618, 114614, 114611, 114608, 114605, 114602, 114599, 114596, 114593, 114590, 114587, 114584, 114581,
    114578, 114575, 114572, 114569, 114566, 114563, 114559, 114556, 114553, 114550, 114547, 114544, 114541, 114538,
    114535, 114532, 114529, 114526, 114523, 114520, 114517, 114514, 114511, 114508, 114504, 114501, 114498, 114495,
    114492, 114489, 114486, 114483, 114480, 114477, 114474, 114471, 114468, 114465, 114462, 114459, 114456, 114453,
    114450, 114447, 114443, 114440, 114437, 114434, 114431, 114428, 114425, 114422, 114419, 114416, 114413, 114410,
    114407, 114404, 114401, 114398, 114395, 114392, 114389, 114386, 114383, 114379, 114376, 114373, 114370, 114367,
    114364, 114361, 114358, 114355, 114352, 114349, 114346, 114343, 114340, 114337, 114334, 114331, 114328, 114325,
    114322, 114319, 114316, 114312, 114309, 114306, 114303, 114300, 114297, 114294, 114291, 114288, 114285, 114282,
    114279, 114276, 114273, 114270, 114267, 114264, 114261, 114258, 114255, 114252, 114249, 114246, 114243, 114240,
    114236, 114233, 114230, 114227, 114224, 114221, 114218, 114215, 114212, 114209, 114206, 114203, 114200, 114197,
    114194, 114191, 114188, 114185, 114182, 114179, 114176, 114173, 114170, 114167, 114164, 114161, 114158, 114154,
    114151, 114148, 114145, 114142, 114139, 114136, 114133, 114130, 114127, 114124, 114121, 114118, 114115, 114112,
    114109, 114106, 114103, 114100, 114097, 114094, 114091, 114088, 114085, 114082, 114079, 114076, 114073, 114070,
    114067, 114064, 114061, 114057, 114054, 114051, 114048, 114045, 114042, 114039, 114036, 114033, 114030, 114027,
    114024, 114021, 114018, 114015, 114012, 114009, 114006, 114003, 114000, 113997, 113994, 113991, 113988, 113985,
    113982, 113979, 113976, 113973, 113970, 113967, 113964, 113961, 113958, 113955, 113952, 113949, 113946, 113943,
    113939, 113936, 113933, 113930, 113927, 113924, 113921, 113918, 113915, 113912, 113909, 113906, 113903, 113900,
    113897, 113894, 113891, 113888, 113885, 113882, 113879, 113876, 113873, 113870, 113867, 113864, 113861, 113858,
    113855, 113852, 113849, 113846, 113843, 113840, 113837, 113834, 113831, 113828, 113825, 113822, 113819, 113816,
    113813, 113810, 113807, 113804, 113801, 113798, 113795, 113792, 113789, 113786, 113783, 113780, 113776, 113773,
    113770, 113767, 113764, 113761, 113758, 113755, 113752, 113749, 113746, 113743, 113740, 113737, 113734, 113731,
    113728, 113725, 113722, 113719, 113716, 113713, 113710, 113707, 113704, 113701, 113698, 113695, 113692, 113689,
    113686, 113683, 113680, 113677, 113674, 113671, 113668, 113665, 113662, 113659, 113656, 113653, 113650, 113647,
    113644, 113641, 113638, 113635, 113632, 113629, 113626, 113623, 113620, 113617, 113614, 113611, 113608, 113605,
    113602, 113599, 113596, 113593, 113590, 113587, 113584, 113581, 113578, 113575, 113572, 113569, 113566, 113563,
    113560, 113557, 113554, 113551, 113548, 113545, 113542, 113539, 113536, 113533, 113530, 113527, 113524, 113521,
    113518, 113515, 113512, 113509, 113506, 113503, 113500, 113497, 113494, 113491, 113488, 113485, 113482, 113479,
    113476, 113473, 113470, 113467, 113464, 113461, 113458, 113455, 113452, 113449, 113446, 113443, 113440, 113437,
    113434, 113431, 113428, 113425, 113422, 113419, 113416, 113413, 113410, 113407, 113404, 113401, 113398, 113395,
    113392, 113389, 113386, 113383, 113380, 113377, 113374, 113371, 113368, 113365, 113362, 113359, 113356, 113353,
    113350, 113347, 113344, 113341, 113338, 113335, 113332, 113329, 113326, 113323, 113320, 113317, 113314, 113311,
    113308, 113305, 113302, 113299, 113296, 113293, 113290, 113287, 113284, 113281, 113278, 113275, 113272, 113269,
    113266, 113263, 113260, 113257, 113254, 113251, 113248, 113245, 113243, 113240, 113237, 113234, 113231, 113228,
    113225, 113222, 113219, 113216, 113213, 113210, 113207, 113204, 113201, 113198, 113195, 113192, 113189, 113186,
    113183, 113180, 113177, 113174, 113171, 113168, 113165, 113162, 113159, 113156, 113153, 113150, 113147, 113144,
    113141, 113138, 113135, 113132, 113129, 113126, 113123, 113120, 113117, 113114, 113111, 113108, 113105, 113102,
    113099, 113096, 113093, 113090, 113087, 113084, 113082, 113079, 113076, 113073, 113070, 113067, 113064, 113061,
    113058, 113055, 113052, 113049, 113046, 113043, 113040, 113037, 113034, 113031, 113028, 113025, 113022, 113019,
    113016, 113013, 113010, 113007, 113004, 113001, 112998, 112995, 112992, 112989, 112986, 112983, 112980, 112977,
    112974, 112971, 112968, 112966, 112963, 112960, 112957, 112954, 112951, 112948, 112945, 112942, 112939, 112936,
    112933, 112930, 112927, 112924, 112921, 112918, 112915, 112912, 112909, 112906, 112903, 112900, 112897, 112894,
    112891, 112888, 112885, 112882, 112879, 112876, 112873, 112871, 112868, 112865, 112862, 112859, 112856, 112853,
    112850, 112847, 112844, 112841, 112838, 112835, 112832, 112829, 112826, 112823, 112820, 112817, 112814, 112811,
    112808, 112805, 112802, 112799, 112796, 112793, 112790, 112788, 112785, 112782, 112779, 112776, 112773, 112770,
    112767, 112764, 112761, 112758, 112755, 112752, 112749, 112746, 112743, 112740, 112737, 112734, 112731, 112728,
    112725, 112722, 112719, 112716, 112714, 112711, 112708, 112705, 112702, 112699, 112696, 112693, 112690, 112687,
    112684, 112681, 112678, 112675, 112672, 112669, 112666, 112663, 112660, 112657, 112654, 112651, 112648, 112646,
    112643, 112640, 112637, 112634, 112631, 112628, 112625, 112622, 112619, 112616, 112613, 112610, 112607, 112604,
    112601, 112598, 112595, 112592, 112589, 112586, 112584, 112581, 112578, 112575, 112572, 112569, 112566, 112563,
    112560, 112557, 112554, 112551, 112548, 112545, 112542, 112539, 112536, 112533, 112530, 112527, 112525, 112522,
    112519, 112516, 112513, 112510, 112507, 112504, 112501, 112498, 112495, 112492, 112489, 112486, 112483, 112480,
    112477, 112474, 112471, 112469, 112466, 112463, 112460, 112457, 112454, 112451, 112448, 112445, 112442, 112439,
    112436, 112433, 112430, 112427, 112424, 112421, 112418, 112416, 112413, 112410, 112407, 112404, 112401, 112398,
    112395, 112392, 112389, 112386, 112383, 112380, 112377, 112374, 112371, 112368, 112366, 112363, 112360, 112357,
    112354, 112351, 112348, 112345, 112342, 112339, 112336, 112333, 112330, 112327, 112324, 112321, 112319, 112316,
    112313, 112310, 112307, 112304, 112301, 112298, 112295, 112292, 112289, 112286, 112283, 112280, 112277, 112274,
    112272, 112269, 112266, 112263, 112260, 112257, 112254, 112251, 112248, 112245, 112242, 112239, 112236, 112233,
    112230, 112228, 112225, 112222, 112219, 112216, 112213, 112210, 112207, 112204, 112201, 112198, 112195, 112192,
    112189, 112187, 112184, 112181, 112178, 112175, 112172, 112169, 112166, 112163, 112160, 112157, 112154, 112151,
    112148, 112145, 112143, 112140, 112137, 112134, 112131, 112128, 112125, 112122, 112119, 112116, 112113, 112110,
    112107, 112105, 112102, 112099, 112096, 112093, 112090, 112087, 112084, 112081, 112078, 112075, 112072, 112069,
    112066, 112064, 112061, 112058, 112055, 112052, 112049, 112046, 112043, 112040, 112037, 112034, 112031, 112028,
    112026, 112023, 112020, 112017, 112014, 112011, 112008, 112005, 112002, 111999, 111996, 111993, 111991, 111988,
    111985, 111982, 111979, 111976, 111973, 111970, 111967, 111964, 111961, 111958, 111955, 111953, 111950, 111947,
    111944, 111941, 111938, 111935, 111932, 111929, 111926, 111923, 111920, 111918, 111915, 111912, 111909, 111906,
    111903, 111900, 111897, 111894, 111891, 111888, 111885, 111883, 111880, 111877, 111874, 111871, 111868, 111865,
    111862, 111859, 111856, 111853, 111851, 111848, 111845, 111842, 111839, 111836, 111833, 111830, 111827, 111824,
    111821, 111818, 111816, 111813, 111810, 111807, 111804, 111801, 111798, 111795, 111792, 111789, 111786, 111784,
    111781, 111778, 111775, 111772, 111769, 111766, 111763, 111760, 111757, 111754, 111752, 111749, 111746, 111743,
    111740, 111737, 111734, 111731, 111728, 111725, 111723, 111720, 111717, 111714, 111711, 111708, 111705, 111702,
    111699, 111696, 111693, 111691, 111688, 111685, 111682, 111679, 111676, 111673, 111670, 111667, 111664, 111662,
    111659, 111656, 111653, 111650, 111647, 111644, 111641, 111638, 111635, 111632, 111630, 111627, 111624, 111621,
    111618, 111615, 111612, 111609, 111606, 111603, 111601, 111598, 111595, 111592, 111589, 111586, 111583, 111580,
    111577, 111574, 111572, 111569, 111566, 111563, 111560, 111557, 111554, 111551, 111548, 111546, 111543, 111540,
    111537, 111534, 111531, 111528, 111525, 111522, 111519, 111517, 111514, 111511, 111508, 111505, 111502, 111499,
    111496, 111493, 111490, 111488, 111485, 111482, 111479, 111476, 111473, 111470, 111467, 111464, 111462, 111459,
    111456, 111453, 111450, 111447, 111444, 111441, 111438, 111436, 111433, 111430, 111427, 111424, 111421, 111418,
    111415, 111412, 111410, 111407, 111404, 111401, 111398, 111395, 111392, 111389, 111386, 111384, 111381, 111378,
    111375, 111372, 111369, 111366, 111363, 111360, 111358, 111355, 111352, 111349, 111346, 111343, 111340, 111337,
    111334, 111332, 111329, 111326, 111323, 111320, 111317, 111314, 111311, 111308, 111306, 111303, 111300, 111297,
    111294, 111291, 111288, 111285, 111283, 111280, 111277, 111274, 111271, 111268, 111265, 111262, 111259, 111257,
    111254, 111251, 111248, 111245, 111242, 111239, 111236, 111234, 111231, 111228, 111225, 111222, 111219, 111216,
    111213, 111210, 111208, 111205, 111202, 111199, 111196, 111193, 111190, 111187, 111185, 111182, 111179, 111176,
    111173, 111170, 111167, 111164, 111162, 111159, 111156, 111153, 111150, 111147, 111144, 111141, 111139, 111136,
    111133, 111130, 111127, 111124, 111121, 111118, 111116, 111113, 111110, 111107, 111104, 111101, 111098, 111095,
    111093, 111090, 111087, 111084, 111081, 111078, 111075, 111072, 111070, 111067, 111064, 111061, 111058, 111055,
    111052, 111049, 111047, 111044, 111041, 111038, 111035, 111032, 111029, 111026, 111024, 111021, 111018, 111015,
    111012, 111009, 111006, 111004, 111001, 110998, 110995, 110992, 110989, 110986, 110983, 110981, 110978, 110975,
    110972, 110969, 110966, 110963, 110961, 110958, 110955, 110952, 110949, 110946, 110943, 110940, 110938, 110935,
    110932, 110929, 110926, 110923, 110920, 110918, 110915, 110912, 110909, 110906, 110903, 110900, 110897, 110895,
    110892, 110889, 110886, 110883, 110880, 110877, 110875, 110872, 110869, 110866, 110863, 110860, 110857, 110855,
    110852, 110849, 110846, 110843, 110840, 110837, 110835, 110832, 110829, 110826, 110823, 110820, 110817, 110814,
    110812, 110809, 110806, 110803, 110800, 110797, 110794, 110792, 110789, 110786, 110783, 110780, 110777, 110774,
    110772, 110769, 110766, 110763, 110760, 110757, 110754, 110752, 110749, 110746, 110743, 110740, 110737, 110734,
    110732, 110729, 110726, 110723, 110720, 110717, 110715, 110712, 110709, 110706, 110703, 110700, 110697, 110695,
    110692, 110689, 110686, 110683, 110680, 110677, 110675, 110672, 110669, 110666, 110663, 110660, 110657, 110655,
    110652, 110649, 110646, 110643, 110640, 110638, 110635, 110632, 110629, 110626, 110623, 110620, 110618, 110615,
    110612, 110609, 110606, 110603, 110600, 110598, 110595, 110592, 110589, 110586, 110583, 110581, 110578, 110575,
    110572, 110569, 110566, 110563, 110561, 110558, 110555, 110552, 110549, 110546, 110544, 110541, 110538, 110535,
    110532, 110529, 110526, 110524, 110521, 110518, 110515, 110512, 110509, 110507, 110504, 110501, 110498, 110495,
    110492, 110490, 110487, 110484, 110481, 110478, 110475, 110472, 110470, 110467, 110464, 110461, 110458, 110455,
    110453, 110450, 110447, 110444, 110441, 110438, 110436, 110433, 110430, 110427, 110424, 110421, 110418, 110416,
    110413, 110410, 110407, 110404, 110401, 110399, 110396, 110393, 110390, 110387, 110384, 110382, 110379, 110376,
    110373, 110370, 110367, 110365, 110362, 110359, 110356, 110353, 110350, 110348, 110345, 110342, 110339, 110336,
    110333, 110331, 110328, 110325, 110322, 110319, 110316, 110314, 110311, 110308, 110305, 110302, 110299, 110297,
    110294, 110291, 110288, 110285, 110282, 110280, 110277, 110274, 110271, 110268, 110265, 110263, 110260, 110257,
    110254, 110251, 110248, 110246, 110243, 110240, 110237, 110234, 110231, 110229, 110226, 110223, 110220, 110217,
    110214, 110212, 110209, 110206, 110203, 110200, 110198, 110195, 110192, 110189, 110186, 110183, 110181, 110178,
    110175, 110172, 110169, 110166, 110164, 110161, 110158, 110155, 110152, 110149, 110147, 110144, 110141, 110138,
    110135, 110133, 110130, 110127, 110124, 110121, 110118, 110116, 110113, 110110, 110107, 110104, 110101, 110099,
    110096, 110093, 110090, 110087, 110085, 110082, 110079, 110076, 110073, 110070, 110068, 110065, 110062, 110059,
    110056, 110054, 110051, 110048, 110045, 110042, 110039, 110037, 110034, 110031, 110028, 110025, 110022, 110020,
    110017, 110014, 110011, 110008, 110006, 110003, 110000, 109997, 109994, 109991, 109989, 109986, 109983, 109980,
    109977, 109975, 109972, 109969, 109966, 109963, 109961, 109958, 109955, 109952, 109949, 109946, 109944, 109941,
    109938, 109935, 109932, 109930, 109927, 109924, 109921, 109918, 109915, 109913, 109910, 109907, 109904, 109901,
    109899, 109896, 109893, 109890, 109887, 109885, 109882, 109879, 109876, 109873, 109871, 109868, 109865, 109862,
    109859, 109856, 109854, 109851, 109848, 109845, 109842, 109840, 109837, 109834, 109831, 109828, 109826, 109823,
    109820, 109817, 109814, 109812, 109809, 109806, 109803, 109800, 109797, 109795, 109792, 109789, 109786, 109783,
    109781, 109778, 109775, 109772, 109769, 109767, 109764, 109761, 109758, 109755, 109753, 109750, 109747, 109744,
    109741, 109739, 109736, 109733, 109730, 109727, 109725, 109722, 109719, 109716, 109713, 109711, 109708, 109705,
    109702, 109699, 109697, 109694, 109691, 109688, 109685, 109683, 109680, 109677, 109674, 109671, 109669, 109666,
    109663, 109660, 109657, 109655, 109652, 109649, 109646, 109643, 109641, 109638, 109635, 109632, 109629, 109627,
    109624, 109621, 109618, 109615, 109613, 109610, 109607, 109604, 109601, 109599, 109596, 109593, 109590, 109587,
    109585, 109582, 109579, 109576, 109573, 109571, 109568, 109565, 109562, 109559, 109557, 109554, 109551, 109548,
    109545, 109543, 109540, 109537, 109534, 109531, 109529, 109526, 109523, 109520, 109518, 109515, 109512, 109509,
    109506, 109504, 109501, 109498, 109495, 109492, 109490, 109487, 109484, 109481, 109478, 109476, 109473, 109470,
    109467, 109464, 109462, 109459, 109456, 109453, 109451, 109448, 109445, 109442, 109439, 109437, 109434, 109431,
    109428, 109425, 109423, 109420, 109417, 109414, 109411, 109409, 109406, 109403, 109400, 109398, 109395, 109392,
    109389, 109386, 109384, 109381, 109378, 109375, 109372, 109370, 109367, 109364, 109361, 109359, 109356, 109353,
    109350, 109347, 109345, 109342, 109339, 109336, 109333, 109331, 109328, 109325, 109322, 109320, 109317, 109314,
    109311, 109308, 109306, 109303, 109300, 109297, 109295, 109292, 109289, 109286, 109283, 109281, 109278, 109275,
    109272, 109270, 109267, 109264, 109261, 109258, 109256, 109253, 109250, 109247, 109245, 109242, 109239, 109236,
    109233, 109231, 109228, 109225, 109222, 109220, 109217, 109214, 109211, 109208, 109206, 109203, 109200, 109197,
    109195, 109192, 109189, 109186, 109183, 109181, 109178, 109175, 109172, 109170, 109167, 109164, 109161, 109158,
    109156, 109153, 109150, 109147, 109145, 109142, 109139, 109136, 109133, 109131, 109128, 109125, 109122, 109120,
    109117, 109114, 109111, 109109, 109106, 109103, 109100, 109097, 109095, 109092, 109089, 109086, 109084, 109081,
    109078, 109075, 109072, 109070, 109067, 109064, 109061, 109059, 109056, 109053, 109050, 109048, 109045, 109042,
    109039, 109037, 109034, 109031, 109028, 109025, 109023, 109020, 109017, 109014, 109012, 109009, 109006, 109003,
    109001, 108998, 108995, 108992, 108989, 108987, 108984, 108981, 108978, 108976, 108973, 108970, 108967, 108965,
    108962, 108959, 108956, 108954, 108951, 108948, 108945, 108942, 108940, 108937, 108934, 108931, 108929, 108926,
    108923, 108920, 108918, 108915, 108912, 108909, 108907, 108904, 108901, 108898, 108896, 108893, 108890, 108887,
    108884, 108882, 108879, 108876, 108873, 108871, 108868, 108865, 108862, 108860, 108857, 108854, 108851, 108849,
    108846, 108843, 108840, 108838, 108835, 108832, 108829, 108827, 108824, 108821, 108818, 108815, 108813, 108810,
    108807, 108804, 108802, 108799, 108796, 108793, 108791, 108788, 108785, 108782, 108780, 108777, 108774, 108771,
    108769, 108766, 108763, 108760, 108758, 108755, 108752, 108749, 108747, 108744, 108741, 108738, 108736, 108733,
    108730, 108727, 108725, 108722, 108719, 108716, 108714, 108711, 108708, 108705, 108703, 108700, 108697, 108694,
    108692, 108689, 108686, 108683, 108681, 108678, 108675, 108672, 108670, 108667, 108664, 108661, 108659, 108656,
    108653, 108650, 108648, 108645, 108642, 108639, 108637, 108634, 108631, 108628, 108626, 108623, 108620, 108617,
    108615, 108612, 108609, 108606, 108604, 108601, 108598, 108595, 108593, 108590, 108587, 108584, 108582, 108579,
    108576, 108573, 108571, 108568, 108565, 108562, 108560, 108557, 108554, 108551, 108549, 108546, 108543, 108541,
    108538, 108535, 108532, 108530, 108527, 108524, 108521, 108519, 108516, 108513, 108510, 108508, 108505, 108502,
    108499, 108497, 108494, 108491, 108488, 108486, 108483, 108480, 108477, 108475, 108472, 108469, 108466, 108464,
    108461, 108458, 108456, 108453, 108450, 108447, 108445, 108442, 108439, 108436, 108434, 108431, 108428, 108425,
    108423, 108420, 108417, 108414, 108412, 108409, 108406, 108404, 108401, 108398, 108395, 108393, 108390, 108387,
    108384, 108382, 108379, 108376, 108373, 108371, 108368, 108365, 108362, 108360, 108357, 108354, 108352, 108349,
    108346, 108343, 108341, 108338, 108335, 108332, 108330, 108327, 108324, 108322, 108319, 108316, 108313, 108311,
    108308, 108305, 108302, 108300, 108297, 108294, 108291, 108289, 108286, 108283, 108281, 108278, 108275, 108272,
    108270, 108267, 108264, 108261, 108259, 108256, 108253, 108251, 108248, 108245, 108242, 108240, 108237, 108234,
    108231, 108229, 108226, 108223, 108221, 108218, 108215, 108212, 108210, 108207, 108204, 108201, 108199, 108196,
    108193, 108191, 108188, 108185, 108182, 108180, 108177, 108174, 108171, 108169, 108166, 108163, 108161, 108158,
    108155, 108152, 108150, 108147, 108144, 108141, 108139, 108136, 108133, 108131, 108128, 108125, 108122, 108120,
    108117, 108114, 108112, 108109, 108106, 108103, 108101, 108098, 108095, 108093, 108090, 108087, 108084, 108082,
    108079, 108076, 108073, 108071, 108068, 108065, 108063, 108060, 108057, 108054, 108052, 108049, 108046, 108044,
    108041, 108038, 108035, 108033, 108030, 108027, 108025, 108022, 108019, 108016, 108014, 108011, 108008, 108006,
    108003, 108000, 107997, 107995, 107992, 107989, 107987, 107984, 107981, 107978, 107976, 107973, 107970, 107968,
    107965, 107962, 107959, 107957, 107954, 107951, 107949, 107946, 107943, 107940, 107938, 107935, 107932, 107930,
    107927, 107924, 107921, 107919, 107916, 107913, 107911, 107908, 107905, 107902, 107900, 107897, 107894, 107892,
    107889, 107886, 107883, 107881, 107878, 107875, 107873, 107870, 107867, 107864, 107862, 107859, 107856, 107854,
    107851, 107848, 107846, 107843, 107840, 107837, 107835, 107832, 107829, 107827, 107824, 107821, 107818, 107816,
    107813, 107810, 107808, 107805, 107802, 107799, 107797, 107794, 107791, 107789, 107786, 107783, 107781, 107778,
    107775, 107772, 107770, 107767, 107764, 107762, 107759, 107756, 107754, 107751, 107748, 107745, 107743, 107740,
    107737, 107735, 107732, 107729, 107726, 107724, 107721, 107718, 107716, 107713, 107710, 107708, 107705, 107702,
    107699, 107697, 107694, 107691, 107689, 107686, 107683, 107681, 107678, 107675, 107672, 107670, 107667, 107664,
    107662, 107659, 107656, 107654, 107651, 107648, 107645, 107643, 107640, 107637, 107635, 107632, 107629, 107627,
    107624, 107621, 107619, 107616, 107613, 107610, 107608, 107605, 107602, 107600, 107597, 107594, 107592, 107589,
    107586, 107583, 107581, 107578, 107575, 107573, 107570, 107567, 107565, 107562, 107559, 107557, 107554, 107551,
    107548, 107546, 107543, 107540, 107538, 107535, 107532, 107530, 107527, 107524, 107522, 107519, 107516, 107513,
    107511, 107508, 107505, 107503, 107500, 107497, 107495, 107492, 107489, 107487, 107484, 107481, 107478, 107476,
    107473, 107470, 107468, 107465, 107462, 107460, 107457, 107454, 107452, 107449, 107446, 107444, 107441, 107438,
    107435, 107433, 107430, 107427, 107425, 107422, 107419, 107417, 107414, 107411, 107409, 107406, 107403, 107401,
    107398, 107395, 107392, 107390, 107387, 107384, 107382, 107379, 107376, 107374, 107371, 107368, 107366, 107363,
    107360, 107358, 107355, 107352, 107350, 107347, 107344, 107341, 107339, 107336, 107333, 107331, 107328, 107325,
    107323, 107320, 107317, 107315, 107312, 107309, 107307, 107304, 107301, 107299, 107296, 107293, 107291, 107288,
    107285, 107282, 107280, 107277, 107274, 107272, 107269, 107266, 107264, 107261, 107258, 107256, 107253, 107250,
    107248, 107245, 107242, 107240, 107237, 107234, 107232, 107229, 107226, 107224, 107221, 107218, 107216, 107213,
    107210, 107208, 107205, 107202, 107199, 107197, 107194, 107191, 107189, 107186, 107183, 107181, 107178, 107175,
    107173, 107170, 107167, 107165, 107162, 107159, 107157, 107154, 107151, 107149, 107146, 107143, 107141, 107138,
    107135, 107133, 107130, 107127, 107125, 107122, 107119, 107117, 107114, 107111, 107109, 107106, 107103, 107101,
    107098, 107095, 107093, 107090, 107087, 107085, 107082, 107079, 107077, 107074, 107071, 107069, 107066, 107063,
    107061, 107058, 107055, 107053, 107050, 107047, 107045, 107042, 107039, 107037, 107034, 107031, 107029, 107026,
    107023, 107021, 107018, 107015, 107013, 107010, 107007, 107005, 107002, 106999, 106997, 106994, 106991, 106989,
    106986, 106983, 106981, 106978, 106975, 106973, 106970, 106967, 106965, 106962, 106959, 106957, 106954, 106951,
    106949, 106946, 106943, 106941, 106938, 106935, 106933, 106930, 106927, 106925, 106922, 106919, 106917, 106914,
    106911, 106909, 106906, 106903, 106901, 106898, 106895, 106893, 106890, 106887, 106885, 106882, 106879, 106877,
    106874, 106871, 106869, 106866, 106863, 106861, 106858, 106855, 106853, 106850, 106847, 106845, 106842, 106839,
    106837, 106834, 106832, 106829, 106826, 106824, 106821, 106818, 106816, 106813, 106810, 106808, 106805, 106802,
    106800, 106797, 106794, 106792, 106789, 106786, 106784, 106781, 106778, 106776, 106773, 106770, 106768, 106765,
    106762, 106760, 106757, 106755, 106752, 106749, 106747, 106744, 106741, 106739, 106736, 106733, 106731, 106728,
    106725, 106723, 106720, 106717, 106715, 106712, 106709, 106707, 106704, 106701, 106699, 106696, 106694, 106691,
    106688, 106686, 106683, 106680, 106678, 106675, 106672, 106670, 106667, 106664, 106662, 106659, 106656, 106654,
    106651, 106648, 106646, 106643, 106641, 106638, 106635, 106633, 106630, 106627, 106625, 106622, 106619, 106617,
    106614, 106611, 106609, 106606, 106603, 106601, 106598, 106596, 106593, 106590, 106588, 106585, 106582, 106580,
    106577, 106574, 106572, 106569, 106566, 106564, 106561, 106559, 106556, 106553, 106551, 106548, 106545, 106543,
    106540, 106537, 106535, 106532, 106529, 106527, 106524, 106522, 106519, 106516, 106514, 106511, 106508, 106506,
    106503, 106500, 106498, 106495, 106492, 106490, 106487, 106485, 106482, 106479, 106477, 106474, 106471, 106469,
    106466, 106463, 106461, 106458, 106456, 106453, 106450, 106448, 106445, 106442, 106440, 106437, 106434, 106432,
    106429, 106426, 106424, 106421, 106419, 106416, 106413, 106411, 106408, 106405, 106403, 106400, 106397, 106395,
    106392, 106390, 106387, 106384, 106382, 106379, 106376, 106374, 106371, 106368, 106366, 106363, 106361, 106358,
    106355, 106353, 106350, 106347, 106345, 106342, 106340, 106337, 106334, 106332, 106329, 106326, 106324, 106321,
    106318, 106316, 106313, 106311, 106308, 106305, 106303, 106300, 106297, 106295, 106292, 106290, 106287, 106284,
    106282, 106279, 106276, 106274, 106271, 106268, 106266, 106263, 106261, 106258, 106255, 106253, 106250, 106247,
    106245, 106242, 106240, 106237, 106234, 106232, 106229, 106226, 106224, 106221, 106219, 106216, 106213, 106211,
    106208, 106205, 106203, 106200, 106198, 106195, 106192, 106190, 106187, 106184, 106182, 106179, 106177, 106174,
    106171, 106169, 106166, 106163, 106161, 106158, 106156, 106153, 106150, 106148, 106145, 106142, 106140, 106137,
    106135, 106132, 106129, 106127, 106124, 106121, 106119, 106116, 106114, 106111, 106108, 106106, 106103, 106100,
    106098, 106095, 106093, 106090, 106087, 106085, 106082, 106080, 106077, 106074, 106072, 106069, 106066, 106064,
    106061, 106059, 106056, 106053, 106051, 106048, 106045, 106043, 106040, 106038, 106035, 106032, 106030, 106027,
    106025, 106022, 106019, 106017, 106014, 106011, 106009, 106006, 106004, 106001, 105998, 105996, 105993, 105991,
    105988, 105985, 105983, 105980, 105977, 105975, 105972, 105970, 105967, 105964, 105962, 105959, 105957, 105954,
    105951, 105949, 105946, 105943, 105941, 105938, 105936, 105933, 105930, 105928, 105925, 105923, 105920, 105917,
    105915, 105912, 105909, 105907, 105904, 105902, 105899, 105896, 105894, 105891, 105889, 105886, 105883, 105881,
    105878, 105876, 105873, 105870, 105868, 105865, 105862, 105860, 105857, 105855, 105852, 105849, 105847, 105844,
    105842, 105839, 105836, 105834, 105831, 105829, 105826, 105823, 105821, 105818, 105816, 105813, 105810, 105808,
    105805, 105803, 105800, 105797, 105795, 105792, 105789, 105787, 105784, 105782, 105779, 105776, 105774, 105771,
    105769, 105766, 105763, 105761, 105758, 105756, 105753, 105750, 105748, 105745, 105743, 105740, 105737, 105735,
    105732, 105730, 105727, 105724, 105722, 105719, 105717, 105714, 105711, 105709, 105706, 105704, 105701, 105698,
    105696, 105693, 105691, 105688, 105685, 105683, 105680, 105678, 105675, 105672, 105670, 105667, 105665, 105662,
    105659, 105657, 105654, 105652, 105649, 105646, 105644, 105641, 105639, 105636, 105633, 105631, 105628, 105626,
    105623, 105620, 105618, 105615, 105613, 105610, 105607, 105605, 105602, 105600, 105597, 105594, 105592, 105589,
    105587, 105584, 105581, 105579, 105576, 105574, 105571, 105568, 105566, 105563, 105561, 105558, 105555, 105553,
    105550, 105548, 105545, 105543, 105540, 105537, 105535, 105532, 105530, 105527, 105524, 105522, 105519, 105517,
    105514, 105511, 105509, 105506, 105504, 105501, 105498, 105496, 105493, 105491, 105488, 105485, 105483, 105480,
    105478, 105475, 105473, 105470, 105467, 105465, 105462, 105460, 105457, 105454, 105452, 105449, 105447, 105444,
    105441, 105439, 105436, 105434, 105431, 105429, 105426, 105423, 105421, 105418, 105416, 105413, 105410, 105408,
    105405, 105403, 105400, 105397, 105395, 105392, 105390, 105387, 105385, 105382, 105379, 105377, 105374, 105372,
    105369, 105366, 105364, 105361, 105359, 105356, 105354, 105351, 105348, 105346, 105343, 105341, 105338, 105335,
    105333, 105330, 105328, 105325, 105323, 105320, 105317, 105315, 105312, 105310, 105307, 105304, 105302, 105299,
    105297, 105294, 105292, 105289, 105286, 105284, 105281, 105279, 105276, 105273, 105271, 105268, 105266, 105263,
    105261, 105258, 105255, 105253, 105250, 105248, 105245, 105243, 105240, 105237, 105235, 105232, 105230, 105227,
    105224, 105222, 105219, 105217, 105214, 105212, 105209, 105206, 105204, 105201, 105199, 105196, 105194, 105191,
    105188, 105186, 105183, 105181, 105178, 105176, 105173, 105170, 105168, 105165, 105163, 105160, 105157, 105155,
    105152, 105150, 105147, 105145, 105142, 105139, 105137, 105134, 105132, 105129, 105127, 105124, 105121, 105119,
    105116, 105114, 105111, 105109, 105106, 105103, 105101, 105098, 105096, 105093, 105091, 105088, 105085, 105083,
    105080, 105078, 105075, 105073, 105070, 105067, 105065, 105062, 105060, 105057, 105055, 105052, 105049, 105047,
    105044, 105042, 105039, 105037, 105034, 105031, 105029, 105026, 105024, 105021, 105019, 105016, 105013, 105011,
    105008, 105006, 105003, 105001, 104998, 104996, 104993, 104990, 104988, 104985, 104983, 104980, 104978, 104975,
    104972, 104970, 104967, 104965, 104962, 104960, 104957, 104954, 104952, 104949, 104947, 104944, 104942, 104939,
    104937, 104934, 104931, 104929, 104926, 104924, 104921, 104919, 104916, 104913, 104911, 104908, 104906, 104903,
    104901, 104898, 104896, 104893, 104890, 104888, 104885, 104883, 104880, 104878, 104875, 104872, 104870, 104867,
    104865, 104862, 104860, 104857, 104855, 104852, 104849, 104847, 104844, 104842, 104839, 104837, 104834, 104832,
    104829, 104826, 104824, 104821, 104819, 104816, 104814, 104811, 104808, 104806, 104803, 104801, 104798, 104796,
    104793, 104791, 104788, 104785, 104783, 104780, 104778, 104775, 104773, 104770, 104768, 104765, 104762, 104760,
    104757, 104755, 104752, 104750, 104747, 104745, 104742, 104739, 104737, 104734, 104732, 104729, 104727, 104724,
    104722, 104719, 104716, 104714, 104711, 104709, 104706, 104704, 104701, 104699, 104696, 104694, 104691, 104688,
    104686, 104683, 104681, 104678, 104676, 104673, 104671, 104668, 104665, 104663, 104660, 104658, 104655, 104653,
    104650, 104648, 104645, 104643, 104640, 104637, 104635, 104632, 104630, 104627, 104625, 104622, 104620, 104617,
    104614, 104612, 104609, 104607, 104604, 104602, 104599, 104597, 104594, 104592, 104589, 104586, 104584, 104581,
    104579, 104576, 104574, 104571, 104569, 104566, 104564, 104561, 104558, 104556, 104553, 104551, 104548, 104546,
    104543, 104541, 104538, 104536, 104533, 104530, 104528, 104525, 104523, 104520, 104518, 104515, 104513, 104510,
    104508, 104505, 104502, 104500, 104497, 104495, 104492, 104490, 104487, 104485, 104482, 104480, 104477, 104475,
    104472, 104469, 104467, 104464, 104462, 104459, 104457, 104454, 104452, 104449, 104447, 104444, 104441, 104439,
    104436, 104434, 104431, 104429, 104426, 104424, 104421, 104419, 104416, 104414, 104411, 104408, 104406, 104403,
    104401, 104398, 104396, 104393, 104391, 104388, 104386, 104383, 104381, 104378, 104375, 104373, 104370, 104368,
    104365, 104363, 104360, 104358, 104355, 104353, 104350, 104348, 104345, 104343, 104340, 104337, 104335, 104332,
    104330, 104327, 104325, 104322, 104320, 104317, 104315, 104312, 104310, 104307, 104305, 104302, 104299, 104297,
    104294, 104292, 104289, 104287, 104284, 104282, 104279, 104277, 104274, 104272, 104269, 104267, 104264, 104261,
    104259, 104256, 104254, 104251, 104249, 104246, 104244, 104241, 104239, 104236, 104234, 104231, 104229, 104226,
    104224, 104221, 104218, 104216, 104213, 104211, 104208, 104206, 104203, 104201, 104198, 104196, 104193, 104191,
    104188, 104186, 104183, 104181, 104178, 104175, 104173, 104170, 104168, 104165, 104163, 104160, 104158, 104155,
    104153, 104150, 104148, 104145, 104143, 104140, 104138, 104135, 104133, 104130, 104127, 104125, 104122, 104120,
    104117, 104115, 104112, 104110, 104107, 104105, 104102, 104100, 104097, 104095, 104092, 104090, 104087, 104085,
    104082, 104080, 104077, 104075, 104072, 104069, 104067, 104064, 104062, 104059, 104057, 104054, 104052, 104049,
    104047, 104044, 104042, 104039, 104037, 104034, 104032, 104029, 104027, 104024, 104022, 104019, 104017, 104014,
    104011, 104009, 104006, 104004, 104001, 103999, 103996, 103994, 103991, 103989, 103986, 103984, 103981, 103979,
    103976, 103974, 103971, 103969, 103966, 103964, 103961, 103959, 103956, 103954, 103951, 103949, 103946, 103944,
    103941, 103939, 103936, 103933, 103931, 103928, 103926, 103923, 103921, 103918, 103916, 103913, 103911, 103908,
    103906, 103903, 103901, 103898, 103896, 103893, 103891, 103888, 103886, 103883, 103881, 103878, 103876, 103873,
    103871, 103868, 103866, 103863, 103861, 103858, 103856, 103853, 103851, 103848, 103846, 103843, 103840, 103838,
    103835, 103833, 103830, 103828, 103825, 103823, 103820, 103818, 103815, 103813, 103810, 103808, 103805, 103803,
    103800, 103798, 103795, 103793, 103790, 103788, 103785, 103783, 103780, 103778, 103775, 103773, 103770, 103768,
    103765, 103763, 103760, 103758, 103755, 103753, 103750, 103748, 103745, 103743, 103740, 103738, 103735, 103733,
    103730, 103728, 103725, 103723, 103720, 103718, 103715, 103713, 103710, 103708, 103705, 103703, 103700, 103698,
    103695, 103693, 103690, 103688, 103685, 103683, 103680, 103678, 103675, 103673, 103670, 103668, 103665, 103663,
    103660, 103658, 103655, 103653, 103650, 103648, 103645, 103643, 103640, 103638, 103635, 103633, 103630, 103628,
    103625, 103623, 103620, 103618, 103615, 103613, 103610, 103608, 103605, 103603, 103600, 103598, 103595, 103593,
    103590, 103588, 103585, 103583, 103580, 103578, 103575, 103573, 103570, 103568, 103565, 103563, 103560, 103558,
    103555, 103553, 103550, 103548, 103545, 103543, 103540, 103538, 103535, 103533, 103530, 103528, 103525, 103523,
    103520, 103518, 103515, 103513, 103510, 103508, 103505, 103503, 103500, 103498, 103495, 103493, 103490, 103488,
    103485, 103483, 103480, 103478, 103475, 103473, 103470, 103468, 103465, 103463, 103460, 103458, 103455, 103453,
    103450, 103448, 103445, 103443, 103440, 103438, 103435, 103433, 103430, 103428, 103425, 103423, 103420, 103418,
    103415, 103413, 103410, 103408, 103405, 103403, 103401, 103398, 103396, 103393, 103391, 103388, 103386, 103383,
    103381, 103378, 103376, 103373, 103371, 103368, 103366, 103363, 103361, 103358, 103356, 103353, 103351, 103348,
    103346, 103343, 103341, 103338, 103336, 103333, 103331, 103328, 103326, 103323, 103321, 103318, 103316, 103313,
    103311, 103308, 103306, 103304, 103301, 103299, 103296, 103294, 103291, 103289, 103286, 103284, 103281, 103279,
    103276, 103274, 103271, 103269, 103266, 103264, 103261, 103259, 103256, 103254, 103251, 103249, 103246, 103244,
    103241, 103239, 103236, 103234, 103232, 103229, 103227, 103224, 103222, 103219, 103217, 103214, 103212, 103209,
    103207, 103204, 103202, 103199, 103197, 103194, 103192, 103189, 103187, 103184, 103182, 103179, 103177, 103174,
    103172, 103170, 103167, 103165, 103162, 103160, 103157, 103155, 103152, 103150, 103147, 103145, 103142, 103140,
    103137, 103135, 103132, 103130, 103127, 103125, 103122, 103120, 103117, 103115, 103113, 103110, 103108, 103105,
    103103, 103100, 103098, 103095, 103093, 103090, 103088, 103085, 103083, 103080, 103078, 103075, 103073, 103070,
    103068, 103066, 103063, 103061, 103058, 103056, 103053, 103051, 103048, 103046, 103043, 103041, 103038, 103036,
    103033, 103031, 103028, 103026, 103023, 103021, 103019, 103016, 103014, 103011, 103009, 103006, 103004, 103001,
    102999, 102996, 102994, 102991, 102989, 102986, 102984, 102982, 102979, 102977, 102974, 102972, 102969, 102967,
    102964, 102962, 102959, 102957, 102954, 102952, 102949, 102947, 102944, 102942, 102940, 102937, 102935, 102932,
    102930, 102927, 102925, 102922, 102920, 102917, 102915, 102912, 102910, 102907, 102905, 102903, 102900, 102898,
    102895, 102893, 102890, 102888, 102885, 102883, 102880, 102878, 102875, 102873, 102871, 102868, 102866, 102863,
    102861, 102858, 102856, 102853, 102851, 102848, 102846, 102843, 102841, 102838, 102836, 102834, 102831, 102829,
    102826, 102824, 102821, 102819, 102816, 102814, 102811, 102809, 102806, 102804, 102802, 102799, 102797, 102794,
    102792, 102789, 102787, 102784, 102782, 102779, 102777, 102775, 102772, 102770, 102767, 102765, 102762, 102760,
    102757, 102755, 102752, 102750, 102747, 102745, 102743, 102740, 102738, 102735, 102733, 102730, 102728, 102725,
    102723, 102720, 102718, 102716, 102713, 102711, 102708, 102706, 102703, 102701, 102698, 102696, 102693, 102691,
    102689, 102686, 102684, 102681, 102679, 102676, 102674, 102671, 102669, 102666, 102664, 102662, 102659, 102657,
    102654, 102652, 102649, 102647, 102644, 102642, 102639, 102637, 102635, 102632, 102630, 102627, 102625, 102622,
    102620, 102617, 102615, 102612, 102610, 102608, 102605, 102603, 102600, 102598, 102595, 102593, 102590, 102588,
    102585, 102583, 102581, 102578, 102576, 102573, 102571, 102568, 102566, 102563, 102561, 102559, 102556, 102554,
    102551, 102549, 102546, 102544, 102541, 102539, 102537, 102534, 102532, 102529, 102527, 102524, 102522, 102519,
    102517, 102514, 102512, 102510, 102507, 102505, 102502, 102500, 102497, 102495, 102492, 102490, 102488, 102485,
    102483, 102480, 102478, 102475, 102473, 102470, 102468, 102466, 102463, 102461, 102458, 102456, 102453, 102451,
    102448, 102446, 102444, 102441, 102439, 102436, 102434, 102431, 102429, 102426, 102424, 102422, 102419, 102417,
    102414, 102412, 102409, 102407, 102404, 102402, 102400, 102397, 102395, 102392, 102390, 102387, 102385, 102383,
    102380, 102378, 102375, 102373, 102370, 102368, 102365, 102363, 102361, 102358, 102356, 102353, 102351, 102348,
    102346, 102343, 102341, 102339, 102336, 102334, 102331, 102329, 102326, 102324, 102322, 102319, 102317, 102314,
    102312, 102309, 102307, 102304, 102302, 102300, 102297, 102295, 102292, 102290, 102287, 102285, 102283, 102280,
    102278, 102275, 102273, 102270, 102268, 102265, 102263, 102261, 102258, 102256, 102253, 102251, 102248, 102246,
    102244, 102241, 102239, 102236, 102234, 102231, 102229, 102227, 102224, 102222, 102219, 102217, 102214, 102212,
    102210, 102207, 102205, 102202, 102200, 102197, 102195, 102193, 102190, 102188, 102185, 102183, 102180, 102178,
    102175, 102173, 102171, 102168, 102166, 102163, 102161, 102158, 102156, 102154, 102151, 102149, 102146, 102144,
    102141, 102139, 102137, 102134, 102132, 102129, 102127, 102124, 102122, 102120, 102117, 102115, 102112, 102110,
    102107, 102105, 102103, 102100, 102098, 102095, 102093, 102090, 102088, 102086, 102083, 102081, 102078, 102076,
    102073, 102071, 102069, 102066, 102064, 102061, 102059, 102057, 102054, 102052, 102049, 102047, 102044, 102042,
    102040, 102037, 102035, 102032, 102030, 102027, 102025, 102023, 102020, 102018, 102015, 102013, 102010, 102008,
    102006, 102003, 102001, 101998, 101996, 101994, 101991, 101989, 101986, 101984, 101981, 101979, 101977, 101974,
    101972, 101969, 101967, 101964, 101962, 101960, 101957, 101955, 101952, 101950, 101948, 101945, 101943, 101940,
    101938, 101935, 101933, 101931, 101928, 101926, 101923, 101921, 101918, 101916, 101914, 101911, 101909, 101906,
    101904, 101902, 101899, 101897, 101894, 101892, 101889, 101887, 101885, 101882, 101880, 101877, 101875, 101873,
    101870, 101868, 101865, 101863, 101860, 101858, 101856, 101853, 101851, 101848, 101846, 101844, 101841, 101839,
    101836, 101834, 101831, 101829, 101827, 101824, 101822, 101819, 101817, 101815, 101812, 101810, 101807, 101805,
    101803, 101800, 101798, 101795, 101793, 101790, 101788, 101786, 101783, 101781, 101778, 101776, 101774, 101771,
    101769, 101766, 101764, 101762, 101759, 101757, 101754, 101752, 101749, 101747, 101745, 101742, 101740, 101737,
    101735, 101733, 101730, 101728, 101725, 101723, 101721, 101718, 101716, 101713, 101711, 101708, 101706, 101704,
    101701, 101699, 101696, 101694, 101692, 101689, 101687, 101684, 101682, 101680, 101677, 101675, 101672, 101670,
    101668, 101665, 101663, 101660, 101658, 101656, 101653, 101651, 101648, 101646, 101644, 101641, 101639, 101636,
    101634, 101631, 101629, 101627, 101624, 101622, 101619, 101617, 101615, 101612, 101610, 101607, 101605, 101603,
    101600, 101598, 101595, 101593, 101591, 101588, 101586, 101583, 101581, 101579, 101576, 101574, 101571, 101569,
    101567, 101564, 101562, 101559, 101557, 101555, 101552, 101550, 101547, 101545, 101543, 101540, 101538, 101535,
    101533, 101531, 101528, 101526, 101523, 101521, 101519, 101516, 101514, 101511, 101509, 101507, 101504, 101502,
    101499, 101497, 101495, 101492, 101490, 101487, 101485, 101483, 101480, 101478, 101475, 101473, 101471, 101468,
    101466, 101463, 101461, 101459, 101456, 101454, 101451, 101449, 101447, 101444, 101442, 101439, 101437, 101435,
    101432, 101430, 101427, 101425, 101423, 101420, 101418, 101415, 101413, 101411, 101408, 101406, 101404, 101401,
    101399, 101396, 101394, 101392, 101389, 101387, 101384, 101382, 101380, 101377, 101375, 101372, 101370, 101368,
    101365, 101363, 101360, 101358, 101356, 101353, 101351, 101348, 101346, 101344, 101341, 101339, 101337, 101334,
    101332, 101329, 101327, 101325, 101322, 101320, 101317, 101315, 101313, 101310, 101308, 101305, 101303, 101301,
    101298, 101296, 101294, 101291, 101289, 101286, 101284, 101282, 101279, 101277, 101274, 101272, 101270, 101267,
    101265, 101262, 101260, 101258, 101255, 101253, 101251, 101248, 101246, 101243, 101241, 101239, 101236, 101234,
    101231, 101229, 101227, 101224, 101222, 101220, 101217, 101215, 101212, 101210, 101208, 101205, 101203, 101200,
    101198, 101196, 101193, 101191, 101189, 101186, 101184, 101181, 101179, 101177, 101174, 101172, 101169, 101167,
    101165, 101162, 101160, 101158, 101155, 101153, 101150, 101148, 101146, 101143, 101141, 101138, 101136, 101134,
    101131, 101129, 101127, 101124, 101122, 101119, 101117, 101115, 101112, 101110, 101108, 101105, 101103, 101100,
    101098, 101096, 101093, 101091, 101088, 101086, 101084, 101081, 101079, 101077, 101074, 101072, 101069, 101067,
    101065, 101062, 101060, 101058, 101055, 101053, 101050, 101048, 101046, 101043, 101041, 101039, 101036, 101034,
    101031, 101029, 101027, 101024, 101022, 101020, 101017, 101015, 101012, 101010, 101008, 101005, 101003, 101001,
    100998, 100996, 100993, 100991, 100989, 100986, 100984, 100982, 100979, 100977, 100974, 100972, 100970, 100967,
    100965, 100963, 100960, 100958, 100955, 100953, 100951, 100948, 100946, 100944, 100941, 100939, 100936, 100934,
    100932, 100929, 100927, 100925, 100922, 100920, 100917, 100915, 100913, 100910, 100908, 100906, 100903, 100901,
    100898, 100896, 100894, 100891, 100889, 100887, 100884, 100882, 100880, 100877, 100875, 100872, 100870, 100868,
    100865, 100863, 100861, 100858, 100856, 100853, 100851, 100849, 100846, 100844, 100842, 100839, 100837, 100835,
    100832, 100830, 100827, 100825, 100823, 100820, 100818, 100816, 100813, 100811, 100809, 100806, 100804, 100801,
    100799, 100797, 100794, 100792, 100790, 100787, 100785, 100782, 100780, 100778, 100775, 100773, 100771, 100768,
    100766, 100764, 100761, 100759, 100756, 100754, 100752, 100749, 100747, 100745, 100742, 100740, 100738, 100735,
    100733, 100730, 100728, 100726, 100723, 100721, 100719, 100716, 100714, 100712, 100709, 100707, 100704, 100702,
    100700, 100697, 100695, 100693, 100690, 100688, 100686, 100683, 100681, 100679, 100676, 100674, 100671, 100669,
    100667, 100664, 100662, 100660, 100657, 100655, 100653, 100650, 100648, 100646, 100643, 100641, 100638, 100636,
    100634, 100631, 100629, 100627, 100624, 100622, 100620, 100617, 100615, 100612, 100610, 100608, 100605, 100603,
    100601, 100598, 100596, 100594, 100591, 100589, 100587, 100584, 100582, 100580, 100577, 100575, 100572, 100570,
    100568, 100565, 100563, 100561, 100558, 100556, 100554, 100551, 100549, 100547, 100544, 100542, 100539, 100537,
    100535, 100532, 100530, 100528, 100525, 100523, 100521, 100518, 100516, 100514, 100511, 100509, 100507, 100504,
    100502, 100499, 100497, 100495, 100492, 100490, 100488, 100485, 100483, 100481, 100478, 100476, 100474, 100471,
    100469, 100467, 100464, 100462, 100460, 100457, 100455, 100452, 100450, 100448, 100445, 100443, 100441, 100438,
    100436, 100434, 100431, 100429, 100427, 100424, 100422, 100420, 100417, 100415, 100413, 100410, 100408, 100406,
    100403, 100401, 100398, 100396, 100394, 100391, 100389, 100387, 100384, 100382, 100380, 100377, 100375, 100373,
    100370, 100368, 100366, 100363, 100361, 100359, 100356, 100354, 100352, 100349, 100347, 100345, 100342, 100340,
    100337, 100335, 100333, 100330, 100328, 100326, 100323, 100321, 100319, 100316, 100314, 100312, 100309, 100307,
    100305, 100302, 100300, 100298, 100295, 100293, 100291, 100288, 100286, 100284, 100281, 100279, 100277, 100274,
    100272, 100270, 100267, 100265, 100263, 100260, 100258, 100256, 100253, 100251, 100248, 100246, 100244, 100241,
    100239, 100237, 100234, 100232, 100230, 100227, 100225, 100223, 100220, 100218, 100216, 100213, 100211, 100209,
    100206, 100204, 100202, 100199, 100197, 100195, 100192, 100190, 100188, 100185, 100183, 100181, 100178, 100176,
    100174, 100171, 100169, 100167, 100164, 100162, 100160, 100157, 100155, 100153, 100150, 100148, 100146, 100143,
    100141, 100139, 100136, 100134, 100132, 100129, 100127, 100125, 100122, 100120, 100118, 100115, 100113, 100111,
    100108, 100106, 100104, 100101, 100099, 100097, 100094, 100092, 100090, 100087, 100085, 100083, 100080, 100078,
    100076, 100073, 100071, 100069, 100066, 100064, 100062, 100059, 100057, 100055, 100052, 100050, 100048, 100045,
    100043, 100041, 100038, 100036, 100034, 100031, 100029, 100027, 100024, 100022, 100020, 100017, 100015, 100013,
    100010, 100008, 100006, 100003, 100001, 99999, 99996, 99994, 99992, 99989, 99987, 99985, 99982, 99980,
    99978, 99975, 99973, 99971, 99968, 99966, 99964, 99962, 99959, 99957, 99955, 99952, 99950, 99948,
    99945, 99943, 99941, 99938, 99936, 99934, 99931, 99929, 99927, 99924, 99922, 99920, 99917, 99915,
    99913, 99910, 99908, 99906, 99903, 99901, 99899, 99896, 99894, 99892, 99889, 99887, 99885, 99882,
    99880, 99878, 99875, 99873, 99871, 99869, 99866, 99864, 99862, 99859, 99857, 99855, 99852, 99850,
    99848, 99845, 99843, 99841, 99838, 99836, 99834, 99831, 99829, 99827, 99824, 99822, 99820, 99817,
    99815, 99813, 99811, 99808, 99806, 99804, 99801, 99799, 99797, 99794, 99792, 99790, 99787, 99785,
    99783, 99780, 99778, 99776, 99773, 99771, 99769, 99766, 99764, 99762, 99760, 99757, 99755, 99753,
    99750, 99748, 99746, 99743, 99741, 99739, 99736, 99734, 99732, 99729, 99727, 99725, 99722, 99720,
    99718, 99715, 99713, 99711, 99709, 99706, 99704, 99702, 99699, 99697, 99695, 99692, 99690, 99688,
    99685, 99683, 99681, 99678, 99676, 99674, 99672, 99669, 99667, 99665, 99662, 99660, 99658, 99655,
    99653, 99651, 99648, 99646, 99644, 99641, 99639, 99637, 99635, 99632, 99630, 99628, 99625, 99623,
    99621, 99618, 99616, 99614, 99611, 99609, 99607, 99604, 99602, 99600, 99598, 99595, 99593, 99591,
    99588, 99586, 99584, 99581, 99579, 99577, 99574, 99572, 99570, 99568, 99565, 99563, 99561, 99558,
    99556, 99554, 99551, 99549, 99547, 99544, 99542, 99540, 99538, 99535, 99533, 99531, 99528, 99526,
    99524, 99521, 99519, 99517, 99514, 99512, 99510, 99508, 99505, 99503, 99501, 99498, 99496, 99494,
    99491, 99489, 99487, 99485, 99482, 99480, 99478, 99475, 99473, 99471, 99468, 99466, 99464, 99461,
    99459, 99457, 99455, 99452, 99450, 99448, 99445, 99443, 99441, 99438, 99436, 99434, 99432, 99429,
    99427, 99425, 99422, 99420, 99418, 99415, 99413, 99411, 99409, 99406, 99404, 99402, 99399, 99397,
    99395, 99392, 99390, 99388, 99386, 99383, 99381, 99379, 99376, 99374, 99372, 99369, 99367, 99365,
    99363, 99360, 99358, 99356, 99353, 99351, 99349, 99346, 99344, 99342, 99340, 99337, 99335, 99333,
    99330, 99328, 99326, 99323, 99321, 99319, 99317, 99314, 99312, 99310, 99307, 99305, 99303, 99301,
    99298, 99296, 99294, 99291, 99289, 99287, 99284, 99282, 99280, 99278, 99275, 99273, 99271, 99268,
    99266, 99264, 99261, 99259, 99257, 99255, 99252, 99250, 99248, 99245, 99243, 99241, 99239, 99236,
    99234, 99232, 99229, 99227, 99225, 99223, 99220, 99218, 99216, 99213, 99211, 99209, 99206, 99204,
    99202, 99200, 99197, 99195, 99193, 99190, 99188, 99186, 99184, 99181, 99179, 99177, 99174, 99172,
    99170, 99168, 99165, 99163, 99161, 99158, 99156, 99154, 99152, 99149, 99147, 99145, 99142, 99140,
    99138, 99135, 99133, 99131, 99129, 99126, 99124, 99122, 99119, 99117, 99115, 99113, 99110, 99108,
    99106, 99103, 99101, 99099, 99097, 99094, 99092, 99090, 99087, 99085, 99083, 99081, 99078, 99076,
    99074, 99071, 99069, 99067, 99065, 99062, 99060, 99058, 99055, 99053, 99051, 99049, 99046, 99044,
    99042, 99039, 99037, 99035, 99033, 99030, 99028, 99026, 99023, 99021, 99019, 99017, 99014, 99012,
    99010, 99008, 99005, 99003, 99001, 98998, 98996, 98994, 98992, 98989, 98987, 98985, 98982, 98980,
    98978, 98976, 98973, 98971, 98969, 98966, 98964, 98962, 98960, 98957, 98955, 98953, 98950, 98948,
    98946, 98944, 98941, 98939, 98937, 98935, 98932, 98930, 98928, 98925, 98923, 98921, 98919, 98916,
    98914, 98912, 98909, 98907, 98905, 98903, 98900, 98898, 98896, 98894, 98891, 98889, 98887, 98884,
    98882, 98880, 98878, 98875, 98873, 98871, 98868, 98866, 98864, 98862, 98859, 98857, 98855, 98853,
    98850, 98848, 98846, 98843, 98841, 98839, 98837, 98834, 98832, 98830, 98828, 98825, 98823, 98821,
    98818, 98816, 98814, 98812, 98809, 98807, 98805, 98803, 98800, 98798, 98796, 98793, 98791, 98789,
    98787, 98784, 98782, 98780, 98778, 98775, 98773, 98771, 98768, 98766, 98764, 98762, 98759, 98757,
    98755, 98753, 98750, 98748, 98746, 98743, 98741, 98739, 98737, 98734, 98732, 98730, 98728, 98725,
    98723, 98721, 98718, 98716, 98714, 98712, 98709, 98707, 98705, 98703, 98700, 98698, 98696, 98694,
    98691, 98689, 98687, 98684, 98682, 98680, 98678, 98675, 98673, 98671, 98669, 98666, 98664, 98662,
    98660, 98657, 98655, 98653, 98650, 98648, 98646, 98644, 98641, 98639, 98637, 98635, 98632, 98630,
    98628, 98626, 98623, 98621, 98619, 98616, 98614, 98612, 98610, 98607, 98605, 98603, 98601, 98598,
    98596, 98594, 98592, 98589, 98587, 98585, 98583, 98580, 98578, 98576, 98573, 98571, 98569, 98567,
    98564, 98562, 98560, 98558, 98555, 98553, 98551, 98549, 98546, 98544, 98542, 98540, 98537, 98535,
    98533, 98531, 98528, 98526, 98524, 98521, 98519, 98517, 98515, 98512, 98510, 98508, 98506, 98503,
    98501, 98499, 98497, 98494, 98492, 98490, 98488, 98485, 98483, 98481, 98479, 98476, 98474, 98472,
    98470, 98467, 98465, 98463, 98461, 98458, 98456, 98454, 98451, 98449, 98447, 98445, 98442, 98440,
    98438, 98436, 98433, 98431, 98429, 98427, 98424, 98422, 98420, 98418, 98415, 98413, 98411, 98409,
    98406, 98404, 98402, 98400, 98397, 98395, 98393, 98391, 98388, 98386, 98384, 98382, 98379, 98377,
    98375, 98373, 98370, 98368, 98366, 98364, 98361, 98359, 98357, 98355, 98352, 98350, 98348, 98346,
    98343, 98341, 98339, 98337, 98334, 98332, 98330, 98328, 98325, 98323, 98321, 98319, 98316, 98314,
    98312, 98310, 98307, 98305, 98303, 98301, 98298, 98296, 98294, 98292, 98289, 98287, 98285, 98283,
    98280, 98278, 98276, 98274, 98271, 98269, 98267, 98265, 98262, 98260, 98258, 98256, 98253, 98251,
    98249, 98247, 98244, 98242, 98240, 98238, 98235, 98233, 98231, 98229, 98226, 98224, 98222, 98220,
    98217, 98215, 98213, 98211, 98208, 98206, 98204, 98202, 98199, 98197, 98195, 98193, 98190, 98188,
    98186, 98184, 98181, 98179, 98177, 98175, 98172, 98170, 98168, 98166, 98163, 98161, 98159, 98157,
    98154, 98152, 98150, 98148, 98146, 98143, 98141, 98139, 98137, 98134, 98132, 98130, 98128, 98125,
    98123, 98121, 98119, 98116, 98114, 98112, 98110, 98107, 98105, 98103, 98101, 98098, 98096, 98094,
    98092, 98089, 98087, 98085, 98083, 98081, 98078, 98076, 98074, 98072, 98069, 98067, 98065, 98063,
    98060, 98058, 98056, 98054, 98051, 98049, 98047, 98045, 98042, 98040, 98038, 98036, 98033, 98031,
    98029, 98027, 98025, 98022, 98020, 98018, 98016, 98013, 98011, 98009, 98007, 98004, 98002, 98000,
    97998, 97995, 97993, 97991, 97989, 97987, 97984, 97982, 97980, 97978, 97975, 97973, 97971, 97969,
    97966, 97964, 97962, 97960, 97957, 97955, 97953, 97951, 97949, 97946, 97944, 97942, 97940, 97937,
    97935, 97933, 97931, 97928, 97926, 97924, 97922, 97920, 97917, 97915, 97913, 97911, 97908, 97906,
    97904, 97902, 97899, 97897, 97895, 97893, 97890, 97888, 97886, 97884, 97882, 97879, 97877, 97875,
    97873, 97870, 97868, 97866, 97864, 97862, 97859, 97857, 97855, 97853, 97850, 97848, 97846, 97844,
    97841, 97839, 97837, 97835, 97833, 97830, 97828, 97826, 97824, 97821, 97819, 97817, 97815, 97812,
    97810, 97808, 97806, 97804, 97801, 97799, 97797, 97795, 97792, 97790, 97788, 97786, 97784, 97781,
    97779, 97777, 97775, 97772, 97770, 97768, 97766, 97763, 97761, 97759, 97757, 97755, 97752, 97750,
    97748, 97746, 97743, 97741, 97739, 97737, 97735, 97732, 97730, 97728, 97726, 97723, 97721, 97719,
    97717, 97715, 97712, 97710, 97708, 97706, 97703, 97701, 97699, 97697, 97695, 97692, 97690, 97688,
    97686, 97683, 97681, 97679, 97677, 97675, 97672, 97670, 97668, 97666, 97663, 97661, 97659, 97657,
    97655, 97652, 97650, 97648, 97646, 97643, 97641, 97639, 97637, 97635, 97632, 97630, 97628, 97626,
    97623, 97621, 97619, 97617, 97615, 97612, 97610, 97608, 97606, 97604, 97601, 97599, 97597, 97595,
    97592, 97590, 97588, 97586, 97584, 97581, 97579, 97577, 97575, 97572, 97570, 97568, 97566, 97564,
    97561, 97559, 97557, 97555, 97553, 97550, 97548, 97546, 97544, 97541, 97539, 97537, 97535, 97533,
    97530, 97528, 97526, 97524, 97522, 97519, 97517, 97515, 97513, 97510, 97508, 97506, 97504, 97502,
    97499, 97497, 97495, 97493, 97491, 97488, 97486, 97484, 97482, 97479, 97477, 97475, 97473, 97471,
    97468, 97466, 97464, 97462, 97460, 97457, 97455, 97453, 97451, 97449, 97446, 97444, 97442, 97440,
    97437, 97435, 97433, 97431, 97429, 97426, 97424, 97422, 97420, 97418, 97415, 97413, 97411, 97409,
    97407, 97404, 97402, 97400, 97398, 97395, 97393, 97391, 97389, 97387, 97384, 97382, 97380, 97378,
    97376, 97373, 97371, 97369, 97367, 97365, 97362, 97360, 97358, 97356, 97354, 97351, 97349, 97347,
    97345, 97342, 97340, 97338, 97336, 97334, 97331, 97329, 97327, 97325, 97323, 97320, 97318, 97316,
    97314, 97312, 97309, 97307, 97305, 97303, 97301, 97298, 97296, 97294, 97292, 97290, 97287, 97285,
    97283, 97281, 97279, 97276, 97274, 97272, 97270, 97268, 97265, 97263, 97261, 97259, 97257, 97254,
    97252, 97250, 97248, 97246, 97243, 97241, 97239, 97237, 97235, 97232, 97230, 97228, 97226, 97224,
    97221, 97219, 97217, 97215, 97212, 97210, 97208, 97206, 97204, 97201, 97199, 97197, 97195, 97193,
    97190, 97188, 97186, 97184, 97182, 97180, 97177, 97175, 97173, 97171, 97169, 97166, 97164, 97162,
    97160, 97158, 97155, 97153, 97151, 97149, 97147, 97144, 97142, 97140, 97138, 97136, 97133, 97131,
    97129, 97127, 97125, 97122, 97120, 97118, 97116, 97114, 97111, 97109, 97107, 97105, 97103, 97100,
    97098, 97096, 97094, 97092, 97089, 97087, 97085, 97083, 97081, 97078, 97076, 97074, 97072, 97070,
    97067, 97065, 97063, 97061, 97059, 97057, 97054, 97052, 97050, 97048, 97046, 97043, 97041, 97039,
    97037, 97035, 97032, 97030, 97028, 97026, 97024, 97021, 97019, 97017, 97015, 97013, 97010, 97008,
    97006, 97004, 97002, 97000, 96997, 96995, 96993, 96991, 96989, 96986, 96984, 96982, 96980, 96978,
    96975, 96973, 96971, 96969, 96967, 96964, 96962, 96960, 96958, 96956, 96954, 96951, 96949, 96947,
    96945, 96943, 96940, 96938, 96936, 96934, 96932, 96929, 96927, 96925, 96923, 96921, 96919, 96916,
    96914, 96912, 96910, 96908, 96905, 96903, 96901, 96899, 96897, 96894, 96892, 96890, 96888, 96886,
    96884, 96881, 96879, 96877, 96875, 96873, 96870, 96868, 96866, 96864, 96862, 96860, 96857, 96855,
    96853, 96851, 96849, 96846, 96844, 96842, 96840, 96838, 96836, 96833, 96831, 96829, 96827, 96825,
    96822, 96820, 96818, 96816, 96814, 96811, 96809, 96807, 96805, 96803, 96801, 96798, 96796, 96794,
    96792, 96790, 96787, 96785, 96783, 96781, 96779, 96777, 96774, 96772, 96770, 96768, 96766, 96764,
    96761, 96759, 96757, 96755, 96753, 96750, 96748, 96746, 96744, 96742, 96740, 96737, 96735, 96733,
    96731, 96729, 96726, 96724, 96722, 96720, 96718, 96716, 96713, 96711, 96709, 96707, 96705, 96703,
    96700, 96698, 96696, 96694, 96692, 96689, 96687, 96685, 96683, 96681, 96679, 96676, 96674, 96672,
    96670, 96668, 96666, 96663, 96661, 96659, 96657, 96655, 96652, 96650, 96648, 96646, 96644, 96642,
    96639, 96637, 96635, 96633, 96631, 96629, 96626, 96624, 96622, 96620, 96618, 96615, 96613, 96611,
    96609, 96607, 96605, 96602, 96600, 96598, 96596, 96594, 96592, 96589, 96587, 96585, 96583, 96581,
    96579, 96576, 96574, 96572, 96570, 96568, 96566, 96563, 96561, 96559, 96557, 96555, 96553, 96550,
    96548, 96546, 96544, 96542, 96539, 96537, 96535, 96533, 96531, 96529, 96526, 96524, 96522, 96520,
    96518, 96516, 96513, 96511, 96509, 96507, 96505, 96503, 96500, 96498, 96496, 96494, 96492, 96490,
    96487, 96485, 96483, 96481, 96479, 96477, 96474, 96472, 96470, 96468, 96466, 96464, 96461, 96459,
    96457, 96455, 96453, 96451, 96448, 96446, 96444, 96442, 96440, 96438, 96435, 96433, 96431, 96429,
    96427, 96425, 96422, 96420, 96418, 96416, 96414, 96412, 96409, 96407, 96405, 96403, 96401, 96399,
    96396, 96394, 96392, 96390, 96388, 96386, 96384, 96381, 96379, 96377, 96375, 96373, 96371, 96368,
    96366, 96364, 96362, 96360, 96358, 96355, 96353, 96351, 96349, 96347, 96345, 96342, 96340, 96338,
    96336, 96334, 96332, 96329, 96327, 96325, 96323, 96321, 96319, 96316, 96314, 96312, 96310, 96308,
    96306, 96304, 96301, 96299, 96297, 96295, 96293, 96291, 96288, 96286, 96284, 96282, 96280, 96278,
    96275, 96273, 96271, 96269, 96267, 96265, 96263, 96260, 96258, 96256, 96254, 96252, 96250, 96247,
    96245, 96243, 96241, 96239, 96237, 96234, 96232, 96230, 96228, 96226, 96224, 96222, 96219, 96217,
    96215, 96213, 96211, 96209, 96206, 96204, 96202, 96200, 96198, 96196, 96194, 96191, 96189, 96187,
    96185, 96183, 96181, 96178, 96176, 96174, 96172, 96170, 96168, 96166, 96163, 96161, 96159, 96157,
    96155, 96153, 96150, 96148, 96146, 96144, 96142, 96140, 96138, 96135, 96133, 96131, 96129, 96127,
    96125, 96122, 96120, 96118, 96116, 96114, 96112, 96110, 96107, 96105, 96103, 96101, 96099, 96097,
    96095, 96092, 96090, 96088, 96086, 96084, 96082, 96079, 96077, 96075, 96073, 96071, 96069, 96067,
    96064, 96062, 96060, 96058, 96056, 96054, 96052, 96049, 96047, 96045, 96043, 96041, 96039, 96037,
    96034, 96032, 96030, 96028, 96026, 96024, 96021, 96019, 96017, 96015, 96013, 96011, 96009, 96006,
    96004, 96002, 96000, 95998, 95996, 95994, 95991, 95989, 95987, 95985, 95983, 95981, 95979, 95976,
    95974, 95972, 95970, 95968, 95966, 95964, 95961, 95959, 95957, 95955, 95953, 95951, 95949, 95946,
    95944, 95942, 95940, 95938, 95936, 95934, 95931, 95929, 95927, 95925, 95923, 95921, 95919, 95916,
    95914, 95912, 95910, 95908, 95906, 95904, 95901, 95899, 95897, 95895, 95893, 95891, 95889, 95886,
    95884, 95882, 95880, 95878, 95876, 95874, 95871, 95869, 95867, 95865, 95863, 95861, 95859, 95856,
    95854, 95852, 95850, 95848, 95846, 95844, 95841, 95839, 95837, 95835, 95833, 95831, 95829, 95827,
    95824, 95822, 95820, 95818, 95816, 95814, 95812, 95809, 95807, 95805, 95803, 95801, 95799, 95797,
    95794, 95792, 95790, 95788, 95786, 95784, 95782, 95780, 95777, 95775, 95773, 95771, 95769, 95767,
    95765, 95762, 95760, 95758, 95756, 95754, 95752, 95750, 95747, 95745, 95743, 95741, 95739, 95737,
    95735, 95733, 95730, 95728, 95726, 95724, 95722, 95720, 95718, 95715, 95713, 95711, 95709, 95707,
    95705, 95703, 95701, 95698, 95696, 95694, 95692, 95690, 95688, 95686, 95683, 95681, 95679, 95677,
    95675, 95673, 95671, 95669, 95666, 95664, 95662, 95660, 95658, 95656, 95654, 95652, 95649, 95647,
    95645, 95643, 95641, 95639, 95637, 95634, 95632, 95630, 95628, 95626, 95624, 95622, 95620, 95617,
    95615, 95613, 95611, 95609, 95607, 95605, 95603, 95600, 95598, 95596, 95594, 95592, 95590, 95588,
    95586, 95583, 95581, 95579, 95577, 95575, 95573, 95571, 95569, 95566, 95564, 95562, 95560, 95558,
    95556, 95554, 95552, 95549, 95547, 95545, 95543, 95541, 95539, 95537, 95535, 95532, 95530, 95528,
    95526, 95524, 95522, 95520, 95518, 95515, 95513, 95511, 95509, 95507, 95505, 95503, 95501, 95498,
    95496, 95494, 95492, 95490, 95488, 95486, 95484, 95481, 95479, 95477, 95475, 95473, 95471, 95469,
    95467, 95464, 95462, 95460, 95458, 95456, 95454, 95452, 95450, 95447, 95445, 95443, 95441, 95439,
    95437, 95435, 95433, 95430, 95428, 95426, 95424, 95422, 95420, 95418, 95416, 95414, 95411, 95409,
    95407, 95405, 95403, 95401, 95399, 95397, 95394, 95392, 95390, 95388, 95386, 95384, 95382, 95380,
    95378, 95375, 95373, 95371, 95369, 95367, 95365, 95363, 95361, 95358, 95356, 95354, 95352, 95350,
    95348, 95346, 95344, 95342, 95339, 95337, 95335, 95333, 95331, 95329, 95327, 95325, 95322, 95320,
    95318, 95316, 95314, 95312, 95310, 95308, 95306, 95303, 95301, 95299, 95297, 95295, 95293, 95291,
    95289, 95287, 95284, 95282, 95280, 95278, 95276, 95274, 95272, 95270, 95268, 95265, 95263, 95261,
    95259, 95257, 95255, 95253, 95251, 95248, 95246, 95244, 95242, 95240, 95238, 95236, 95234, 95232,
    95229, 95227, 95225, 95223, 95221, 95219, 95217, 95215, 95213, 95210, 95208, 95206, 95204, 95202,
    95200, 95198, 95196, 95194, 95191, 95189, 95187, 95185, 95183, 95181, 95179, 95177, 95175, 95173,
    95170, 95168, 95166, 95164, 95162, 95160, 95158, 95156, 95154, 95151, 95149, 95147, 95145, 95143,
    95141, 95139, 95137, 95135, 95132, 95130, 95128, 95126, 95124, 95122, 95120, 95118, 95116, 95113,
    95111, 95109, 95107, 95105, 95103, 95101, 95099, 95097, 95095, 95092, 95090, 95088, 95086, 95084,
    95082, 95080, 95078, 95076, 95073, 95071, 95069, 95067, 95065, 95063, 95061, 95059, 95057, 95055,
    95052, 95050, 95048, 95046, 95044, 95042, 95040, 95038, 95036, 95034, 95031, 95029, 95027, 95025,
    95023, 95021, 95019, 95017, 95015, 95012, 95010, 95008, 95006, 95004, 95002, 95000, 94998, 94996,
    94994, 94991, 94989, 94987, 94985, 94983, 94981, 94979, 94977, 94975, 94973, 94970, 94968, 94966,
    94964, 94962, 94960, 94958, 94956, 94954, 94952, 94949, 94947, 94945, 94943, 94941, 94939, 94937,
    94935, 94933, 94931, 94928, 94926, 94924, 94922, 94920, 94918, 94916, 94914, 94912, 94910, 94908,
    94905, 94903, 94901, 94899, 94897, 94895, 94893, 94891, 94889, 94887, 94884, 94882, 94880, 94878,
    94876, 94874, 94872, 94870, 94868, 94866, 94863, 94861, 94859, 94857, 94855, 94853, 94851, 94849,
    94847, 94845, 94843, 94840, 94838, 94836, 94834, 94832, 94830, 94828, 94826, 94824, 94822, 94820,
    94817, 94815, 94813, 94811, 94809, 94807, 94805, 94803, 94801, 94799, 94796, 94794, 94792, 94790,
    94788, 94786, 94784, 94782, 94780, 94778, 94776, 94773, 94771, 94769, 94767, 94765, 94763, 94761,
    94759, 94757, 94755, 94753, 94750, 94748, 94746, 94744, 94742, 94740, 94738, 94736, 94734, 94732,
    94730, 94727, 94725, 94723, 94721, 94719, 94717, 94715, 94713, 94711, 94709, 94707, 94705, 94702,
    94700, 94698, 94696, 94694, 94692, 94690, 94688, 94686, 94684, 94682, 94679, 94677, 94675, 94673,
    94671, 94669, 94667, 94665, 94663, 94661, 94659, 94657, 94654, 94652, 94650, 94648, 94646, 94644,
    94642, 94640, 94638, 94636, 94634, 94631, 94629, 94627, 94625, 94623, 94621, 94619, 94617, 94615,
    94613, 94611, 94609, 94606, 94604, 94602, 94600, 94598, 94596, 94594, 94592, 94590, 94588, 94586,
    94584, 94581, 94579, 94577, 94575, 94573, 94571, 94569, 94567, 94565, 94563, 94561, 94559, 94556,
    94554, 94552, 94550, 94548, 94546, 94544, 94542, 94540, 94538, 94536, 94534, 94532, 94529, 94527,
    94525, 94523, 94521, 94519, 94517, 94515, 94513, 94511, 94509, 94507, 94504, 94502, 94500, 94498,
    94496, 94494, 94492, 94490, 94488, 94486, 94484, 94482, 94480, 94477, 94475, 94473, 94471, 94469,
    94467, 94465, 94463, 94461, 94459, 94457, 94455, 94453, 94450, 94448, 94446, 94444, 94442, 94440,
    94438, 94436, 94434, 94432, 94430, 94428, 94426, 94423, 94421, 94419, 94417, 94415, 94413, 94411,
    94409, 94407, 94405, 94403, 94401, 94399, 94396, 94394, 94392, 94390, 94388, 94386, 94384, 94382,
    94380, 94378, 94376, 94374, 94372, 94370, 94367, 94365, 94363, 94361, 94359, 94357, 94355, 94353,
    94351, 94349, 94347, 94345, 94343, 94340, 94338, 94336, 94334, 94332, 94330, 94328, 94326, 94324,
    94322, 94320, 94318, 94316, 94314, 94311, 94309, 94307, 94305, 94303, 94301, 94299, 94297, 94295,
    94293, 94291, 94289, 94287, 94285, 94282, 94280, 94278, 94276, 94274, 94272, 94270, 94268, 94266,
    94264, 94262, 94260, 94258, 94256, 94254, 94251, 94249, 94247, 94245, 94243, 94241, 94239, 94237,
    94235, 94233, 94231, 94229, 94227, 94225, 94223, 94220, 94218, 94216, 94214, 94212, 94210, 94208,
    94206, 94204, 94202, 94200, 94198, 94196, 94194, 94192, 94189, 94187, 94185, 94183, 94181, 94179,
    94177, 94175, 94173, 94171, 94169, 94167, 94165, 94163, 94161, 94158, 94156, 94154, 94152, 94150,
    94148, 94146, 94144, 94142, 94140, 94138, 94136, 94134, 94132, 94130, 94128, 94125, 94123, 94121,
    94119, 94117, 94115, 94113, 94111, 94109, 94107, 94105, 94103, 94101, 94099, 94097, 94095, 94092,
    94090, 94088, 94086, 94084, 94082, 94080, 94078, 94076, 94074, 94072, 94070, 94068, 94066, 94064,
    94062, 94059, 94057, 94055, 94053, 94051, 94049, 94047, 94045, 94043, 94041, 94039, 94037, 94035,
    94033, 94031, 94029, 94027, 94024, 94022, 94020, 94018, 94016, 94014, 94012, 94010, 94008, 94006,
    94004, 94002, 94000, 93998, 93996, 93994, 93992, 93990, 93987, 93985, 93983, 93981, 93979, 93977,
    93975, 93973, 93971, 93969, 93967, 93965, 93963, 93961, 93959, 93957, 93955, 93953, 93950, 93948,
    93946, 93944, 93942, 93940, 93938, 93936, 93934, 93932, 93930, 93928, 93926, 93924, 93922, 93920,
    93918, 93916, 93913, 93911, 93909, 93907, 93905, 93903, 93901, 93899, 93897, 93895, 93893, 93891,
    93889, 93887, 93885, 93883, 93881, 93879, 93877, 93874, 93872, 93870, 93868, 93866, 93864, 93862,
    93860, 93858, 93856, 93854, 93852, 93850, 93848, 93846, 93844, 93842, 93840, 93838, 93835, 93833,
    93831, 93829, 93827, 93825, 93823, 93821, 93819, 93817, 93815, 93813, 93811, 93809, 93807, 93805,
    93803, 93801, 93799, 93797, 93795, 93792, 93790, 93788, 93786, 93784, 93782, 93780, 93778, 93776,
    93774, 93772, 93770, 93768, 93766, 93764, 93762, 93760, 93758, 93756, 93754, 93752, 93749, 93747,
    93745, 93743, 93741, 93739, 93737, 93735, 93733, 93731, 93729, 93727, 93725, 93723, 93721, 93719,
    93717, 93715, 93713, 93711, 93709, 93707, 93704, 93702, 93700, 93698, 93696, 93694, 93692, 93690,
    93688, 93686, 93684, 93682, 93680, 93678, 93676, 93674, 93672, 93670, 93668, 93666, 93664, 93662,
    93660, 93657, 93655, 93653, 93651, 93649, 93647, 93645, 93643, 93641, 93639, 93637, 93635, 93633,
    93631, 93629, 93627, 93625, 93623, 93621, 93619, 93617, 93615, 93613, 93611, 93608, 93606, 93604,
    93602, 93600, 93598, 93596, 93594, 93592, 93590, 93588, 93586, 93584, 93582, 93580, 93578, 93576,
    93574, 93572, 93570, 93568, 93566, 93564, 93562, 93560, 93558, 93555, 93553, 93551, 93549, 93547,
    93545, 93543, 93541, 93539, 93537, 93535, 93533, 93531, 93529, 93527, 93525, 93523, 93521, 93519,
    93517, 93515, 93513, 93511, 93509, 93507, 93505, 93503, 93500, 93498, 93496, 93494, 93492, 93490,
    93488, 93486, 93484, 93482, 93480, 93478, 93476, 93474, 93472, 93470, 93468, 93466, 93464, 93462,
    93460, 93458, 93456, 93454, 93452, 93450, 93448, 93446, 93444, 93441, 93439, 93437, 93435, 93433,
    93431, 93429, 93427, 93425, 93423, 93421, 93419, 93417, 93415, 93413, 93411, 93409, 93407, 93405,
    93403, 93401, 93399, 93397, 93395, 93393, 93391, 93389, 93387, 93385, 93383, 93381, 93379, 93376,
    93374, 93372, 93370, 93368, 93366, 93364, 93362, 93360, 93358, 93356, 93354, 93352, 93350, 93348,
    93346, 93344, 93342, 93340, 93338, 93336, 93334, 93332, 93330, 93328, 93326, 93324, 93322, 93320,
    93318, 93316, 93314, 93312, 93310, 93308, 93305, 93303, 93301, 93299, 93297, 93295, 93293, 93291,
    93289, 93287, 93285, 93283, 93281, 93279, 93277, 93275, 93273, 93271, 93269, 93267, 93265, 93263,
    93261, 93259, 93257, 93255, 93253, 93251, 93249, 93247, 93245, 93243, 93241, 93239, 93237, 93235,
    93233, 93231, 93229, 93226, 93224, 93222, 93220, 93218, 93216, 93214, 93212, 93210, 93208, 93206,
    93204, 93202, 93200, 93198, 93196, 93194, 93192, 93190, 93188, 93186, 93184, 93182, 93180, 93178,
    93176, 93174, 93172, 93170, 93168, 93166, 93164, 93162, 93160, 93158, 93156, 93154, 93152, 93150,
    93148, 93146, 93144, 93142, 93140, 93138, 93136, 93133, 93131, 93129, 93127, 93125, 93123, 93121,
    93119, 93117, 93115, 93113, 93111, 93109, 93107, 93105, 93103, 93101, 93099, 93097, 93095, 93093,
    93091, 93089, 93087, 93085, 93083, 93081, 93079, 93077, 93075, 93073, 93071, 93069, 93067, 93065,
    93063, 93061, 93059, 93057, 93055, 93053, 93051, 93049, 93047, 93045, 93043, 93041, 93039, 93037,
    93035, 93033, 93031, 93029, 93027, 93025, 93023, 93021, 93019, 93017, 93014, 93012, 93010, 93008,
    93006, 93004, 93002, 93000, 92998, 92996, 92994, 92992, 92990, 92988, 92986, 92984, 92982, 92980,
    92978, 92976, 92974, 92972, 92970, 92968, 92966, 92964, 92962, 92960, 92958, 92956, 92954, 92952,
    92950, 92948, 92946, 92944, 92942, 92940, 92938, 92936, 92934, 92932, 92930, 92928, 92926, 92924,
    92922, 92920, 92918, 92916, 92914, 92912, 92910, 92908, 92906, 92904, 92902, 92900, 92898, 92896,
    92894, 92892, 92890, 92888, 92886, 92884, 92882, 92880, 92878, 92876, 92874, 92872, 92870, 92868,
    92866, 92864, 92862, 92860, 92858, 92856, 92854, 92852, 92850, 92848, 92846, 92844, 92842, 92840,
    92838, 92836, 92834, 92832, 92830, 92828, 92826, 92824, 92822, 92820, 92818, 92815, 92813, 92811,
    92809, 92807, 92805, 92803, 92801, 92799, 92797, 92795, 92793, 92791, 92789, 92787, 92785, 92783,
    92781, 92779, 92777, 92775, 92773, 92771, 92769, 92767, 92765, 92763, 92761, 92759, 92757, 92755,
    92753, 92751, 92749, 92747, 92745, 92743, 92741, 92739, 92737, 92735, 92733, 92731, 92729, 92727,
    92725, 92723, 92721, 92719, 92717, 92715, 92713, 92711, 92709, 92707, 92705, 92703, 92701, 92699,
    92697, 92695, 92693, 92691, 92689, 92687, 92685, 92683, 92681, 92679, 92677, 92675, 92673, 92671,
    92669, 92667, 92665, 92663, 92661, 92659, 92657, 92655, 92653, 92651, 92649, 92647, 92645, 92643,
    92641, 92639, 92637, 92635, 92633, 92631, 92629, 92627, 92625, 92623, 92621, 92619, 92617, 92615,
    92613, 92611, 92609, 92607, 92605, 92603, 92601, 92599, 92597, 92595, 92593, 92591, 92589, 92587,
    92585, 92583, 92581, 92579, 92577, 92575, 92573, 92571, 92569, 92567, 92565, 92563, 92561, 92559,
    92557, 92555, 92553, 92551, 92549, 92547, 92546, 92544, 92542, 92540, 92538, 92536, 92534, 92532,
    92530, 92528, 92526, 92524, 92522, 92520, 92518, 92516, 92514, 92512, 92510, 92508, 92506, 92504,
    92502, 92500, 92498, 92496, 92494, 92492, 92490, 92488, 92486, 92484, 92482, 92480, 92478, 92476,
    92474, 92472, 92470, 92468, 92466, 92464, 92462, 92460, 92458, 92456, 92454, 92452, 92450, 92448,
    92446, 92444, 92442, 92440, 92438, 92436, 92434, 92432, 92430, 92428, 92426, 92424, 92422, 92420,
    92418, 92416, 92414, 92412, 92410, 92408, 92406, 92404, 92402, 92400, 92398, 92396, 92394, 92392,
    92390, 92388, 92386, 92384, 92382, 92380, 92378, 92376, 92374, 92372, 92370, 92368, 92366, 92364,
    92362, 92360, 92358, 92356, 92354, 92352, 92350, 92349, 92347, 92345, 92343, 92341, 92339, 92337,
    92335, 92333, 92331, 92329, 92327, 92325, 92323, 92321, 92319, 92317, 92315, 92313, 92311, 92309,
    92307, 92305, 92303, 92301, 92299, 92297, 92295, 92293, 92291, 92289, 92287, 92285, 92283, 92281,
    92279, 92277, 92275, 92273, 92271, 92269, 92267, 92265, 92263, 92261, 92259, 92257, 92255, 92253,
    92251, 92249, 92247, 92245, 92243, 92241, 92239, 92237, 92235, 92233, 92231, 92230, 92228, 92226,
    92224, 92222, 92220, 92218, 92216, 92214, 92212, 92210, 92208, 92206, 92204, 92202, 92200, 92198,
    92196, 92194, 92192, 92190, 92188, 92186, 92184, 92182, 92180, 92178, 92176, 92174, 92172, 92170,
    92168, 92166, 92164, 92162, 92160, 92158, 92156, 92154, 92152, 92150, 92148, 92146, 92144, 92142,
    92140, 92139, 92137, 92135, 92133, 92131, 92129, 92127, 92125, 92123, 92121, 92119, 92117, 92115,
    92113, 92111, 92109, 92107, 92105, 92103, 92101, 92099, 92097, 92095, 92093, 92091, 92089, 92087,
    92085, 92083, 92081, 92079, 92077, 92075, 92073, 92071, 92069, 92067, 92065, 92063, 92061, 92060,
    92058, 92056, 92054, 92052, 92050, 92048, 92046, 92044, 92042, 92040, 92038, 92036, 92034, 92032,
    92030, 92028, 92026, 92024, 92022, 92020, 92018, 92016, 92014, 92012, 92010, 92008, 92006, 92004,
    92002, 92000, 91998, 91996, 91994, 91992, 91990, 91989, 91987, 91985, 91983, 91981, 91979, 91977,
    91975, 91973, 91971, 91969, 91967, 91965, 91963, 91961, 91959, 91957, 91955, 91953, 91951, 91949,
    91947, 91945, 91943, 91941, 91939, 91937, 91935, 91933, 91931, 91929, 91927, 91926, 91924, 91922,
    91920, 91918, 91916, 91914, 91912, 91910, 91908, 91906, 91904, 91902, 91900, 91898, 91896, 91894,
    91892, 91890, 91888, 91886, 91884, 91882, 91880, 91878, 91876, 91874, 91872, 91870, 91868, 91867,
    91865, 91863, 91861, 91859, 91857, 91855, 91853, 91851, 91849, 91847, 91845, 91843, 91841, 91839,
    91837, 91835, 91833, 91831, 91829, 91827, 91825, 91823, 91821, 91819, 91817, 91815, 91814, 91812,
    91810, 91808, 91806, 91804, 91802, 91800, 91798, 91796, 91794, 91792, 91790, 91788, 91786, 91784,
    91782, 91780, 91778, 91776, 91774, 91772, 91770, 91768, 91766, 91764, 91763, 91761, 91759, 91757,
    91755, 91753, 91751, 91749, 91747, 91745, 91743, 91741, 91739, 91737, 91735, 91733, 91731, 91729,
    91727, 91725, 91723, 91721, 91719, 91717, 91715, 91714, 91712, 91710, 91708, 91706, 91704, 91702,
    91700, 91698, 91696, 91694, 91692, 91690, 91688, 91686, 91684, 91682, 91680, 91678, 91676, 91674,
    91672, 91670, 91668, 91667, 91665, 91663, 91661, 91659, 91657, 91655, 91653, 91651, 91649, 91647,
    91645, 91643, 91641, 91639, 91637, 91635, 91633, 91631, 91629, 91627, 91625, 91624, 91622, 91620,
    91618, 91616, 91614, 91612, 91610, 91608, 91606, 91604, 91602, 91600, 91598, 91596, 91594, 91592,
    91590, 91588, 91586, 91584, 91582, 91581, 91579, 91577, 91575, 91573, 91571, 91569, 91567, 91565,
    91563, 91561, 91559, 91557, 91555, 91553, 91551, 91549, 91547, 91545, 91543, 91541, 91540, 91538,
    91536, 91534, 91532, 91530, 91528, 91526, 91524, 91522, 91520, 91518, 91516, 91514, 91512, 91510,
    91508, 91506, 91504, 91502, 91501, 91499, 91497, 91495, 91493, 91491, 91489, 91487, 91485, 91483,
    91481, 91479, 91477, 91475, 91473, 91471, 91469, 91467, 91465, 91464, 91462, 91460, 91458, 91456,
    91454, 91452, 91450, 91448, 91446, 91444, 91442, 91440, 91438, 91436, 91434, 91432, 91430, 91428,
    91427, 91425, 91423, 91421, 91419, 91417, 91415, 91413, 91411, 91409, 91407, 91405, 91403, 91401,
    91399, 91397, 91395, 91393, 91392, 91390, 91388, 91386, 91384, 91382, 91380, 91378, 91376, 91374,
    91372, 91370, 91368, 91366, 91364, 91362, 91360, 91358, 91357, 91355, 91353, 91351, 91349, 91347,
    91345, 91343, 91341, 91339, 91337, 91335, 91333, 91331, 91329, 91327, 91325, 91323, 91322, 91320,
    91318, 91316, 91314, 91312, 91310, 91308, 91306, 91304, 91302, 91300, 91298, 91296, 91294, 91292,
    91290, 91289, 91287, 91285, 91283, 91281, 91279, 91277, 91275, 91273, 91271, 91269, 91267, 91265,
    91263, 91261, 91259, 91258, 91256, 91254, 91252, 91250, 91248, 91246, 91244, 91242, 91240, 91238,
    91236, 91234, 91232, 91230, 91228, 91227, 91225, 91223, 91221, 91219, 91217, 91215, 91213, 91211,
    91209, 91207, 91205, 91203, 91201, 91199, 91197, 91196, 91194, 91192, 91190, 91188, 91186, 91184,
    91182, 91180, 91178, 91176, 91174, 91172, 91170, 91168, 91166, 91165, 91163, 91161, 91159, 91157,
    91155, 91153, 91151, 91149, 91147, 91145, 91143, 91141, 91139, 91137, 91136, 91134, 91132, 91130,
    91128, 91126, 91124, 91122, 91120, 91118, 91116, 91114, 91112, 91110, 91108, 91107, 91105, 91103,
    91101, 91099, 91097, 91095, 91093, 91091, 91089, 91087, 91085, 91083, 91081, 91079, 91078, 91076,
    91074, 91072, 91070, 91068, 91066, 91064, 91062, 91060, 91058, 91056, 91054, 91052, 91051, 91049,
    91047, 91045, 91043, 91041, 91039, 91037, 91035, 91033, 91031, 91029, 91027, 91025, 91024, 91022,
    91020, 91018, 91016, 91014, 91012, 91010, 91008, 91006, 91004, 91002, 91000, 90998, 90997, 90995,
    90993, 90991, 90989, 90987, 90985, 90983, 90981, 90979, 90977, 90975, 90973, 90971, 90970, 90968,
    90966, 90964, 90962, 90960, 90958, 90956, 90954, 90952, 90950, 90948, 90946, 90944, 90943, 90941,
    90939, 90937, 90935, 90933, 90931, 90929, 90927, 90925, 90923, 90921, 90919, 90918, 90916, 90914,
    90912, 90910, 90908, 90906, 90904, 90902, 90900, 90898, 90896, 90894, 90893, 90891, 90889, 90887,
    90885, 90883, 90881, 90879, 90877, 90875, 90873, 90871, 90869, 90868, 90866, 90864, 90862, 90860,
    90858, 90856, 90854, 90852, 90850, 90848, 90846, 90844, 90843, 90841, 90839, 90837, 90835, 90833,
    90831, 90829, 90827, 90825, 90823, 90821, 90819, 90818, 90816, 90814, 90812, 90810, 90808, 90806,
    90804, 90802, 90800, 90798, 90796, 90795, 90793, 90791, 90789, 90787, 90785, 90783, 90781, 90779,
    90777, 90775, 90773, 90771, 90770, 90768, 90766, 90764, 90762, 90760, 90758, 90756, 90754, 90752,
    90750, 90748, 90747, 90745, 90743, 90741, 90739, 90737, 90735, 90733, 90731, 90729, 90727, 90725,
    90724, 90722, 90720, 90718, 90716, 90714, 90712, 90710, 90708, 90706, 90704, 90702, 90701, 90699,
    90697, 90695, 90693, 90691, 90689, 90687, 90685, 90683, 90681, 90679, 90678, 90676, 90674, 90672,
    90670, 90668, 90666, 90664, 90662, 90660, 90658, 90657, 90655, 90653, 90651, 90649, 90647, 90645,
    90643, 90641, 90639, 90637, 90635, 90634, 90632, 90630, 90628, 90626, 90624, 90622, 90620, 90618,
    90616, 90614, 90613, 90611, 90609, 90607, 90605, 90603, 90601, 90599, 90597, 90595, 90593, 90592,
    90590, 90588, 90586, 90584, 90582, 90580, 90578, 90576, 90574, 90572, 90571, 90569, 90567, 90565,
    90563, 90561, 90559, 90557, 90555, 90553, 90551, 90549, 90548, 90546, 90544, 90542, 90540, 90538,
    90536, 90534, 90532, 90530, 90529, 90527, 90525, 90523, 90521, 90519, 90517, 90515, 90513, 90511,
    90509, 90508, 90506, 90504, 90502, 90500, 90498, 90496, 90494, 90492, 90490, 90488, 90487, 90485,
    90483, 90481, 90479, 90477, 90475, 90473, 90471, 90469, 90467, 90466, 90464, 90462, 90460, 90458,
    90456, 90454, 90452, 90450, 90448, 90447, 90445, 90443, 90441, 90439, 90437, 90435, 90433, 90431,
    90429, 90427, 90426, 90424, 90422, 90420, 90418, 90416, 90414, 90412, 90410, 90408, 90407, 90405,
    90403, 90401, 90399, 90397, 90395, 90393, 90391, 90389, 90388, 90386, 90384, 90382, 90380, 90378,
    90376, 90374, 90372, 90370, 90369, 90367, 90365, 90363, 90361, 90359, 90357, 90355, 90353, 90351,
    90349, 90348, 90346, 90344, 90342, 90340, 90338, 90336, 90334, 90332, 90330, 90329, 90327, 90325,
    90323, 90321, 90319, 90317, 90315, 90313, 90311, 90310, 90308, 90306, 90304, 90302, 90300, 90298,
    90296, 90294, 90293, 90291, 90289, 90287, 90285, 90283, 90281, 90279, 90277, 90275, 90274, 90272,
    90270, 90268, 90266, 90264, 90262, 90260, 90258, 90256, 90255, 90253, 90251, 90249, 90247, 90245,
    90243, 90241, 90239, 90237, 90236, 90234, 90232, 90230, 90228, 90226, 90224, 90222, 90220, 90219,
    90217, 90215, 90213, 90211, 90209, 90207, 90205, 90203, 90201, 90200, 90198, 90196, 90194, 90192,
    90190, 90188, 90186, 90184, 90183, 90181, 90179, 90177, 90175, 90173, 90171, 90169, 90167, 90166,
    90164, 90162, 90160, 90158, 90156, 90154, 90152, 90150, 90148, 90147, 90145, 90143, 90141, 90139,
    90137, 90135, 90133, 90131, 90130, 90128, 90126, 90124, 90122, 90120, 90118, 90116, 90114, 90113,
    90111, 90109, 90107, 90105, 90103, 90101, 90099, 90097, 90096, 90094, 90092, 90090, 90088, 90086,
    90084, 90082, 90080, 90079, 90077, 90075, 90073, 90071, 90069, 90067, 90065, 90063, 90062, 90060,
    90058, 90056, 90054, 90052, 90050, 90048, 90046, 90045, 90043, 90041, 90039, 90037, 90035, 90033,
    90031, 90029, 90028, 90026, 90024, 90022, 90020, 90018, 90016, 90014, 90012, 90011, 90009, 90007,
    90005, 90003, 90001, 89999, 89997, 89995, 89994, 89992, 89990, 89988, 89986, 89984, 89982, 89980,
    89978, 89977, 89975, 89973, 89971, 89969, 89967, 89965, 89963, 89962, 89960, 89958, 89956, 89954,
    89952, 89950, 89948, 89946, 89945, 89943, 89941, 89939, 89937, 89935, 89933, 89931, 89930, 89928,
    89926, 89924, 89922, 89920, 89918, 89916, 89914, 89913, 89911, 89909, 89907, 89905, 89903, 89901,
    89899, 89898, 89896, 89894, 89892, 89890, 89888, 89886, 89884, 89882, 89881, 89879, 89877, 89875,
    89873, 89871, 89869, 89867, 89866, 89864, 89862, 89860, 89858, 89856, 89854, 89852, 89850, 89849,
    89847, 89845, 89843, 89841, 89839, 89837, 89835, 89834, 89832, 89830, 89828, 89826, 89824, 89822,
    89820, 89819, 89817, 89815, 89813, 89811, 89809, 89807, 89805, 89804, 89802, 89800, 89798, 89796,
    89794, 89792, 89790, 89789, 89787, 89785, 89783, 89781, 89779, 89777, 89775, 89773, 89772, 89770,
    89768, 89766, 89764, 89762, 89760, 89758, 89757, 89755, 89753, 89751, 89749, 89747, 89745, 89743,
    89742, 89740, 89738, 89736, 89734, 89732, 89730, 89728, 89727, 89725, 89723, 89721, 89719, 89717,
    89715, 89713, 89712, 89710, 89708, 89706, 89704, 89702, 89700, 89698, 89697, 89695, 89693, 89691,
    89689, 89687, 89685, 89684, 89682, 89680, 89678, 89676, 89674, 89672, 89670, 89669, 89667, 89665,
    89663, 89661, 89659, 89657, 89655, 89654, 89652, 89650, 89648, 89646, 89644, 89642, 89640, 89639,
    89637, 89635, 89633, 89631, 89629, 89627, 89625, 89624, 89622, 89620, 89618, 89616, 89614, 89612,
    89611, 89609, 89607, 89605, 89603, 89601, 89599, 89597, 89596, 89594, 89592, 89590, 89588, 89586,
    89584, 89583, 89581, 89579, 89577, 89575, 89573, 89571, 89569, 89568, 89566, 89564, 89562, 89560,
    89558, 89556, 89554, 89553, 89551, 89549, 89547, 89545, 89543, 89541, 89540, 89538, 89536, 89534,
    89532, 89530, 89528, 89526, 89525, 89523, 89521, 89519, 89517, 89515, 89513, 89512, 89510, 89508,
    89506, 89504, 89502, 89500, 89498, 89497, 89495, 89493, 89491, 89489, 89487, 89485, 89484, 89482,
    89480, 89478, 89476, 89474, 89472, 89471, 89469, 89467, 89465, 89463, 89461, 89459, 89457, 89456,
    89454, 89452, 89450, 89448, 89446, 89444, 89443, 89441, 89439, 89437, 89435, 89433, 89431, 89430,
    89428, 89426, 89424, 89422, 89420, 89418, 89417, 89415, 89413, 89411, 89409, 89407, 89405, 89403,
    89402, 89400, 89398, 89396, 89394, 89392, 89390, 89389, 89387, 89385, 89383, 89381, 89379, 89377,
    89376, 89374, 89372, 89370, 89368, 89366, 89364, 89363, 89361, 89359, 89357, 89355, 89353, 89351,
    89350, 89348, 89346, 89344, 89342, 89340, 89338, 89337, 89335, 89333, 89331, 89329, 89327, 89325,
    89324, 89322, 89320, 89318, 89316, 89314, 89312, 89311, 89309, 89307, 89305, 89303, 89301, 89299,
    89298, 89296, 89294, 89292, 89290, 89288, 89286, 89285, 89283, 89281, 89279, 89277, 89275, 89273,
    89272, 89270, 89268, 89266, 89264, 89262, 89260, 89259, 89257, 89255, 89253, 89251, 89249, 89247,
    89246, 89244, 89242, 89240, 89238, 89236, 89234, 89233, 89231, 89229, 89227, 89225, 89223, 89221,
    89220, 89218, 89216, 89214, 89212, 89210, 89209, 89207, 89205, 89203, 89201, 89199, 89197, 89196,
    89194, 89192, 89190, 89188, 89186, 89184, 89183, 89181, 89179, 89177, 89175, 89173, 89171, 89170,
    89168, 89166, 89164, 89162, 89160, 89159, 89157, 89155, 89153, 89151, 89149, 89147, 89146, 89144,
    89142, 89140, 89138, 89136, 89134, 89133, 89131, 89129, 89127, 89125, 89123, 89122, 89120, 89118,
    89116, 89114, 89112, 89110, 89109, 89107, 89105, 89103, 89101, 89099, 89097, 89096, 89094, 89092,
    89090, 89088, 89086, 89085, 89083, 89081, 89079, 89077, 89075, 89073, 89072, 89070, 89068, 89066,
    89064, 89062, 89061, 89059, 89057, 89055, 89053, 89051, 89049, 89048, 89046, 89044, 89042, 89040,
    89038, 89037, 89035, 89033, 89031, 89029, 89027, 89025, 89024, 89022, 89020, 89018, 89016, 89014,
    89013, 89011, 89009, 89007, 89005, 89003, 89001, 89000, 88998, 88996, 88994, 88992, 88990, 88989,
    88987, 88985, 88983, 88981, 88979, 88977, 88976, 88974, 88972, 88970, 88968, 88966, 88965, 88963,
    88961, 88959, 88957, 88955, 88954, 88952, 88950, 88948, 88946, 88944, 88942, 88941, 88939, 88937,
    88935, 88933, 88931, 88930, 88928, 88926, 88924, 88922, 88920, 88919, 88917, 88915, 88913, 88911,
    88909, 88907, 88906, 88904, 88902, 88900, 88898, 88896, 88895, 88893, 88891, 88889, 88887, 88885,
    88884, 88882, 88880, 88878, 88876, 88874, 88873, 88871, 88869, 88867, 88865, 88863, 88862, 88860,
    88858, 88856, 88854, 88852, 88850, 88849, 88847, 88845, 88843, 88841, 88839, 88838, 88836, 88834,
    88832, 88830, 88828, 88827, 88825, 88823, 88821, 88819, 88817, 88816, 88814, 88812, 88810, 88808,
    88806, 88805, 88803, 88801, 88799, 88797, 88795, 88794, 88792, 88790, 88788, 88786, 88784, 88783,
    88781, 88779, 88777, 88775, 88773, 88772, 88770, 88768, 88766, 88764, 88762, 88761, 88759, 88757,
    88755, 88753, 88751, 88749, 88748, 88746, 88744, 88742, 88740, 88738, 88737, 88735, 88733, 88731,
    88729, 88727, 88726, 88724, 88722, 88720, 88718, 88717, 88715, 88713, 88711, 88709, 88707, 88706,
    88704, 88702, 88700, 88698, 88696, 88695, 88693, 88691, 88689, 88687, 88685, 88684, 88682, 88680,
    88678, 88676, 88674, 88673, 88671, 88669, 88667, 88665, 88663, 88662, 88660, 88658, 88656, 88654,
    88652, 88651, 88649, 88647, 88645, 88643, 88641, 88640, 88638, 88636, 88634, 88632, 88630, 88629,
    88627, 88625, 88623, 88621, 88619, 88618, 88616, 88614, 88612, 88610, 88609, 88607, 88605, 88603,
    88601, 88599, 88598, 88596, 88594, 88592, 88590, 88588, 88587, 88585, 88583, 88581, 88579, 88577,
    88576, 88574, 88572, 88570, 88568, 88566, 88565, 88563, 88561, 88559, 88557, 88556, 88554, 88552,
    88550, 88548, 88546, 88545, 88543, 88541, 88539, 88537, 88535, 88534, 88532, 88530, 88528, 88526,
    88525, 88523, 88521, 88519, 88517, 88515, 88514, 88512, 88510, 88508, 88506, 88504, 88503, 88501,
    88499, 88497, 88495, 88493, 88492, 88490, 88488, 88486, 88484, 88483, 88481, 88479, 88477, 88475,
    88473, 88472, 88470, 88468, 88466, 88464, 88463, 88461, 88459, 88457, 88455, 88453, 88452, 88450,
    88448, 88446, 88444, 88442, 88441, 88439, 88437, 88435, 88433, 88432, 88430, 88428, 88426, 88424,
    88422, 88421, 88419, 88417, 88415, 88413, 88412, 88410, 88408, 88406, 88404, 88402, 88401, 88399,
    88397, 88395, 88393, 88392, 88390, 88388, 88386, 88384, 88382, 88381, 88379, 88377, 88375, 88373,
    88371, 88370, 88368, 88366, 88364, 88362, 88361, 88359, 88357, 88355, 88353, 88352, 88350, 88348,
    88346, 88344, 88342, 88341, 88339, 88337, 88335, 88333, 88332, 88330, 88328, 88326, 88324, 88322,
    88321, 88319, 88317, 88315, 88313, 88312, 88310, 88308, 88306, 88304, 88302, 88301, 88299, 88297,
    88295, 88293, 88292, 88290, 88288, 88286, 88284, 88282, 88281, 88279, 88277, 88275, 88273, 88272,
    88270, 88268, 88266, 88264, 88263, 88261, 88259, 88257, 88255, 88253, 88252, 88250, 88248, 88246,
    88244, 88243, 88241, 88239, 88237, 88235, 88234, 88232, 88230, 88228, 88226, 88224, 88223, 88221,
    88219, 88217, 88215, 88214, 88212, 88210, 88208, 88206, 88205, 88203, 88201, 88199, 88197, 88195,
    88194, 88192, 88190, 88188, 88186, 88185, 88183, 88181, 88179, 88177, 88176, 88174, 88172, 88170,
    88168, 88167, 88165, 88163, 88161, 88159, 88157, 88156, 88154, 88152, 88150, 88148, 88147, 88145,
    88143, 88141, 88139, 88138, 88136, 88134, 88132, 88130, 88129, 88127, 88125, 88123, 88121, 88119,
    88118, 88116, 88114, 88112, 88110, 88109, 88107, 88105, 88103, 88101, 88100, 88098, 88096, 88094,
    88092, 88091, 88089, 88087, 88085, 88083, 88082, 88080, 88078, 88076, 88074, 88072, 88071, 88069,
    88067, 88065, 88063, 88062, 88060, 88058, 88056, 88054, 88053, 88051, 88049, 88047, 88045, 88044,
    88042, 88040, 88038, 88036, 88035, 88033, 88031, 88029, 88027, 88026, 88024, 88022, 88020, 88018,
    88017, 88015, 88013, 88011, 88009, 88008, 88006, 88004, 88002, 88000, 87999, 87997, 87995, 87993,
    87991, 87989, 87988, 87986, 87984, 87982, 87980, 87979, 87977, 87975, 87973, 87971, 87970, 87968,
    87966, 87964, 87962, 87961, 87959, 87957, 87955, 87953, 87952, 87950, 87948, 87946, 87944, 87943,
    87941, 87939, 87937, 87935, 87934, 87932, 87930, 87928, 87926, 87925, 87923, 87921, 87919, 87917,
    87916, 87914, 87912, 87910, 87908, 87907, 87905, 87903, 87901, 87899, 87898, 87896, 87894, 87892,
    87890, 87889, 87887, 87885, 87883, 87881, 87880, 87878, 87876, 87874, 87872, 87871, 87869, 87867,
    87865, 87863, 87862, 87860, 87858, 87856, 87855, 87853, 87851, 87849, 87847, 87846, 87844, 87842,
    87840, 87838, 87837, 87835, 87833, 87831, 87829, 87828, 87826, 87824, 87822, 87820, 87819, 87817,
    87815, 87813, 87811, 87810, 87808, 87806, 87804, 87802, 87801, 87799, 87797, 87795, 87793, 87792,
    87790, 87788, 87786, 87784, 87783, 87781, 87779, 87777, 87776, 87774, 87772, 87770, 87768, 87767,
    87765, 87763, 87761, 87759, 87758, 87756, 87754, 87752, 87750, 87749, 87747, 87745, 87743, 87741,
    87740, 87738, 87736, 87734, 87732, 87731, 87729, 87727, 87725, 87724, 87722, 87720, 87718, 87716,
    87715, 87713, 87711, 87709, 87707, 87706, 87704, 87702, 87700, 87698, 87697, 87695, 87693, 87691,
    87689, 87688, 87686, 87684, 87682, 87681, 87679, 87677, 87675, 87673, 87672, 87670, 87668, 87666,
    87664, 87663, 87661, 87659, 87657, 87655, 87654, 87652, 87650, 87648, 87647, 87645, 87643, 87641,
    87639, 87638, 87636, 87634, 87632, 87630, 87629, 87627, 87625, 87623, 87621, 87620, 87618, 87616,
    87614, 87613, 87611, 87609, 87607, 87605, 87604, 87602, 87600, 87598, 87596, 87595, 87593, 87591,
    87589, 87588, 87586, 87584, 87582, 87580, 87579, 87577, 87575, 87573, 87571, 87570, 87568, 87566,
    87564, 87563, 87561, 87559, 87557, 87555, 87554, 87552, 87550, 87548, 87546, 87545, 87543, 87541,
    87539, 87538, 87536, 87534, 87532, 87530, 87529, 87527, 87525, 87523, 87522, 87520, 87518, 87516,
    87514, 87513, 87511, 87509, 87507, 87505, 87504, 87502, 87500, 87498, 87497, 87495, 87493, 87491,
    87489, 87488, 87486, 87484, 87482, 87481, 87479, 87477, 87475, 87473, 87472, 87470, 87468, 87466,
    87464, 87463, 87461, 87459, 87457, 87456, 87454, 87452, 87450, 87448, 87447, 87445, 87443, 87441,
    87440, 87438, 87436, 87434, 87432, 87431, 87429, 87427, 87425, 87424, 87422, 87420, 87418, 87416,
    87415, 87413, 87411, 87409, 87408, 87406, 87404, 87402, 87400, 87399, 87397, 87395, 87393, 87392,
    87390, 87388, 87386, 87384, 87383, 87381, 87379, 87377, 87376, 87374, 87372, 87370, 87368, 87367,
    87365, 87363, 87361, 87360, 87358, 87356, 87354, 87352, 87351, 87349, 87347, 87345, 87344, 87342,
    87340, 87338, 87336, 87335, 87333, 87331, 87329, 87328, 87326, 87324, 87322, 87320, 87319, 87317,
    87315, 87313, 87312, 87310, 87308, 87306, 87304, 87303, 87301, 87299, 87297, 87296, 87294, 87292,
    87290, 87288, 87287, 87285, 87283, 87281, 87280, 87278, 87276, 87274, 87273, 87271, 87269, 87267,
    87265, 87264, 87262, 87260, 87258, 87257, 87255, 87253, 87251, 87249, 87248, 87246, 87244, 87242,
    87241, 87239, 87237, 87235, 87234, 87232, 87230, 87228, 87226, 87225, 87223, 87221, 87219, 87218,
    87216, 87214, 87212, 87211, 87209, 87207, 87205, 87203, 87202, 87200, 87198, 87196, 87195, 87193,
    87191, 87189, 87187, 87186, 87184, 87182, 87180, 87179, 87177, 87175, 87173, 87172, 87170, 87168,
    87166, 87164, 87163, 87161, 87159, 87157, 87156, 87154, 87152, 87150, 87149, 87147, 87145, 87143,
    87141, 87140, 87138, 87136, 87134, 87133, 87131, 87129, 87127, 87126, 87124, 87122, 87120, 87119,
    87117, 87115, 87113, 87111, 87110, 87108, 87106, 87104, 87103, 87101, 87099, 87097, 87096, 87094,
    87092, 87090, 87088, 87087, 87085, 87083, 87081, 87080, 87078, 87076, 87074, 87073, 87071, 87069,
    87067, 87066, 87064, 87062, 87060, 87058, 87057, 87055, 87053, 87051, 87050, 87048, 87046, 87044,
    87043, 87041, 87039, 87037, 87036, 87034, 87032, 87030, 87028, 87027, 87025, 87023, 87021, 87020,
    87018, 87016, 87014, 87013, 87011, 87009, 87007, 87006, 87004, 87002, 87000, 86999, 86997, 86995,
    86993, 86991, 86990, 86988, 86986, 86984, 86983, 86981, 86979, 86977, 86976, 86974, 86972, 86970,
    86969, 86967, 86965, 86963, 86962, 86960, 86958, 86956, 86954, 86953, 86951, 86949, 86947, 86946,
    86944, 86942, 86940, 86939, 86937, 86935, 86933, 86932, 86930, 86928, 86926, 86925, 86923, 86921,
    86919, 86918, 86916, 86914, 86912, 86910, 86909, 86907, 86905, 86903, 86902, 86900, 86898, 86896,
    86895, 86893, 86891, 86889, 86888, 86886, 86884, 86882, 86881, 86879, 86877, 86875, 86874, 86872,
    86870, 86868, 86867, 86865, 86863, 86861, 86860, 86858, 86856, 86854, 86852, 86851, 86849, 86847,
    86845, 86844, 86842, 86840, 86838, 86837, 86835, 86833, 86831, 86830, 86828, 86826, 86824, 86823,
    86821, 86819, 86817, 86816, 86814, 86812, 86810, 86809, 86807, 86805, 86803, 86802, 86800, 86798,
    86796, 86795, 86793, 86791, 86789, 86788, 86786, 86784, 86782, 86781, 86779, 86777, 86775, 86774,
    86772, 86770, 86768, 86767, 86765, 86763, 86761, 86760, 86758, 86756, 86754, 86752, 86751, 86749,
    86747, 86745, 86744, 86742, 86740, 86738, 86737, 86735, 86733, 86731, 86730, 86728, 86726, 86724,
    86723, 86721, 86719, 86717, 86716, 86714, 86712, 86710, 86709, 86707, 86705, 86703, 86702, 86700,
    86698, 86696, 86695, 86693, 86691, 86689, 86688, 86686, 86684, 86682, 86681, 86679, 86677, 86675,
    86674, 86672, 86670, 86668, 86667, 86665, 86663, 86661, 86660, 86658, 86656, 86654, 86653, 86651,
    86649, 86647, 86646, 86644, 86642, 86640, 86639, 86637, 86635, 86634, 86632, 86630, 86628, 86627,
    86625, 86623, 86621, 86620, 86618, 86616, 86614, 86613, 86611, 86609, 86607, 86606, 86604, 86602,
    86600, 86599, 86597, 86595, 86593, 86592, 86590, 86588, 86586, 86585, 86583, 86581, 86579, 86578,
    86576, 86574, 86572, 86571, 86569, 86567, 86565, 86564, 86562, 86560, 86558, 86557, 86555, 86553,
    86551, 86550, 86548, 86546, 86544, 86543, 86541, 86539, 86538, 86536, 86534, 86532, 86531, 86529,
    86527, 86525, 86524, 86522, 86520, 86518, 86517, 86515, 86513, 86511, 86510, 86508, 86506, 86504,
    86503, 86501, 86499, 86497, 86496, 86494, 86492, 86490, 86489, 86487, 86485, 86483, 86482, 86480,
    86478, 86477, 86475, 86473, 86471, 86470, 86468, 86466, 86464, 86463, 86461, 86459, 86457, 86456,
    86454, 86452, 86450, 86449, 86447, 86445, 86443, 86442, 86440, 86438, 86436, 86435, 86433, 86431,
    86430, 86428, 86426, 86424, 86423, 86421, 86419, 86417, 86416, 86414, 86412, 86410, 86409, 86407,
    86405, 86403, 86402, 86400, 86398, 86396, 86395, 86393, 86391, 86390, 86388, 86386, 86384, 86383,
    86381, 86379, 86377, 86376, 86374, 86372, 86370, 86369, 86367, 86365, 86363, 86362, 86360, 86358,
    86357, 86355, 86353, 86351, 86350, 86348, 86346, 86344, 86343, 86341, 86339, 86337, 86336, 86334,
    86332, 86331, 86329, 86327, 86325, 86324, 86322, 86320, 86318, 86317, 86315, 86313, 86311, 86310,
    86308, 86306, 86304, 86303, 86301, 86299, 86298, 86296, 86294, 86292, 86291, 86289, 86287, 86285,
    86284, 86282, 86280, 86278, 86277, 86275, 86273, 86272, 86270, 86268, 86266, 86265, 86263, 86261,
    86259, 86258, 86256, 86254, 86252, 86251, 86249, 86247, 86246, 86244, 86242, 86240, 86239, 86237,
    86235, 86233, 86232, 86230, 86228, 86227, 86225, 86223, 86221, 86220, 86218, 86216, 86214, 86213,
    86211, 86209, 86207, 86206, 86204, 86202, 86201, 86199, 86197, 86195, 86194, 86192, 86190, 86188,
    86187, 86185, 86183, 86182, 86180, 86178, 86176, 86175, 86173, 86171, 86169, 86168, 86166, 86164,
    86163, 86161, 86159, 86157, 86156, 86154, 86152, 86150, 86149, 86147, 86145, 86143, 86142, 86140,
    86138, 86137, 86135, 86133, 86131, 86130, 86128, 86126, 86124, 86123, 86121, 86119, 86118, 86116,
    86114, 86112, 86111, 86109, 86107, 86106, 86104, 86102, 86100, 86099, 86097, 86095, 86093, 86092,
    86090, 86088, 86087, 86085, 86083, 86081, 86080, 86078, 86076, 86074, 86073, 86071, 86069, 86068,
    86066, 86064, 86062, 86061, 86059, 86057, 86055, 86054, 86052, 86050, 86049, 86047, 86045, 86043,
    86042, 86040, 86038, 86037, 86035, 86033, 86031, 86030, 86028, 86026, 86024, 86023, 86021, 86019,
    86018, 86016, 86014, 86012, 86011, 86009, 86007, 86005, 86004, 86002, 86000, 85999, 85997, 85995,
    85993, 85992, 85990, 85988, 85987, 85985, 85983, 85981, 85980, 85978, 85976, 85975, 85973, 85971,
    85969, 85968, 85966, 85964, 85962, 85961, 85959, 85957, 85956, 85954, 85952, 85950, 85949, 85947,
    85945, 85944, 85942, 85940, 85938, 85937, 85935, 85933, 85932, 85930, 85928, 85926, 85925, 85923,
    85921, 85919, 85918, 85916, 85914, 85913, 85911, 85909, 85907, 85906, 85904, 85902, 85901, 85899,
    85897, 85895, 85894, 85892, 85890, 85889, 85887, 85885, 85883, 85882, 85880, 85878, 85877, 85875,
    85873, 85871, 85870, 85868, 85866, 85865, 85863, 85861, 85859, 85858, 85856, 85854, 85852, 85851,
    85849, 85847, 85846, 85844, 85842, 85840, 85839, 85837, 85835, 85834, 85832, 85830, 85828, 85827,
    85825, 85823, 85822, 85820, 85818, 85816, 85815, 85813, 85811, 85810, 85808, 85806, 85804, 85803,
    85801, 85799, 85798, 85796, 85794, 85792, 85791, 85789, 85787, 85786, 85784, 85782, 85780, 85779,
    85777, 85775, 85774, 85772, 85770, 85768, 85767, 85765, 85763, 85762, 85760, 85758, 85756, 85755,
    85753, 85751, 85750, 85748, 85746, 85745, 85743, 85741, 85739, 85738, 85736, 85734, 85733, 85731,
    85729, 85727, 85726, 85724, 85722, 85721, 85719, 85717, 85715, 85714, 85712, 85710, 85709, 85707,
    85705, 85703, 85702, 85700, 85698, 85697, 85695, 85693, 85691, 85690, 85688, 85686, 85685, 85683,
    85681, 85680, 85678, 85676, 85674, 85673, 85671, 85669, 85668, 85666, 85664, 85662, 85661, 85659,
    85657, 85656, 85654, 85652, 85650, 85649, 85647, 85645, 85644, 85642, 85640, 85639, 85637, 85635,
    85633, 85632, 85630, 85628, 85627, 85625, 85623, 85621, 85620, 85618, 85616, 85615, 85613, 85611,
    85609, 85608, 85606, 85604, 85603, 85601, 85599, 85598, 85596, 85594, 85592, 85591, 85589, 85587,
    85586, 85584, 85582, 85580, 85579, 85577, 85575, 85574, 85572, 85570, 85569, 85567, 85565, 85563,
    85562, 85560, 85558, 85557, 85555, 85553, 85552, 85550, 85548, 85546, 85545, 85543, 85541, 85540,
    85538, 85536, 85534, 85533, 85531, 85529, 85528, 85526, 85524, 85523, 85521, 85519, 85517, 85516,
    85514, 85512, 85511, 85509, 85507, 85506, 85504, 85502, 85500, 85499, 85497, 85495, 85494, 85492,
    85490, 85489, 85487, 85485, 85483, 85482, 85480, 85478, 85477, 85475, 85473, 85471, 85470, 85468,
    85466, 85465, 85463, 85461, 85460, 85458, 85456, 85454, 85453, 85451, 85449, 85448, 85446, 85444,
    85443, 85441, 85439, 85437, 85436, 85434, 85432, 85431, 85429, 85427, 85426, 85424, 85422, 85420,
    85419, 85417, 85415, 85414, 85412, 85410, 85409, 85407, 85405, 85404, 85402, 85400, 85398, 85397,
    85395, 85393, 85392, 85390, 85388, 85387, 85385, 85383, 85381, 85380, 85378, 85376, 85375, 85373,
    85371, 85370, 85368, 85366, 85364, 85363, 85361, 85359, 85358, 85356, 85354, 85353, 85351, 85349,
    85348, 85346, 85344, 85342, 85341, 85339, 85337, 85336, 85334, 85332, 85331, 85329, 85327, 85325,
    85324, 85322, 85320, 85319, 85317, 85315, 85314, 85312, 85310, 85309, 85307, 85305, 85303, 85302,
    85300, 85298, 85297, 85295, 85293, 85292, 85290, 85288, 85286, 85285, 85283, 85281, 85280, 85278,
    85276, 85275, 85273, 85271, 85270, 85268, 85266, 85264, 85263, 85261, 85259, 85258, 85256, 85254,
    85253, 85251, 85249, 85248, 85246, 85244, 85242, 85241, 85239, 85237, 85236, 85234, 85232, 85231,
    85229, 85227, 85226, 85224, 85222, 85220, 85219, 85217, 85215, 85214, 85212, 85210, 85209, 85207,
    85205, 85204, 85202, 85200, 85199, 85197, 85195, 85193, 85192, 85190, 85188, 85187, 85185, 85183,
    85182, 85180, 85178, 85177, 85175, 85173, 85171, 85170, 85168, 85166, 85165, 85163, 85161, 85160,
    85158, 85156, 85155, 85153, 85151, 85150, 85148, 85146, 85144, 85143, 85141, 85139, 85138, 85136,
    85134, 85133, 85131, 85129, 85128, 85126, 85124, 85123, 85121, 85119, 85117, 85116, 85114, 85112,
    85111, 85109, 85107, 85106, 85104, 85102, 85101, 85099, 85097, 85096, 85094, 85092, 85090, 85089,
    85087, 85085, 85084, 85082, 85080, 85079, 85077, 85075, 85074, 85072, 85070, 85069, 85067, 85065,
    85064, 85062, 85060, 85058, 85057, 85055, 85053, 85052, 85050, 85048, 85047, 85045, 85043, 85042,
    85040, 85038, 85037, 85035, 85033, 85032, 85030, 85028, 85026, 85025, 85023, 85021, 85020, 85018,
    85016, 85015, 85013, 85011, 85010, 85008, 85006, 85005, 85003, 85001, 85000, 84998, 84996, 84995,
    84993, 84991, 84989, 84988, 84986, 84984, 84983, 84981, 84979, 84978, 84976, 84974, 84973, 84971,
    84969, 84968, 84966, 84964, 84963, 84961, 84959, 84958, 84956, 84954, 84952, 84951, 84949, 84947,
    84946, 84944, 84942, 84941, 84939, 84937, 84936, 84934, 84932, 84931, 84929, 84927, 84926, 84924,
    84922, 84921, 84919, 84917, 84916, 84914, 84912, 84910, 84909, 84907, 84905, 84904, 84902, 84900,
    84899, 84897, 84895, 84894, 84892, 84890, 84889, 84887, 84885, 84884, 84882, 84880, 84879, 84877,
    84875, 84874, 84872, 84870, 84869, 84867, 84865, 84864, 84862, 84860, 84858, 84857, 84855, 84853,
    84852, 84850, 84848, 84847, 84845, 84843, 84842, 84840, 84838, 84837, 84835, 84833, 84832, 84830,
    84828, 84827, 84825, 84823, 84822, 84820, 84818, 84817, 84815, 84813, 84812, 84810, 84808, 84807,
    84805, 84803, 84802, 84800, 84798, 84796, 84795, 84793, 84791, 84790, 84788, 84786, 84785, 84783,
    84781, 84780, 84778, 84776, 84775, 84773, 84771, 84770, 84768, 84766, 84765, 84763, 84761, 84760,
    84758, 84756, 84755, 84753, 84751, 84750, 84748, 84746, 84745, 84743, 84741, 84740, 84738, 84736,
    84735, 84733, 84731, 84730, 84728, 84726, 84725, 84723, 84721, 84720, 84718, 84716, 84715, 84713,
    84711, 84710, 84708, 84706, 84705, 84703, 84701, 84699, 84698, 84696, 84694, 84693, 84691, 84689,
    84688, 84686, 84684, 84683, 84681, 84679, 84678, 84676, 84674, 84673, 84671, 84669, 84668, 84666,
    84664, 84663, 84661, 84659, 84658, 84656, 84654, 84653, 84651, 84649, 84648, 84646, 84644, 84643,
    84641, 84639, 84638, 84636, 84634, 84633, 84631, 84629, 84628, 84626, 84624, 84623, 84621, 84619,
    84618, 84616, 84614, 84613, 84611, 84609, 84608, 84606, 84604, 84603, 84601, 84599, 84598, 84596,
    84594, 84593, 84591, 84589, 84588, 84586, 84584, 84583, 84581, 84579, 84578, 84576, 84574, 84573,
    84571, 84569, 84568, 84566, 84564, 84563, 84561, 84559, 84558, 84556, 84554, 84553, 84551, 84549,
    84548, 84546, 84544, 84543, 84541, 84539, 84538, 84536, 84534, 84533, 84531, 84529, 84528, 84526,
    84524, 84523, 84521, 84519, 84518, 84516, 84514, 84513, 84511, 84510, 84508, 84506, 84505, 84503,
    84501, 84500, 84498, 84496, 84495, 84493, 84491, 84490, 84488, 84486, 84485, 84483, 84481, 84480,
    84478, 84476, 84475, 84473, 84471, 84470, 84468, 84466, 84465, 84463, 84461, 84460, 84458, 84456,
    84455, 84453, 84451, 84450, 84448, 84446, 84445, 84443, 84441, 84440, 84438, 84436, 84435, 84433,
    84431, 84430, 84428, 84426, 84425, 84423, 84421, 84420, 84418, 84416, 84415, 84413, 84412, 84410,
    84408, 84407, 84405, 84403, 84402, 84400, 84398, 84397, 84395, 84393, 84392, 84390, 84388, 84387,
    84385, 84383, 84382, 84380, 84378, 84377, 84375, 84373, 84372, 84370, 84368, 84367, 84365, 84363,
    84362, 84360, 84358, 84357, 84355, 84353, 84352, 84350, 84349, 84347, 84345, 84344, 84342, 84340,
    84339, 84337, 84335, 84334, 84332, 84330, 84329, 84327, 84325, 84324, 84322, 84320, 84319, 84317,
    84315, 84314, 84312, 84310, 84309, 84307, 84305, 84304, 84302, 84301, 84299, 84297, 84296, 84294,
    84292, 84291, 84289, 84287, 84286, 84284, 84282, 84281, 84279, 84277, 84276, 84274, 84272, 84271,
    84269, 84267, 84266, 84264, 84262, 84261, 84259, 84258, 84256, 84254, 84253, 84251, 84249, 84248,
    84246, 84244, 84243, 84241, 84239, 84238, 84236, 84234, 84233, 84231, 84229, 84228, 84226, 84224,
    84223, 84221, 84220, 84218, 84216, 84215, 84213, 84211, 84210, 84208, 84206, 84205, 84203, 84201,
    84200, 84198, 84196, 84195, 84193, 84191, 84190, 84188, 84186, 84185, 84183, 84182, 84180, 84178,
    84177, 84175, 84173, 84172, 84170, 84168, 84167, 84165, 84163, 84162, 84160, 84158, 84157, 84155,
    84153, 84152, 84150, 84149, 84147, 84145, 84144, 84142, 84140, 84139, 84137, 84135, 84134, 84132,
    84130, 84129, 84127, 84125, 84124, 84122, 84121, 84119, 84117, 84116, 84114, 84112, 84111, 84109,
    84107, 84106, 84104, 84102, 84101, 84099, 84097, 84096, 84094, 84093, 84091, 84089, 84088, 84086,
    84084, 84083, 84081, 84079, 84078, 84076, 84074, 84073, 84071, 84069, 84068, 84066, 84065, 84063,
    84061, 84060, 84058, 84056, 84055, 84053, 84051, 84050, 84048, 84046, 84045, 84043, 84042, 84040,
    84038, 84037, 84035, 84033, 84032, 84030, 84028, 84027, 84025, 84023, 84022, 84020, 84019, 84017,
    84015, 84014, 84012, 84010, 84009, 84007, 84005, 84004, 84002, 84000, 83999, 83997, 83996, 83994,
    83992, 83991, 83989, 83987, 83986, 83984, 83982, 83981, 83979, 83977, 83976, 83974, 83973, 83971,
    83969, 83968, 83966, 83964, 83963, 83961, 83959, 83958, 83956, 83954, 83953, 83951, 83950, 83948,
    83946, 83945, 83943, 83941, 83940, 83938, 83936, 83935, 83933, 83931, 83930, 83928, 83927, 83925,
    83923, 83922, 83920, 83918, 83917, 83915, 83913, 83912, 83910, 83909, 83907, 83905, 83904, 83902,
    83900, 83899, 83897, 83895, 83894, 83892, 83890, 83889, 83887, 83886, 83884, 83882, 83881, 83879,
    83877, 83876, 83874, 83872, 83871, 83869, 83868, 83866, 83864, 83863, 83861, 83859, 83858, 83856,
    83854, 83853, 83851, 83850, 83848, 83846, 83845, 83843, 83841, 83840, 83838, 83836, 83835, 83833,
    83832, 83830, 83828, 83827, 83825, 83823, 83822, 83820, 83818, 83817, 83815, 83814, 83812, 83810,
    83809, 83807, 83805, 83804, 83802, 83800, 83799, 83797, 83796, 83794, 83792, 83791, 83789, 83787,
    83786, 83784, 83782, 83781, 83779, 83778, 83776, 83774, 83773, 83771, 83769, 83768, 83766, 83765,
    83763, 83761, 83760, 83758, 83756, 83755, 83753, 83751, 83750, 83748, 83747, 83745, 83743, 83742,
    83740, 83738, 83737, 83735, 83733, 83732, 83730, 83729, 83727, 83725, 83724, 83722, 83720, 83719,
    83717, 83716, 83714, 83712, 83711, 83709, 83707, 83706, 83704, 83702, 83701, 83699, 83698, 83696,
    83694, 83693, 83691, 83689, 83688, 83686, 83685, 83683, 83681, 83680, 83678, 83676, 83675, 83673,
    83672, 83670, 83668, 83667, 83665, 83663, 83662, 83660, 83658, 83657, 83655, 83654, 83652, 83650,
    83649, 83647, 83645, 83644, 83642, 83641, 83639, 83637, 83636, 83634, 83632, 83631, 83629, 83628,
    83626, 83624, 83623, 83621, 83619, 83618, 83616, 83614, 83613, 83611, 83610, 83608, 83606, 83605,
    83603, 83601, 83600, 83598, 83597, 83595, 83593, 83592, 83590, 83588, 83587, 83585, 83584, 83582,
    83580, 83579, 83577, 83575, 83574, 83572, 83571, 83569, 83567, 83566, 83564, 83562, 83561, 83559,
    83558, 83556, 83554, 83553, 83551, 83549, 83548, 83546, 83545, 83543, 83541, 83540, 83538, 83536,
    83535, 83533, 83532, 83530, 83528, 83527, 83525, 83523, 83522, 83520, 83519, 83517, 83515, 83514,
    83512, 83510, 83509, 83507, 83506, 83504, 83502, 83501, 83499, 83497, 83496, 83494, 83493, 83491,
    83489, 83488, 83486, 83484, 83483, 83481, 83480, 83478, 83476, 83475, 83473, 83471, 83470, 83468,
    83467, 83465, 83463, 83462, 83460, 83459, 83457, 83455, 83454, 83452, 83450, 83449, 83447, 83446,
    83444, 83442, 83441, 83439, 83437, 83436, 83434, 83433, 83431, 83429, 83428, 83426, 83424, 83423,
    83421, 83420, 83418, 83416, 83415, 83413, 83412, 83410, 83408, 83407, 83405, 83403, 83402, 83400,
    83399, 83397, 83395, 83394, 83392, 83390, 83389, 83387, 83386, 83384, 83382, 83381, 83379, 83377,
    83376, 83374, 83373, 83371, 83369, 83368, 83366, 83365, 83363, 83361, 83360, 83358, 83356, 83355,
    83353, 83352, 83350, 83348, 83347, 83345, 83344, 83342, 83340, 83339, 83337, 83335, 83334, 83332,
    83331, 83329, 83327, 83326, 83324, 83323, 83321, 83319, 83318, 83316, 83314, 83313, 83311, 83310,
    83308, 83306, 83305, 83303, 83301, 83300, 83298, 83297, 83295, 83293, 83292, 83290, 83289, 83287,
    83285, 83284, 83282, 83280, 83279, 83277, 83276, 83274, 83272, 83271, 83269, 83268, 83266, 83264,
    83263, 83261, 83260, 83258, 83256, 83255, 83253, 83251, 83250, 83248, 83247, 83245, 83243, 83242,
    83240, 83239, 83237, 83235, 83234, 83232, 83230, 83229, 83227, 83226, 83224, 83222, 83221, 83219,
    83218, 83216, 83214, 83213, 83211, 83210, 83208, 83206, 83205, 83203, 83201, 83200, 83198, 83197,
    83195, 83193, 83192, 83190, 83189, 83187, 83185, 83184, 83182, 83180, 83179, 83177, 83176, 83174,
    83172, 83171, 83169, 83168, 83166, 83164, 83163, 83161, 83160, 83158, 83156, 83155, 83153, 83152,
    83150, 83148, 83147, 83145, 83143, 83142, 83140, 83139, 83137, 83135, 83134, 83132, 83131, 83129,
    83127, 83126, 83124, 83123, 83121, 83119, 83118, 83116, 83114, 83113, 83111, 83110, 83108, 83106,
    83105, 83103, 83102, 83100, 83098, 83097, 83095, 83094, 83092, 83090, 83089, 83087, 83086, 83084,
    83082, 83081, 83079, 83078, 83076, 83074, 83073, 83071, 83069, 83068, 83066, 83065, 83063, 83061,
    83060, 83058, 83057, 83055, 83053, 83052, 83050, 83049, 83047, 83045, 83044, 83042, 83041, 83039,
    83037, 83036, 83034, 83033, 83031, 83029, 83028, 83026, 83025, 83023, 83021, 83020, 83018, 83016,
    83015, 83013, 83012, 83010, 83008, 83007, 83005, 83004, 83002, 83000, 82999, 82997, 82996, 82994,
    82992, 82991, 82989, 82988, 82986, 82984, 82983, 82981, 82980, 82978, 82976, 82975, 82973, 82972,
    82970, 82968, 82967, 82965, 82964, 82962, 82960, 82959, 82957, 82956, 82954, 82952, 82951, 82949,
    82948, 82946, 82944, 82943, 82941, 82940, 82938, 82936, 82935, 82933, 82932, 82930, 82928, 82927,
    82925, 82924, 82922, 82920, 82919, 82917, 82916, 82914, 82912, 82911, 82909, 82908, 82906, 82904,
    82903, 82901, 82900, 82898, 82896, 82895, 82893, 82892, 82890, 82888, 82887, 82885, 82884, 82882,
    82880, 82879, 82877, 82876, 82874, 82872, 82871, 82869, 82868, 82866, 82864, 82863, 82861, 82860,
    82858, 82856, 82855, 82853, 82852, 82850, 82848, 82847, 82845, 82844, 82842, 82840, 82839, 82837,
    82836, 82834, 82832, 82831, 82829, 82828, 82826, 82824, 82823, 82821, 82820, 82818, 82816, 82815,
    82813, 82812, 82810, 82808, 82807, 82805, 82804, 82802, 82800, 82799, 82797, 82796, 82794, 82792,
    82791, 82789, 82788, 82786, 82784, 82783, 82781, 82780, 82778, 82777, 82775, 82773, 82772, 82770,
    82769, 82767, 82765, 82764, 82762, 82761, 82759, 82757, 82756, 82754, 82753, 82751, 82749, 82748,
    82746, 82745, 82743, 82741, 82740, 82738, 82737, 82735, 82733, 82732, 82730, 82729, 82727, 82725,
    82724, 82722, 82721, 82719, 82718, 82716, 82714, 82713, 82711, 82710, 82708, 82706, 82705, 82703,
    82702, 82700, 82698, 82697, 82695, 82694, 82692, 82690, 82689, 82687, 82686, 82684, 82682, 82681,
    82679, 82678, 82676, 82675, 82673, 82671, 82670, 82668, 82667, 82665, 82663, 82662, 82660, 82659,
    82657, 82655, 82654, 82652, 82651, 82649, 82647, 82646, 82644, 82643, 82641, 82640, 82638, 82636,
    82635, 82633, 82632, 82630, 82628, 82627, 82625, 82624, 82622, 82620, 82619, 82617, 82616, 82614,
    82613, 82611, 82609, 82608, 82606, 82605, 82603, 82601, 82600, 82598, 82597, 82595, 82593, 82592,
    82590, 82589, 82587, 82585, 82584, 82582, 82581, 82579, 82578, 82576, 82574, 82573, 82571, 82570,
    82568, 82566, 82565, 82563, 82562, 82560, 82559, 82557, 82555, 82554, 82552, 82551, 82549, 82547,
    82546, 82544, 82543, 82541, 82539, 82538, 82536, 82535, 82533, 82532, 82530, 82528, 82527, 82525,
    82524, 82522, 82520, 82519, 82517, 82516, 82514, 82513, 82511, 82509, 82508, 82506, 82505, 82503,
    82501, 82500, 82498, 82497, 82495, 82493, 82492, 82490, 82489, 82487, 82486, 82484, 82482, 82481,
    82479, 82478, 82476, 82474, 82473, 82471, 82470, 82468, 82467, 82465, 82463, 82462, 82460, 82459,
    82457, 82455, 82454, 82452, 82451, 82449, 82448, 82446, 82444, 82443, 82441, 82440, 82438, 82436,
    82435, 82433, 82432, 82430, 82429, 82427, 82425, 82424, 82422, 82421, 82419, 82418, 82416, 82414,
    82413, 82411, 82410, 82408, 82406, 82405, 82403, 82402, 82400, 82399, 82397, 82395, 82394, 82392,
    82391, 82389, 82387, 82386, 82384, 82383, 82381, 82380, 82378, 82376, 82375, 82373, 82372, 82370,
    82369, 82367, 82365, 82364, 82362, 82361, 82359, 82357, 82356, 82354, 82353, 82351, 82350, 82348,
    82346, 82345, 82343, 82342, 82340, 82339, 82337, 82335, 82334, 82332, 82331, 82329, 82327, 82326,
    82324, 82323, 82321, 82320, 82318, 82316, 82315, 82313, 82312, 82310, 82309, 82307, 82305, 82304,
    82302, 82301, 82299, 82297, 82296, 82294, 82293, 82291, 82290, 82288, 82286, 82285, 82283, 82282,
    82280, 82279, 82277, 82275, 82274, 82272, 82271, 82269, 82268, 82266, 82264, 82263, 82261, 82260,
    82258, 82257, 82255, 82253, 82252, 82250, 82249, 82247, 82245, 82244, 82242, 82241, 82239, 82238,
    82236, 82234, 82233, 82231, 82230, 82228, 82227, 82225, 82223, 82222, 82220, 82219, 82217, 82216,
    82214, 82212, 82211, 82209, 82208, 82206, 82205, 82203, 82201, 82200, 82198, 82197, 82195, 82194,
    82192, 82190, 82189, 82187, 82186, 82184, 82183, 82181, 82179, 82178, 82176, 82175, 82173, 82172,
    82170, 82168, 82167, 82165, 82164, 82162, 82161, 82159, 82157, 82156, 82154, 82153, 82151, 82150,
    82148, 82146, 82145, 82143, 82142, 82140, 82139, 82137, 82135, 82134, 82132, 82131, 82129, 82128,
    82126, 82124, 82123, 82121, 82120, 82118, 82117, 82115, 82113, 82112, 82110, 82109, 82107, 82106,
    82104, 82102, 82101, 82099, 82098, 82096, 82095, 82093, 82091, 82090, 82088, 82087, 82085, 82084,
    82082, 82080, 82079, 82077, 82076, 82074, 82073, 82071, 82069, 82068, 82066, 82065, 82063, 82062,
    82060, 82058, 82057, 82055, 82054, 82052, 82051, 82049, 82048, 82046, 82044, 82043, 82041, 82040,
    82038, 82037, 82035, 82033, 82032, 82030, 82029, 82027, 82026, 82024, 82022, 82021, 82019, 82018,
    82016, 82015, 82013, 82011, 82010, 82008, 82007, 82005, 82004, 82002, 82001, 81999, 81997, 81996,
    81994, 81993, 81991, 81990, 81988, 81986, 81985, 81983, 81982, 81980, 81979, 81977, 81975, 81974,
    81972, 81971, 81969, 81968, 81966, 81965, 81963, 81961, 81960, 81958, 81957, 81955, 81954, 81952,
    81950, 81949, 81947, 81946, 81944, 81943, 81941, 81940, 81938, 81936, 81935, 81933, 81932, 81930,
    81929, 81927, 81925, 81924, 81922, 81921, 81919, 81918, 81916, 81915, 81913, 81911, 81910, 81908,
    81907, 81905, 81904, 81902, 81900, 81899, 81897, 81896, 81894, 81893, 81891, 81890, 81888, 81886,
    81885, 81883, 81882, 81880, 81879, 81877, 81875, 81874, 81872, 81871, 81869, 81868, 81866, 81865,
    81863, 81861, 81860, 81858, 81857, 81855, 81854, 81852, 81850, 81849, 81847, 81846, 81844, 81843,
    81841, 81840, 81838, 81836, 81835, 81833, 81832, 81830, 81829, 81827, 81826, 81824, 81822, 81821,
    81819, 81818, 81816, 81815, 81813, 81812, 81810, 81808, 81807, 81805, 81804, 81802, 81801, 81799,
    81797, 81796, 81794, 81793, 81791, 81790, 81788, 81787, 81785, 81783, 81782, 81780, 81779, 81777,
    81776, 81774, 81773, 81771, 81769, 81768, 81766, 81765, 81763, 81762, 81760, 81759, 81757, 81755,
    81754, 81752, 81751, 81749, 81748, 81746, 81745, 81743, 81741, 81740, 81738, 81737, 81735, 81734,
    81732, 81731, 81729, 81727, 81726, 81724, 81723, 81721, 81720, 81718, 81717, 81715, 81713, 81712,
    81710, 81709, 81707, 81706, 81704, 81703, 81701, 81699, 81698, 81696, 81695, 81693, 81692, 81690,
    81689, 81687, 81685, 81684, 81682, 81681, 81679, 81678, 81676, 81675, 81673, 81672, 81670, 81668,
    81667, 81665, 81664, 81662, 81661, 81659, 81658, 81656, 81654, 81653, 81651, 81650, 81648, 81647,
    81645, 81644, 81642, 81640, 81639, 81637, 81636, 81634, 81633, 81631, 81630, 81628, 81626, 81625,
    81623, 81622, 81620, 81619, 81617, 81616, 81614, 81613, 81611, 81609, 81608, 81606, 81605, 81603,
    81602, 81600, 81599, 81597, 81595, 81594, 81592, 81591, 81589, 81588, 81586, 81585, 81583, 81582,
    81580, 81578, 81577, 81575, 81574, 81572, 81571, 81569, 81568, 81566, 81564, 81563, 81561, 81560,
    81558, 81557, 81555, 81554, 81552, 81551, 81549, 81547, 81546, 81544, 81543, 81541, 81540, 81538,
    81537, 81535, 81534, 81532, 81530, 81529, 81527, 81526, 81524, 81523, 81521, 81520, 81518, 81516,
    81515, 81513, 81512, 81510, 81509, 81507, 81506, 81504, 81503, 81501, 81499, 81498, 81496, 81495,
    81493, 81492, 81490, 81489, 81487, 81486, 81484, 81482, 81481, 81479, 81478, 81476, 81475, 81473,
    81472, 81470, 81469, 81467, 81465, 81464, 81462, 81461, 81459, 81458, 81456, 81455, 81453, 81452,
    81450, 81448, 81447, 81445, 81444, 81442, 81441, 81439, 81438, 81436, 81435, 81433, 81431, 81430,
    81428, 81427, 81425, 81424, 81422, 81421, 81419, 81418, 81416, 81415, 81413, 81411, 81410, 81408,
    81407, 81405, 81404, 81402, 81401, 81399, 81398, 81396, 81394, 81393, 81391, 81390, 81388, 81387,
    81385, 81384, 81382, 81381, 81379, 81377, 81376, 81374, 81373, 81371, 81370, 81368, 81367, 81365,
    81364, 81362, 81361, 81359, 81357, 81356, 81354, 81353, 81351, 81350, 81348, 81347, 81345, 81344,
    81342, 81341, 81339, 81337, 81336, 81334, 81333, 81331, 81330, 81328, 81327, 81325, 81324, 81322,
    81320, 81319, 81317, 81316, 81314, 81313, 81311, 81310, 81308, 81307, 81305, 81304, 81302, 81300,
    81299, 81297, 81296, 81294, 81293, 81291, 81290, 81288, 81287, 81285, 81284, 81282, 81280, 81279,
    81277, 81276, 81274, 81273, 81271, 81270, 81268, 81267, 81265, 81264, 81262, 81260, 81259, 81257,
    81256, 81254, 81253, 81251, 81250, 81248, 81247, 81245, 81244, 81242, 81240, 81239, 81237, 81236,
    81234, 81233, 81231, 81230, 81228, 81227, 81225, 81224, 81222, 81221, 81219, 81217, 81216, 81214,
    81213, 81211, 81210, 81208, 81207, 81205, 81204, 81202, 81201, 81199, 81197, 81196, 81194, 81193,
    81191, 81190, 81188, 81187, 81185, 81184, 81182, 81181, 81179, 81178, 81176, 81174, 81173, 81171,
    81170, 81168, 81167, 81165, 81164, 81162, 81161, 81159, 81158, 81156, 81155, 81153, 81151, 81150,
    81148, 81147, 81145, 81144, 81142, 81141, 81139, 81138, 81136, 81135, 81133, 81132, 81130, 81128,
    81127, 81125, 81124, 81122, 81121, 81119, 81118, 81116, 81115, 81113, 81112, 81110, 81109, 81107,
    81105, 81104, 81102, 81101, 81099, 81098, 81096, 81095, 81093, 81092, 81090, 81089, 81087, 81086,
    81084, 81083, 81081, 81079, 81078, 81076, 81075, 81073, 81072, 81070, 81069, 81067, 81066, 81064,
    81063, 81061, 81060, 81058, 81057, 81055, 81053, 81052, 81050, 81049, 81047, 81046, 81044, 81043,
    81041, 81040, 81038, 81037, 81035, 81034, 81032, 81031, 81029, 81027, 81026, 81024, 81023, 81021,
    81020, 81018, 81017, 81015, 81014, 81012, 81011, 81009, 81008, 81006, 81005, 81003, 81001, 81000,
    80998, 80997, 80995, 80994, 80992, 80991, 80989, 80988, 80986, 80985, 80983, 80982, 80980, 80979,
    80977, 80976, 80974, 80972, 80971, 80969, 80968, 80966, 80965, 80963, 80962, 80960, 80959, 80957,
    80956, 80954, 80953, 80951, 80950, 80948, 80947, 80945, 80943, 80942, 80940, 80939, 80937, 80936,
    80934, 80933, 80931, 80930, 80928, 80927, 80925, 80924, 80922, 80921, 80919, 80918, 80916, 80914,
    80913, 80911, 80910, 80908, 80907, 80905, 80904, 80902, 80901, 80899, 80898, 80896, 80895, 80893,
    80892, 80890, 80889, 80887, 80886, 80884, 80882, 80881, 80879, 80878, 80876, 80875, 80873, 80872,
    80870, 80869, 80867, 80866, 80864, 80863, 80861, 80860, 80858, 80857, 80855, 80854, 80852, 80851,
    80849, 80847, 80846, 80844, 80843, 80841, 80840, 80838, 80837, 80835, 80834, 80832, 80831, 80829,
    80828, 80826, 80825, 80823, 80822, 80820, 80819, 80817, 80816, 80814, 80812, 80811, 80809, 80808,
    80806, 80805, 80803, 80802, 80800, 80799, 80797, 80796, 80794, 80793, 80791, 80790, 80788, 80787,
    80785, 80784, 80782, 80781, 80779, 80778, 80776, 80774, 80773, 80771, 80770, 80768, 80767, 80765,
    80764, 80762, 80761, 80759, 80758, 80756, 80755, 80753, 80752, 80750, 80749, 80747, 80746, 80744,
    80743, 80741, 80740, 80738, 80737, 80735, 80733, 80732, 80730, 80729, 80727, 80726, 80724, 80723,
    80721, 80720, 80718, 80717, 80715, 80714, 80712, 80711, 80709, 80708, 80706, 80705, 80703, 80702,
    80700, 80699, 80697, 80696, 80694, 80693, 80691, 80690, 80688, 80686, 80685, 80683, 80682, 80680,
    80679, 80677, 80676, 80674, 80673, 80671, 80670, 80668, 80667, 80665, 80664, 80662, 80661, 80659,
    80658, 80656, 80655, 80653, 80652, 80650, 80649, 80647, 80646, 80644, 80643, 80641, 80640, 80638,
    80636, 80635, 80633, 80632, 80630, 80629, 80627, 80626, 80624, 80623, 80621, 80620, 80618, 80617,
    80615, 80614, 80612, 80611, 80609, 80608, 80606, 80605, 80603, 80602, 80600, 80599, 80597, 80596,
    80594, 80593, 80591, 80590, 80588, 80587, 80585, 80584, 80582, 80581, 80579, 80577, 80576, 80574,
    80573, 80571, 80570, 80568, 80567, 80565, 80564, 80562, 80561, 80559, 80558, 80556, 80555, 80553,
    80552, 80550, 80549, 80547, 80546, 80544, 80543, 80541, 80540, 80538, 80537, 80535, 80534, 80532,
    80531, 80529, 80528, 80526, 80525, 80523, 80522, 80520, 80519, 80517, 80516, 80514, 80513, 80511,
    80510, 80508, 80506, 80505, 80503, 80502, 80500, 80499, 80497, 80496, 80494, 80493, 80491, 80490,
    80488, 80487, 80485, 80484, 80482, 80481, 80479, 80478, 80476, 80475, 80473, 80472, 80470, 80469,
    80467, 80466, 80464, 80463, 80461, 80460, 80458, 80457, 80455, 80454, 80452, 80451, 80449, 80448,
    80446, 80445, 80443, 80442, 80440, 80439, 80437, 80436, 80434, 80433, 80431, 80430, 80428, 80427,
    80425, 80424, 80422, 80421, 80419, 80418, 80416, 80415, 80413, 80412, 80410, 80409, 80407, 80406,
    80404, 80403, 80401, 80399, 80398, 80396, 80395, 80393, 80392, 80390, 80389, 80387, 80386, 80384,
    80383, 80381, 80380, 80378, 80377, 80375, 80374, 80372, 80371, 80369, 80368, 80366, 80365, 80363,
    80362, 80360, 80359, 80357, 80356, 80354, 80353, 80351, 80350, 80348, 80347, 80345, 80344, 80342,
    80341, 80339, 80338, 80336, 80335, 80333, 80332, 80330, 80329, 80327, 80326, 80324, 80323, 80321,
    80320, 80318, 80317, 80315, 80314, 80312, 80311, 80309, 80308, 80306, 80305, 80303, 80302, 80300,
    80299, 80297, 80296, 80294, 80293, 80291, 80290, 80288, 80287, 80285, 80284, 80282, 80281, 80279,
    80278, 80276, 80275, 80273, 80272, 80270, 80269, 80267, 80266, 80264, 80263, 80261, 80260, 80258,
    80257, 80255, 80254, 80252, 80251, 80249, 80248, 80246, 80245, 80243, 80242, 80240, 80239, 80237,
    80236, 80234, 80233, 80231, 80230, 80228, 80227, 80225, 80224, 80222, 80221, 80219, 80218, 80216,
    80215, 80213, 80212, 80210, 80209, 80207, 80206, 80204, 80203, 80201, 80200, 80198, 80197, 80195,
    80194, 80192, 80191, 80189, 80188, 80186, 80185, 80183, 80182, 80180, 80179, 80177, 80176, 80174,
    80173, 80171, 80170, 80168, 80167, 80165, 80164, 80162, 80161, 80159, 80158, 80156, 80155, 80153,
    80152, 80150, 80149, 80147, 80146, 80144, 80143, 80141, 80140, 80138, 80137, 80135, 80134, 80132,
    80131, 80129, 80128, 80127, 80125, 80124, 80122, 80121, 80119, 80118, 80116, 80115, 80113, 80112,
    80110, 80109, 80107, 80106, 80104, 80103, 80101, 80100, 80098, 80097, 80095, 80094, 80092, 80091,
    80089, 80088, 80086, 80085, 80083, 80082, 80080, 80079, 80077, 80076, 80074, 80073, 80071, 80070,
    80068, 80067, 80065, 80064, 80062, 80061, 80059, 80058, 80056, 80055, 80053, 80052, 80050, 80049,
    80047, 80046, 80044, 80043, 80041, 80040, 80038, 80037, 80035, 80034, 80032, 80031, 80029, 80028,
    80026, 80025, 80023, 80022, 80021, 80019, 80018, 80016, 80015, 80013, 80012, 80010, 80009, 80007,
    80006, 80004, 80003, 80001, 80000, 79998, 79997, 79995, 79994, 79992, 79991, 79989, 79988, 79986,
    79985, 79983, 79982, 79980, 79979, 79977, 79976, 79974, 79973, 79971, 79970, 79968, 79967, 79965,
    79964, 79962, 79961, 79959, 79958, 79956, 79955, 79953, 79952, 79950, 79949, 79948, 79946, 79945,
    79943, 79942, 79940, 79939, 79937, 79936, 79934, 79933, 79931, 79930, 79928, 79927, 79925, 79924,
    79922, 79921, 79919, 79918, 79916, 79915, 79913, 79912, 79910, 79909, 79907, 79906, 79904, 79903,
    79901, 79900, 79898, 79897, 79895, 79894, 79892, 79891, 79890, 79888, 79887, 79885, 79884, 79882,
    79881, 79879, 79878, 79876, 79875, 79873, 79872, 79870, 79869, 79867, 79866, 79864, 79863, 79861,
    79860, 79858, 79857, 79855, 79854, 79852, 79851, 79849, 79848, 79846, 79845, 79843, 79842, 79841,
    79839, 79838, 79836, 79835, 79833, 79832, 79830, 79829, 79827, 79826, 79824, 79823, 79821, 79820,
    79818, 79817, 79815, 79814, 79812, 79811, 79809, 79808, 79806, 79805, 79803, 79802, 79800, 79799,
    79797, 79796, 79795, 79793, 79792, 79790, 79789, 79787, 79786, 79784, 79783, 79781, 79780, 79778,
    79777, 79775, 79774, 79772, 79771, 79769, 79768, 79766, 79765, 79763, 79762, 79760, 79759, 79757,
    79756, 79755, 79753, 79752, 79750, 79749, 79747, 79746, 79744, 79743, 79741, 79740, 79738, 79737,
    79735, 79734, 79732, 79731, 79729, 79728, 79726, 79725, 79723, 79722, 79720, 79719, 79718, 79716,
    79715, 79713, 79712, 79710, 79709, 79707, 79706, 79704, 79703, 79701, 79700, 79698, 79697, 79695,
    79694, 79692, 79691, 79689, 79688, 79686, 79685, 79683, 79682, 79681, 79679, 79678, 79676, 79675,
    79673, 79672, 79670, 79669, 79667, 79666, 79664, 79663, 79661, 79660, 79658, 79657, 79655, 79654,
    79652, 79651, 79650, 79648, 79647, 79645, 79644, 79642, 79641, 79639, 79638, 79636, 79635, 79633,
    79632, 79630, 79629, 79627, 79626, 79624, 79623, 79621, 79620, 79619, 79617, 79616, 79614, 79613,
    79611, 79610, 79608, 79607, 79605, 79604, 79602, 79601, 79599, 79598, 79596, 79595, 79593, 79592,
    79590, 79589, 79588, 79586, 79585, 79583, 79582, 79580, 79579, 79577, 79576, 79574, 79573, 79571,
    79570, 79568, 79567, 79565, 79564, 79562, 79561, 79560, 79558, 79557, 79555, 79554, 79552, 79551,
    79549, 79548, 79546, 79545, 79543, 79542, 79540, 79539, 79537, 79536, 79534, 79533, 79532, 79530,
    79529, 79527, 79526, 79524, 79523, 79521, 79520, 79518, 79517, 79515, 79514, 79512, 79511, 79509,
    79508, 79506, 79505, 79504, 79502, 79501, 79499, 79498, 79496, 79495, 79493, 79492, 79490, 79489,
    79487, 79486, 79484, 79483, 79481, 79480, 79479, 79477, 79476, 79474, 79473, 79471, 79470, 79468,
    79467, 79465, 79464, 79462, 79461, 79459, 79458, 79456, 79455, 79454, 79452, 79451, 79449, 79448,
    79446, 79445, 79443, 79442, 79440, 79439, 79437, 79436, 79434, 79433, 79431, 79430, 79429, 79427,
    79426, 79424, 79423, 79421, 79420, 79418, 79417, 79415, 79414, 79412, 79411, 79409, 79408, 79407,
    79405, 79404, 79402, 79401, 79399, 79398, 79396, 79395, 79393, 79392, 79390, 79389, 79387, 79386,
    79385, 79383, 79382, 79380, 79379, 79377, 79376, 79374, 79373, 79371, 79370, 79368, 79367, 79365,
    79364, 79363, 79361, 79360, 79358, 79357, 79355, 79354, 79352, 79351, 79349, 79348, 79346, 79345,
    79343, 79342, 79341, 79339, 79338, 79336, 79335, 79333, 79332, 79330, 79329, 79327, 79326, 79324,
    79323, 79321, 79320, 79319, 79317, 79316, 79314, 79313, 79311, 79310, 79308, 79307, 79305, 79304,
    79302, 79301, 79300, 79298, 79297, 79295, 79294, 79292, 79291, 79289, 79288, 79286, 79285, 79283,
    79282, 79280, 79279, 79278, 79276, 79275, 79273, 79272, 79270, 79269, 79267, 79266, 79264, 79263,
    79261, 79260, 79259, 79257, 79256, 79254, 79253, 79251, 79250, 79248, 79247, 79245, 79244, 79242,
    79241, 79240, 79238, 79237, 79235, 79234, 79232, 79231, 79229, 79228, 79226, 79225, 79223, 79222,
    79221, 79219, 79218, 79216, 79215, 79213, 79212, 79210, 79209, 79207, 79206, 79204, 79203, 79202,
    79200, 79199, 79197, 79196, 79194, 79193, 79191, 79190, 79188, 79187, 79185, 79184, 79183, 79181,
    79180, 79178, 79177, 79175, 79174, 79172, 79171, 79169, 79168, 79166, 79165, 79164, 79162, 79161,
    79159, 79158, 79156, 79155, 79153, 79152, 79150, 79149, 79148, 79146, 79145, 79143, 79142, 79140,
    79139, 79137, 79136, 79134, 79133, 79131, 79130, 79129, 79127, 79126, 79124, 79123, 79121, 79120,
    79118, 79117, 79115, 79114, 79113, 79111, 79110, 79108, 79107, 79105, 79104, 79102, 79101, 79099,
    79098, 79097, 79095, 79094, 79092, 79091, 79089, 79088, 79086, 79085, 79083, 79082, 79080, 79079,
    79078, 79076, 79075, 79073, 79072, 79070, 79069, 79067, 79066, 79064, 79063, 79062, 79060, 79059,
    79057, 79056, 79054, 79053, 79051, 79050, 79048, 79047, 79046, 79044, 79043, 79041, 79040, 79038,
    79037, 79035, 79034, 79032, 79031, 79030, 79028, 79027, 79025, 79024, 79022, 79021, 79019, 79018,
    79016, 79015, 79014, 79012, 79011, 79009, 79008, 79006, 79005, 79003, 79002, 79000, 78999, 78998,
    78996, 78995, 78993, 78992, 78990, 78989, 78987, 78986, 78985, 78983, 78982, 78980, 78979, 78977,
    78976, 78974, 78973, 78971, 78970, 78969, 78967, 78966, 78964, 78963, 78961, 78960, 78958, 78957,
    78955, 78954, 78953, 78951, 78950, 78948, 78947, 78945, 78944, 78942, 78941, 78939, 78938, 78937,
    78935, 78934, 78932, 78931, 78929, 78928, 78926, 78925, 78924, 78922, 78921, 78919, 78918, 78916,
    78915, 78913, 78912, 78910, 78909, 78908, 78906, 78905, 78903, 78902, 78900, 78899, 78897, 78896,
    78895, 78893, 78892, 78890, 78889, 78887, 78886, 78884, 78883, 78882, 78880, 78879, 78877, 78876,
    78874, 78873, 78871, 78870, 78868, 78867, 78866, 78864, 78863, 78861, 78860, 78858, 78857, 78855,
    78854, 78853, 78851, 78850, 78848, 78847, 78845, 78844, 78842, 78841, 78840, 78838, 78837, 78835,
    78834, 78832, 78831, 78829, 78828, 78826, 78825, 78824, 78822, 78821, 78819, 78818, 78816, 78815,
    78813, 78812, 78811, 78809, 78808, 78806, 78805, 78803, 78802, 78800, 78799, 78798, 78796, 78795,
    78793, 78792, 78790, 78789, 78787, 78786, 78785, 78783, 78782, 78780, 78779, 78777, 78776, 78774,
    78773, 78772, 78770, 78769, 78767, 78766, 78764, 78763, 78761, 78760, 78759, 78757, 78756, 78754,
    78753, 78751, 78750, 78748, 78747, 78746, 78744, 78743, 78741, 78740, 78738, 78737, 78735, 78734,
    78733, 78731, 78730, 78728, 78727, 78725, 78724, 78722, 78721, 78720, 78718, 78717, 78715, 78714,
    78712, 78711, 78709, 78708, 78707, 78705, 78704, 78702, 78701, 78699, 78698, 78697, 78695, 78694,
    78692, 78691, 78689, 78688, 78686, 78685, 78684, 78682, 78681, 78679, 78678, 78676, 78675, 78673,
    78672, 78671, 78669, 78668, 78666, 78665, 78663, 78662, 78660, 78659, 78658, 78656, 78655, 78653,
    78652, 78650, 78649, 78648, 78646, 78645, 78643, 78642, 78640, 78639, 78637, 78636, 78635, 78633,
    78632, 78630, 78629, 78627, 78626, 78624, 78623, 78622, 78620, 78619, 78617, 78616, 78614, 78613,
    78612, 78610, 78609, 78607, 78606, 78604, 78603, 78601, 78600, 78599, 78597, 78596, 78594, 78593,
    78591, 78590, 78589, 78587, 78586, 78584, 78583, 78581, 78580, 78578, 78577, 78576, 78574, 78573,
    78571, 78570, 78568, 78567, 78565, 78564, 78563, 78561, 78560, 78558, 78557, 78555, 78554, 78553,
    78551, 78550, 78548, 78547, 78545, 78544, 78543, 78541, 78540, 78538, 78537, 78535, 78534, 78532,
    78531, 78530, 78528, 78527, 78525, 78524, 78522, 78521, 78520, 78518, 78517, 78515, 78514, 78512,
    78511, 78509, 78508, 78507, 78505, 78504, 78502, 78501, 78499, 78498, 78497, 78495, 78494, 78492,
    78491, 78489, 78488, 78487, 78485, 78484, 78482, 78481, 78479, 78478, 78476, 78475, 78474, 78472,
    78471, 78469, 78468, 78466, 78465, 78464, 78462, 78461, 78459, 78458, 78456, 78455, 78454, 78452,
    78451, 78449, 78448, 78446, 78445, 78444, 78442, 78441, 78439, 78438, 78436, 78435, 78434, 78432,
    78431, 78429, 78428, 78426, 78425, 78423, 78422, 78421, 78419, 78418, 78416, 78415, 78413, 78412,
    78411, 78409, 78408, 78406, 78405, 78403, 78402, 78401, 78399, 78398, 78396, 78395, 78393, 78392,
    78391, 78389, 78388, 78386, 78385, 78383, 78382, 78381, 78379, 78378, 78376, 78375, 78373, 78372,
    78371, 78369, 78368, 78366, 78365, 78363, 78362, 78361, 78359, 78358, 78356, 78355, 78353, 78352,
    78351, 78349, 78348, 78346, 78345, 78343, 78342, 78341, 78339, 78338, 78336, 78335, 78333, 78332,
    78331, 78329, 78328, 78326, 78325, 78323, 78322, 78321, 78319, 78318, 78316, 78315, 78313, 78312,
    78311, 78309, 78308, 78306, 78305, 78303, 78302, 78301, 78299, 78298, 78296, 78295, 78293, 78292,
    78291, 78289, 78288, 78286, 78285, 78283, 78282, 78281, 78279, 78278, 78276, 78275, 78273, 78272,
    78271, 78269, 78268, 78266, 78265, 78263, 78262, 78261, 78259, 78258, 78256, 78255, 78253, 78252,
    78251, 78249, 78248, 78246, 78245, 78243, 78242, 78241, 78239, 78238, 78236, 78235, 78233, 78232,
    78231, 78229, 78228, 78226, 78225, 78224, 78222, 78221, 78219, 78218, 78216, 78215, 78214, 78212,
    78211, 78209, 78208, 78206, 78205, 78204, 78202, 78201, 78199, 78198, 78196, 78195, 78194, 78192,
    78191, 78189, 78188, 78186, 78185, 78184, 78182, 78181, 78179, 78178, 78177, 78175, 78174, 78172,
    78171, 78169, 78168, 78167, 78165, 78164, 78162, 78161, 78159, 78158, 78157, 78155, 78154, 78152,
    78151, 78149, 78148, 78147, 78145, 78144, 78142, 78141, 78140, 78138, 78137, 78135, 78134, 78132,
    78131, 78130, 78128, 78127, 78125, 78124, 78122, 78121, 78120, 78118, 78117, 78115, 78114, 78113,
    78111, 78110, 78108, 78107, 78105, 78104, 78103, 78101, 78100, 78098, 78097, 78095, 78094, 78093,
    78091, 78090, 78088, 78087, 78086, 78084, 78083, 78081, 78080, 78078, 78077, 78076, 78074, 78073,
    78071, 78070, 78069, 78067, 78066, 78064, 78063, 78061, 78060, 78059, 78057, 78056, 78054, 78053,
    78052, 78050, 78049, 78047, 78046, 78044, 78043, 78042, 78040, 78039, 78037, 78036, 78034, 78033,
    78032, 78030, 78029, 78027, 78026, 78025, 78023, 78022, 78020, 78019, 78017, 78016, 78015, 78013,
    78012, 78010, 78009, 78008, 78006, 78005, 78003, 78002, 78000, 77999, 77998, 77996, 77995, 77993,
    77992, 77991, 77989, 77988, 77986, 77985, 77983, 77982, 77981, 77979, 77978, 77976, 77975, 77974,
    77972, 77971, 77969, 77968, 77966, 77965, 77964, 77962, 77961, 77959, 77958, 77957, 77955, 77954,
    77952, 77951, 77950, 77948, 77947, 77945, 77944, 77942, 77941, 77940, 77938, 77937, 77935, 77934,
    77933, 77931, 77930, 77928, 77927, 77925, 77924, 77923, 77921, 77920, 77918, 77917, 77916, 77914,
    77913, 77911, 77910, 77909, 77907, 77906, 77904, 77903, 77901, 77900, 77899, 77897, 77896, 77894,
    77893, 77892, 77890, 77889, 77887, 77886, 77884, 77883, 77882, 77880, 77879, 77877, 77876, 77875,
    77873, 77872, 77870, 77869, 77868, 77866, 77865, 77863, 77862, 77860, 77859, 77858, 77856, 77855,
    77853, 77852, 77851, 77849, 77848, 77846, 77845, 77844, 77842, 77841, 77839, 77838, 77836, 77835,
    77834, 77832, 77831, 77829, 77828, 77827, 77825, 77824, 77822, 77821, 77820, 77818, 77817, 77815,
    77814, 77813, 77811, 77810, 77808, 77807, 77805, 77804, 77803, 77801, 77800, 77798, 77797, 77796,
    77794, 77793, 77791, 77790, 77789, 77787, 77786, 77784, 77783, 77782, 77780, 77779, 77777, 77776,
    77774, 77773, 77772, 77770, 77769, 77767, 77766, 77765, 77763, 77762, 77760, 77759, 77758, 77756,
    77755, 77753, 77752, 77751, 77749, 77748, 77746, 77745, 77744, 77742, 77741, 77739, 77738, 77736,
    77735, 77734, 77732, 77731, 77729, 77728, 77727, 77725, 77724, 77722, 77721, 77720, 77718, 77717,
    77715, 77714, 77713, 77711, 77710, 77708, 77707, 77706, 77704, 77703, 77701, 77700, 77698, 77697,
    77696, 77694, 77693, 77691, 77690, 77689, 77687, 77686, 77684, 77683, 77682, 77680, 77679, 77677,
    77676, 77675, 77673, 77672, 77670, 77669, 77668, 77666, 77665, 77663, 77662, 77661, 77659, 77658,
    77656, 77655, 77654, 77652, 77651, 77649, 77648, 77647, 77645, 77644, 77642, 77641, 77640, 77638,
    77637, 77635, 77634, 77632, 77631, 77630, 77628, 77627, 77625, 77624, 77623, 77621, 77620, 77618,
    77617, 77616, 77614, 77613, 77611, 77610, 77609, 77607, 77606, 77604, 77603, 77602, 77600, 77599,
    77597, 77596, 77595, 77593, 77592, 77590, 77589, 77588, 77586, 77585, 77583, 77582, 77581, 77579,
    77578, 77576, 77575, 77574, 77572, 77571, 77569, 77568, 77567, 77565, 77564, 77562, 77561, 77560,
    77558, 77557, 77555, 77554, 77553, 77551, 77550, 77548, 77547, 77546, 77544, 77543, 77541, 77540,
    77539, 77537, 77536, 77534, 77533, 77532, 77530, 77529, 77527, 77526, 77525, 77523, 77522, 77520,
    77519, 77518, 77516, 77515, 77513, 77512, 77511, 77509, 77508, 77506, 77505, 77504, 77502, 77501,
    77499, 77498, 77497, 77495, 77494, 77492, 77491, 77490, 77488, 77487, 77485, 77484, 77483, 77481,
    77480, 77478, 77477, 77476, 77474, 77473, 77471, 77470, 77469, 77467, 77466, 77464, 77463, 77462,
    77460, 77459, 77457, 77456, 77455, 77453, 77452, 77450, 77449, 77448, 77446, 77445, 77444, 77442,
    77441, 77439, 77438, 77437, 77435, 77434, 77432, 77431, 77430, 77428, 77427, 77425, 77424, 77423,
    77421, 77420, 77418, 77417, 77416, 77414, 77413, 77411, 77410, 77409, 77407, 77406, 77404, 77403,
    77402, 77400, 77399, 77397, 77396, 77395, 77393, 77392, 77390, 77389, 77388, 77386, 77385, 77384,
    77382, 77381, 77379, 77378, 77377, 77375, 77374, 77372, 77371, 77370, 77368, 77367, 77365, 77364,
    77363, 77361, 77360, 77358, 77357, 77356, 77354, 77353, 77351, 77350, 77349, 77347, 77346, 77344,
    77343, 77342, 77340, 77339, 77338, 77336, 77335, 77333, 77332, 77331, 77329, 77328, 77326, 77325,
    77324, 77322, 77321, 77319, 77318, 77317, 77315, 77314, 77312, 77311, 77310, 77308, 77307, 77306,
    77304, 77303, 77301, 77300, 77299, 77297, 77296, 77294, 77293, 77292, 77290, 77289, 77287, 77286,
    77285, 77283, 77282, 77280, 77279, 77278, 77276, 77275, 77274, 77272, 77271, 77269, 77268, 77267,
    77265, 77264, 77262, 77261, 77260, 77258, 77257, 77255, 77254, 77253, 77251, 77250, 77249, 77247,
    77246, 77244, 77243, 77242, 77240, 77239, 77237, 77236, 77235, 77233, 77232, 77230, 77229, 77228,
    77226, 77225, 77224, 77222, 77221, 77219, 77218, 77217, 77215, 77214, 77212, 77211, 77210, 77208,
    77207, 77205, 77204, 77203, 77201, 77200, 77199, 77197, 77196, 77194, 77193, 77192, 77190, 77189,
    77187, 77186, 77185, 77183, 77182, 77180, 77179, 77178, 77176, 77175, 77174, 77172, 77171, 77169,
    77168, 77167, 77165, 77164, 77162, 77161, 77160, 77158, 77157, 77156, 77154, 77153, 77151, 77150,
    77149, 77147, 77146, 77144, 77143, 77142, 77140, 77139, 77138, 77136, 77135, 77133, 77132, 77131,
    77129, 77128, 77126, 77125, 77124, 77122, 77121, 77120, 77118, 77117, 77115, 77114, 77113, 77111,
    77110, 77108, 77107, 77106, 77104, 77103, 77102, 77100, 77099, 77097, 77096, 77095, 77093, 77092,
    77090, 77089, 77088, 77086, 77085, 77084, 77082, 77081, 77079, 77078, 77077, 77075, 77074, 77072,
    77071, 77070, 77068, 77067, 77066, 77064, 77063, 77061, 77060, 77059, 77057, 77056, 77054, 77053,
    77052, 77050, 77049, 77048, 77046, 77045, 77043, 77042, 77041, 77039, 77038, 77037, 77035, 77034,
    77032, 77031, 77030, 77028, 77027, 77025, 77024, 77023, 77021, 77020, 77019, 77017, 77016, 77014,
    77013, 77012, 77010, 77009, 77008, 77006, 77005, 77003, 77002, 77001, 76999, 76998, 76996, 76995,
    76994, 76992, 76991, 76990, 76988, 76987, 76985, 76984, 76983, 76981, 76980, 76979, 76977, 76976,
    76974, 76973, 76972, 76970, 76969, 76967, 76966, 76965, 76963, 76962, 76961, 76959, 76958, 76956,
    76955, 76954, 76952, 76951, 76950, 76948, 76947, 76945, 76944, 76943, 76941, 76940, 76939, 76937,
    76936, 76934, 76933, 76932, 76930, 76929, 76928, 76926, 76925, 76923, 76922, 76921, 76919, 76918,
    76916, 76915, 76914, 76912, 76911, 76910, 76908, 76907, 76905, 76904, 76903, 76901, 76900, 76899,
    76897, 76896, 76894, 76893, 76892, 76890, 76889, 76888, 76886, 76885, 76883, 76882, 76881, 76879,
    76878, 76877, 76875, 76874, 76872, 76871, 76870, 76868, 76867, 76866, 76864, 76863, 76861, 76860,
    76859, 76857, 76856, 76855, 76853, 76852, 76850, 76849, 76848, 76846, 76845, 76844, 76842, 76841,
    76839, 76838, 76837, 76835, 76834, 76833, 76831, 76830, 76828, 76827, 76826, 76824, 76823, 76822,
    76820, 76819, 76817, 76816, 76815, 76813, 76812, 76811, 76809, 76808, 76806, 76805, 76804, 76802,
    76801, 76800, 76798, 76797, 76795, 76794, 76793, 76791, 76790, 76789, 76787, 76786, 76784, 76783,
    76782, 76780, 76779, 76778, 76776, 76775, 76773, 76772, 76771, 76769, 76768, 76767, 76765, 76764,
    76763, 76761, 76760, 76758, 76757, 76756, 76754, 76753, 76752, 76750, 76749, 76747, 76746, 76745,
    76743, 76742, 76741, 76739, 76738, 76736, 76735, 76734, 76732, 76731, 76730, 76728, 76727, 76725,
    76724, 76723, 76721, 76720, 76719, 76717, 76716, 76715, 76713, 76712, 76710, 76709, 76708, 76706,
    76705, 76704, 76702, 76701, 76699, 76698, 76697, 76695, 76694, 76693, 76691, 76690, 76689, 76687,
    76686, 76684, 76683, 76682, 76680, 76679, 76678, 76676, 76675, 76673, 76672, 76671, 76669, 76668,
    76667, 76665, 76664, 76662, 76661, 76660, 76658, 76657, 76656, 76654, 76653, 76652, 76650, 76649,
    76647, 76646, 76645, 76643, 76642, 76641, 76639, 76638, 76637, 76635, 76634, 76632, 76631, 76630,
    76628, 76627, 76626, 76624, 76623, 76621, 76620, 76619, 76617, 76616, 76615, 76613, 76612, 76611,
    76609, 76608, 76606, 76605, 76604, 76602, 76601, 76600, 76598, 76597, 76596, 76594, 76593, 76591,
    76590, 76589, 76587, 76586, 76585, 76583, 76582, 76580, 76579, 76578, 76576, 76575, 76574, 76572,
    76571, 76570, 76568, 76567, 76565, 76564, 76563, 76561, 76560, 76559, 76557, 76556, 76555, 76553,
    76552, 76550, 76549, 76548, 76546, 76545, 76544, 76542, 76541, 76540, 76538, 76537, 76535, 76534,
    76533, 76531, 76530, 76529, 76527, 76526, 76525, 76523, 76522, 76520, 76519, 76518, 76516, 76515,
    76514, 76512, 76511, 76510, 76508, 76507, 76505, 76504, 76503, 76501, 76500, 76499, 76497, 76496,
    76495, 76493, 76492, 76490, 76489, 76488, 76486, 76485, 76484, 76482, 76481, 76480, 76478, 76477,
    76475, 76474, 76473, 76471, 76470, 76469, 76467, 76466, 76465, 76463, 76462, 76461, 76459, 76458,
    76456, 76455, 76454, 76452, 76451, 76450, 76448, 76447, 76446, 76444, 76443, 76441, 76440, 76439,
    76437, 76436, 76435, 76433, 76432, 76431, 76429, 76428, 76426, 76425, 76424, 76422, 76421, 76420,
    76418, 76417, 76416, 76414, 76413, 76412, 76410, 76409, 76407, 76406, 76405, 76403, 76402, 76401,
    76399, 76398, 76397, 76395, 76394, 76393, 76391, 76390, 76388, 76387, 76386, 76384, 76383, 76382,
    76380, 76379, 76378, 76376, 76375, 76373, 76372, 76371, 76369, 76368, 76367, 76365, 76364, 76363,
    76361, 76360, 76359, 76357, 76356, 76354, 76353, 76352, 76350, 76349, 76348, 76346, 76345, 76344,
    76342, 76341, 76340, 76338, 76337, 76335, 76334, 76333, 76331, 76330, 76329, 76327, 76326, 76325,
    76323, 76322, 76321, 76319, 76318, 76316, 76315, 76314, 76312, 76311, 76310, 76308, 76307, 76306,
    76304, 76303, 76302, 76300, 76299, 76298, 76296, 76295, 76293, 76292, 76291, 76289, 76288, 76287,
    76285, 76284, 76283, 76281, 76280, 76279, 76277, 76276, 76274, 76273, 76272, 76270, 76269, 76268,
    76266, 76265, 76264, 76262, 76261, 76260, 76258, 76257, 76256, 76254, 76253, 76251, 76250, 76249,
    76247, 76246, 76245, 76243, 76242, 76241, 76239, 76238, 76237, 76235, 76234, 76233, 76231, 76230,
    76228, 76227, 76226, 76224, 76223, 76222, 76220, 76219, 76218, 76216, 76215, 76214, 76212, 76211,
    76210, 76208, 76207, 76205, 76204, 76203, 76201, 76200, 76199, 76197, 76196, 76195, 76193, 76192,
    76191, 76189, 76188, 76187, 76185, 76184, 76182, 76181, 76180, 76178, 76177, 76176, 76174, 76173,
    76172, 76170, 76169, 76168, 76166, 76165, 76164, 76162, 76161, 76160, 76158, 76157, 76155, 76154,
    76153, 76151, 76150, 76149, 76147, 76146, 76145, 76143, 76142, 76141, 76139, 76138, 76137, 76135,
    76134, 76133, 76131, 76130, 76128, 76127, 76126, 76124, 76123, 76122, 76120, 76119, 76118, 76116,
    76115, 76114, 76112, 76111, 76110, 76108, 76107, 76106, 76104, 76103, 76101, 76100, 76099, 76097,
    76096, 76095, 76093, 76092, 76091, 76089, 76088, 76087, 76085, 76084, 76083, 76081, 76080, 76079,
    76077, 76076, 76075, 76073, 76072, 76070, 76069, 76068, 76066, 76065, 76064, 76062, 76061, 76060,
    76058, 76057, 76056, 76054, 76053, 76052, 76050, 76049, 76048, 76046, 76045, 76044, 76042, 76041,
    76040, 76038, 76037, 76035, 76034, 76033, 76031, 76030, 76029, 76027, 76026, 76025, 76023, 76022,
    76021, 76019, 76018, 76017, 76015, 76014, 76013, 76011, 76010, 76009, 76007, 76006, 76005, 76003,
    76002, 76000, 75999, 75998, 75996, 75995, 75994, 75992, 75991, 75990, 75988, 75987, 75986, 75984,
    75983, 75982, 75980, 75979, 75978, 75976, 75975, 75974, 75972, 75971, 75970, 75968, 75967, 75966,
    75964, 75963, 75962, 75960, 75959, 75957, 75956, 75955, 75953, 75952, 75951, 75949, 75948, 75947,
    75945, 75944, 75943, 75941, 75940, 75939, 75937, 75936, 75935, 75933, 75932, 75931, 75929, 75928,
    75927, 75925, 75924, 75923, 75921, 75920, 75919, 75917, 75916, 75915, 75913, 75912, 75910, 75909,
    75908, 75906, 75905, 75904, 75902, 75901, 75900, 75898, 75897, 75896, 75894, 75893, 75892, 75890,
    75889, 75888, 75886, 75885, 75884, 75882, 75881, 75880, 75878, 75877, 75876, 75874, 75873, 75872,
    75870, 75869, 75868, 75866, 75865, 75864, 75862, 75861, 75860, 75858, 75857, 75856, 75854, 75853,
    75851, 75850, 75849, 75847, 75846, 75845, 75843, 75842, 75841, 75839, 75838, 75837, 75835, 75834,
    75833, 75831, 75830, 75829, 75827, 75826, 75825, 75823, 75822, 75821, 75819, 75818, 75817, 75815,
    75814, 75813, 75811, 75810, 75809, 75807, 75806, 75805, 75803, 75802, 75801, 75799, 75798, 75797,
    75795, 75794, 75793, 75791, 75790, 75789, 75787, 75786, 75785, 75783, 75782, 75781, 75779, 75778,
    75777, 75775, 75774, 75773, 75771, 75770, 75769, 75767, 75766, 75765, 75763, 75762, 75761, 75759,
    75758, 75757, 75755, 75754, 75752, 75751, 75750, 75748, 75747, 75746, 75744, 75743, 75742, 75740,
    75739, 75738, 75736, 75735, 75734, 75732, 75731, 75730, 75728, 75727, 75726, 75724, 75723, 75722,
    75720, 75719, 75718, 75716, 75715, 75714, 75712, 75711, 75710, 75708, 75707, 75706, 75704, 75703,
    75702, 75700, 75699, 75698, 75696, 75695, 75694, 75692, 75691, 75690, 75688, 75687, 75686, 75684,
    75683, 75682, 75680, 75679, 75678, 75676, 75675, 75674, 75672, 75671, 75670, 75668, 75667, 75666,
    75664, 75663, 75662, 75660, 75659, 75658, 75656, 75655, 75654, 75652, 75651, 75650, 75648, 75647,
    75646, 75644, 75643, 75642, 75640, 75639, 75638, 75636, 75635, 75634, 75632, 75631, 75630, 75628,
    75627, 75626, 75624, 75623, 75622, 75620, 75619, 75618, 75616, 75615, 75614, 75612, 75611, 75610,
    75608, 75607, 75606, 75604, 75603, 75602, 75600, 75599, 75598, 75596, 75595, 75594, 75593, 75591,
    75590, 75589, 75587, 75586, 75585, 75583, 75582, 75581, 75579, 75578, 75577, 75575, 75574, 75573,
    75571, 75570, 75569, 75567, 75566, 75565, 75563, 75562, 75561, 75559, 75558, 75557, 75555, 75554,
    75553, 75551, 75550, 75549, 75547, 75546, 75545, 75543, 75542, 75541, 75539, 75538, 75537, 75535,
    75534, 75533, 75531, 75530, 75529, 75527, 75526, 75525, 75523, 75522, 75521, 75519, 75518, 75517,
    75515, 75514, 75513, 75511, 75510, 75509, 75507, 75506, 75505, 75503, 75502, 75501, 75499, 75498,
    75497, 75496, 75494, 75493, 75492, 75490, 75489, 75488, 75486, 75485, 75484, 75482, 75481, 75480,
    75478, 75477, 75476, 75474, 75473, 75472, 75470, 75469, 75468, 75466, 75465, 75464, 75462, 75461,
    75460, 75458, 75457, 75456, 75454, 75453, 75452, 75450, 75449, 75448, 75446, 75445, 75444, 75442,
    75441, 75440, 75438, 75437, 75436, 75435, 75433, 75432, 75431, 75429, 75428, 75427, 75425, 75424,
    75423, 75421, 75420, 75419, 75417, 75416, 75415, 75413, 75412, 75411, 75409, 75408, 75407, 75405,
    75404, 75403, 75401, 75400, 75399, 75397, 75396, 75395, 75393, 75392, 75391, 75389, 75388, 75387,
    75386, 75384, 75383, 75382, 75380, 75379, 75378, 75376, 75375, 75374, 75372, 75371, 75370, 75368,
    75367, 75366, 75364, 75363, 75362, 75360, 75359, 75358, 75356, 75355, 75354, 75352, 75351, 75350,
    75348, 75347, 75346, 75345, 75343, 75342, 75341, 75339, 75338, 75337, 75335, 75334, 75333, 75331,
    75330, 75329, 75327, 75326, 75325, 75323, 75322, 75321, 75319, 75318, 75317, 75315, 75314, 75313,
    75311, 75310, 75309, 75308, 75306, 75305, 75304, 75302, 75301, 75300, 75298, 75297, 75296, 75294,
    75293, 75292, 75290, 75289, 75288, 75286, 75285, 75284, 75282, 75281, 75280, 75278, 75277, 75276,
    75275, 75273, 75272, 75271, 75269, 75268, 75267, 75265, 75264, 75263, 75261, 75260, 75259, 75257,
    75256, 75255, 75253, 75252, 75251, 75249, 75248, 75247, 75246, 75244, 75243, 75242, 75240, 75239,
    75238, 75236, 75235, 75234, 75232, 75231, 75230, 75228, 75227, 75226, 75224, 75223, 75222, 75220,
    75219, 75218, 75217, 75215, 75214, 75213, 75211, 75210, 75209, 75207, 75206, 75205, 75203, 75202,
    75201, 75199, 75198, 75197, 75195, 75194, 75193, 75192, 75190, 75189, 75188, 75186, 75185, 75184,
    75182, 75181, 75180, 75178, 75177, 75176, 75174, 75173, 75172, 75170, 75169, 75168, 75167, 75165,
    75164, 75163, 75161, 75160, 75159, 75157, 75156, 75155, 75153, 75152, 75151, 75149, 75148, 75147,
    75145, 75144, 75143, 75142, 75140, 75139, 75138, 75136, 75135, 75134, 75132, 75131, 75130, 75128,
    75127, 75126, 75124, 75123, 75122, 75120, 75119, 75118, 75117, 75115, 75114, 75113, 75111, 75110,
    75109, 75107, 75106, 75105, 75103, 75102, 75101, 75099, 75098, 75097, 75096, 75094, 75093, 75092,
    75090, 75089, 75088, 75086, 75085, 75084, 75082, 75081, 75080, 75078, 75077, 75076, 75075, 75073,
    75072, 75071, 75069, 75068, 75067, 75065, 75064, 75063, 75061, 75060, 75059, 75057, 75056, 75055,
    75054, 75052, 75051, 75050, 75048, 75047, 75046, 75044, 75043, 75042, 75040, 75039, 75038, 75036,
    75035, 75034, 75033, 75031, 75030, 75029, 75027, 75026, 75025, 75023, 75022, 75021, 75019, 75018,
    75017, 75016, 75014, 75013, 75012, 75010, 75009, 75008, 75006, 75005, 75004, 75002, 75001, 75000,
    74998, 74997, 74996, 74995, 74993, 74992, 74991, 74989, 74988, 74987, 74985, 74984, 74983, 74981,
    74980, 74979, 74978, 74976, 74975, 74974, 74972, 74971, 74970, 74968, 74967, 74966, 74964, 74963,
    74962, 74961, 74959, 74958, 74957, 74955, 74954, 74953, 74951, 74950, 74949, 74947, 74946, 74945,
    74944, 74942, 74941, 74940, 74938, 74937, 74936, 74934, 74933, 74932, 74930, 74929, 74928, 74927,
    74925, 74924, 74923, 74921, 74920, 74919, 74917, 74916, 74915, 74913, 74912, 74911, 74910, 74908,
    74907, 74906, 74904, 74903, 74902, 74900, 74899, 74898, 74896, 74895, 74894, 74893, 74891, 74890,
    74889, 74887, 74886, 74885, 74883, 74882, 74881, 74880, 74878, 74877, 74876, 74874, 74873, 74872,
    74870, 74869, 74868, 74866, 74865, 74864, 74863, 74861, 74860, 74859, 74857, 74856, 74855, 74853,
    74852, 74851, 74849, 74848, 74847, 74846, 74844, 74843, 74842, 74840, 74839, 74838, 74836, 74835,
    74834, 74833, 74831, 74830, 74829, 74827, 74826, 74825, 74823, 74822, 74821, 74820, 74818, 74817,
    74816, 74814, 74813, 74812, 74810, 74809, 74808, 74806, 74805, 74804, 74803, 74801, 74800, 74799,
    74797, 74796, 74795, 74793, 74792, 74791, 74790, 74788, 74787, 74786, 74784, 74783, 74782, 74780,
    74779, 74778, 74777, 74775, 74774, 74773, 74771, 74770, 74769, 74767, 74766, 74765, 74764, 74762,
    74761, 74760, 74758, 74757, 74756, 74754, 74753, 74752, 74750, 74749, 74748, 74747, 74745, 74744,
    74743, 74741, 74740, 74739, 74737, 74736, 74735, 74734, 74732, 74731, 74730, 74728, 74727, 74726,
    74724, 74723, 74722, 74721, 74719, 74718, 74717, 74715, 74714, 74713, 74711, 74710, 74709, 74708,
    74706, 74705, 74704, 74702, 74701, 74700, 74698, 74697, 74696, 74695, 74693, 74692, 74691, 74689,
    74688, 74687, 74685, 74684, 74683, 74682, 74680, 74679, 74678, 74676, 74675, 74674, 74673, 74671,
    74670, 74669, 74667, 74666, 74665, 74663, 74662, 74661, 74660, 74658, 74657, 74656, 74654, 74653,
    74652, 74650, 74649, 74648, 74647, 74645, 74644, 74643, 74641, 74640, 74639, 74637, 74636, 74635,
    74634, 74632, 74631, 74630, 74628, 74627, 74626, 74625, 74623, 74622, 74621, 74619, 74618, 74617,
    74615, 74614, 74613, 74612, 74610, 74609, 74608, 74606, 74605, 74604, 74602, 74601, 74600, 74599,
    74597, 74596, 74595, 74593, 74592, 74591, 74590, 74588, 74587, 74586, 74584, 74583, 74582, 74580,
    74579, 74578, 74577, 74575, 74574, 74573, 74571, 74570, 74569, 74567, 74566, 74565, 74564, 74562,
    74561, 74560, 74558, 74557, 74556, 74555, 74553, 74552, 74551, 74549, 74548, 74547, 74545, 74544,
    74543, 74542, 74540, 74539, 74538, 74536, 74535, 74534, 74533, 74531, 74530, 74529, 74527, 74526,
    74525, 74524, 74522, 74521, 74520, 74518, 74517, 74516, 74514, 74513, 74512, 74511, 74509, 74508,
    74507, 74505, 74504, 74503, 74502, 74500, 74499, 74498, 74496, 74495, 74494, 74492, 74491, 74490,
    74489, 74487, 74486, 74485, 74483, 74482, 74481, 74480, 74478, 74477, 74476, 74474, 74473, 74472,
    74471, 74469, 74468, 74467, 74465, 74464, 74463, 74461, 74460, 74459, 74458, 74456, 74455, 74454,
    74452, 74451, 74450, 74449, 74447, 74446, 74445, 74443, 74442, 74441, 74440, 74438, 74437, 74436,
    74434, 74433, 74432, 74431, 74429, 74428, 74427, 74425, 74424, 74423, 74421, 74420, 74419, 74418,
    74416, 74415, 74414, 74412, 74411, 74410, 74409, 74407, 74406, 74405, 74403, 74402, 74401, 74400,
    74398, 74397, 74396, 74394, 74393, 74392, 74391, 74389, 74388, 74387, 74385, 74384, 74383, 74382,
    74380, 74379, 74378, 74376, 74375, 74374, 74373, 74371, 74370, 74369, 74367, 74366, 74365, 74364,
    74362, 74361, 74360, 74358, 74357, 74356, 74354, 74353, 74352, 74351, 74349, 74348, 74347, 74345,
    74344, 74343, 74342, 74340, 74339, 74338, 74336, 74335, 74334, 74333, 74331, 74330, 74329, 74327,
    74326, 74325, 74324, 74322, 74321, 74320, 74318, 74317, 74316, 74315, 74313, 74312, 74311, 74309,
    74308, 74307, 74306, 74304, 74303, 74302, 74300, 74299, 74298, 74297, 74295, 74294, 74293, 74291,
    74290, 74289, 74288, 74286, 74285, 74284, 74282, 74281, 74280, 74279, 74277, 74276, 74275, 74273,
    74272, 74271, 74270, 74268, 74267, 74266, 74264, 74263, 74262, 74261, 74259, 74258, 74257, 74256,
    74254, 74253, 74252, 74250, 74249, 74248, 74247, 74245, 74244, 74243, 74241, 74240, 74239, 74238,
    74236, 74235, 74234, 74232, 74231, 74230, 74229, 74227, 74226, 74225, 74223, 74222, 74221, 74220,
    74218, 74217, 74216, 74214, 74213, 74212, 74211, 74209, 74208, 74207, 74205, 74204, 74203, 74202,
    74200, 74199, 74198, 74196, 74195, 74194, 74193, 74191, 74190, 74189, 74188, 74186, 74185, 74184,
    74182, 74181, 74180, 74179, 74177, 74176, 74175, 74173, 74172, 74171, 74170, 74168, 74167, 74166,
    74164, 74163, 74162, 74161, 74159, 74158, 74157, 74156, 74154, 74153, 74152, 74150, 74149, 74148,
    74147, 74145, 74144, 74143, 74141, 74140, 74139, 74138, 74136, 74135, 74134, 74132, 74131, 74130,
    74129, 74127, 74126, 74125, 74124, 74122, 74121, 74120, 74118, 74117, 74116, 74115, 74113, 74112,
    74111, 74109, 74108, 74107, 74106, 74104, 74103, 74102, 74100, 74099, 74098, 74097, 74095, 74094,
    74093, 74092, 74090, 74089, 74088, 74086, 74085, 74084, 74083, 74081, 74080, 74079, 74077, 74076,
    74075, 74074, 74072, 74071, 74070, 74069, 74067, 74066, 74065, 74063, 74062, 74061, 74060, 74058,
    74057, 74056, 74054, 74053, 74052, 74051, 74049, 74048, 74047, 74046, 74044, 74043, 74042, 74040,
    74039, 74038, 74037, 74035, 74034, 74033, 74032, 74030, 74029, 74028, 74026, 74025, 74024, 74023,
    74021, 74020, 74019, 74017, 74016, 74015, 74014, 74012, 74011, 74010, 74009, 74007, 74006, 74005,
    74003, 74002, 74001, 74000, 73998, 73997, 73996, 73995, 73993, 73992, 73991, 73989, 73988, 73987,
    73986, 73984, 73983, 73982, 73981, 73979, 73978, 73977, 73975, 73974, 73973, 73972, 73970, 73969,
    73968, 73966, 73965, 73964, 73963, 73961, 73960, 73959, 73958, 73956, 73955, 73954, 73952, 73951,
    73950, 73949, 73947, 73946, 73945, 73944, 73942, 73941, 73940, 73938, 73937, 73936, 73935, 73933,
    73932, 73931, 73930, 73928, 73927, 73926, 73924, 73923, 73922, 73921, 73919, 73918, 73917, 73916,
    73914, 73913, 73912, 73910, 73909, 73908, 73907, 73905, 73904, 73903, 73902, 73900, 73899, 73898,
    73896, 73895, 73894, 73893, 73891, 73890, 73889, 73888, 73886, 73885, 73884, 73883, 73881, 73880,
    73879, 73877, 73876, 73875, 73874, 73872, 73871, 73870, 73869, 73867, 73866, 73865, 73863, 73862,
    73861, 73860, 73858, 73857, 73856, 73855, 73853, 73852, 73851, 73849, 73848, 73847, 73846, 73844,
    73843, 73842, 73841, 73839, 73838, 73837, 73836, 73834, 73833, 73832, 73830, 73829, 73828, 73827,
    73825, 73824, 73823, 73822, 73820, 73819, 73818, 73816, 73815, 73814, 73813, 73811, 73810, 73809,
    73808, 73806, 73805, 73804, 73803, 73801, 73800, 73799, 73797, 73796, 73795, 73794, 73792, 73791,
    73790, 73789, 73787, 73786, 73785, 73784, 73782, 73781, 73780, 73778, 73777, 73776, 73775, 73773,
    73772, 73771, 73770, 73768, 73767, 73766, 73765, 73763, 73762, 73761, 73759, 73758, 73757, 73756,
    73754, 73753, 73752, 73751, 73749, 73748, 73747, 73746, 73744, 73743, 73742, 73740, 73739, 73738,
    73737, 73735, 73734, 73733, 73732, 73730, 73729, 73728, 73727, 73725, 73724, 73723, 73721, 73720,
    73719, 73718, 73716, 73715, 73714, 73713, 73711, 73710, 73709, 73708, 73706, 73705, 73704, 73702,
    73701, 73700, 73699, 73697, 73696, 73695, 73694, 73692, 73691, 73690, 73689, 73687, 73686, 73685,
    73684, 73682, 73681, 73680, 73678, 73677, 73676, 73675, 73673, 73672, 73671, 73670, 73668, 73667,
    73666, 73665, 73663, 73662, 73661, 73660, 73658, 73657, 73656, 73654, 73653, 73652, 73651, 73649,
    73648, 73647, 73646, 73644, 73643, 73642, 73641, 73639, 73638, 73637, 73636, 73634, 73633, 73632,
    73630, 73629, 73628, 73627, 73625, 73624, 73623, 73622, 73620, 73619, 73618, 73617, 73615, 73614,
    73613, 73612, 73610, 73609, 73608, 73606, 73605, 73604, 73603, 73601, 73600, 73599, 73598, 73596,
    73595, 73594, 73593, 73591, 73590, 73589, 73588, 73586, 73585, 73584, 73583, 73581, 73580, 73579,
    73577, 73576, 73575, 73574, 73572, 73571, 73570, 73569, 73567, 73566, 73565, 73564, 73562, 73561,
    73560, 73559, 73557, 73556, 73555, 73554, 73552, 73551, 73550, 73549, 73547, 73546, 73545, 73543,
    73542, 73541, 73540, 73538, 73537, 73536, 73535, 73533, 73532, 73531, 73530, 73528, 73527, 73526,
    73525, 73523, 73522, 73521, 73520, 73518, 73517, 73516, 73515, 73513, 73512, 73511, 73509, 73508,
    73507, 73506, 73504, 73503, 73502, 73501, 73499, 73498, 73497, 73496, 73494, 73493, 73492, 73491,
    73489, 73488, 73487, 73486, 73484, 73483, 73482, 73481, 73479, 73478, 73477, 73476, 73474, 73473,
    73472, 73470, 73469, 73468, 73467, 73465, 73464, 73463, 73462, 73460, 73459, 73458, 73457, 73455,
    73454, 73453, 73452, 73450, 73449, 73448, 73447, 73445, 73444, 73443, 73442, 73440, 73439, 73438,
    73437, 73435, 73434, 73433, 73432, 73430, 73429, 73428, 73427, 73425, 73424, 73423, 73422, 73420,
    73419, 73418, 73416, 73415, 73414, 73413, 73411, 73410, 73409, 73408, 73406, 73405, 73404, 73403,
    73401, 73400, 73399, 73398, 73396, 73395, 73394, 73393, 73391, 73390, 73389, 73388, 73386, 73385,
    73384, 73383, 73381, 73380, 73379, 73378, 73376, 73375, 73374, 73373, 73371, 73370, 73369, 73368,
    73366, 73365, 73364, 73363, 73361, 73360, 73359, 73358, 73356, 73355, 73354, 73353, 73351, 73350,
    73349, 73348, 73346, 73345, 73344, 73343, 73341, 73340, 73339, 73338, 73336, 73335, 73334, 73333,
    73331, 73330, 73329, 73327, 73326, 73325, 73324, 73322, 73321, 73320, 73319, 73317, 73316, 73315,
    73314, 73312, 73311, 73310, 73309, 73307, 73306, 73305, 73304, 73302, 73301, 73300, 73299, 73297,
    73296, 73295, 73294, 73292, 73291, 73290, 73289, 73287, 73286, 73285, 73284, 73282, 73281, 73280,
    73279, 73277, 73276, 73275, 73274, 73272, 73271, 73270, 73269, 73267, 73266, 73265, 73264, 73262,
    73261, 73260, 73259, 73257, 73256, 73255, 73254, 73252, 73251, 73250, 73249, 73247, 73246, 73245,
    73244, 73242, 73241, 73240, 73239, 73237, 73236, 73235, 73234, 73232, 73231, 73230, 73229, 73227,
    73226, 73225, 73224, 73222, 73221, 73220, 73219, 73217, 73216, 73215, 73214, 73213, 73211, 73210,
    73209, 73208, 73206, 73205, 73204, 73203, 73201, 73200, 73199, 73198, 73196, 73195, 73194, 73193,
    73191, 73190, 73189, 73188, 73186, 73185, 73184, 73183, 73181, 73180, 73179, 73178, 73176, 73175,
    73174, 73173, 73171, 73170, 73169, 73168, 73166, 73165, 73164, 73163, 73161, 73160, 73159, 73158,
    73156, 73155, 73154, 73153, 73151, 73150, 73149, 73148, 73146, 73145, 73144, 73143, 73141, 73140,
    73139, 73138, 73136, 73135, 73134, 73133, 73131, 73130, 73129, 73128, 73126, 73125, 73124, 73123,
    73122, 73120, 73119, 73118, 73117, 73115, 73114, 73113, 73112, 73110, 73109, 73108, 73107, 73105,
    73104, 73103, 73102, 73100, 73099, 73098, 73097, 73095, 73094, 73093, 73092, 73090, 73089, 73088,
    73087, 73085, 73084, 73083, 73082, 73080, 73079, 73078, 73077, 73075, 73074, 73073, 73072, 73071,
    73069, 73068, 73067, 73066, 73064, 73063, 73062, 73061, 73059, 73058, 73057, 73056, 73054, 73053,
    73052, 73051, 73049, 73048, 73047, 73046, 73044, 73043, 73042, 73041, 73039, 73038, 73037, 73036,
    73034, 73033, 73032, 73031, 73030, 73028, 73027, 73026, 73025, 73023, 73022, 73021, 73020, 73018,
    73017, 73016, 73015, 73013, 73012, 73011, 73010, 73008, 73007, 73006, 73005, 73003, 73002, 73001,
    73000, 72998, 72997, 72996, 72995, 72994, 72992, 72991, 72990, 72989, 72987, 72986, 72985, 72984,
    72982, 72981, 72980, 72979, 72977, 72976, 72975, 72974, 72972, 72971, 72970, 72969, 72967, 72966,
    72965, 72964, 72963, 72961, 72960, 72959, 72958, 72956, 72955, 72954, 72953, 72951, 72950, 72949,
    72948, 72946, 72945, 72944, 72943, 72941, 72940, 72939, 72938, 72936, 72935, 72934, 72933, 72932,
    72930, 72929, 72928, 72927, 72925, 72924, 72923, 72922, 72920, 72919, 72918, 72917, 72915, 72914,
    72913, 72912, 72910, 72909, 72908, 72907, 72906, 72904, 72903, 72902, 72901, 72899, 72898, 72897,
    72896, 72894, 72893, 72892, 72891, 72889, 72888, 72887, 72886, 72885, 72883, 72882, 72881, 72880,
    72878, 72877, 72876, 72875, 72873, 72872, 72871, 72870, 72868, 72867, 72866, 72865, 72863, 72862,
    72861, 72860, 72859, 72857, 72856, 72855, 72854, 72852, 72851, 72850, 72849, 72847, 72846, 72845,
    72844, 72842, 72841, 72840, 72839, 72838, 72836, 72835, 72834, 72833, 72831, 72830, 72829, 72828,
    72826, 72825, 72824, 72823, 72821, 72820, 72819, 72818, 72817, 72815, 72814, 72813, 72812, 72810,
    72809, 72808, 72807, 72805, 72804, 72803, 72802, 72800, 72799, 72798, 72797, 72796, 72794, 72793,
    72792, 72791, 72789, 72788, 72787, 72786, 72784, 72783, 72782, 72781, 72780, 72778, 72777, 72776,
    72775, 72773, 72772, 72771, 72770, 72768, 72767, 72766, 72765, 72763, 72762, 72761, 72760, 72759,
    72757, 72756, 72755, 72754, 72752, 72751, 72750, 72749, 72747, 72746, 72745, 72744, 72743, 72741,
    72740, 72739, 72738, 72736, 72735, 72734, 72733, 72731, 72730, 72729, 72728, 72727, 72725, 72724,
    72723, 72722, 72720, 72719, 72718, 72717, 72715, 72714, 72713, 72712, 72711, 72709, 72708, 72707,
    72706, 72704, 72703, 72702, 72701, 72699, 72698, 72697, 72696, 72695, 72693, 72692, 72691, 72690,
    72688, 72687, 72686, 72685, 72683, 72682, 72681, 72680, 72679, 72677, 72676, 72675, 72674, 72672,
    72671, 72670, 72669, 72667, 72666, 72665, 72664, 72663, 72661, 72660, 72659, 72658, 72656, 72655,
    72654, 72653, 72651, 72650, 72649, 72648, 72647, 72645, 72644, 72643, 72642, 72640, 72639, 72638,
    72637, 72636, 72634, 72633, 72632, 72631, 72629, 72628, 72627, 72626, 72624, 72623, 72622, 72621,
    72620, 72618, 72617, 72616, 72615, 72613, 72612, 72611, 72610, 72608, 72607, 72606, 72605, 72604,
    72602, 72601, 72600, 72599, 72597, 72596, 72595, 72594, 72593, 72591, 72590, 72589, 72588, 72586,
    72585, 72584, 72583, 72582, 72580, 72579, 72578, 72577, 72575, 72574, 72573, 72572, 72570, 72569,
    72568, 72567, 72566, 72564, 72563, 72562, 72561, 72559, 72558, 72557, 72556, 72555, 72553, 72552,
    72551, 72550, 72548, 72547, 72546, 72545, 72544, 72542, 72541, 72540, 72539, 72537, 72536, 72535,
    72534, 72532, 72531, 72530, 72529, 72528, 72526, 72525, 72524, 72523, 72521, 72520, 72519, 72518,
    72517, 72515, 72514, 72513, 72512, 72510, 72509, 72508, 72507, 72506, 72504, 72503, 72502, 72501,
    72499, 72498, 72497, 72496, 72495, 72493, 72492, 72491, 72490, 72488, 72487, 72486, 72485, 72484,
    72482, 72481, 72480, 72479, 72477, 72476, 72475, 72474, 72473, 72471, 72470, 72469, 72468, 72466,
    72465, 72464, 72463, 72461, 72460, 72459, 72458, 72457, 72455, 72454, 72453, 72452, 72450, 72449,
    72448, 72447, 72446, 72444, 72443, 72442, 72441, 72439, 72438, 72437, 72436, 72435, 72433, 72432,
    72431, 72430, 72429, 72427, 72426, 72425, 72424, 72422, 72421, 72420, 72419, 72418, 72416, 72415,
    72414, 72413, 72411, 72410, 72409, 72408, 72407, 72405, 72404, 72403, 72402, 72400, 72399, 72398,
    72397, 72396, 72394, 72393, 72392, 72391, 72389, 72388, 72387, 72386, 72385, 72383, 72382, 72381,
    72380, 72378, 72377, 72376, 72375, 72374, 72372, 72371, 72370, 72369, 72367, 72366, 72365, 72364,
    72363, 72361, 72360, 72359, 72358, 72357, 72355, 72354, 72353, 72352, 72350, 72349, 72348, 72347,
    72346, 72344, 72343, 72342, 72341, 72339, 72338, 72337, 72336, 72335, 72333, 72332, 72331, 72330,
    72328, 72327, 72326, 72325, 72324, 72322, 72321, 72320, 72319, 72318, 72316, 72315, 72314, 72313,
    72311, 72310, 72309, 72308, 72307, 72305, 72304, 72303, 72302, 72300, 72299, 72298, 72297, 72296,
    72294, 72293, 72292, 72291, 72290, 72288, 72287, 72286, 72285, 72283, 72282, 72281, 72280, 72279,
    72277, 72276, 72275, 72274, 72272, 72271, 72270, 72269, 72268, 72266, 72265, 72264, 72263, 72262,
    72260, 72259, 72258, 72257, 72255, 72254, 72253, 72252, 72251, 72249, 72248, 72247, 72246, 72245,
    72243, 72242, 72241, 72240, 72238, 72237, 72236, 72235, 72234, 72232, 72231, 72230, 72229, 72228,
    72226, 72225, 72224, 72223, 72221, 72220, 72219, 72218, 72217, 72215, 72214, 72213, 72212, 72211,
    72209, 72208, 72207, 72206, 72204, 72203, 72202, 72201, 72200, 72198, 72197, 72196, 72195, 72194,
    72192, 72191, 72190, 72189, 72187, 72186, 72185, 72184, 72183, 72181, 72180, 72179, 72178, 72177,
    72175, 72174, 72173, 72172, 72170, 72169, 72168, 72167, 72166, 72164, 72163, 72162, 72161, 72160,
    72158, 72157, 72156, 72155, 72154, 72152, 72151, 72150, 72149, 72147, 72146, 72145, 72144, 72143,
    72141, 72140, 72139, 72138, 72137, 72135, 72134, 72133, 72132, 72130, 72129, 72128, 72127, 72126,
    72124, 72123, 72122, 72121, 72120, 72118, 72117, 72116, 72115, 72114, 72112, 72111, 72110, 72109,
    72107, 72106, 72105, 72104, 72103, 72101, 72100, 72099, 72098, 72097, 72095, 72094, 72093, 72092,
    72091, 72089, 72088, 72087, 72086, 72084, 72083, 72082, 72081, 72080, 72078, 72077, 72076, 72075,
    72074, 72072, 72071, 72070, 72069, 72068, 72066, 72065, 72064, 72063, 72062, 72060, 72059, 72058,
    72057, 72055, 72054, 72053, 72052, 72051, 72049, 72048, 72047, 72046, 72045, 72043, 72042, 72041,
    72040, 72039, 72037, 72036, 72035, 72034, 72032, 72031, 72030, 72029, 72028, 72026, 72025, 72024,
    72023, 72022, 72020, 72019, 72018, 72017, 72016, 72014, 72013, 72012, 72011, 72010, 72008, 72007,
    72006, 72005, 72004, 72002, 72001, 72000, 71999, 71997, 71996, 71995, 71994, 71993, 71991, 71990,
    71989, 71988, 71987, 71985, 71984, 71983, 71982, 71981, 71979, 71978, 71977, 71976, 71975, 71973,
    71972, 71971, 71970, 71969, 71967, 71966, 71965, 71964, 71962, 71961, 71960, 71959, 71958, 71956,
    71955, 71954, 71953, 71952, 71950, 71949, 71948, 71947, 71946, 71944, 71943, 71942, 71941, 71940,
    71938, 71937, 71936, 71935, 71934, 71932, 71931, 71930, 71929, 71928, 71926, 71925, 71924, 71923,
    71922, 71920, 71919, 71918, 71917, 71916, 71914, 71913, 71912, 71911, 71909, 71908, 71907, 71906,
    71905, 71903, 71902, 71901, 71900, 71899, 71897, 71896, 71895, 71894, 71893, 71891, 71890, 71889,
    71888, 71887, 71885, 71884, 71883, 71882, 71881, 71879, 71878, 71877, 71876, 71875, 71873, 71872,
    71871, 71870, 71869, 71867, 71866, 71865, 71864, 71863, 71861, 71860, 71859, 71858, 71857, 71855,
    71854, 71853, 71852, 71851, 71849, 71848, 71847, 71846, 71845, 71843, 71842, 71841, 71840, 71839,
    71837, 71836, 71835, 71834, 71833, 71831, 71830, 71829, 71828, 71827, 71825, 71824, 71823, 71822,
    71820, 71819, 71818, 71817, 71816, 71814, 71813, 71812, 71811, 71810, 71808, 71807, 71806, 71805,
    71804, 71802, 71801, 71800, 71799, 71798, 71796, 71795, 71794, 71793, 71792, 71790, 71789, 71788,
    71787, 71786, 71784, 71783, 71782, 71781, 71780, 71778, 71777, 71776, 71775, 71774, 71772, 71771,
    71770, 71769, 71768, 71766, 71765, 71764, 71763, 71762, 71760, 71759, 71758, 71757, 71756, 71755,
    71753, 71752, 71751, 71750, 71749, 71747, 71746, 71745, 71744, 71743, 71741, 71740, 71739, 71738,
    71737, 71735, 71734, 71733, 71732, 71731, 71729, 71728, 71727, 71726, 71725, 71723, 71722, 71721,
    71720, 71719, 71717, 71716, 71715, 71714, 71713, 71711, 71710, 71709, 71708, 71707, 71705, 71704,
    71703, 71702, 71701, 71699, 71698, 71697, 71696, 71695, 71693, 71692, 71691, 71690, 71689, 71687,
    71686, 71685, 71684, 71683, 71681, 71680, 71679, 71678, 71677, 71675, 71674, 71673, 71672, 71671,
    71669, 71668, 71667, 71666, 71665, 71664, 71662, 71661, 71660, 71659, 71658, 71656, 71655, 71654,
    71653, 71652, 71650, 71649, 71648, 71647, 71646, 71644, 71643, 71642, 71641, 71640, 71638, 71637,
    71636, 71635, 71634, 71632, 71631, 71630, 71629, 71628, 71626, 71625, 71624, 71623, 71622, 71620,
    71619, 71618, 71617, 71616, 71615, 71613, 71612, 71611, 71610, 71609, 71607, 71606, 71605, 71604,
    71603, 71601, 71600, 71599, 71598, 71597, 71595, 71594, 71593, 71592, 71591, 71589, 71588, 71587,
    71586, 71585, 71583, 71582, 71581, 71580, 71579, 71578, 71576, 71575, 71574, 71573, 71572, 71570,
    71569, 71568, 71567, 71566, 71564, 71563, 71562, 71561, 71560, 71558, 71557, 71556, 71555, 71554,
    71552, 71551, 71550, 71549, 71548, 71547, 71545, 71544, 71543, 71542, 71541, 71539, 71538, 71537,
    71536, 71535, 71533, 71532, 71531, 71530, 71529, 71527, 71526, 71525, 71524, 71523, 71521, 71520,
    71519, 71518, 71517, 71516, 71514, 71513, 71512, 71511, 71510, 71508, 71507, 71506, 71505, 71504,
    71502, 71501, 71500, 71499, 71498, 71496, 71495, 71494, 71493, 71492, 71491, 71489, 71488, 71487,
    71486, 71485, 71483, 71482, 71481, 71480, 71479, 71477, 71476, 71475, 71474, 71473, 71472, 71470,
    71469, 71468, 71467, 71466, 71464, 71463, 71462, 71461, 71460, 71458, 71457, 71456, 71455, 71454,
    71452, 71451, 71450, 71449, 71448, 71447, 71445, 71444, 71443, 71442, 71441, 71439, 71438, 71437,
    71436, 71435, 71433, 71432, 71431, 71430, 71429, 71428, 71426, 71425, 71424, 71423, 71422, 71420,
    71419, 71418, 71417, 71416, 71414, 71413, 71412, 71411, 71410, 71409, 71407, 71406, 71405, 71404,
    71403, 71401, 71400, 71399, 71398, 71397, 71395, 71394, 71393, 71392, 71391, 71390, 71388, 71387,
    71386, 71385, 71384, 71382, 71381, 71380, 71379, 71378, 71376, 71375, 71374, 71373, 71372, 71371,
    71369, 71368, 71367, 71366, 71365, 71363, 71362, 71361, 71360, 71359, 71358, 71356, 71355, 71354,
    71353, 71352, 71350, 71349, 71348, 71347, 71346, 71344, 71343, 71342, 71341, 71340, 71339, 71337,
    71336, 71335, 71334, 71333, 71331, 71330, 71329, 71328, 71327, 71326, 71324, 71323, 71322, 71321,
    71320, 71318, 71317, 71316, 71315, 71314, 71312, 71311, 71310, 71309, 71308, 71307, 71305, 71304,
    71303, 71302, 71301, 71299, 71298, 71297, 71296, 71295, 71294, 71292, 71291, 71290, 71289, 71288,
    71286, 71285, 71284, 71283, 71282, 71281, 71279, 71278, 71277, 71276, 71275, 71273, 71272, 71271,
    71270, 71269, 71268, 71266, 71265, 71264, 71263, 71262, 71260, 71259, 71258, 71257, 71256, 71255,
    71253, 71252, 71251, 71250, 71249, 71247, 71246, 71245, 71244, 71243, 71242, 71240, 71239, 71238,
    71237, 71236, 71234, 71233, 71232, 71231, 71230, 71229, 71227, 71226, 71225, 71224, 71223, 71221,
    71220, 71219, 71218, 71217, 71216, 71214, 71213, 71212, 71211, 71210, 71208, 71207, 71206, 71205,
    71204, 71203, 71201, 71200, 71199, 71198, 71197, 71195, 71194, 71193, 71192, 71191, 71190, 71188,
    71187, 71186, 71185, 71184, 71182, 71181, 71180, 71179, 71178, 71177, 71175, 71174, 71173, 71172,
    71171, 71170, 71168, 71167, 71166, 71165, 71164, 71162, 71161, 71160, 71159, 71158, 71157, 71155,
    71154, 71153, 71152, 71151, 71149, 71148, 71147, 71146, 71145, 71144, 71142, 71141, 71140, 71139,
    71138, 71137, 71135, 71134, 71133, 71132, 71131, 71129, 71128, 71127, 71126, 71125, 71124, 71122,
    71121, 71120, 71119, 71118, 71116, 71115, 71114, 71113, 71112, 71111, 71109, 71108, 71107, 71106,
    71105, 71104, 71102, 71101, 71100, 71099, 71098, 71096, 71095, 71094, 71093, 71092, 71091, 71089,
    71088, 71087, 71086, 71085, 71084, 71082, 71081, 71080, 71079, 71078, 71076, 71075, 71074, 71073,
    71072, 71071, 71069, 71068, 71067, 71066, 71065, 71064, 71062, 71061, 71060, 71059, 71058, 71056,
    71055, 71054, 71053, 71052, 71051, 71049, 71048, 71047, 71046, 71045, 71044, 71042, 71041, 71040,
    71039, 71038, 71036, 71035, 71034, 71033, 71032, 71031, 71029, 71028, 71027, 71026, 71025, 71024,
    71022, 71021, 71020, 71019, 71018, 71017, 71015, 71014, 71013, 71012, 71011, 71009, 71008, 71007,
    71006, 71005, 71004, 71002, 71001, 71000, 70999, 70998, 70997, 70995, 70994, 70993, 70992, 70991,
    70990, 70988, 70987, 70986, 70985, 70984, 70982, 70981, 70980, 70979, 70978, 70977, 70975, 70974,
    70973, 70972, 70971, 70970, 70968, 70967, 70966, 70965, 70964, 70963, 70961, 70960, 70959, 70958,
    70957, 70956, 70954, 70953, 70952, 70951, 70950, 70948, 70947, 70946, 70945, 70944, 70943, 70941,
    70940, 70939, 70938, 70937, 70936, 70934, 70933, 70932, 70931, 70930, 70929, 70927, 70926, 70925,
    70924, 70923, 70922, 70920, 70919, 70918, 70917, 70916, 70915, 70913, 70912, 70911, 70910, 70909,
    70907, 70906, 70905, 70904, 70903, 70902, 70900, 70899, 70898, 70897, 70896, 70895, 70893, 70892,
    70891, 70890, 70889, 70888, 70886, 70885, 70884, 70883, 70882, 70881, 70879, 70878, 70877, 70876,
    70875, 70874, 70872, 70871, 70870, 70869, 70868, 70867, 70865, 70864, 70863, 70862, 70861, 70860,
    70858, 70857, 70856, 70855, 70854, 70853, 70851, 70850, 70849, 70848, 70847, 70845, 70844, 70843,
    70842, 70841, 70840, 70838, 70837, 70836, 70835, 70834, 70833, 70831, 70830, 70829, 70828, 70827,
    70826, 70824, 70823, 70822, 70821, 70820, 70819, 70817, 70816, 70815, 70814, 70813, 70812, 70810,
    70809, 70808, 70807, 70806, 70805, 70803, 70802, 70801, 70800, 70799, 70798, 70796, 70795, 70794,
    70793, 70792, 70791, 70789, 70788, 70787, 70786, 70785, 70784, 70782, 70781, 70780, 70779, 70778,
    70777, 70775, 70774, 70773, 70772, 70771, 70770, 70768, 70767, 70766, 70765, 70764, 70763, 70761,
    70760, 70759, 70758, 70757, 70756, 70754, 70753, 70752, 70751, 70750, 70749, 70747, 70746, 70745,
    70744, 70743, 70742, 70740, 70739, 70738, 70737, 70736, 70735, 70733, 70732, 70731, 70730, 70729,
    70728, 70726, 70725, 70724, 70723, 70722, 70721, 70720, 70718, 70717, 70716, 70715, 70714, 70713,
    70711, 70710, 70709, 70708, 70707, 70706, 70704, 70703, 70702, 70701, 70700, 70699, 70697, 70696,
    70695, 70694, 70693, 70692, 70690, 70689, 70688, 70687, 70686, 70685, 70683, 70682, 70681, 70680,
    70679, 70678, 70676, 70675, 70674, 70673, 70672, 70671, 70669, 70668, 70667, 70666, 70665, 70664,
    70662, 70661, 70660, 70659, 70658, 70657, 70656, 70654, 70653, 70652, 70651, 70650, 70649, 70647,
    70646, 70645, 70644, 70643, 70642, 70640, 70639, 70638, 70637, 70636, 70635, 70633, 70632, 70631,
    70630, 70629, 70628, 70626, 70625, 70624, 70623, 70622, 70621, 70620, 70618, 70617, 70616, 70615,
    70614, 70613, 70611, 70610, 70609, 70608, 70607, 70606, 70604, 70603, 70602, 70601, 70600, 70599,
    70597, 70596, 70595, 70594, 70593, 70592, 70590, 70589, 70588, 70587, 70586, 70585, 70584, 70582,
    70581, 70580, 70579, 70578, 70577, 70575, 70574, 70573, 70572, 70571, 70570, 70568, 70567, 70566,
    70565, 70564, 70563, 70561, 70560, 70559, 70558, 70557, 70556, 70555, 70553, 70552, 70551, 70550,
    70549, 70548, 70546, 70545, 70544, 70543, 70542, 70541, 70539, 70538, 70537, 70536, 70535, 70534,
    70533, 70531, 70530, 70529, 70528, 70527, 70526, 70524, 70523, 70522, 70521, 70520, 70519, 70517,
    70516, 70515, 70514, 70513, 70512, 70511, 70509, 70508, 70507, 70506, 70505, 70504, 70502, 70501,
    70500, 70499, 70498, 70497, 70495, 70494, 70493, 70492, 70491, 70490, 70489, 70487, 70486, 70485,
    70484, 70483, 70482, 70480, 70479, 70478, 70477, 70476, 70475, 70474, 70472, 70471, 70470, 70469,
    70468, 70467, 70465, 70464, 70463, 70462, 70461, 70460, 70458, 70457, 70456, 70455, 70454, 70453,
    70452, 70450, 70449, 70448, 70447, 70446, 70445, 70443, 70442, 70441, 70440, 70439, 70438, 70437,
    70435, 70434, 70433, 70432, 70431, 70430, 70428, 70427, 70426, 70425, 70424, 70423, 70422, 70420,
    70419, 70418, 70417, 70416, 70415, 70413, 70412, 70411, 70410, 70409, 70408, 70406, 70405, 70404,
    70403, 70402, 70401, 70400, 70398, 70397, 70396, 70395, 70394, 70393, 70391, 70390, 70389, 70388,
    70387, 70386, 70385, 70383, 70382, 70381, 70380, 70379, 70378, 70376, 70375, 70374, 70373, 70372,
    70371, 70370, 70368, 70367, 70366, 70365, 70364, 70363, 70362, 70360, 70359, 70358, 70357, 70356,
    70355, 70353, 70352, 70351, 70350, 70349, 70348, 70347, 70345, 70344, 70343, 70342, 70341, 70340,
    70338, 70337, 70336, 70335, 70334, 70333, 70332, 70330, 70329, 70328, 70327, 70326, 70325, 70323,
    70322, 70321, 70320, 70319, 70318, 70317, 70315, 70314, 70313, 70312, 70311, 70310, 70309, 70307,
    70306, 70305, 70304, 70303, 70302, 70300, 70299, 70298, 70297, 70296, 70295, 70294, 70292, 70291,
    70290, 70289, 70288, 70287, 70286, 70284, 70283, 70282, 70281, 70280, 70279, 70277, 70276, 70275,
    70274, 70273, 70272, 70271, 70269, 70268, 70267, 70266, 70265, 70264, 70263, 70261, 70260, 70259,
    70258, 70257, 70256, 70254, 70253, 70252, 70251, 70250, 70249, 70248, 70246, 70245, 70244, 70243,
    70242, 70241, 70240, 70238, 70237, 70236, 70235, 70234, 70233, 70231, 70230, 70229, 70228, 70227,
    70226, 70225, 70223, 70222, 70221, 70220, 70219, 70218, 70217, 70215, 70214, 70213, 70212, 70211,
    70210, 70209, 70207, 70206, 70205, 70204, 70203, 70202, 70201, 70199, 70198, 70197, 70196, 70195,
    70194, 70192, 70191, 70190, 70189, 70188, 70187, 70186, 70184, 70183, 70182, 70181, 70180, 70179,
    70178, 70176, 70175, 70174, 70173, 70172, 70171, 70170, 70168, 70167, 70166, 70165, 70164, 70163,
    70162, 70160, 70159, 70158, 70157, 70156, 70155, 70153, 70152, 70151, 70150, 70149, 70148, 70147,
    70145, 70144, 70143, 70142, 70141, 70140, 70139, 70137, 70136, 70135, 70134, 70133, 70132, 70131,
    70129, 70128, 70127, 70126, 70125, 70124, 70123, 70121, 70120, 70119, 70118, 70117, 70116, 70115,
    70113, 70112, 70111, 70110, 70109, 70108, 70107, 70105, 70104, 70103, 70102, 70101, 70100, 70099,
    70097, 70096, 70095, 70094, 70093, 70092, 70091, 70089, 70088, 70087, 70086, 70085, 70084, 70083,
    70081, 70080, 70079, 70078, 70077, 70076, 70075, 70073, 70072, 70071, 70070, 70069, 70068, 70067,
    70065, 70064, 70063, 70062, 70061, 70060, 70059, 70057, 70056, 70055, 70054, 70053, 70052, 70051,
    70049, 70048, 70047, 70046, 70045, 70044, 70043, 70041, 70040, 70039, 70038, 70037, 70036, 70035,
    70033, 70032, 70031, 70030, 70029, 70028, 70027, 70025, 70024, 70023, 70022, 70021, 70020, 70019,
    70017, 70016, 70015, 70014, 70013, 70012, 70011, 70009, 70008, 70007, 70006, 70005, 70004, 70003,
    70001, 70000, 69999, 69998, 69997, 69996, 69995, 69993, 69992, 69991, 69990, 69989, 69988, 69987,
    69985, 69984, 69983, 69982, 69981, 69980, 69979, 69977, 69976, 69975, 69974, 69973, 69972, 69971,
    69969, 69968, 69967, 69966, 69965, 69964, 69963, 69962, 69960, 69959, 69958, 69957, 69956, 69955,
    69954, 69952, 69951, 69950, 69949, 69948, 69947, 69946, 69944, 69943, 69942, 69941, 69940, 69939,
    69938, 69936, 69935, 69934, 69933, 69932, 69931, 69930, 69928, 69927, 69926, 69925, 69924, 69923,
    69922, 69921, 69919, 69918, 69917, 69916, 69915, 69914, 69913, 69911, 69910, 69909, 69908, 69907,
    69906, 69905, 69903, 69902, 69901, 69900, 69899, 69898, 69897, 69895, 69894, 69893, 69892, 69891,
    69890, 69889, 69888, 69886, 69885, 69884, 69883, 69882, 69881, 69880, 69878, 69877, 69876, 69875,
    69874, 69873, 69872, 69870, 69869, 69868, 69867, 69866, 69865, 69864, 69862, 69861, 69860, 69859,
    69858, 69857, 69856, 69855, 69853, 69852, 69851, 69850, 69849, 69848, 69847, 69845, 69844, 69843,
    69842, 69841, 69840, 69839, 69838, 69836, 69835, 69834, 69833, 69832, 69831, 69830, 69828, 69827,
    69826, 69825, 69824, 69823, 69822, 69820, 69819, 69818, 69817, 69816, 69815, 69814, 69813, 69811,
    69810, 69809, 69808, 69807, 69806, 69805, 69803, 69802, 69801, 69800, 69799, 69798, 69797, 69796,
    69794, 69793, 69792, 69791, 69790, 69789, 69788, 69786, 69785, 69784, 69783, 69782, 69781, 69780,
    69779, 69777, 69776, 69775, 69774, 69773, 69772, 69771, 69769, 69768, 69767, 69766, 69765, 69764,
    69763, 69762, 69760, 69759, 69758, 69757, 69756, 69755, 69754, 69752, 69751, 69750, 69749, 69748,
    69747, 69746, 69745, 69743, 69742, 69741, 69740, 69739, 69738, 69737, 69735, 69734, 69733, 69732,
    69731, 69730, 69729, 69728, 69726, 69725, 69724, 69723, 69722, 69721, 69720, 69718, 69717, 69716,
    69715, 69714, 69713, 69712, 69711, 69709, 69708, 69707, 69706, 69705, 69704, 69703, 69701, 69700,
    69699, 69698, 69697, 69696, 69695, 69694, 69692, 69691, 69690, 69689, 69688, 69687, 69686, 69685,
    69683, 69682, 69681, 69680, 69679, 69678, 69677, 69675, 69674, 69673, 69672, 69671, 69670, 69669,
    69668, 69666, 69665, 69664, 69663, 69662, 69661, 69660, 69659, 69657, 69656, 69655, 69654, 69653,
    69652, 69651, 69650, 69648, 69647, 69646, 69645, 69644, 69643, 69642, 69640, 69639, 69638, 69637,
    69636, 69635, 69634, 69633, 69631, 69630, 69629, 69628, 69627, 69626, 69625, 69624, 69622, 69621,
    69620, 69619, 69618, 69617, 69616, 69615, 69613, 69612, 69611, 69610, 69609, 69608, 69607, 69605,
    69604, 69603, 69602, 69601, 69600, 69599, 69598, 69596, 69595, 69594, 69593, 69592, 69591, 69590,
    69589, 69587, 69586, 69585, 69584, 69583, 69582, 69581, 69580, 69578, 69577, 69576, 69575, 69574,
    69573, 69572, 69571, 69569, 69568, 69567, 69566, 69565, 69564, 69563, 69562, 69560, 69559, 69558,
    69557, 69556, 69555, 69554, 69553, 69551, 69550, 69549, 69548, 69547, 69546, 69545, 69543, 69542,
    69541, 69540, 69539, 69538, 69537, 69536, 69534, 69533, 69532, 69531, 69530, 69529, 69528, 69527,
    69525, 69524, 69523, 69522, 69521, 69520, 69519, 69518, 69516, 69515, 69514, 69513, 69512, 69511,
    69510, 69509, 69507, 69506, 69505, 69504, 69503, 69502, 69501, 69500, 69498, 69497, 69496, 69495,
    69494, 69493, 69492, 69491, 69489, 69488, 69487, 69486, 69485, 69484, 69483, 69482, 69480, 69479,
    69478, 69477, 69476, 69475, 69474, 69473, 69472, 69470, 69469, 69468, 69467, 69466, 69465, 69464,
    69463, 69461, 69460, 69459, 69458, 69457, 69456, 69455, 69454, 69452, 69451, 69450, 69449, 69448,
    69447, 69446, 69445, 69443, 69442, 69441, 69440, 69439, 69438, 69437, 69436, 69434, 69433, 69432,
    69431, 69430, 69429, 69428, 69427, 69425, 69424, 69423, 69422, 69421, 69420, 69419, 69418, 69416,
    69415, 69414, 69413, 69412, 69411, 69410, 69409, 69408, 69406, 69405, 69404, 69403, 69402, 69401,
    69400, 69399, 69397, 69396, 69395, 69394, 69393, 69392, 69391, 69390, 69388, 69387, 69386, 69385,
    69384, 69383, 69382, 69381, 69379, 69378, 69377, 69376, 69375, 69374, 69373, 69372, 69371, 69369,
    69368, 69367, 69366, 69365, 69364, 69363, 69362, 69360, 69359, 69358, 69357, 69356, 69355, 69354,
    69353, 69351, 69350, 69349, 69348, 69347, 69346, 69345, 69344, 69343, 69341, 69340, 69339, 69338,
    69337, 69336, 69335, 69334, 69332, 69331, 69330, 69329, 69328, 69327, 69326, 69325, 69323, 69322,
    69321, 69320, 69319, 69318, 69317, 69316, 69315, 69313, 69312, 69311, 69310, 69309, 69308, 69307,
    69306, 69304, 69303, 69302, 69301, 69300, 69299, 69298, 69297, 69296, 69294, 69293, 69292, 69291,
    69290, 69289, 69288, 69287, 69285, 69284, 69283, 69282, 69281, 69280, 69279, 69278, 69277, 69275,
    69274, 69273, 69272, 69271, 69270, 69269, 69268, 69266, 69265, 69264, 69263, 69262, 69261, 69260,
    69259, 69258, 69256, 69255, 69254, 69253, 69252, 69251, 69250, 69249, 69247, 69246, 69245, 69244,
    69243, 69242, 69241, 69240, 69239, 69237, 69236, 69235, 69234, 69233, 69232, 69231, 69230, 69229,
    69227, 69226, 69225, 69224, 69223, 69222, 69221, 69220, 69218, 69217, 69216, 69215, 69214, 69213,
    69212, 69211, 69210, 69208, 69207, 69206, 69205, 69204, 69203, 69202, 69201, 69200, 69198, 69197,
    69196, 69195, 69194, 69193, 69192, 69191, 69189, 69188, 69187, 69186, 69185, 69184, 69183, 69182,
    69181, 69179, 69178, 69177, 69176, 69175, 69174, 69173, 69172, 69171, 69169, 69168, 69167, 69166,
    69165, 69164, 69163, 69162, 69161, 69159, 69158, 69157, 69156, 69155, 69154, 69153, 69152, 69150,
    69149, 69148, 69147, 69146, 69145, 69144, 69143, 69142, 69140, 69139, 69138, 69137, 69136, 69135,
    69134, 69133, 69132, 69130, 69129, 69128, 69127, 69126, 69125, 69124, 69123, 69122, 69120, 69119,
    69118, 69117, 69116, 69115, 69114, 69113, 69112, 69110, 69109, 69108, 69107, 69106, 69105, 69104,
    69103, 69102, 69100, 69099, 69098, 69097, 69096, 69095, 69094, 69093, 69092, 69090, 69089, 69088,
    69087, 69086, 69085, 69084, 69083, 69082, 69080, 69079, 69078, 69077, 69076, 69075, 69074, 69073,
    69072, 69070, 69069, 69068, 69067, 69066, 69065, 69064, 69063, 69062, 69060, 69059, 69058, 69057,
    69056, 69055, 69054, 69053, 69052, 69050, 69049, 69048, 69047, 69046, 69045, 69044, 69043, 69042,
    69040, 69039, 69038, 69037, 69036, 69035, 69034, 69033, 69032, 69030, 69029, 69028, 69027, 69026,
    69025, 69024, 69023, 69022, 69020, 69019, 69018, 69017, 69016, 69015, 69014, 69013, 69012, 69010,
    69009, 69008, 69007, 69006, 69005, 69004, 69003, 69002, 69001, 68999, 68998, 68997, 68996, 68995,
    68994, 68993, 68992, 68991, 68989, 68988, 68987, 68986, 68985, 68984, 68983, 68982, 68981, 68979,
    68978, 68977, 68976, 68975, 68974, 68973, 68972, 68971, 68969, 68968, 68967, 68966, 68965, 68964,
    68963, 68962, 68961, 68960, 68958, 68957, 68956, 68955, 68954, 68953, 68952, 68951, 68950, 68948,
    68947, 68946, 68945, 68944, 68943, 68942, 68941, 68940, 68938, 68937, 68936, 68935, 68934, 68933,
    68932, 68931, 68930, 68929, 68927, 68926, 68925, 68924, 68923, 68922, 68921, 68920, 68919, 68917,
    68916, 68915, 68914, 68913, 68912, 68911, 68910, 68909, 68908, 68906, 68905, 68904, 68903, 68902,
    68901, 68900, 68899, 68898, 68896, 68895, 68894, 68893, 68892, 68891, 68890, 68889, 68888, 68887,
    68885, 68884, 68883, 68882, 68881, 68880, 68879, 68878, 68877, 68875, 68874, 68873, 68872, 68871,
    68870, 68869, 68868, 68867, 68866, 68864, 68863, 68862, 68861, 68860, 68859, 68858, 68857, 68856,
    68854, 68853, 68852, 68851, 68850, 68849, 68848, 68847, 68846, 68845, 68843, 68842, 68841, 68840,
    68839, 68838, 68837, 68836, 68835, 68834, 68832, 68831, 68830, 68829, 68828, 68827, 68826, 68825,
    68824, 68822, 68821, 68820, 68819, 68818, 68817, 68816, 68815, 68814, 68813, 68811, 68810, 68809,
    68808, 68807, 68806, 68805, 68804, 68803, 68802, 68800, 68799, 68798, 68797, 68796, 68795, 68794,
    68793, 68792, 68791, 68789, 68788, 68787, 68786, 68785, 68784, 68783, 68782, 68781, 68780, 68778,
    68777, 68776, 68775, 68774, 68773, 68772, 68771, 68770, 68768, 68767, 68766, 68765, 68764, 68763,
    68762, 68761, 68760, 68759, 68757, 68756, 68755, 68754, 68753, 68752, 68751, 68750, 68749, 68748,
    68746, 68745, 68744, 68743, 68742, 68741, 68740, 68739, 68738, 68737, 68735, 68734, 68733, 68732,
    68731, 68730, 68729, 68728, 68727, 68726, 68724, 68723, 68722, 68721, 68720, 68719, 68718, 68717,
    68716, 68715, 68713, 68712, 68711, 68710, 68709, 68708, 68707, 68706, 68705, 68704, 68702, 68701,
    68700, 68699, 68698, 68697, 68696, 68695, 68694, 68693, 68692, 68690, 68689, 68688, 68687, 68686,
    68685, 68684, 68683, 68682, 68681, 68679, 68678, 68677, 68676, 68675, 68674, 68673, 68672, 68671,
    68670, 68668, 68667, 68666, 68665, 68664, 68663, 68662, 68661, 68660, 68659, 68657, 68656, 68655,
    68654, 68653, 68652, 68651, 68650, 68649, 68648, 68646, 68645, 68644, 68643, 68642, 68641, 68640,
    68639, 68638, 68637, 68636, 68634, 68633, 68632, 68631, 68630, 68629, 68628, 68627, 68626, 68625,
    68623, 68622, 68621, 68620, 68619, 68618, 68617, 68616, 68615, 68614, 68612, 68611, 68610, 68609,
    68608, 68607, 68606, 68605, 68604, 68603, 68602, 68600, 68599, 68598, 68597, 68596, 68595, 68594,
    68593, 68592, 68591, 68589, 68588, 68587, 68586, 68585, 68584, 68583, 68582, 68581, 68580, 68579,
    68577, 68576, 68575, 68574, 68573, 68572, 68571, 68570, 68569, 68568, 68566, 68565, 68564, 68563,
    68562, 68561, 68560, 68559, 68558, 68557, 68556, 68554, 68553, 68552, 68551, 68550, 68549, 68548,
    68547, 68546, 68545, 68544, 68542, 68541, 68540, 68539, 68538, 68537, 68536, 68535, 68534, 68533,
    68531, 68530, 68529, 68528, 68527, 68526, 68525, 68524, 68523, 68522, 68521, 68519, 68518, 68517,
    68516, 68515, 68514, 68513, 68512, 68511, 68510, 68509, 68507, 68506, 68505, 68504, 68503, 68502,
    68501, 68500, 68499, 68498, 68497, 68495, 68494, 68493, 68492, 68491, 68490, 68489, 68488, 68487,
    68486, 68484, 68483, 68482, 68481, 68480, 68479, 68478, 68477, 68476, 68475, 68474, 68472, 68471,
    68470, 68469, 68468, 68467, 68466, 68465, 68464, 68463, 68462, 68460, 68459, 68458, 68457, 68456,
    68455, 68454, 68453, 68452, 68451, 68450, 68448, 68447, 68446, 68445, 68444, 68443, 68442, 68441,
    68440, 68439, 68438, 68436, 68435, 68434, 68433, 68432, 68431, 68430, 68429, 68428, 68427, 68426,
    68424, 68423, 68422, 68421, 68420, 68419, 68418, 68417, 68416, 68415, 68414, 68412, 68411, 68410,
    68409, 68408, 68407, 68406, 68405, 68404, 68403, 68402, 68401, 68399, 68398, 68397, 68396, 68395,
    68394, 68393, 68392, 68391, 68390, 68389, 68387, 68386, 68385, 68384, 68383, 68382, 68381, 68380,
    68379, 68378, 68377, 68375, 68374, 68373, 68372, 68371, 68370, 68369, 68368, 68367, 68366, 68365,
    68363, 68362, 68361, 68360, 68359, 68358, 68357, 68356, 68355, 68354, 68353, 68352, 68350, 68349,
    68348, 68347, 68346, 68345, 68344, 68343, 68342, 68341, 68340, 68338, 68337, 68336, 68335, 68334,
    68333, 68332, 68331, 68330, 68329, 68328, 68327, 68325, 68324, 68323, 68322, 68321, 68320, 68319,
    68318, 68317, 68316, 68315, 68313, 68312, 68311, 68310, 68309, 68308, 68307, 68306, 68305, 68304,
    68303, 68302, 68300, 68299, 68298, 68297, 68296, 68295, 68294, 68293, 68292, 68291, 68290, 68288,
    68287, 68286, 68285, 68284, 68283, 68282, 68281, 68280, 68279, 68278, 68277, 68275, 68274, 68273,
    68272, 68271, 68270, 68269, 68268, 68267, 68266, 68265, 68264, 68262, 68261, 68260, 68259, 68258,
    68257, 68256, 68255, 68254, 68253, 68252, 68251, 68249, 68248, 68247, 68246, 68245, 68244, 68243,
    68242, 68241, 68240, 68239, 68237, 68236, 68235, 68234, 68233, 68232, 68231, 68230, 68229, 68228,
    68227, 68226, 68224, 68223, 68222, 68221, 68220, 68219, 68218, 68217, 68216, 68215, 68214, 68213,
    68211, 68210, 68209, 68208, 68207, 68206, 68205, 68204, 68203, 68202, 68201, 68200, 68198, 68197,
    68196, 68195, 68194, 68193, 68192, 68191, 68190, 68189, 68188, 68187, 68185, 68184, 68183, 68182,
    68181, 68180, 68179, 68178, 68177, 68176, 68175, 68174, 68173, 68171, 68170, 68169, 68168, 68167,
    68166, 68165, 68164, 68163, 68162, 68161, 68160, 68158, 68157, 68156, 68155, 68154, 68153, 68152,
    68151, 68150, 68149, 68148, 68147, 68145, 68144, 68143, 68142, 68141, 68140, 68139, 68138, 68137,
    68136, 68135, 68134, 68132, 68131, 68130, 68129, 68128, 68127, 68126, 68125, 68124, 68123, 68122,
    68121, 68120, 68118, 68117, 68116, 68115, 68114, 68113, 68112, 68111, 68110, 68109, 68108, 68107,
    68105, 68104, 68103, 68102, 68101, 68100, 68099, 68098, 68097, 68096, 68095, 68094, 68093, 68091,
    68090, 68089, 68088, 68087, 68086, 68085, 68084, 68083, 68082, 68081, 68080, 68078, 68077, 68076,
    68075, 68074, 68073, 68072, 68071, 68070, 68069, 68068, 68067, 68066, 68064, 68063, 68062, 68061,
    68060, 68059, 68058, 68057, 68056, 68055, 68054, 68053, 68052, 68050, 68049, 68048, 68047, 68046,
    68045, 68044, 68043, 68042, 68041, 68040, 68039, 68038, 68036, 68035, 68034, 68033, 68032, 68031,
    68030, 68029, 68028, 68027, 68026, 68025, 68024, 68022, 68021, 68020, 68019, 68018, 68017, 68016,
    68015, 68014, 68013, 68012, 68011, 68010, 68008, 68007, 68006, 68005, 68004, 68003, 68002, 68001,
    68000, 67999, 67998, 67997, 67996, 67994, 67993, 67992, 67991, 67990, 67989, 67988, 67987, 67986,
    67985, 67984, 67983, 67982, 67980, 67979, 67978, 67977, 67976, 67975, 67974, 67973, 67972, 67971,
    67970, 67969, 67968, 67966, 67965, 67964, 67963, 67962, 67961, 67960, 67959, 67958, 67957, 67956,
    67955, 67954, 67952, 67951, 67950, 67949, 67948, 67947, 67946, 67945, 67944, 67943, 67942, 67941,
    67940, 67938, 67937, 67936, 67935, 67934, 67933, 67932, 67931, 67930, 67929, 67928, 67927, 67926,
    67925, 67923, 67922, 67921, 67920, 67919, 67918, 67917, 67916, 67915, 67914, 67913, 67912, 67911,
    67909, 67908, 67907, 67906, 67905, 67904, 67903, 67902, 67901, 67900, 67899, 67898, 67897, 67896,
    67894, 67893, 67892, 67891, 67890, 67889, 67888, 67887, 67886, 67885, 67884, 67883, 67882, 67881,
    67879, 67878, 67877, 67876, 67875, 67874, 67873, 67872, 67871, 67870, 67869, 67868, 67867, 67865,
    67864, 67863, 67862, 67861, 67860, 67859, 67858, 67857, 67856, 67855, 67854, 67853, 67852, 67850,
    67849, 67848, 67847, 67846, 67845, 67844, 67843, 67842, 67841, 67840, 67839, 67838, 67837, 67835,
    67834, 67833, 67832, 67831, 67830, 67829, 67828, 67827, 67826, 67825, 67824, 67823, 67822, 67820,
    67819, 67818, 67817, 67816, 67815, 67814, 67813, 67812, 67811, 67810, 67809, 67808, 67807, 67805,
    67804, 67803, 67802, 67801, 67800, 67799, 67798, 67797, 67796, 67795, 67794, 67793, 67792, 67791,
    67789, 67788, 67787, 67786, 67785, 67784, 67783, 67782, 67781, 67780, 67779, 67778, 67777, 67776,
    67774, 67773, 67772, 67771, 67770, 67769, 67768, 67767, 67766, 67765, 67764, 67763, 67762, 67761,
    67759, 67758, 67757, 67756, 67755, 67754, 67753, 67752, 67751, 67750, 67749, 67748, 67747, 67746,
    67745, 67743, 67742, 67741, 67740, 67739, 67738, 67737, 67736, 67735, 67734, 67733, 67732, 67731,
    67730, 67729, 67727, 67726, 67725, 67724, 67723, 67722, 67721, 67720, 67719, 67718, 67717, 67716,
    67715, 67714, 67712, 67711, 67710, 67709, 67708, 67707, 67706, 67705, 67704, 67703, 67702, 67701,
    67700, 67699, 67698, 67696, 67695, 67694, 67693, 67692, 67691, 67690, 67689, 67688, 67687, 67686,
    67685, 67684, 67683, 67682, 67680, 67679, 67678, 67677, 67676, 67675, 67674, 67673, 67672, 67671,
    67670, 67669, 67668, 67667, 67666, 67664, 67663, 67662, 67661, 67660, 67659, 67658, 67657, 67656,
    67655, 67654, 67653, 67652, 67651, 67650, 67649, 67647, 67646, 67645, 67644, 67643, 67642, 67641,
    67640, 67639, 67638, 67637, 67636, 67635, 67634, 67633, 67631, 67630, 67629, 67628, 67627, 67626,
    67625, 67624, 67623, 67622, 67621, 67620, 67619, 67618, 67617, 67615, 67614, 67613, 67612, 67611,
    67610, 67609, 67608, 67607, 67606, 67605, 67604, 67603, 67602, 67601, 67600, 67598, 67597, 67596,
    67595, 67594, 67593, 67592, 67591, 67590, 67589, 67588, 67587, 67586, 67585, 67584, 67583, 67581,
    67580, 67579, 67578, 67577, 67576, 67575, 67574, 67573, 67572, 67571, 67570, 67569, 67568, 67567,
    67565, 67564, 67563, 67562, 67561, 67560, 67559, 67558, 67557, 67556, 67555, 67554, 67553, 67552,
    67551, 67550, 67548, 67547, 67546, 67545, 67544, 67543, 67542, 67541, 67540, 67539, 67538, 67537,
    67536, 67535, 67534, 67533, 67531, 67530, 67529, 67528, 67527, 67526, 67525, 67524, 67523, 67522,
    67521, 67520, 67519, 67518, 67517, 67516, 67515, 67513, 67512, 67511, 67510, 67509, 67508, 67507,
    67506, 67505, 67504, 67503, 67502, 67501, 67500, 67499, 67498, 67496, 67495, 67494, 67493, 67492,
    67491, 67490, 67489, 67488, 67487, 67486, 67485, 67484, 67483, 67482, 67481, 67480, 67478, 67477,
    67476, 67475, 67474, 67473, 67472, 67471, 67470, 67469, 67468, 67467, 67466, 67465, 67464, 67463,
    67461, 67460, 67459, 67458, 67457, 67456, 67455, 67454, 67453, 67452, 67451, 67450, 67449, 67448,
    67447, 67446, 67445, 67443, 67442, 67441, 67440, 67439, 67438, 67437, 67436, 67435, 67434, 67433,
    67432, 67431, 67430, 67429, 67428, 67427, 67425, 67424, 67423, 67422, 67421, 67420, 67419, 67418,
    67417, 67416, 67415, 67414, 67413, 67412, 67411, 67410, 67409, 67407, 67406, 67405, 67404, 67403,
    67402, 67401, 67400, 67399, 67398, 67397, 67396, 67395, 67394, 67393, 67392, 67391, 67390, 67388,
    67387, 67386, 67385, 67384, 67383, 67382, 67381, 67380, 67379, 67378, 67377, 67376, 67375, 67374,
    67373, 67372, 67370, 67369, 67368, 67367, 67366, 67365, 67364, 67363, 67362, 67361, 67360, 67359,
    67358, 67357, 67356, 67355, 67354, 67353, 67351, 67350, 67349, 67348, 67347, 67346, 67345, 67344,
    67343, 67342, 67341, 67340, 67339, 67338, 67337, 67336, 67335, 67334, 67332, 67331, 67330, 67329,
    67328, 67327, 67326, 67325, 67324, 67323, 67322, 67321, 67320, 67319, 67318, 67317, 67316, 67315,
    67313, 67312, 67311, 67310, 67309, 67308, 67307, 67306, 67305, 67304, 67303, 67302, 67301, 67300,
    67299, 67298, 67297, 67296, 67294, 67293, 67292, 67291, 67290, 67289, 67288, 67287, 67286, 67285,
    67284, 67283, 67282, 67281, 67280, 67279, 67278, 67277, 67276, 67274, 67273, 67272, 67271, 67270,
    67269, 67268, 67267, 67266, 67265, 67264, 67263, 67262, 67261, 67260, 67259, 67258, 67257, 67255,
    67254, 67253, 67252, 67251, 67250, 67249, 67248, 67247, 67246, 67245, 67244, 67243, 67242, 67241,
    67240, 67239, 67238, 67237, 67235, 67234, 67233, 67232, 67231, 67230, 67229, 67228, 67227, 67226,
    67225, 67224, 67223, 67222, 67221, 67220, 67219, 67218, 67217, 67215, 67214, 67213, 67212, 67211,
    67210, 67209, 67208, 67207, 67206, 67205, 67204, 67203, 67202, 67201, 67200, 67199, 67198, 67197,
    67196, 67194, 67193, 67192, 67191, 67190, 67189, 67188, 67187, 67186, 67185, 67184, 67183, 67182,
    67181, 67180, 67179, 67178, 67177, 67176, 67174, 67173, 67172, 67171, 67170, 67169, 67168, 67167,
    67166, 67165, 67164, 67163, 67162, 67161, 67160, 67159, 67158, 67157, 67156, 67155, 67153, 67152,
    67151, 67150, 67149, 67148, 67147, 67146, 67145, 67144, 67143, 67142, 67141, 67140, 67139, 67138,
    67137, 67136, 67135, 67134, 67132, 67131, 67130, 67129, 67128, 67127, 67126, 67125, 67124, 67123,
    67122, 67121, 67120, 67119, 67118, 67117, 67116, 67115, 67114, 67113, 67112, 67110, 67109, 67108,
    67107, 67106, 67105, 67104, 67103, 67102, 67101, 67100, 67099, 67098, 67097, 67096, 67095, 67094,
    67093, 67092, 67091, 67089, 67088, 67087, 67086, 67085, 67084, 67083, 67082, 67081, 67080, 67079,
    67078, 67077, 67076, 67075, 67074, 67073, 67072, 67071, 67070, 67069, 67067, 67066, 67065, 67064,
    67063, 67062, 67061, 67060, 67059, 67058, 67057, 67056, 67055, 67054, 67053, 67052, 67051, 67050,
    67049, 67048, 67047, 67046, 67044, 67043, 67042, 67041, 67040, 67039, 67038, 67037, 67036, 67035,
    67034, 67033, 67032, 67031, 67030, 67029, 67028, 67027, 67026, 67025, 67024, 67022, 67021, 67020,
    67019, 67018, 67017, 67016, 67015, 67014, 67013, 67012, 67011, 67010, 67009, 67008, 67007, 67006,
    67005, 67004, 67003, 67002, 67001, 66999, 66998, 66997, 66996, 66995, 66994, 66993, 66992, 66991,
    66990, 66989, 66988, 66987, 66986, 66985, 66984, 66983, 66982, 66981, 66980, 66979, 66978, 66977,
    66975, 66974, 66973, 66972, 66971, 66970, 66969, 66968, 66967, 66966, 66965, 66964, 66963, 66962,
    66961, 66960, 66959, 66958, 66957, 66956, 66955, 66954, 66952, 66951, 66950, 66949, 66948, 66947,
    66946, 66945, 66944, 66943, 66942, 66941, 66940, 66939, 66938, 66937, 66936, 66935, 66934, 66933,
    66932, 66931, 66930, 66928, 66927, 66926, 66925, 66924, 66923, 66922, 66921, 66920, 66919, 66918,
    66917, 66916, 66915, 66914, 66913, 66912, 66911, 66910, 66909, 66908, 66907, 66906, 66905, 66903,
    66902, 66901, 66900, 66899, 66898, 66897, 66896, 66895, 66894, 66893, 66892, 66891, 66890, 66889,
    66888, 66887, 66886, 66885, 66884, 66883, 66882, 66881, 66880, 66878, 66877, 66876, 66875, 66874,
    66873, 66872, 66871, 66870, 66869, 66868, 66867, 66866, 66865, 66864, 66863, 66862, 66861, 66860,
    66859, 66858, 66857, 66856, 66855, 66853, 66852, 66851, 66850, 66849, 66848, 66847, 66846, 66845,
    66844, 66843, 66842, 66841, 66840, 66839, 66838, 66837, 66836, 66835, 66834, 66833, 66832, 66831,
    66830, 66829, 66827, 66826, 66825, 66824, 66823, 66822, 66821, 66820, 66819, 66818, 66817, 66816,
    66815, 66814, 66813, 66812, 66811, 66810, 66809, 66808, 66807, 66806, 66805, 66804, 66803, 66801,
    66800, 66799, 66798, 66797, 66796, 66795, 66794, 66793, 66792, 66791, 66790, 66789, 66788, 66787,
    66786, 66785, 66784, 66783, 66782, 66781, 66780, 66779, 66778, 66777, 66776, 66774, 66773, 66772,
    66771, 66770, 66769, 66768, 66767, 66766, 66765, 66764, 66763, 66762, 66761, 66760, 66759, 66758,
    66757, 66756, 66755, 66754, 66753, 66752, 66751, 66750, 66749, 66748, 66746, 66745, 66744, 66743,
    66742, 66741, 66740, 66739, 66738, 66737, 66736, 66735, 66734, 66733, 66732, 66731, 66730, 66729,
    66728, 66727, 66726, 66725, 66724, 66723, 66722, 66721, 66720, 66718, 66717, 66716, 66715, 66714,
    66713, 66712, 66711, 66710, 66709, 66708, 66707, 66706, 66705, 66704, 66703, 66702, 66701, 66700,
    66699, 66698, 66697, 66696, 66695, 66694, 66693, 66692, 66691, 66689, 66688, 66687, 66686, 66685,
    66684, 66683, 66682, 66681, 66680, 66679, 66678, 66677, 66676, 66675, 66674, 66673, 66672, 66671,
    66670, 66669, 66668, 66667, 66666, 66665, 66664, 66663, 66662, 66660, 66659, 66658, 66657, 66656,
    66655, 66654, 66653, 66652, 66651, 66650, 66649, 66648, 66647, 66646, 66645, 66644, 66643, 66642,
    66641, 66640, 66639, 66638, 66637, 66636, 66635, 66634, 66633, 66632, 66630, 66629, 66628, 66627,
    66626, 66625, 66624, 66623, 66622, 66621, 66620, 66619, 66618, 66617, 66616, 66615, 66614, 66613,
    66612, 66611, 66610, 66609, 66608, 66607, 66606, 66605, 66604, 66603, 66602, 66601, 66600, 66598,
    66597, 66596, 66595, 66594, 66593, 66592, 66591, 66590, 66589, 66588, 66587, 66586, 66585, 66584,
    66583, 66582, 66581, 66580, 66579, 66578, 66577, 66576, 66575, 66574, 66573, 66572, 66571, 66570,
    66569, 66568, 66566, 66565, 66564, 66563, 66562, 66561, 66560, 66559, 66558, 66557, 66556, 66555,
    66554, 66553, 66552, 66551, 66550, 66549, 66548, 66547, 66546, 66545, 66544, 66543, 66542, 66541,
    66540, 66539, 66538, 66537, 66536, 66535, 66533, 66532, 66531, 66530, 66529, 66528, 66527, 66526,
    66525, 66524, 66523, 66522, 66521, 66520, 66519, 66518, 66517, 66516, 66515, 66514, 66513, 66512,
    66511, 66510, 66509, 66508, 66507, 66506, 66505, 66504, 66503, 66502, 66501, 66499, 66498, 66497,
    66496, 66495, 66494, 66493, 66492, 66491, 66490, 66489, 66488, 66487, 66486, 66485, 66484, 66483,
    66482, 66481, 66480, 66479, 66478, 66477, 66476, 66475, 66474, 66473, 66472, 66471, 66470, 66469,
    66468, 66467, 66466, 66464, 66463, 66462, 66461, 66460, 66459, 66458, 66457, 66456, 66455, 66454,
    66453, 66452, 66451, 66450, 66449, 66448, 66447, 66446, 66445, 66444, 66443, 66442, 66441, 66440,
    66439, 66438, 66437, 66436, 66435, 66434, 66433, 66432, 66431, 66430, 66429, 66427, 66426, 66425,
    66424, 66423, 66422, 66421, 66420, 66419, 66418, 66417, 66416, 66415, 66414, 66413, 66412, 66411,
    66410, 66409, 66408, 66407, 66406, 66405, 66404, 66403, 66402, 66401, 66400, 66399, 66398, 66397,
    66396, 66395, 66394, 66393, 66392, 66391, 66389, 66388, 66387, 66386, 66385, 66384, 66383, 66382,
    66381, 66380, 66379, 66378, 66377, 66376, 66375, 66374, 66373, 66372, 66371, 66370, 66369, 66368,
    66367, 66366, 66365, 66364, 66363, 66362, 66361, 66360, 66359, 66358, 66357, 66356, 66355, 66354,
    66353, 66352, 66351, 66349, 66348, 66347, 66346, 66345, 66344, 66343, 66342, 66341, 66340, 66339,
    66338, 66337, 66336, 66335, 66334, 66333, 66332, 66331, 66330, 66329, 66328, 66327, 66326, 66325,
    66324, 66323, 66322, 66321, 66320, 66319, 66318, 66317, 66316, 66315, 66314, 66313, 66312, 66311,
    66310, 66309, 66307, 66306, 66305, 66304, 66303, 66302, 66301, 66300, 66299, 66298, 66297, 66296,
    66295, 66294, 66293, 66292, 66291, 66290, 66289, 66288, 66287, 66286, 66285, 66284, 66283, 66282,
    66281, 66280, 66279, 66278, 66277, 66276, 66275, 66274, 66273, 66272, 66271, 66270, 66269, 66268,
    66267, 66266, 66265, 66264, 66262, 66261, 66260, 66259, 66258, 66257, 66256, 66255, 66254, 66253,
    66252, 66251, 66250, 66249, 66248, 66247, 66246, 66245, 66244, 66243, 66242, 66241, 66240, 66239,
    66238, 66237, 66236, 66235, 66234, 66233, 66232, 66231, 66230, 66229, 66228, 66227, 66226, 66225,
    66224, 66223, 66222, 66221, 66220, 66219, 66218, 66217, 66215, 66214, 66213, 66212, 66211, 66210,
    66209, 66208, 66207, 66206, 66205, 66204, 66203, 66202, 66201, 66200, 66199, 66198, 66197, 66196,
    66195, 66194, 66193, 66192, 66191, 66190, 66189, 66188, 66187, 66186, 66185, 66184, 66183, 66182,
    66181, 66180, 66179, 66178, 66177, 66176, 66175, 66174, 66173, 66172, 66171, 66170, 66169, 66168,
    66167, 66166, 66164, 66163, 66162, 66161, 66160, 66159, 66158, 66157, 66156, 66155, 66154, 66153,
    66152, 66151, 66150, 66149, 66148, 66147, 66146, 66145, 66144, 66143, 66142, 66141, 66140, 66139,
    66138, 66137, 66136, 66135, 66134, 66133, 66132, 66131, 66130, 66129, 66128, 66127, 66126, 66125,
    66124, 66123, 66122, 66121, 66120, 66119, 66118, 66117, 66116, 66115, 66114, 66113, 66112, 66111,
    66109, 66108, 66107, 66106, 66105, 66104, 66103, 66102, 66101, 66100, 66099, 66098, 66097, 66096,
    66095, 66094, 66093, 66092, 66091, 66090, 66089, 66088, 66087, 66086, 66085, 66084, 66083, 66082,
    66081, 66080, 66079, 66078, 66077, 66076, 66075, 66074, 66073, 66072, 66071, 66070, 66069, 66068,
    66067, 66066, 66065, 66064, 66063, 66062, 66061, 66060, 66059, 66058, 66057, 66056, 66055, 66054,
    66053, 66052, 66051, 66050, 66048, 66047, 66046, 66045, 66044, 66043, 66042, 66041, 66040, 66039,
    66038, 66037, 66036, 66035, 66034, 66033, 66032, 66031, 66030, 66029, 66028, 66027, 66026, 66025,
    66024, 66023, 66022, 66021, 66020, 66019, 66018, 66017, 66016, 66015, 66014, 66013, 66012, 66011,
    66010, 66009, 66008, 66007, 66006, 66005, 66004, 66003, 66002, 66001, 66000, 65999, 65998, 65997,
    65996, 65995, 65994, 65993, 65992, 65991, 65990, 65989, 65988, 65987, 65986, 65985, 65984, 65983,
    65982, 65981, 65979, 65978, 65977, 65976, 65975, 65974, 65973, 65972, 65971, 65970, 65969, 65968,
    65967, 65966, 65965, 65964, 65963, 65962, 65961, 65960, 65959, 65958, 65957, 65956, 65955, 65954,
    65953, 65952, 65951, 65950, 65949, 65948, 65947, 65946, 65945, 65944, 65943, 65942, 65941, 65940,
    65939, 65938, 65937, 65936, 65935, 65934, 65933, 65932, 65931, 65930, 65929, 65928, 65927, 65926,
    65925, 65924, 65923, 65922, 65921, 65920, 65919, 65918, 65917, 65916, 65915, 65914, 65913, 65912,
    65911, 65910, 65909, 65908, 65907, 65906, 65905, 65904, 65903, 65902, 65901, 65900, 65899, 65897,
    65896, 65895, 65894, 65893, 65892, 65891, 65890, 65889, 65888, 65887, 65886, 65885, 65884, 65883,
    65882, 65881, 65880, 65879, 65878, 65877, 65876, 65875, 65874, 65873, 65872, 65871, 65870, 65869,
    65868, 65867, 65866, 65865, 65864, 65863, 65862, 65861, 65860, 65859, 65858, 65857, 65856, 65855,
    65854, 65853, 65852, 65851, 65850, 65849, 65848, 65847, 65846, 65845, 65844, 65843, 65842, 65841,
    65840, 65839, 65838, 65837, 65836, 65835, 65834, 65833, 65832, 65831, 65830, 65829, 65828, 65827,
    65826, 65825, 65824, 65823, 65822, 65821, 65820, 65819, 65818, 65817, 65816, 65815, 65814, 65813,
    65812, 65811, 65810, 65809, 65808, 65807, 65806, 65805, 65804, 65803, 65802, 65801, 65800, 65799,
    65798, 65797, 65796, 65795, 65794, 65793, 65791, 65790, 65789, 65788, 65787, 65786, 65785, 65784,
    65783, 65782, 65781, 65780, 65779, 65778, 65777, 65776, 65775, 65774, 65773, 65772, 65771, 65770,
    65769, 65768, 65767, 65766, 65765, 65764, 65763, 65762, 65761, 65760, 65759, 65758, 65757, 65756,
    65755, 65754, 65753, 65752, 65751, 65750, 65749, 65748, 65747, 65746, 65745, 65744, 65743, 65742,
    65741, 65740, 65739, 65738, 65737, 65736, 65735, 65734, 65733, 65732, 65731, 65730, 65729, 65728,
    65727, 65726, 65725, 65724, 65723, 65722, 65721, 65720, 65719, 65718, 65717, 65716, 65715, 65714,
    65713, 65712, 65711, 65710, 65709, 65708, 65707, 65706, 65705, 65704, 65703, 65702, 65701, 65700,
    65699, 65698, 65697, 65696, 65695, 65694, 65693, 65692, 65691, 65690, 65689, 65688, 65687, 65686,
    65685, 65684, 65683, 65682, 65681, 65680, 65679, 65678, 65677, 65676, 65675, 65674, 65673, 65672,
    65671, 65670, 65669, 65668, 65667, 65666, 65665, 65664, 65663, 65662, 65661, 65660, 65659, 65658,
    65657, 65656, 65655, 65654, 65653, 65652, 65651, 65650, 65649, 65648, 65647, 65646, 65645, 65644,
    65643, 65642, 65641, 65640, 65639, 65638, 65637, 65636, 65635, 65634, 65633, 65632, 65631, 65630,
    65629, 65628, 65627, 65626, 65625, 65624, 65623, 65622, 65621, 65620, 65619, 65618, 65617, 65616,
    65615, 65614, 65613, 65612, 65611, 65610, 65609, 65608, 65607, 65606, 65605, 65604, 65603, 65602,
    65601, 65600, 65599, 65598, 65597, 65596, 65595, 65594, 65593, 65592, 65591, 65590, 65589, 65588,
    65587, 65586, 65585, 65584, 65583, 65582, 65581, 65580, 65579, 65578, 65577, 65576, 65575, 65574,
    65573, 65572, 65571, 65570, 65569, 65568, 65567, 65566, 65565, 65564, 65563, 65562, 65561, 65560,
    65559, 65558, 65557, 65556, 65555, 65554, 65553, 65552, 65551, 65550, 65549, 65548, 65547, 65546,
    65545, 65544, 65543, 65542, 65541, 65540, 65539, 65538};


static unsigned short division_lut[] = {
    65535, 65471, 65407, 65343, 65279, 65216, 65153, 65090, 65026, 64964, 64901, 64838, 64775, 64713, 64651, 64588,
    64526, 64464, 64402, 64341, 64279, 64218, 64156, 64095, 64034, 63973, 63912, 63851, 63790, 63730, 63669, 63609,
    63549, 63488, 63428, 63369, 63309, 63249, 63190, 63130, 63071, 63012, 62952, 62893, 62835, 62776, 62717, 62659,
    62600, 62542, 62483, 62425, 62367, 62309, 62252, 62194, 62136, 62079, 62021, 61964, 61907, 61850, 61793, 61736,
    61679, 61623, 61566, 61510, 61454, 61397, 61341, 61285, 61229, 61173, 61118, 61062, 61007, 60951, 60896, 60841,
    60786, 60731, 60676, 60621, 60566, 60511, 60457, 60403, 60348, 60294, 60240, 60186, 60132, 60078, 60024, 59971,
    59917, 59864, 59810, 59757, 59704, 59651, 59598, 59545, 59492, 59439, 59387, 59334, 59282, 59230, 59177, 59125,
    59073, 59021, 58969, 58918, 58866, 58814, 58763, 58711, 58660, 58609, 58558, 58507, 58456, 58405, 58354, 58303,
    58253, 58202, 58152, 58101, 58051, 58001, 57951, 57901, 57851, 57801, 57751, 57702, 57652, 57603, 57553, 57504,
    57455, 57406, 57357, 57308, 57259, 57210, 57161, 57112, 57064, 57015, 56967, 56919, 56870, 56822, 56774, 56726,
    56678, 56630, 56583, 56535, 56487, 56440, 56393, 56345, 56298, 56251, 56204, 56157, 56110, 56063, 56016, 55969,
    55923, 55876, 55830, 55783, 55737, 55691, 55644, 55598, 55552, 55506, 55460, 55415, 55369, 55323, 55278, 55232,
    55187, 55141, 55096, 55051, 55006, 54961, 54916, 54871, 54826, 54781, 54737, 54692, 54647, 54603, 54559, 54514,
    54470, 54426, 54382, 54338, 54294, 54250, 54206, 54162, 54119, 54075, 54031, 53988, 53945, 53901, 53858, 53815,
    53772, 53729, 53686, 53643, 53600, 53557, 53514, 53472, 53429, 53387, 53344, 53302, 53260, 53217, 53175, 53133,
    53091, 53049, 53007, 52965, 52923, 52882, 52840, 52799, 52757, 52716, 52674, 52633, 52592, 52550, 52509, 52468,
    52427, 52386, 52346, 52305, 52264, 52223, 52183, 52142, 52102, 52061, 52021, 51981, 51940, 51900, 51860, 51820,
    51780, 51740, 51700, 51660, 51621, 51581, 51541, 51502, 51462, 51423, 51384, 51344, 51305, 51266, 51227, 51188,
    51149, 51110, 51071, 51032, 50993, 50954, 50916, 50877, 50839, 50800, 50762, 50723, 50685, 50647, 50609, 50570,
    50532, 50494, 50456, 50418, 50381, 50343, 50305, 50267, 50230, 50192, 50155, 50117, 50080, 50042, 50005, 49968,
    49931, 49894, 49856, 49819, 49783, 49746, 49709, 49672, 49635, 49599, 49562, 49525, 49489, 49452, 49416, 49380,
    49343, 49307, 49271, 49235, 49199, 49163, 49127, 49091, 49055, 49019, 48983, 48947, 48912, 48876, 48840, 48805,
    48769, 48734, 48699, 48663, 48628, 48593, 48558, 48523, 48488, 48453, 48418, 48383, 48348, 48313, 48278, 48244,
    48209, 48174, 48140, 48105, 48071, 48036, 48002, 47968, 47933, 47899, 47865, 47831, 47797, 47763, 47729, 47695,
    47661, 47627, 47593, 47560, 47526, 47492, 47459, 47425, 47392, 47358, 47325, 47292, 47258, 47225, 47192, 47159,
    47126, 47092, 47059, 47026, 46994, 46961, 46928, 46895, 46862, 46830, 46797, 46764, 46732, 46699, 46667, 46634,
    46602, 46570, 46537, 46505, 46473, 46441, 46409, 46376, 46344, 46312, 46280, 46249, 46217, 46185, 46153, 46121,
    46090, 46058, 46027, 45995, 45963, 45932, 45901, 45869, 45838, 45807, 45775, 45744, 45713, 45682, 45651, 45620,
    45589, 45558, 45527, 45496, 45465, 45434, 45404, 45373, 45342, 45312, 45281, 45251, 45220, 45190, 45159, 45129,
    45099, 45068, 45038, 45008, 44978, 44948, 44917, 44887, 44857, 44827, 44797, 44768, 44738, 44708, 44678, 44648,
    44619, 44589, 44559, 44530, 44500, 44471, 44441, 44412, 44383, 44353, 44324, 44295, 44266, 44236, 44207, 44178,
    44149, 44120, 44091, 44062, 44033, 44004, 43975, 43947, 43918, 43889, 43861, 43832, 43803, 43775, 43746, 43718,
    43689, 43661, 43632, 43604, 43576, 43547, 43519, 43491, 43463, 43435, 43407, 43379, 43350, 43322, 43295, 43267,
    43239, 43211, 43183, 43155, 43128, 43100, 43072, 43045, 43017, 42989, 42962, 42934, 42907, 42880, 42852, 42825,
    42798, 42770, 42743, 42716, 42689, 42661, 42634, 42607, 42580, 42553, 42526, 42499, 42472, 42446, 42419, 42392,
    42365, 42338, 42312, 42285, 42258, 42232, 42205, 42179, 42152, 42126, 42099, 42073, 42047, 42020, 41994, 41968,
    41942, 41915, 41889, 41863, 41837, 41811, 41785, 41759, 41733, 41707, 41681, 41655, 41629, 41603, 41578, 41552,
    41526, 41501, 41475, 41449, 41424, 41398, 41373, 41347, 41322, 41296, 41271, 41245, 41220, 41195, 41170, 41144,
    41119, 41094, 41069, 41044, 41019, 40994, 40969, 40944, 40919, 40894, 40869, 40844, 40819, 40794, 40769, 40745,
    40720, 40695, 40671, 40646, 40621, 40597, 40572, 40548, 40523, 40499, 40474, 40450, 40426, 40401, 40377, 40353,
    40328, 40304, 40280, 40256, 40232, 40208, 40183, 40159, 40135, 40111, 40087, 40063, 40040, 40016, 39992, 39968,
    39944, 39920, 39897, 39873, 39849, 39826, 39802, 39779, 39755, 39731, 39708, 39684, 39661, 39638, 39614, 39591,
    39567, 39544, 39521, 39498, 39474, 39451, 39428, 39405, 39382, 39359, 39335, 39312, 39289, 39266, 39243, 39221,
    39198, 39175, 39152, 39129, 39106, 39083, 39061, 39038, 39015, 38993, 38970, 38947, 38925, 38902, 38880, 38857,
    38835, 38812, 38790, 38767, 38745, 38723, 38700, 38678, 38656, 38633, 38611, 38589, 38567, 38545, 38523, 38500,
    38478, 38456, 38434, 38412, 38390, 38368, 38346, 38325, 38303, 38281, 38259, 38237, 38215, 38194, 38172, 38150,
    38129, 38107, 38085, 38064, 38042, 38021, 37999, 37977, 37956, 37935, 37913, 37892, 37870, 37849, 37828, 37806,
    37785, 37764, 37743, 37721, 37700, 37679, 37658, 37637, 37616, 37595, 37573, 37552, 37531, 37510, 37489, 37469,
    37448, 37427, 37406, 37385, 37364, 37343, 37323, 37302, 37281, 37261, 37240, 37219, 37199, 37178, 37157, 37137,
    37116, 37096, 37075, 37055, 37034, 37014, 36993, 36973, 36953, 36932, 36912, 36892, 36872, 36851, 36831, 36811,
    36791, 36770, 36750, 36730, 36710, 36690, 36670, 36650, 36630, 36610, 36590, 36570, 36550, 36530, 36510, 36491,
    36471, 36451, 36431, 36411, 36392, 36372, 36352, 36332, 36313, 36293, 36274, 36254, 36234, 36215, 36195, 36176,
    36156, 36137, 36117, 36098, 36079, 36059, 36040, 36020, 36001, 35982, 35963, 35943, 35924, 35905, 35886, 35866,
    35847, 35828, 35809, 35790, 35771, 35752, 35733, 35714, 35695, 35676, 35657, 35638, 35619, 35600, 35581, 35562,
    35543, 35525, 35506, 35487, 35468, 35450, 35431, 35412, 35393, 35375, 35356, 35338, 35319, 35300, 35282, 35263,
    35245, 35226, 35208, 35189, 35171, 35152, 35134, 35116, 35097, 35079, 35061, 35042, 35024, 35006, 34987, 34969,
    34951, 34933, 34915, 34897, 34878, 34860, 34842, 34824, 34806, 34788, 34770, 34752, 34734, 34716, 34698, 34680,
    34662, 34644, 34626, 34609, 34591, 34573, 34555, 34537, 34520, 34502, 34484, 34466, 34449, 34431, 34413, 34396,
    34378, 34360, 34343, 34325, 34308, 34290, 34273, 34255, 34238, 34220, 34203, 34185, 34168, 34151, 34133, 34116,
    34099, 34081, 34064, 34047, 34029, 34012, 33995, 33978, 33960, 33943, 33926, 33909, 33892, 33875, 33858, 33841,
    33824, 33806, 33789, 33772, 33755, 33739, 33722, 33705, 33688, 33671, 33654, 33637, 33620, 33603, 33587, 33570,
    33553, 33536, 33519, 33503, 33486, 33469, 33453, 33436, 33419, 33403, 33386, 33369, 33353, 33336, 33320, 33303,
    33287, 33270, 33254, 33237, 33221, 33204, 33188, 33171, 33155, 33139, 33122, 33106, 33090, 33073, 33057, 33041,
    33025, 33008, 32992, 32976, 32960, 32943, 32927, 32911, 32895, 32879, 32863, 32847, 32831, 32815, 32799, 32783};


static unsigned short division_lut8[256] = {
    65535, 32768, 16384, 10922, 8192, 6553, 5461, 4681, 4096, 3640, 3276, 2978, 2730, 2520, 2340, 2184, 2048, 1927,
    1820, 1724, 1638, 1560, 1489, 1424, 1365, 1310, 1260, 1213, 1170, 1129, 1092, 1057, 1024, 992, 963, 936,
    910, 885, 862, 840, 819, 799, 780, 762, 744, 728, 712, 697, 682, 668, 655, 642, 630, 618,
    606, 595, 585, 574, 564, 555, 546, 537, 528, 520, 512, 504, 496, 489, 481, 474, 468, 461,
    455, 448, 442, 436, 431, 425, 420, 414, 409, 404, 399, 394, 390, 385, 381, 376, 372, 368,
    364, 360, 356, 352, 348, 344, 341, 337, 334, 330, 327, 324, 321, 318, 315, 312, 309, 306,
    303, 300, 297, 295, 292, 289, 287, 284, 282, 280, 277, 275, 273, 270, 268, 266, 264, 262,
    260, 258, 256, 254, 252, 250, 248, 246, 244, 242, 240, 239, 237, 235, 234, 232, 230, 229,
    227, 225, 224, 222, 221, 219, 218, 217, 215, 214, 212, 211, 210, 208, 207, 206, 204, 203,
    202, 201, 199, 198, 197, 196, 195, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183,
    182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 168, 167, 166,
    165, 164, 163, 163, 162, 161, 160, 159, 159, 158, 157, 156, 156, 155, 154, 153, 153, 152,
    151, 151, 150, 149, 148, 148, 147, 146, 146, 145, 144, 144, 143, 143, 142, 141, 141, 140,
    140, 139, 138, 138, 137, 137, 136, 135, 135, 134, 134, 133, 133, 132, 132, 131, 131, 130,
    130, 129, 129, 128};



static int base_addr_lut[63] = {0, 512, 768, 896, 960, 1024, 1088, 1120, 1152, 1184, 1200, 1216, 1232,
                                1248, 1264, 1280, 1296, 1304, 1312, 1320, 1328, 1336, 1344, 1352, 1360, 1362,
                                1364, 1366, 1368, 1370, 1372, 1374, 1376, 1378, 1380, 1382, 1384, 1386, 1388,
                                1390, 1392, 1394, 1396, 1398, 1400, 1402, 1404, 1406, 1408, 1410, 1412, 1414,
                                1416, 1418, 1420, 1422, 1424, 1426, 1428, 1430, 1432, 1434, 1436};

static int frac_bits_lut[63] = {9, 8, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3,
                                3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2};

static short atan_lut_fp[1440] = {
    0, 7, 15, 23, 31, 39, 47, 55, 63, 71, 79, 87, 95, 103, 111, 119, 127, 135, 143,
    151, 159, 167, 175, 183, 191, 199, 207, 215, 223, 231, 239, 247, 255, 263, 271, 279, 287, 295,
    303, 311, 319, 327, 335, 343, 351, 358, 366, 374, 382, 390, 398, 406, 414, 422, 430, 438, 446,
    454, 461, 469, 477, 485, 493, 501, 509, 517, 524, 532, 540, 548, 556, 564, 572, 579, 587, 595,
    603, 611, 619, 626, 634, 642, 650, 658, 665, 673, 681, 689, 697, 704, 712, 720, 728, 735, 743,
    751, 758, 766, 774, 782, 789, 797, 805, 812, 820, 828, 835, 843, 851, 858, 866, 874, 881, 889,
    897, 904, 912, 919, 927, 935, 942, 950, 957, 965, 973, 980, 988, 995, 1003, 1010, 1018, 1025, 1033,
    1040, 1048, 1055, 1063, 1070, 1078, 1085, 1093, 1100, 1107, 1115, 1122, 1130, 1137, 1144, 1152, 1159, 1167, 1174,
    1181, 1189, 1196, 1203, 1211, 1218, 1225, 1233, 1240, 1247, 1254, 1262, 1269, 1276, 1283, 1291, 1298, 1305, 1312,
    1319, 1327, 1334, 1341, 1348, 1355, 1362, 1370, 1377, 1384, 1391, 1398, 1405, 1412, 1419, 1426, 1433, 1441, 1448,
    1455, 1462, 1469, 1476, 1483, 1490, 1497, 1504, 1511, 1518, 1524, 1531, 1538, 1545, 1552, 1559, 1566, 1573, 1580,
    1587, 1593, 1600, 1607, 1614, 1621, 1628, 1634, 1641, 1648, 1655, 1661, 1668, 1675, 1682, 1688, 1695, 1702, 1708,
    1715, 1722, 1728, 1735, 1742, 1748, 1755, 1762, 1768, 1775, 1781, 1788, 1794, 1801, 1808, 1814, 1821, 1827, 1834,
    1840, 1847, 1853, 1860, 1866, 1872, 1879, 1885, 1892, 1898, 1905, 1911, 1917, 1924, 1930, 1936, 1943, 1949, 1955,
    1962, 1968, 1974, 1980, 1987, 1993, 1999, 2005, 2012, 2018, 2024, 2030, 2036, 2043, 2049, 2055, 2061, 2067, 2073,
    2079, 2086, 2092, 2098, 2104, 2110, 2116, 2122, 2128, 2134, 2140, 2146, 2152, 2158, 2164, 2170, 2176, 2182, 2188,
    2194, 2200, 2205, 2211, 2217, 2223, 2229, 2235, 2241, 2246, 2252, 2258, 2264, 2270, 2275, 2281, 2287, 2293, 2298,
    2304, 2310, 2316, 2321, 2327, 2333, 2338, 2344, 2350, 2355, 2361, 2366, 2372, 2378, 2383, 2389, 2394, 2400, 2406,
    2411, 2417, 2422, 2428, 2433, 2439, 2444, 2450, 2455, 2460, 2466, 2471, 2477, 2482, 2488, 2493, 2498, 2504, 2509,
    2514, 2520, 2525, 2530, 2536, 2541, 2546, 2552, 2557, 2562, 2567, 2573, 2578, 2583, 2588, 2593, 2599, 2604, 2609,
    2614, 2619, 2624, 2630, 2635, 2640, 2645, 2650, 2655, 2660, 2665, 2670, 2675, 2680, 2685, 2690, 2695, 2700, 2705,
    2710, 2715, 2720, 2725, 2730, 2735, 2740, 2745, 2750, 2755, 2760, 2765, 2769, 2774, 2779, 2784, 2789, 2794, 2798,
    2803, 2808, 2813, 2818, 2822, 2827, 2832, 2837, 2841, 2846, 2851, 2855, 2860, 2865, 2869, 2874, 2879, 2883, 2888,
    2893, 2897, 2902, 2907, 2911, 2916, 2920, 2925, 2929, 2934, 2939, 2943, 2948, 2952, 2957, 2961, 2966, 2970, 2975,
    2979, 2984, 2988, 2992, 2997, 3001, 3006, 3010, 3014, 3019, 3023, 3028, 3032, 3036, 3041, 3045, 3049, 3054, 3058,
    3062, 3067, 3071, 3075, 3079, 3084, 3088, 3092, 3096, 3101, 3105, 3109, 3113, 3117, 3122, 3126, 3130, 3134, 3138,
    3142, 3147, 3151, 3155, 3159, 3163, 3167, 3171, 3175, 3179, 3183, 3188, 3192, 3196, 3200, 3204, 3208, 3212, 3216,
    3224, 3232, 3240, 3247, 3255, 3263, 3271, 3279, 3286, 3294, 3302, 3309, 3317, 3325, 3332, 3340, 3347, 3355, 3362,
    3370, 3377, 3384, 3392, 3399, 3406, 3413, 3421, 3428, 3435, 3442, 3449, 3456, 3463, 3470, 3477, 3484, 3491, 3498,
    3505, 3512, 3519, 3526, 3532, 3539, 3546, 3553, 3559, 3566, 3572, 3579, 3586, 3592, 3599, 3605, 3612, 3618, 3625,
    3631, 3637, 3644, 3650, 3656, 3663, 3669, 3675, 3681, 3687, 3694, 3700, 3706, 3712, 3718, 3724, 3730, 3736, 3742,
    3748, 3754, 3760, 3766, 3772, 3777, 3783, 3789, 3795, 3801, 3806, 3812, 3818, 3823, 3829, 3835, 3840, 3846, 3851,
    3857, 3863, 3868, 3873, 3879, 3884, 3890, 3895, 3901, 3906, 3911, 3917, 3922, 3927, 3932, 3938, 3943, 3948, 3953,
    3959, 3964, 3969, 3974, 3979, 3984, 3989, 3994, 3999, 4004, 4009, 4014, 4019, 4024, 4029, 4034, 4039, 4044, 4048,
    4053, 4058, 4063, 4068, 4072, 4077, 4082, 4087, 4091, 4096, 4101, 4105, 4110, 4114, 4119, 4124, 4128, 4133, 4137,
    4142, 4146, 4151, 4155, 4160, 4164, 4168, 4173, 4177, 4182, 4186, 4190, 4195, 4199, 4203, 4208, 4212, 4216, 4220,
    4225, 4229, 4233, 4237, 4241, 4245, 4250, 4254, 4258, 4262, 4266, 4270, 4274, 4278, 4282, 4286, 4290, 4294, 4298,
    4302, 4306, 4310, 4314, 4318, 4322, 4326, 4329, 4333, 4337, 4341, 4345, 4349, 4352, 4356, 4360, 4364, 4367, 4371,
    4375, 4378, 4382, 4386, 4390, 4393, 4397, 4400, 4404, 4408, 4411, 4415, 4418, 4422, 4426, 4429, 4433, 4436, 4440,
    4443, 4447, 4450, 4454, 4457, 4460, 4464, 4467, 4471, 4474, 4477, 4481, 4484, 4487, 4491, 4494, 4497, 4501, 4504,
    4507, 4511, 4514, 4517, 4520, 4524, 4527, 4530, 4533, 4540, 4546, 4552, 4559, 4565, 4571, 4577, 4583, 4589, 4595,
    4601, 4607, 4613, 4619, 4625, 4631, 4637, 4642, 4648, 4654, 4659, 4665, 4671, 4676, 4682, 4687, 4693, 4698, 4703,
    4709, 4714, 4719, 4725, 4730, 4735, 4740, 4745, 4750, 4755, 4761, 4766, 4771, 4776, 4780, 4785, 4790, 4795, 4800,
    4805, 4810, 4814, 4819, 4824, 4828, 4833, 4838, 4842, 4847, 4851, 4856, 4860, 4865, 4869, 4874, 4878, 4883, 4887,
    4891, 4896, 4900, 4904, 4908, 4913, 4917, 4921, 4925, 4929, 4933, 4937, 4941, 4945, 4949, 4953, 4957, 4961, 4965,
    4969, 4973, 4977, 4981, 4985, 4989, 4992, 4996, 5000, 5004, 5007, 5011, 5015, 5018, 5022, 5026, 5029, 5033, 5037,
    5040, 5044, 5047, 5051, 5054, 5058, 5061, 5065, 5068, 5071, 5075, 5078, 5082, 5085, 5088, 5092, 5095, 5098, 5101,
    5105, 5108, 5111, 5114, 5121, 5127, 5133, 5139, 5146, 5152, 5158, 5164, 5170, 5175, 5181, 5187, 5193, 5198, 5204,
    5210, 5215, 5221, 5226, 5231, 5237, 5242, 5247, 5252, 5257, 5263, 5268, 5273, 5278, 5283, 5287, 5292, 5297, 5302,
    5307, 5311, 5316, 5321, 5325, 5330, 5334, 5339, 5343, 5347, 5352, 5356, 5360, 5365, 5369, 5373, 5377, 5381, 5386,
    5390, 5394, 5398, 5402, 5406, 5410, 5413, 5417, 5421, 5425, 5429, 5432, 5436, 5440, 5444, 5447, 5451, 5454, 5458,
    5462, 5465, 5469, 5472, 5475, 5479, 5482, 5486, 5489, 5492, 5496, 5499, 5502, 5505, 5509, 5512, 5515, 5518, 5521,
    5524, 5527, 5530, 5533, 5536, 5539, 5542, 5545, 5548, 5551, 5554, 5557, 5560, 5563, 5566, 5568, 5571, 5574, 5577,
    5579, 5582, 5585, 5588, 5590, 5593, 5596, 5598, 5601, 5603, 5606, 5609, 5611, 5614, 5616, 5619, 5621, 5624, 5626,
    5628, 5631, 5633, 5636, 5638, 5640, 5643, 5645, 5647, 5650, 5652, 5654, 5657, 5659, 5661, 5663, 5666, 5668, 5670,
    5672, 5674, 5677, 5679, 5681, 5683, 5685, 5687, 5689, 5691, 5693, 5695, 5697, 5699, 5702, 5704, 5706, 5707, 5709,
    5711, 5713, 5715, 5717, 5719, 5721, 5723, 5725, 5727, 5729, 5731, 5732, 5734, 5736, 5738, 5740, 5742, 5743, 5745,
    5747, 5749, 5750, 5752, 5754, 5756, 5759, 5762, 5766, 5769, 5772, 5776, 5779, 5782, 5785, 5789, 5792, 5795, 5798,
    5801, 5804, 5807, 5810, 5813, 5816, 5818, 5821, 5824, 5827, 5830, 5832, 5835, 5838, 5840, 5843, 5846, 5848, 5851,
    5853, 5856, 5858, 5861, 5863, 5866, 5868, 5871, 5873, 5875, 5878, 5880, 5882, 5885, 5887, 5889, 5891, 5894, 5896,
    5898, 5900, 5902, 5904, 5906, 5909, 5911, 5913, 5915, 5917, 5919, 5921, 5923, 5925, 5927, 5929, 5930, 5932, 5934,
    5936, 5938, 5940, 5942, 5943, 5945, 5947, 5949, 5951, 5952, 5954, 5956, 5958, 5959, 5961, 5963, 5964, 5966, 5968,
    5969, 5971, 5972, 5974, 5976, 5977, 5979, 5982, 5985, 5988, 5991, 5994, 5997, 6000, 6002, 6005, 6008, 6011, 6013,
    6016, 6019, 6021, 6024, 6026, 6029, 6031, 6034, 6036, 6038, 6041, 6043, 6045, 6048, 6050, 6052, 6054, 6056, 6059,
    6061, 6063, 6065, 6067, 6069, 6071, 6073, 6075, 6077, 6079, 6081, 6082, 6084, 6086, 6088, 6090, 6091, 6093, 6095,
    6097, 6098, 6100, 6102, 6103, 6105, 6107, 6108, 6110, 6111, 6113, 6114, 6116, 6118, 6119, 6121, 6122, 6123, 6125,
    6126, 6128, 6129, 6131, 6132, 6133, 6135, 6136, 6137, 6139, 6140, 6141, 6142, 6144, 6145, 6146, 6147, 6149, 6150,
    6151, 6152, 6154, 6155, 6156, 6157, 6158, 6159, 6160, 6162, 6163, 6164, 6165, 6166, 6167, 6168, 6169, 6170, 6171,
    6172, 6173, 6174, 6175, 6176, 6178, 6180, 6182, 6184, 6186, 6188, 6190, 6191, 6193, 6195, 6196, 6198, 6200, 6201,
    6203, 6205, 6206, 6208, 6209, 6211, 6212, 6214, 6215, 6217, 6218, 6219, 6221, 6222, 6223, 6225, 6226, 6227, 6229,
    6230, 6231, 6232, 6234, 6235, 6236, 6237, 6238, 6239, 6240, 6242, 6243, 6244, 6245, 6246, 6247, 6248, 6249, 6250,
    6251, 6252, 6253, 6254, 6255, 6256, 6257, 6258, 6259, 6260, 6260, 6261, 6265, 6268, 6271, 6274, 6277, 6280, 6283,
    6286, 6288, 6291, 6293, 6295, 6298, 6300, 6302, 6304, 6306, 6308, 6310, 6312, 6313, 6315, 6317, 6318, 6320, 6321,
    6323, 6324, 6326, 6327, 6328, 6330, 6331, 6332, 6333, 6334, 6336, 6337, 6338, 6339, 6340, 6341, 6342, 6343, 6344,
    6345, 6346, 6347, 6347, 6348, 6349, 6350, 6351, 6352, 6352, 6353, 6354, 6355, 6355, 6356, 6357, 6357, 6358, 6359,
    6359, 6360, 6361, 6361, 6362, 6363, 6363, 6364, 6364, 6365, 6365, 6366, 6366, 6367, 6367};


static int base_addr_lut8[126] = {
    0, 512, 640, 704, 736, 768, 800, 816, 832, 848, 856, 864, 872, 880, 888, 896, 904, 908, 912, 916, 920,
    924, 928, 932, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953,
    954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974,
    9, 7, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2,
    2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
static short atan_lut_fp8[977] = {
    0, 7, 15, 23, 31, 39, 47, 55, 63, 71, 79, 87, 95, 103, 111, 119, 127, 135, 143,
    151, 159, 167, 175, 183, 191, 199, 207, 215, 223, 231, 239, 247, 255, 263, 271, 279, 287, 295,
    303, 311, 319, 327, 335, 343, 351, 358, 366, 374, 382, 390, 398, 406, 414, 422, 430, 438, 446,
    454, 461, 469, 477, 485, 493, 501, 509, 517, 524, 532, 540, 548, 556, 564, 572, 579, 587, 595,
    603, 611, 619, 626, 634, 642, 650, 658, 665, 673, 681, 689, 697, 704, 712, 720, 728, 735, 743,
    751, 758, 766, 774, 782, 789, 797, 805, 812, 820, 828, 835, 843, 851, 858, 866, 874, 881, 889,
    897, 904, 912, 919, 927, 935, 942, 950, 957, 965, 973, 980, 988, 995, 1003, 1010, 1018, 1025, 1033,
    1040, 1048, 1055, 1063, 1070, 1078, 1085, 1093, 1100, 1107, 1115, 1122, 1130, 1137, 1144, 1152, 1159, 1167, 1174,
    1181, 1189, 1196, 1203, 1211, 1218, 1225, 1233, 1240, 1247, 1254, 1262, 1269, 1276, 1283, 1291, 1298, 1305, 1312,
    1319, 1327, 1334, 1341, 1348, 1355, 1362, 1370, 1377, 1384, 1391, 1398, 1405, 1412, 1419, 1426, 1433, 1441, 1448,
    1455, 1462, 1469, 1476, 1483, 1490, 1497, 1504, 1511, 1518, 1524, 1531, 1538, 1545, 1552, 1559, 1566, 1573, 1580,
    1587, 1593, 1600, 1607, 1614, 1621, 1628, 1634, 1641, 1648, 1655, 1661, 1668, 1675, 1682, 1688, 1695, 1702, 1708,
    1715, 1722, 1728, 1735, 1742, 1748, 1755, 1762, 1768, 1775, 1781, 1788, 1794, 1801, 1808, 1814, 1821, 1827, 1834,
    1840, 1847, 1853, 1860, 1866, 1872, 1879, 1885, 1892, 1898, 1905, 1911, 1917, 1924, 1930, 1936, 1943, 1949, 1955,
    1962, 1968, 1974, 1980, 1987, 1993, 1999, 2005, 2012, 2018, 2024, 2030, 2036, 2043, 2049, 2055, 2061, 2067, 2073,
    2079, 2086, 2092, 2098, 2104, 2110, 2116, 2122, 2128, 2134, 2140, 2146, 2152, 2158, 2164, 2170, 2176, 2182, 2188,
    2194, 2200, 2205, 2211, 2217, 2223, 2229, 2235, 2241, 2246, 2252, 2258, 2264, 2270, 2275, 2281, 2287, 2293, 2298,
    2304, 2310, 2316, 2321, 2327, 2333, 2338, 2344, 2350, 2355, 2361, 2366, 2372, 2378, 2383, 2389, 2394, 2400, 2406,
    2411, 2417, 2422, 2428, 2433, 2439, 2444, 2450, 2455, 2460, 2466, 2471, 2477, 2482, 2488, 2493, 2498, 2504, 2509,
    2514, 2520, 2525, 2530, 2536, 2541, 2546, 2552, 2557, 2562, 2567, 2573, 2578, 2583, 2588, 2593, 2599, 2604, 2609,
    2614, 2619, 2624, 2630, 2635, 2640, 2645, 2650, 2655, 2660, 2665, 2670, 2675, 2680, 2685, 2690, 2695, 2700, 2705,
    2710, 2715, 2720, 2725, 2730, 2735, 2740, 2745, 2750, 2755, 2760, 2765, 2769, 2774, 2779, 2784, 2789, 2794, 2798,
    2803, 2808, 2813, 2818, 2822, 2827, 2832, 2837, 2841, 2846, 2851, 2855, 2860, 2865, 2869, 2874, 2879, 2883, 2888,
    2893, 2897, 2902, 2907, 2911, 2916, 2920, 2925, 2929, 2934, 2939, 2943, 2948, 2952, 2957, 2961, 2966, 2970, 2975,
    2979, 2984, 2988, 2992, 2997, 3001, 3006, 3010, 3014, 3019, 3023, 3028, 3032, 3036, 3041, 3045, 3049, 3054, 3058,
    3062, 3067, 3071, 3075, 3079, 3084, 3088, 3092, 3096, 3101, 3105, 3109, 3113, 3117, 3122, 3126, 3130, 3134, 3138,
    3142, 3147, 3151, 3155, 3159, 3163, 3167, 3171, 3175, 3179, 3183, 3188, 3192, 3196, 3200, 3204, 3208, 3212, 3216,
    3232, 3247, 3263, 3279, 3294, 3309, 3325, 3340, 3355, 3370, 3384, 3399, 3413, 3428, 3442, 3456, 3470, 3484, 3498,
    3512, 3526, 3539, 3553, 3566, 3579, 3592, 3605, 3618, 3631, 3644, 3656, 3669, 3681, 3694, 3706, 3718, 3730, 3742,
    3754, 3766, 3777, 3789, 3801, 3812, 3823, 3835, 3846, 3857, 3868, 3879, 3890, 3901, 3911, 3922, 3932, 3943, 3953,
    3964, 3974, 3984, 3994, 4004, 4014, 4024, 4034, 4044, 4053, 4063, 4072, 4082, 4091, 4101, 4110, 4119, 4128, 4137,
    4146, 4155, 4164, 4173, 4182, 4190, 4199, 4208, 4216, 4225, 4233, 4241, 4250, 4258, 4266, 4274, 4282, 4290, 4298,
    4306, 4314, 4322, 4329, 4337, 4345, 4352, 4360, 4367, 4375, 4382, 4390, 4397, 4404, 4411, 4418, 4426, 4433, 4440,
    4447, 4454, 4460, 4467, 4474, 4481, 4487, 4494, 4501, 4507, 4514, 4520, 4527, 4533, 4546, 4559, 4571, 4583, 4595,
    4607, 4619, 4631, 4642, 4654, 4665, 4676, 4687, 4698, 4709, 4719, 4730, 4740, 4750, 4761, 4771, 4780, 4790, 4800,
    4810, 4819, 4828, 4838, 4847, 4856, 4865, 4874, 4883, 4891, 4900, 4908, 4917, 4925, 4933, 4941, 4949, 4957, 4965,
    4973, 4981, 4989, 4996, 5004, 5011, 5018, 5026, 5033, 5040, 5047, 5054, 5061, 5068, 5075, 5082, 5088, 5095, 5101,
    5108, 5114, 5127, 5139, 5152, 5164, 5175, 5187, 5198, 5210, 5221, 5231, 5242, 5252, 5263, 5273, 5283, 5292, 5302,
    5311, 5321, 5330, 5339, 5347, 5356, 5365, 5373, 5381, 5390, 5398, 5406, 5413, 5421, 5429, 5436, 5444, 5451, 5458,
    5465, 5472, 5479, 5486, 5492, 5499, 5505, 5512, 5518, 5524, 5530, 5536, 5542, 5548, 5554, 5560, 5566, 5571, 5577,
    5582, 5588, 5593, 5598, 5603, 5609, 5614, 5619, 5624, 5628, 5633, 5638, 5643, 5647, 5652, 5657, 5661, 5666, 5670,
    5674, 5679, 5683, 5687, 5691, 5695, 5699, 5704, 5707, 5711, 5715, 5719, 5723, 5727, 5731, 5734, 5738, 5742, 5745,
    5749, 5752, 5756, 5762, 5769, 5776, 5782, 5789, 5795, 5801, 5807, 5813, 5818, 5824, 5830, 5835, 5840, 5846, 5851,
    5856, 5861, 5866, 5871, 5875, 5880, 5885, 5889, 5894, 5898, 5902, 5906, 5911, 5915, 5919, 5923, 5927, 5930, 5934,
    5938, 5942, 5945, 5949, 5952, 5956, 5959, 5963, 5966, 5969, 5972, 5976, 5979, 5985, 5991, 5997, 6002, 6008, 6013,
    6019, 6024, 6029, 6034, 6038, 6043, 6048, 6052, 6056, 6061, 6065, 6069, 6073, 6077, 6081, 6084, 6088, 6091, 6095,
    6098, 6102, 6105, 6108, 6111, 6114, 6118, 6121, 6123, 6126, 6129, 6132, 6135, 6137, 6140, 6142, 6145, 6147, 6150,
    6152, 6155, 6157, 6159, 6162, 6164, 6166, 6168, 6170, 6172, 6174, 6176, 6180, 6184, 6188, 6191, 6195, 6198, 6201,
    6205, 6208, 6211, 6214, 6217, 6219, 6222, 6225, 6227, 6230, 6232, 6235, 6237, 6239, 6242, 6244, 6246, 6248, 6250,
    6252, 6254, 6256, 6258, 6260, 6261, 6268, 6274, 6280, 6286, 6291, 6295, 6300, 6304, 6308, 6312, 6315, 6318, 6321,
    6324, 6327, 6330, 6332, 6334, 6337, 6339, 6341, 6343, 6345, 6347, 6348, 6350, 6352, 6353, 6355, 6356, 6357, 6359,
    6360, 6361, 6363, 6364, 6365, 6366, 6367, 6367};

static unsigned short sin_fix_lut[1572] = {
    0, 32, 65, 98, 131, 163, 196, 229, 262, 294, 327, 360, 393, 425, 458, 491,
    524, 557, 589, 622, 655, 688, 720, 753, 786, 819, 851, 884, 917, 950, 982, 1015,
    1048, 1081, 1113, 1146, 1179, 1212, 1244, 1277, 1310, 1343, 1375, 1408, 1441, 1474, 1506, 1539,
    1572, 1604, 1637, 1670, 1703, 1735, 1768, 1801, 1834, 1866, 1899, 1932, 1964, 1997, 2030, 2063,
    2095, 2128, 2161, 2193, 2226, 2259, 2291, 2324, 2357, 2389, 2422, 2455, 2487, 2520, 2553, 2585,
    2618, 2651, 2683, 2716, 2749, 2781, 2814, 2847, 2879, 2912, 2945, 2977, 3010, 3043, 3075, 3108,
    3140, 3173, 3206, 3238, 3271, 3303, 3336, 3369, 3401, 3434, 3466, 3499, 3532, 3564, 3597, 3629,
    3662, 3694, 3727, 3760, 3792, 3825, 3857, 3890, 3922, 3955, 3987, 4020, 4052, 4085, 4117, 4150,
    4182, 4215, 4247, 4280, 4312, 4345, 4377, 4410, 4442, 4475, 4507, 4540, 4572, 4604, 4637, 4669,
    4702, 4734, 4767, 4799, 4831, 4864, 4896, 4929, 4961, 4993, 5026, 5058, 5091, 5123, 5155, 5188,
    5220, 5252, 5285, 5317, 5349, 5382, 5414, 5446, 5479, 5511, 5543, 5576, 5608, 5640, 5672, 5705,
    5737, 5769, 5801, 5834, 5866, 5898, 5930, 5963, 5995, 6027, 6059, 6091, 6124, 6156, 6188, 6220,
    6252, 6285, 6317, 6349, 6381, 6413, 6445, 6477, 6510, 6542, 6574, 6606, 6638, 6670, 6702, 6734,
    6766, 6798, 6830, 6862, 6894, 6926, 6958, 6990, 7022, 7054, 7086, 7118, 7150, 7182, 7214, 7246,
    7278, 7310, 7342, 7374, 7406, 7438, 7470, 7502, 7534, 7566, 7597, 7629, 7661, 7693, 7725, 7757,
    7789, 7820, 7852, 7884, 7916, 7948, 7979, 8011, 8043, 8075, 8106, 8138, 8170, 8202, 8233, 8265,
    8297, 8328, 8360, 8392, 8424, 8455, 8487, 8518, 8550, 8582, 8613, 8645, 8677, 8708, 8740, 8771,
    8803, 8834, 8866, 8898, 8929, 8961, 8992, 9024, 9055, 9087, 9118, 9150, 9181, 9212, 9244, 9275,
    9307, 9338, 9370, 9401, 9432, 9464, 9495, 9526, 9558, 9589, 9620, 9652, 9683, 9714, 9746, 9777,
    9808, 9839, 9871, 9902, 9933, 9964, 9996, 10027, 10058, 10089, 10120, 10152, 10183, 10214, 10245, 10276,
    10307, 10338, 10369, 10400, 10432, 10463, 10494, 10525, 10556, 10587, 10618, 10649, 10680, 10711, 10742, 10773,
    10804, 10834, 10865, 10896, 10927, 10958, 10989, 11020, 11051, 11082, 11112, 11143, 11174, 11205, 11236, 11266,
    11297, 11328, 11359, 11389, 11420, 11451, 11481, 11512, 11543, 11573, 11604, 11635, 11665, 11696, 11727, 11757,
    11788, 11818, 11849, 11879, 11910, 11940, 11971, 12001, 12032, 12062, 12093, 12123, 12154, 12184, 12215, 12245,
    12275, 12306, 12336, 12366, 12397, 12427, 12457, 12488, 12518, 12548, 12579, 12609, 12639, 12669, 12700, 12730,
    12760, 12790, 12820, 12850, 12881, 12911, 12941, 12971, 13001, 13031, 13061, 13091, 13121, 13151, 13181, 13211,
    13241, 13271, 13301, 13331, 13361, 13391, 13421, 13451, 13481, 13510, 13540, 13570, 13600, 13630, 13659, 13689,
    13719, 13749, 13778, 13808, 13838, 13868, 13897, 13927, 13957, 13986, 14016, 14045, 14075, 14105, 14134, 14164,
    14193, 14223, 14252, 14282, 14311, 14341, 14370, 14400, 14429, 14459, 14488, 14517, 14547, 14576, 14605, 14635,
    14664, 14693, 14723, 14752, 14781, 14810, 14840, 14869, 14898, 14927, 14956, 14985, 15015, 15044, 15073, 15102,
    15131, 15160, 15189, 15218, 15247, 15276, 15305, 15334, 15363, 15392, 15421, 15450, 15479, 15508, 15536, 15565,
    15594, 15623, 15652, 15680, 15709, 15738, 15767, 15795, 15824, 15853, 15881, 15910, 15939, 15967, 15996, 16025,
    16053, 16082, 16110, 16139, 16167, 16196, 16224, 16253, 16281, 16310, 16338, 16366, 16395, 16423, 16452, 16480,
    16508, 16536, 16565, 16593, 16621, 16649, 16678, 16706, 16734, 16762, 16790, 16819, 16847, 16875, 16903, 16931,
    16959, 16987, 17015, 17043, 17071, 17099, 17127, 17155, 17183, 17211, 17238, 17266, 17294, 17322, 17350, 17378,
    17405, 17433, 17461, 17489, 17516, 17544, 17572, 17599, 17627, 17654, 17682, 17710, 17737, 17765, 17792, 17820,
    17847, 17875, 17902, 17930, 17957, 17984, 18012, 18039, 18067, 18094, 18121, 18148, 18176, 18203, 18230, 18257,
    18285, 18312, 18339, 18366, 18393, 18420, 18447, 18475, 18502, 18529, 18556, 18583, 18610, 18637, 18664, 18690,
    18717, 18744, 18771, 18798, 18825, 18852, 18878, 18905, 18932, 18959, 18985, 19012, 19039, 19065, 19092, 19119,
    19145, 19172, 19198, 19225, 19251, 19278, 19304, 19331, 19357, 19384, 19410, 19437, 19463, 19489, 19516, 19542,
    19568, 19595, 19621, 19647, 19673, 19699, 19726, 19752, 19778, 19804, 19830, 19856, 19882, 19908, 19934, 19960,
    19986, 20012, 20038, 20064, 20090, 20116, 20142, 20168, 20193, 20219, 20245, 20271, 20296, 20322, 20348, 20374,
    20399, 20425, 20450, 20476, 20502, 20527, 20553, 20578, 20604, 20629, 20655, 20680, 20705, 20731, 20756, 20782,
    20807, 20832, 20857, 20883, 20908, 20933, 20958, 20984, 21009, 21034, 21059, 21084, 21109, 21134, 21159, 21184,
    21209, 21234, 21259, 21284, 21309, 21334, 21359, 21383, 21408, 21433, 21458, 21483, 21507, 21532, 21557, 21581,
    21606, 21631, 21655, 21680, 21704, 21729, 21753, 21778, 21802, 21827, 21851, 21876, 21900, 21924, 21949, 21973,
    21997, 22022, 22046, 22070, 22094, 22119, 22143, 22167, 22191, 22215, 22239, 22263, 22287, 22311, 22335, 22359,
    22383, 22407, 22431, 22455, 22479, 22503, 22526, 22550, 22574, 22598, 22621, 22645, 22669, 22692, 22716, 22740,
    22763, 22787, 22810, 22834, 22857, 22881, 22904, 22928, 22951, 22974, 22998, 23021, 23044, 23068, 23091, 23114,
    23137, 23161, 23184, 23207, 23230, 23253, 23276, 23299, 23322, 23345, 23368, 23391, 23414, 23437, 23460, 23483,
    23506, 23528, 23551, 23574, 23597, 23620, 23642, 23665, 23688, 23710, 23733, 23755, 23778, 23800, 23823, 23845,
    23868, 23890, 23913, 23935, 23958, 23980, 24002, 24024, 24047, 24069, 24091, 24113, 24136, 24158, 24180, 24202,
    24224, 24246, 24268, 24290, 24312, 24334, 24356, 24378, 24400, 24422, 24444, 24465, 24487, 24509, 24531, 24552,
    24574, 24596, 24617, 24639, 24661, 24682, 24704, 24725, 24747, 24768, 24790, 24811, 24832, 24854, 24875, 24896,
    24918, 24939, 24960, 24981, 25003, 25024, 25045, 25066, 25087, 25108, 25129, 25150, 25171, 25192, 25213, 25234,
    25255, 25276, 25297, 25317, 25338, 25359, 25380, 25400, 25421, 25442, 25462, 25483, 25504, 25524, 25545, 25565,
    25586, 25606, 25627, 25647, 25667, 25688, 25708, 25728, 25749, 25769, 25789, 25809, 25830, 25850, 25870, 25890,
    25910, 25930, 25950, 25970, 25990, 26010, 26030, 26050, 26070, 26089, 26109, 26129, 26149, 26169, 26188, 26208,
    26228, 26247, 26267, 26286, 26306, 26325, 26345, 26364, 26384, 26403, 26423, 26442, 26461, 26481, 26500, 26519,
    26538, 26558, 26577, 26596, 26615, 26634, 26653, 26672, 26691, 26710, 26729, 26748, 26767, 26786, 26805, 26824,
    26843, 26861, 26880, 26899, 26918, 26936, 26955, 26973, 26992, 27011, 27029, 27048, 27066, 27085, 27103, 27121,
    27140, 27158, 27177, 27195, 27213, 27231, 27250, 27268, 27286, 27304, 27322, 27340, 27358, 27376, 27394, 27412,
    27430, 27448, 27466, 27484, 27502, 27519, 27537, 27555, 27573, 27590, 27608, 27626, 27643, 27661, 27678, 27696,
    27713, 27731, 27748, 27766, 27783, 27800, 27818, 27835, 27852, 27870, 27887, 27904, 27921, 27938, 27955, 27973,
    27990, 28007, 28024, 28041, 28058, 28074, 28091, 28108, 28125, 28142, 28159, 28175, 28192, 28209, 28225, 28242,
    28259, 28275, 28292, 28308, 28325, 28341, 28358, 28374, 28390, 28407, 28423, 28439, 28456, 28472, 28488, 28504,
    28520, 28537, 28553, 28569, 28585, 28601, 28617, 28633, 28649, 28664, 28680, 28696, 28712, 28728, 28744, 28759,
    28775, 28791, 28806, 28822, 28837, 28853, 28868, 28884, 28899, 28915, 28930, 28946, 28961, 28976, 28992, 29007,
    29022, 29037, 29052, 29068, 29083, 29098, 29113, 29128, 29143, 29158, 29173, 29188, 29203, 29217, 29232, 29247,
    29262, 29276, 29291, 29306, 29320, 29335, 29350, 29364, 29379, 29393, 29408, 29422, 29437, 29451, 29465, 29480,
    29494, 29508, 29522, 29537, 29551, 29565, 29579, 29593, 29607, 29621, 29635, 29649, 29663, 29677, 29691, 29705,
    29719, 29732, 29746, 29760, 29774, 29787, 29801, 29814, 29828, 29842, 29855, 29869, 29882, 29896, 29909, 29922,
    29936, 29949, 29962, 29975, 29989, 30002, 30015, 30028, 30041, 30054, 30067, 30080, 30093, 30106, 30119, 30132,
    30145, 30158, 30171, 30183, 30196, 30209, 30222, 30234, 30247, 30259, 30272, 30284, 30297, 30309, 30322, 30334,
    30347, 30359, 30371, 30384, 30396, 30408, 30420, 30432, 30445, 30457, 30469, 30481, 30493, 30505, 30517, 30529,
    30541, 30552, 30564, 30576, 30588, 30600, 30611, 30623, 30635, 30646, 30658, 30669, 30681, 30692, 30704, 30715,
    30727, 30738, 30749, 30761, 30772, 30783, 30794, 30806, 30817, 30828, 30839, 30850, 30861, 30872, 30883, 30894,
    30905, 30916, 30927, 30937, 30948, 30959, 30970, 30980, 30991, 31002, 31012, 31023, 31033, 31044, 31054, 31065,
    31075, 31086, 31096, 31106, 31116, 31127, 31137, 31147, 31157, 31167, 31178, 31188, 31198, 31208, 31218, 31228,
    31237, 31247, 31257, 31267, 31277, 31287, 31296, 31306, 31316, 31325, 31335, 31344, 31354, 31363, 31373, 31382,
    31392, 31401, 31411, 31420, 31429, 31438, 31448, 31457, 31466, 31475, 31484, 31493, 31502, 31511, 31520, 31529,
    31538, 31547, 31556, 31565, 31573, 31582, 31591, 31600, 31608, 31617, 31625, 31634, 31643, 31651, 31659, 31668,
    31676, 31685, 31693, 31701, 31710, 31718, 31726, 31734, 31742, 31751, 31759, 31767, 31775, 31783, 31791, 31799,
    31806, 31814, 31822, 31830, 31838, 31845, 31853, 31861, 31868, 31876, 31884, 31891, 31899, 31906, 31914, 31921,
    31928, 31936, 31943, 31950, 31958, 31965, 31972, 31979, 31986, 31993, 32001, 32008, 32015, 32022, 32028, 32035,
    32042, 32049, 32056, 32063, 32069, 32076, 32083, 32089, 32096, 32103, 32109, 32116, 32122, 32129, 32135, 32141,
    32148, 32154, 32160, 32167, 32173, 32179, 32185, 32191, 32198, 32204, 32210, 32216, 32222, 32228, 32233, 32239,
    32245, 32251, 32257, 32263, 32268, 32274, 32280, 32285, 32291, 32296, 32302, 32307, 32313, 32318, 32324, 32329,
    32334, 32340, 32345, 32350, 32355, 32360, 32366, 32371, 32376, 32381, 32386, 32391, 32396, 32401, 32405, 32410,
    32415, 32420, 32425, 32429, 32434, 32439, 32443, 32448, 32452, 32457, 32461, 32466, 32470, 32475, 32479, 32483,
    32488, 32492, 32496, 32500, 32504, 32509, 32513, 32517, 32521, 32525, 32529, 32533, 32537, 32540, 32544, 32548,
    32552, 32556, 32559, 32563, 32567, 32570, 32574, 32577, 32581, 32584, 32588, 32591, 32595, 32598, 32601, 32605,
    32608, 32611, 32614, 32617, 32620, 32624, 32627, 32630, 32633, 32636, 32638, 32641, 32644, 32647, 32650, 32653,
    32655, 32658, 32661, 32663, 32666, 32668, 32671, 32673, 32676, 32678, 32681, 32683, 32685, 32688, 32690, 32692,
    32694, 32697, 32699, 32701, 32703, 32705, 32707, 32709, 32711, 32713, 32715, 32717, 32718, 32720, 32722, 32724,
    32725, 32727, 32729, 32730, 32732, 32733, 32735, 32736, 32738, 32739, 32740, 32742, 32743, 32744, 32745, 32747,
    32748, 32749, 32750, 32751, 32752, 32753, 32754, 32755, 32756, 32757, 32757, 32758, 32759, 32760, 32760, 32761,
    32762, 32762, 32763, 32763, 32764, 32764, 32765, 32765, 32766, 32766, 32766, 32767, 32767, 32767, 32767, 32767,
    32767, 32767, 32767, 32768};

static unsigned short cos_fix_lut[1572] = {
    32768, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32766, 32766, 32766, 32766, 32765, 32765, 32764, 32764,
    32763, 32763, 32762, 32762, 32761, 32760, 32760, 32759, 32758, 32757, 32756, 32756, 32755, 32754, 32753, 32752,
    32751, 32750, 32749, 32747, 32746, 32745, 32744, 32743, 32741, 32740, 32739, 32737, 32736, 32734, 32733, 32731,
    32730, 32728, 32727, 32725, 32723, 32721, 32720, 32718, 32716, 32714, 32712, 32710, 32709, 32707, 32705, 32702,
    32700, 32698, 32696, 32694, 32692, 32690, 32687, 32685, 32683, 32680, 32678, 32675, 32673, 32670, 32668, 32665,
    32663, 32660, 32657, 32655, 32652, 32649, 32646, 32644, 32641, 32638, 32635, 32632, 32629, 32626, 32623, 32620,
    32617, 32613, 32610, 32607, 32604, 32601, 32597, 32594, 32590, 32587, 32584, 32580, 32577, 32573, 32569, 32566,
    32562, 32559, 32555, 32551, 32547, 32543, 32540, 32536, 32532, 32528, 32524, 32520, 32516, 32512, 32508, 32504,
    32499, 32495, 32491, 32487, 32482, 32478, 32474, 32469, 32465, 32460, 32456, 32451, 32447, 32442, 32438, 32433,
    32428, 32424, 32419, 32414, 32409, 32404, 32400, 32395, 32390, 32385, 32380, 32375, 32370, 32364, 32359, 32354,
    32349, 32344, 32338, 32333, 32328, 32322, 32317, 32312, 32306, 32301, 32295, 32290, 32284, 32278, 32273, 32267,
    32261, 32256, 32250, 32244, 32238, 32232, 32226, 32220, 32214, 32208, 32202, 32196, 32190, 32184, 32178, 32172,
    32165, 32159, 32153, 32146, 32140, 32134, 32127, 32121, 32114, 32108, 32101, 32095, 32088, 32081, 32075, 32068,
    32061, 32054, 32048, 32041, 32034, 32027, 32020, 32013, 32006, 31999, 31992, 31985, 31978, 31971, 31963, 31956,
    31949, 31942, 31934, 31927, 31919, 31912, 31905, 31897, 31890, 31882, 31874, 31867, 31859, 31852, 31844, 31836,
    31828, 31820, 31813, 31805, 31797, 31789, 31781, 31773, 31765, 31757, 31749, 31741, 31733, 31724, 31716, 31708,
    31700, 31691, 31683, 31675, 31666, 31658, 31649, 31641, 31632, 31624, 31615, 31606, 31598, 31589, 31580, 31572,
    31563, 31554, 31545, 31536, 31527, 31518, 31509, 31500, 31491, 31482, 31473, 31464, 31455, 31446, 31436, 31427,
    31418, 31409, 31399, 31390, 31380, 31371, 31362, 31352, 31342, 31333, 31323, 31314, 31304, 31294, 31285, 31275,
    31265, 31255, 31245, 31235, 31226, 31216, 31206, 31196, 31186, 31175, 31165, 31155, 31145, 31135, 31125, 31114,
    31104, 31094, 31083, 31073, 31063, 31052, 31042, 31031, 31021, 31010, 30999, 30989, 30978, 30967, 30957, 30946,
    30935, 30924, 30913, 30903, 30892, 30881, 30870, 30859, 30848, 30837, 30826, 30814, 30803, 30792, 30781, 30770,
    30758, 30747, 30736, 30724, 30713, 30701, 30690, 30679, 30667, 30655, 30644, 30632, 30621, 30609, 30597, 30585,
    30574, 30562, 30550, 30538, 30526, 30514, 30502, 30490, 30478, 30466, 30454, 30442, 30430, 30418, 30406, 30393,
    30381, 30369, 30357, 30344, 30332, 30319, 30307, 30294, 30282, 30269, 30257, 30244, 30232, 30219, 30206, 30194,
    30181, 30168, 30155, 30142, 30130, 30117, 30104, 30091, 30078, 30065, 30052, 30039, 30026, 30012, 29999, 29986,
    29973, 29960, 29946, 29933, 29920, 29906, 29893, 29879, 29866, 29852, 29839, 29825, 29812, 29798, 29785, 29771,
    29757, 29743, 29730, 29716, 29702, 29688, 29674, 29660, 29646, 29632, 29618, 29604, 29590, 29576, 29562, 29548,
    29534, 29520, 29505, 29491, 29477, 29462, 29448, 29434, 29419, 29405, 29390, 29376, 29361, 29347, 29332, 29318,
    29303, 29288, 29274, 29259, 29244, 29229, 29214, 29200, 29185, 29170, 29155, 29140, 29125, 29110, 29095, 29080,
    29065, 29049, 29034, 29019, 29004, 28989, 28973, 28958, 28943, 28927, 28912, 28896, 28881, 28865, 28850, 28834,
    28819, 28803, 28788, 28772, 28756, 28740, 28725, 28709, 28693, 28677, 28661, 28646, 28630, 28614, 28598, 28582,
    28566, 28550, 28533, 28517, 28501, 28485, 28469, 28453, 28436, 28420, 28404, 28387, 28371, 28354, 28338, 28322,
    28305, 28289, 28272, 28255, 28239, 28222, 28206, 28189, 28172, 28155, 28139, 28122, 28105, 28088, 28071, 28054,
    28037, 28020, 28003, 27986, 27969, 27952, 27935, 27918, 27901, 27884, 27866, 27849, 27832, 27815, 27797, 27780,
    27762, 27745, 27728, 27710, 27693, 27675, 27657, 27640, 27622, 27605, 27587, 27569, 27552, 27534, 27516, 27498,
    27480, 27463, 27445, 27427, 27409, 27391, 27373, 27355, 27337, 27319, 27301, 27282, 27264, 27246, 27228, 27210,
    27191, 27173, 27155, 27136, 27118, 27100, 27081, 27063, 27044, 27026, 27007, 26989, 26970, 26951, 26933, 26914,
    26895, 26877, 26858, 26839, 26820, 26801, 26783, 26764, 26745, 26726, 26707, 26688, 26669, 26650, 26631, 26612,
    26592, 26573, 26554, 26535, 26516, 26496, 26477, 26458, 26438, 26419, 26400, 26380, 26361, 26341, 26322, 26302,
    26283, 26263, 26243, 26224, 26204, 26184, 26165, 26145, 26125, 26105, 26086, 26066, 26046, 26026, 26006, 25986,
    25966, 25946, 25926, 25906, 25886, 25866, 25846, 25826, 25805, 25785, 25765, 25745, 25725, 25704, 25684, 25664,
    25643, 25623, 25602, 25582, 25561, 25541, 25520, 25500, 25479, 25458, 25438, 25417, 25396, 25376, 25355, 25334,
    25313, 25293, 25272, 25251, 25230, 25209, 25188, 25167, 25146, 25125, 25104, 25083, 25062, 25041, 25020, 24999,
    24977, 24956, 24935, 24914, 24892, 24871, 24850, 24828, 24807, 24785, 24764, 24743, 24721, 24700, 24678, 24656,
    24635, 24613, 24592, 24570, 24548, 24526, 24505, 24483, 24461, 24439, 24418, 24396, 24374, 24352, 24330, 24308,
    24286, 24264, 24242, 24220, 24198, 24176, 24154, 24131, 24109, 24087, 24065, 24043, 24020, 23998, 23976, 23953,
    23931, 23909, 23886, 23864, 23841, 23819, 23796, 23774, 23751, 23728, 23706, 23683, 23661, 23638, 23615, 23592,
    23570, 23547, 23524, 23501, 23478, 23456, 23433, 23410, 23387, 23364, 23341, 23318, 23295, 23272, 23249, 23226,
    23203, 23179, 23156, 23133, 23110, 23087, 23063, 23040, 23017, 22993, 22970, 22947, 22923, 22900, 22876, 22853,
    22829, 22806, 22782, 22759, 22735, 22712, 22688, 22664, 22641, 22617, 22593, 22569, 22546, 22522, 22498, 22474,
    22450, 22426, 22403, 22379, 22355, 22331, 22307, 22283, 22259, 22235, 22211, 22186, 22162, 22138, 22114, 22090,
    22066, 22041, 22017, 21993, 21969, 21944, 21920, 21895, 21871, 21847, 21822, 21798, 21773, 21749, 21724, 21700,
    21675, 21651, 21626, 21601, 21577, 21552, 21527, 21503, 21478, 21453, 21428, 21404, 21379, 21354, 21329, 21304,
    21279, 21254, 21229, 21204, 21179, 21154, 21129, 21104, 21079, 21054, 21029, 21004, 20979, 20954, 20928, 20903,
    20878, 20853, 20827, 20802, 20777, 20751, 20726, 20701, 20675, 20650, 20624, 20599, 20573, 20548, 20522, 20497,
    20471, 20446, 20420, 20394, 20369, 20343, 20317, 20292, 20266, 20240, 20214, 20188, 20163, 20137, 20111, 20085,
    20059, 20033, 20007, 19981, 19955, 19929, 19903, 19877, 19851, 19825, 19799, 19773, 19747, 19721, 19694, 19668,
    19642, 19616, 19590, 19563, 19537, 19511, 19484, 19458, 19432, 19405, 19379, 19352, 19326, 19299, 19273, 19246,
    19220, 19193, 19167, 19140, 19114, 19087, 19060, 19034, 19007, 18980, 18954, 18927, 18900, 18873, 18846, 18820,
    18793, 18766, 18739, 18712, 18685, 18658, 18631, 18604, 18577, 18550, 18523, 18496, 18469, 18442, 18415, 18388,
    18361, 18334, 18307, 18279, 18252, 18225, 18198, 18171, 18143, 18116, 18089, 18061, 18034, 18007, 17979, 17952,
    17924, 17897, 17870, 17842, 17815, 17787, 17759, 17732, 17704, 17677, 17649, 17622, 17594, 17566, 17539, 17511,
    17483, 17455, 17428, 17400, 17372, 17344, 17317, 17289, 17261, 17233, 17205, 17177, 17149, 17121, 17094, 17066,
    17038, 17010, 16982, 16954, 16925, 16897, 16869, 16841, 16813, 16785, 16757, 16729, 16700, 16672, 16644, 16616,
    16588, 16559, 16531, 16503, 16474, 16446, 16418, 16389, 16361, 16333, 16304, 16276, 16247, 16219, 16190, 16162,
    16133, 16105, 16076, 16048, 16019, 15990, 15962, 15933, 15905, 15876, 15847, 15819, 15790, 15761, 15732, 15704,
    15675, 15646, 15617, 15588, 15560, 15531, 15502, 15473, 15444, 15415, 15386, 15357, 15328, 15299, 15270, 15241,
    15212, 15183, 15154, 15125, 15096, 15067, 15038, 15009, 14980, 14951, 14921, 14892, 14863, 14834, 14805, 14775,
    14746, 14717, 14688, 14658, 14629, 14600, 14570, 14541, 14512, 14482, 14453, 14423, 14394, 14364, 14335, 14306,
    14276, 14247, 14217, 14188, 14158, 14128, 14099, 14069, 14040, 14010, 13980, 13951, 13921, 13891, 13862, 13832,
    13802, 13773, 13743, 13713, 13683, 13654, 13624, 13594, 13564, 13534, 13504, 13475, 13445, 13415, 13385, 13355,
    13325, 13295, 13265, 13235, 13205, 13175, 13145, 13115, 13085, 13055, 13025, 12995, 12965, 12935, 12905, 12874,
    12844, 12814, 12784, 12754, 12724, 12693, 12663, 12633, 12603, 12573, 12542, 12512, 12482, 12451, 12421, 12391,
    12360, 12330, 12300, 12269, 12239, 12208, 12178, 12148, 12117, 12087, 12056, 12026, 11995, 11965, 11934, 11904,
    11873, 11843, 11812, 11782, 11751, 11720, 11690, 11659, 11629, 11598, 11567, 11537, 11506, 11475, 11444, 11414,
    11383, 11352, 11322, 11291, 11260, 11229, 11198, 11168, 11137, 11106, 11075, 11044, 11014, 10983, 10952, 10921,
    10890, 10859, 10828, 10797, 10766, 10735, 10704, 10673, 10642, 10611, 10580, 10549, 10518, 10487, 10456, 10425,
    10394, 10363, 10332, 10301, 10270, 10239, 10207, 10176, 10145, 10114, 10083, 10052, 10020, 9989, 9958, 9927,
    9896, 9864, 9833, 9802, 9771, 9739, 9708, 9677, 9645, 9614, 9583, 9551, 9520, 9489, 9457, 9426,
    9394, 9363, 9332, 9300, 9269, 9237, 9206, 9174, 9143, 9112, 9080, 9049, 9017, 8986, 8954, 8923,
    8891, 8859, 8828, 8796, 8765, 8733, 8702, 8670, 8638, 8607, 8575, 8544, 8512, 8480, 8449, 8417,
    8385, 8354, 8322, 8290, 8258, 8227, 8195, 8163, 8132, 8100, 8068, 8036, 8004, 7973, 7941, 7909,
    7877, 7846, 7814, 7782, 7750, 7718, 7686, 7654, 7623, 7591, 7559, 7527, 7495, 7463, 7431, 7399,
    7367, 7335, 7304, 7272, 7240, 7208, 7176, 7144, 7112, 7080, 7048, 7016, 6984, 6952, 6920, 6888,
    6856, 6824, 6791, 6759, 6727, 6695, 6663, 6631, 6599, 6567, 6535, 6503, 6471, 6438, 6406, 6374,
    6342, 6310, 6278, 6246, 6213, 6181, 6149, 6117, 6085, 6052, 6020, 5988, 5956, 5924, 5891, 5859,
    5827, 5795, 5762, 5730, 5698, 5666, 5633, 5601, 5569, 5536, 5504, 5472, 5439, 5407, 5375, 5342,
    5310, 5278, 5245, 5213, 5181, 5148, 5116, 5084, 5051, 5019, 4987, 4954, 4922, 4889, 4857, 4825,
    4792, 4760, 4727, 4695, 4662, 4630, 4598, 4565, 4533, 4500, 4468, 4435, 4403, 4370, 4338, 4305,
    4273, 4240, 4208, 4175, 4143, 4110, 4078, 4045, 4013, 3980, 3948, 3915, 3883, 3850, 3818, 3785,
    3752, 3720, 3687, 3655, 3622, 3590, 3557, 3525, 3492, 3459, 3427, 3394, 3362, 3329, 3296, 3264,
    3231, 3199, 3166, 3133, 3101, 3068, 3035, 3003, 2970, 2938, 2905, 2872, 2840, 2807, 2774, 2742,
    2709, 2676, 2644, 2611, 2578, 2546, 2513, 2480, 2448, 2415, 2382, 2350, 2317, 2284, 2252, 2219,
    2186, 2153, 2121, 2088, 2055, 2023, 1990, 1957, 1925, 1892, 1859, 1826, 1794, 1761, 1728, 1696,
    1663, 1630, 1597, 1565, 1532, 1499, 1466, 1434, 1401, 1368, 1335, 1303, 1270, 1237, 1204, 1172,
    1139, 1106, 1073, 1041, 1008, 975, 942, 910, 877, 844, 811, 779, 746, 713, 680, 648,
    615, 582, 549, 517, 484, 451, 418, 385, 353, 320, 287, 254, 222, 189, 156, 123,
    91, 58, 25};






static unsigned int Inverse(unsigned short x, int M, char* N);







static unsigned int Inverse32(unsigned short x, int M, char* N);
# 2838 "../../../../../overlays/Vitis_Libraries/vision//L1/include/core/xf_math.h"
static unsigned int DivideYByX(unsigned short x, unsigned short y, int M1, int M2, char* out_M, char* out_N);






static short Atan2LookupFP(short xs, short ys, int M1, int N1, int M2, int N2);
# 2854 "../../../../../overlays/Vitis_Libraries/vision//L1/include/core/xf_math.h"
static int Sqrt(unsigned int D);




static unsigned int Inverse32(unsigned short x, int M, char* N) {
    (__builtin_assume(static_cast <bool> ((M <= 16) && "Integer part of x should always be less than or equal to 16 bits.")));
    unsigned int val = 0;
    unsigned int index;
    int B_L = 17;

    int tmp = 4;
    int pos, block;
    pos = block = 0;
    int shift = 0;
    unsigned short x1 = (x >> 12) & 0x000F;
    unsigned short x2 = (x >> 8) & 0x000F;
    unsigned short x3 = (x >> 4) & 0x000F;
    unsigned short x4 = x & 0x000F;

    unsigned short tmpx = 0;

    if (x == 0) {
        return division_lut[0];
    } else {
        if (x1 > 0) {
            tmpx = x1;
            block = 0;
            VITIS_LOOP_2882_1: for (tmp = 0; tmp < 4; tmp++) {

#pragma HLS LOOP_TRIPCOUNT min=4 max=4 avg=4
#pragma HLS pipeline

 tmpx = x1 >> (3 - tmp);
                if (tmpx) {
                    pos = tmp + 1;
                    break;
                }
            }
        } else if (x2 > 0) {
            block = 4;
            tmpx = x2;
            VITIS_LOOP_2896_2: for (tmp = 0; tmp < 4; tmp++) {

#pragma HLS LOOP_TRIPCOUNT min=4 max=4 avg=4
#pragma HLS pipeline

 tmpx = x2 >> (3 - tmp);
                if (tmpx) {
                    pos = tmp + 1;
                    break;
                }
            }
        } else if (x3 > 0) {
            block = 8;
            tmpx = x3;
            VITIS_LOOP_2910_3: for (tmp = 0; tmp < 4; tmp++) {

#pragma HLS LOOP_TRIPCOUNT min=4 max=4 avg=4
#pragma HLS pipeline

 tmpx = x3 >> (3 - tmp);
                if (tmpx) {
                    pos = tmp + 1;
                    break;
                }
            }
        } else {
            block = 12;
            tmpx = x4;
            VITIS_LOOP_2924_4: for (tmp = 0; tmp < 4; tmp++) {

#pragma HLS LOOP_TRIPCOUNT min=4 max=4 avg=4
#pragma HLS pipeline

 tmpx = x4 >> (3 - tmp);
                if (tmpx) {
                    pos = tmp + 1;
                    break;
                }
            }
        }
    }
    B_L = block + pos;
    shift = 0;
    if (B_L >= 1) {
        index = ((x << (B_L - 1)) & 0x7FFF) >> shift;
    } else {
        index = (x & 0x7FFF) >> shift;
    }
    val = division_lut32[index];

    *N = M + 16 - B_L;

    return val;
}

static unsigned int Inverse(unsigned short x, int M, char* N) {
#pragma HLS inline off
 (__builtin_assume(static_cast <bool> ((M <= 16) && "Integer part of x should always be less than or equal to 16 bits.")));
    unsigned int val = 0;
    unsigned int index;
    int B_L = 16 + 1;


    int pos, block;
    pos = block = 0;
    int shift = 0;
    unsigned short x1 = (x >> 12) & 0x000F;
    unsigned short x2 = (x >> 8) & 0x000F;
    unsigned short x3 = (x >> 4) & 0x000F;
    unsigned short x4 = x & 0x000F;

    unsigned short tmpx = 0;

    unsigned short x_sel;
    if (x1 > 0) {
        block = 0;
        x_sel = x1;
    } else if (x2 > 0) {
        block = 1;
        x_sel = x2;
    } else if (x3 > 0) {
        block = 2;
        x_sel = x3;
    } else {
        block = 3;
        x_sel = x4;
    }

    unsigned short tmpx_0 = x_sel >> (3 - 0);
    unsigned short tmpx_1 = x_sel >> (3 - 1);
    unsigned short tmpx_2 = x_sel >> (3 - 2);
    unsigned short tmpx_3 = x_sel >> (3 - 3);

    if (tmpx_0)
        pos = 1;
    else if (tmpx_1)
        pos = 2;
    else if (tmpx_2)
        pos = 3;
    else if (tmpx_3)
        pos = 4;

    B_L = 4 * block + pos;
    shift = 16 - 11;
    index = ((x << (B_L - 1)) & 0x7FFF) >> shift;

    val = division_lut[index];
    *N = M + 16 - B_L;

    return val;
}

static char IdentifySignBits(ap_int<24> in_val) {
    bool flag = 0;
    char counter = 0;

    bool signbit = in_val.range(23, 23);

signBitsLoop:
    while (flag == 0) {

#pragma HLS LOOP_TRIPCOUNT min=24 max=24
#pragma HLS PIPELINE


 bool bit_val = in_val.range((23 - counter), (23 - counter));

        if (bit_val == signbit)
            counter++;
        else
            flag = 1;

        if (counter == 24) break;
    }
    return counter;
}

static unsigned short Inverse8(unsigned char x, int M, char* N) {
    (__builtin_assume(static_cast <bool> ((M == 8) && "x should be of Q8.0 format.")));
    unsigned int val = 0;
    unsigned int index;

    if (x == 0)
        return division_lut8[0];
    else {
        val = division_lut8[x];
        *N = 15;
    }

    return val;
}

static unsigned int DivideYByX(unsigned short x, unsigned short y, int M1, int M2, char* out_M, char* out_N) {
    unsigned int div_val;
    char MOut, NOut;
    unsigned int x_inv = Inverse(x, M1, &NOut);

    MOut = 16 - NOut + M2;
    NOut = NOut + 16 - M2;

    div_val = y * x_inv;

    *out_M = MOut;
    *out_N = NOut;

    return div_val;
}
static void findInverse24(ap_int<24>& x, int& M, int& N, unsigned int& inv_x, int* outM, int* outN) {
    if (x == 0) {

        inv_x = division_lut[0];
        *outM = 16;
        *outN = 0;
        return;
    }
    char sb = IdentifySignBits(x);

    ap_int24_t unsigned_x = (ap_int24_t)x.range(23 - sb, 0);

    int M1, N1, leftover_bits = 0;
    if (N == 0) {
        M1 = M - sb;
        if (M1 > 16) {
            leftover_bits = M1 - 16;
        }
        M1 = 16;
    }

    unsigned short xs = unsigned_x >> leftover_bits;
    char Nout;
    unsigned int inv_xs = Inverse(xs, M1, &Nout);
    inv_x = (long int)inv_xs;

    *outN = Nout + leftover_bits;
    *outM = 32 - Nout;
}
static unsigned int DivideYByX8(unsigned char x, unsigned char y, int M1, int M2, char* out_M, char* out_N) {
    (__builtin_assume(static_cast <bool> ((M1 == 8) && (M2 == 8) && "x and y should be of Q8.0 format.")));

    unsigned int div_val;
    char MOut, NOut;
    unsigned short x_inv = Inverse8(x, M1, &NOut);

    MOut = (16 - NOut) + M2;
    NOut = NOut + (8 - M2);

    div_val = y * x_inv;

    *out_M = MOut;
    *out_N = NOut;

    return div_val;
}

static unsigned long int DivideYByX24(ap_int24_t x, ap_int24_t y, int M1, int M2, int* out_M, int* out_N) {
    unsigned long int div_val;
    char MOut, NOut;
    unsigned int x_inv;
    int N1 = 0, N2 = 0;
    int M3, N3;

    findInverse24(x, M1, N1, x_inv, &M3, &N3);

    MOut = M2 + M3;
    NOut = N3 + 24 - M2;

    div_val = (unsigned long int)y * x_inv;

    *out_M = MOut;
    *out_N = NOut;

    return div_val;
}
static short Atan2LookupFP(short xs, short ys, int M1, int N1, int M2, int N2) {
    (__builtin_assume(static_cast <bool> (((N1 == 16 - M1) && (N2 == 16 - M2) && (M1 == M2)) && "xs and ys should be of 16-bit and same fixed point type.")));

    short theta;
    signed char s1, s2, s;
    if (ys == 0 && xs == 0)
        return 0;
    else {
        unsigned long gy_fp, gx_fp;
        unsigned long int frac_extractor;
        unsigned long int k2_fp;
        unsigned short int_part;
        unsigned int frac_part, frac_ind, frac_bits;

        gx_fp = xs;
        s1 = 1;
        gy_fp = ys;
        s2 = 1;

        if (xs < 0) {
            gx_fp = -xs;
            s1 = -1;
        }
        if (ys < 0) {
            gy_fp = -ys;
            s2 = -1;
        }

        s = s1 * s2;

        char MOut, NOut;
        k2_fp = DivideYByX(gx_fp, gy_fp, M1, M2, &MOut, &NOut);

        frac_extractor = (1 << NOut) - 1;

        int_part = k2_fp >> NOut;
        frac_part = (k2_fp & frac_extractor);

        if (int_part < 63) {
            frac_bits = frac_bits_lut[int_part];
            frac_ind = (frac_part >> (NOut - frac_bits));
            int ind = base_addr_lut[int_part] + frac_ind;
            theta = atan_lut_fp[ind];
        } else
            theta = 6433;

        if (gx_fp == 0) theta = 6433;

        if (s < 0) theta = -theta;

        if (xs > 0)
            return theta;
        else if (ys >= 0 && xs < 0)
            return 12867 + theta;
        else if (ys < 0 && xs < 0)
            return theta - 12867;
        else if (ys > 0 && xs == 0)
            return 6433;
        else if (ys < 0 && xs == 0)
            return -6433;
    }
    return theta;
}

static short Atan2LUT8(short xs, short ys, int M1, int N1, int M2, int N2) {
    (__builtin_assume(static_cast <bool> (((N1 == 9 - M1) && (N2 == 9 - M2) && (M1 == M2)) && "xs and ys should be of signed 9-bit and same fixed point type.")));

    short theta;
    signed char s1, s2, s;
    if (ys == 0 && xs == 0)
        return 0;
    else {
        unsigned short gy_fp, gx_fp;
        unsigned long int frac_extractor;
        unsigned int k2_fp;
        unsigned short int_part;
        unsigned int frac_part, frac_ind, frac_bits;

        gx_fp = xs;
        s1 = 1;
        gy_fp = ys;
        s2 = 1;

        if (xs < 0) {
            gx_fp = -xs;
            s1 = -1;
        }
        if (ys < 0) {
            gy_fp = -ys;
            s2 = -1;
        }

        s = s1 * s2;

        char MOut, NOut;

        k2_fp = DivideYByX8((unsigned char)gx_fp, (unsigned char)gy_fp, 8, 8, &MOut, &NOut);

        frac_extractor = (1 << NOut) - 1;

        int_part = k2_fp >> NOut;
        frac_part = (k2_fp & frac_extractor);

        if (int_part < 63) {
            frac_bits = base_addr_lut8[63 + int_part];
            frac_ind = (frac_part >> (NOut - frac_bits));
            int ind = base_addr_lut8[int_part] + frac_ind;
            theta = atan_lut_fp8[ind];
        } else
            theta = 6433;

        if (gx_fp == 0) theta = 6433;

        if (s < 0) theta = -theta;

        if (xs > 0)
            return theta;
        else if (ys >= 0 && xs < 0)
            return 12867 + theta;
        else if (ys < 0 && xs < 0)
            return theta - 12867;
        else if (ys > 0 && xs == 0)
            return 6433;
        else if (ys < 0 && xs == 0)
            return -6433;
    }
    return theta;
}

static short Atan2LookupFP24(ap_int24_t xs, ap_int24_t ys, int M1, int N1, int M2, int N2) {
    (__builtin_assume(static_cast <bool> (((N1 == 24 - M1) && (N2 == 24 - M2) && (M1 == M2)) && "xs and ys should be of 24-bit and same fixed point type.")));

    short theta;
    char s1, s2, s;
    if (ys == 0 && xs == 0)
        return 0;
    else {
        ap_int24_t gy_fp, gx_fp;
        unsigned long int frac_extractor;
        unsigned long int k2_fp;
        unsigned short int_part;
        unsigned long int frac_part = 0, frac_ind = 0, frac_bits = 0;

        gx_fp = xs;
        s1 = 1;
        gy_fp = ys;
        s2 = 1;

        if (xs < 0) {
            gx_fp = -xs;
            s1 = -1;
        }
        if (ys < 0) {
            gy_fp = -ys;
            s2 = -1;
        }

        s = s1 * s2;

        int MOut, NOut;

        k2_fp = DivideYByX24(gx_fp, gy_fp, M1, M2, &MOut, &NOut);

        frac_extractor = ((unsigned long int)1 << NOut) - 1;

        int_part = k2_fp >> NOut;
        frac_part = (k2_fp & frac_extractor);

        if (int_part < 63) {
            frac_bits = frac_bits_lut[int_part];
            frac_ind = (unsigned long int)(frac_part >> (NOut - frac_bits));
            int ind = base_addr_lut[int_part] + frac_ind;
            theta = atan_lut_fp[ind];
        } else
            theta = 6433;

        if (gx_fp == 0) theta = 6433;

        if (s < 0) theta = -theta;

        if (xs > 0)
            return theta;
        else if (ys >= 0 && xs < 0)
            return 12867 + theta;
        else if (ys < 0 && xs < 0)
            return theta - 12867;
        else if (ys > 0 && xs == 0)
            return 6433;
        else if (ys < 0 && xs == 0)
            return -6433;
    }
    return theta;
}
# 3338 "../../../../../overlays/Vitis_Libraries/vision//L1/include/core/xf_math.h"
static int Sqrt(unsigned int D) {

    int i;
    short int Q;
    int R;
    Q = R = 0;
    int tmp = 0;
    int tmpQ, tmpR;

    VITIS_LOOP_3347_1: for (i = 15; i >= 0; i--) {

#pragma HLS pipeline

 if (R >= 0) {
            tmp = D >> (i + i);
            tmp = tmp & 3;
            tmpR = R << 2;
            R = tmpR | tmp;

            tmpQ = Q << 2;
            tmpQ = tmpQ | 1;

            R = R - tmpQ;
        } else {
            tmp = D >> (i + i);
            tmp = tmp & 3;
            tmpR = R << 2;
            R = tmpR | tmp;

            tmpQ = Q << 2;
            tmpQ = tmpQ | 3;

            R = R + tmpQ;
        }
        if (R >= 0) {
            Q = Q << 1;
            Q = Q | 1;
        } else {
            Q = Q << 1;
            Q = Q | 0;
        }
    }
    return Q;
}
}
}
# 24 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_quantizationdithering.hpp" 2

# 1 "/tools/Xilinx/Vitis_HLS/2022.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 26 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_quantizationdithering.hpp" 2

namespace xf {
namespace cv {

constexpr unsigned XF_LOG2(unsigned x) {
    return (x < 2) ? 0 : 1 + XF_LOG2(x >> 1);
}

template <int OUT_TYPE>
bool isPowerOfTwo(int n) {
    if (n == 0) return 0;
    VITIS_LOOP_37_1: while (n != 1) {
        if (n % 2 != 0) return 0;
        n = n / 2;
    }
    return 1;
}

template <int IN_TYPE, int OUT_TYPE, int ROWS, int COLS, int SCALE_FACTOR, int MAX_REPRESENTED_VALUE, int NPC>
void xf_QuatizationDithering(xf::cv::Mat<IN_TYPE, ROWS, COLS, NPC>& stream_in,
                             xf::cv::Mat<OUT_TYPE, ROWS, COLS, NPC>& stream_out) {
    enum {
        PLANES = DataType<IN_TYPE, NPC>::channel,

        PIXELWIDTH_IN = DataType<IN_TYPE, NPC>::pixelwidth,
        BITDEPTH_IN = PIXELWIDTH_IN / PLANES,

        PIXELWIDTH_OUT = DataType<OUT_TYPE, NPC>::pixelwidth,
        BITDEPTH_OUT = PIXELWIDTH_OUT / PLANES,

        QUANTIZATION_INTERVAL = MAX_REPRESENTED_VALUE / SCALE_FACTOR,

        LOG2_SCALE_FACTOR = XF_LOG2(SCALE_FACTOR),
        LOG2_QUANTIZATION_INTERVAL = XF_LOG2(QUANTIZATION_INTERVAL),
        LOG2_MAX_REPRESENTED_VALUE = XF_LOG2(MAX_REPRESENTED_VALUE),

        DEPTH_OFFSETBUFFER = (COLS + (NPC - 1)) / NPC
    };
# 96 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_quantizationdithering.hpp"
    unsigned short height = stream_in.rows;
    unsigned short width = stream_in.cols;

    unsigned short imgInput_ncpr = (width + (NPC - 1)) >> xfNPixelsPerCycle<NPC>::datashift;

    short in_col_loop_bound = imgInput_ncpr + 1;


    ap_int<BITDEPTH_IN> offset_buffer[PLANES][NPC][DEPTH_OFFSETBUFFER];

#pragma HLS ARRAY_PARTITION variable = offset_buffer complete dim = 1
#pragma HLS ARRAY_PARTITION variable = offset_buffer complete dim = 2


 VITIS_LOOP_110_1: for (int col_index = 0; col_index < imgInput_ncpr; col_index++) {

#pragma HLS LOOP_TRIPCOUNT min = COLS / NPC max = COLS / NPC
#pragma HLS PIPELINE II = 1

 VITIS_LOOP_115_2: for (int npc_index = 0; npc_index < NPC; npc_index++) {

#pragma HLS unroll

 VITIS_LOOP_119_3: for (int channel_index = 0; channel_index < PLANES; channel_index++) {

#pragma HLS unroll

 offset_buffer[channel_index][npc_index][col_index] = 0;
            }
        }
    }

    ap_int<BITDEPTH_IN> offset_NPC[PLANES][NPC];

#pragma HLS ARRAY_PARTITION variable = offset_NPC complete dim = 0

 ap_int<BITDEPTH_IN> offset_prev_NPC[PLANES][NPC];

#pragma HLS ARRAY_PARTITION variable = offset_prev_NPC complete dim = 0


 int read_index = 0;
    int write_index = 0;

    ap_int<BITDEPTH_IN> q_err_1st[PLANES][NPC];
    ap_int<BITDEPTH_IN> q_err_2nd[PLANES][NPC];
    ap_int<BITDEPTH_IN> q_err_3rd[PLANES][NPC];

#pragma HLS ARRAY_PARTITION variable = q_err_1st complete dim = 0
#pragma HLS ARRAY_PARTITION variable = q_err_2nd complete dim = 0
#pragma HLS ARRAY_PARTITION variable = q_err_3rd complete dim = 0



 VITIS_LOOP_150_4: for (int channel_index = 0; channel_index < PLANES; channel_index++) {

#pragma HLS unroll

 VITIS_LOOP_154_5: for (int pix_num = 0; pix_num < NPC; pix_num++) {

#pragma HLS unroll

 q_err_1st[channel_index][pix_num] = 0;
            q_err_2nd[channel_index][pix_num] = 0;
            q_err_3rd[channel_index][pix_num] = 0;
        }
    }

LOOP_ROW:
    for (short row_index = 0; row_index < height; row_index++) {

#pragma HLS LOOP_TRIPCOUNT min = ROWS max = ROWS

 LOOP_COL:
        for (short col_index = 0; col_index < in_col_loop_bound; col_index++) {

#pragma HLS LOOP_TRIPCOUNT min = COLS / NPC max = COLS / NPC
#pragma HLS PIPELINE II = 1
#pragma HLS DEPENDENCE variable = offset_buffer inter false


 typename DataType<IN_TYPE, NPC>::name read_word;
            typename DataType<OUT_TYPE, NPC>::name write_word;
            if (col_index < imgInput_ncpr) read_word = stream_in.read(read_index++);

            ap_uint<BITDEPTH_IN> read_word_extract[PLANES][NPC];

#pragma HLS ARRAY_PARTITION variable = read_word_extract complete dim = 0

 VITIS_LOOP_185_6: for (int pixel = 0, bit1 = 0, bit1_out = 0; pixel < NPC;
                 pixel++, bit1 += (PLANES * BITDEPTH_IN), bit1_out += (PLANES * BITDEPTH_OUT)) {

#pragma HLS unroll

 VITIS_LOOP_190_7: for (int channel = 0, bit2 = 0, bit2_out = 0; channel < PLANES;
                     channel++, bit2 += BITDEPTH_IN, bit2_out += BITDEPTH_OUT) {

#pragma HLS unroll

 ap_uint<BITDEPTH_IN> in_pixel = read_word.range(bit1 + (bit2 + BITDEPTH_IN - 1), bit1 + bit2);

                    ap_int<BITDEPTH_IN + 2> q_2nd_err_scale7 = q_err_2nd[channel][pixel] * 7;
                    ap_int<BITDEPTH_IN - 2> q_2nd_err_scale7by16 = q_2nd_err_scale7.range(BITDEPTH_IN + 1, 4);

                    ap_int<BITDEPTH_IN + 2> quatizer_in =
                        (ap_int<BITDEPTH_IN + 2>)offset_buffer[channel][pixel][col_index] +
                        (ap_int<BITDEPTH_IN + 2>)in_pixel + q_2nd_err_scale7by16;

                    ap_int<BITDEPTH_IN + 2> round_out =
                        (ap_int<LOG2_SCALE_FACTOR + 2>)quatizer_in.range(BITDEPTH_IN + 1, LOG2_QUANTIZATION_INTERVAL) +
                        quatizer_in[LOG2_QUANTIZATION_INTERVAL - 1];
                    ap_int<LOG2_QUANTIZATION_INTERVAL + 1> q_err_3rd_local;
                    q_err_3rd_local.range(LOG2_QUANTIZATION_INTERVAL - 1, 0) =
                        quatizer_in.range(LOG2_QUANTIZATION_INTERVAL - 1, 0);
                    q_err_3rd_local[LOG2_QUANTIZATION_INTERVAL] = quatizer_in[LOG2_QUANTIZATION_INTERVAL - 1];

                    ap_int<BITDEPTH_IN + 4> sum_tmp =
                        q_err_1st[channel][pixel] + q_err_2nd[channel][pixel] * 5 + q_err_3rd_local * 3;
                    offset_NPC[channel][pixel] = sum_tmp.range(BITDEPTH_IN + 3, 4);

                    if (col_index != 0) offset_buffer[channel][pixel][col_index - 1] = offset_prev_NPC[channel][pixel];

                    if (col_index == in_col_loop_bound - 1 && pixel == NPC - 1) {
                        q_err_1st[channel][pixel] = 0;
                        q_err_2nd[channel][pixel] = 0;
                    } else {
                        if (pixel != NPC - 1) {
                            q_err_1st[channel][pixel + 1] = q_err_2nd[channel][pixel];
                            q_err_2nd[channel][pixel + 1] = q_err_3rd_local;
                        } else {
                            q_err_1st[channel][0] = q_err_2nd[channel][pixel];
                            q_err_2nd[channel][0] = q_err_3rd_local;
                        }
                    }

                    ap_uint<BITDEPTH_OUT> out_tmp;
                    if ((col_index == in_col_loop_bound - 1) || (round_out[LOG2_SCALE_FACTOR + 1] == 1)) {
                        out_tmp = 0;
                    } else {
                        if (round_out[LOG2_SCALE_FACTOR] == 0) {
                            out_tmp = (ap_uint<BITDEPTH_OUT>)round_out.range(BITDEPTH_OUT - 1, 0);
                        } else {
                            out_tmp = SCALE_FACTOR - 1;
                        }
                    }

                    write_word.range(bit1_out + (bit2_out + BITDEPTH_OUT - 1), bit1_out + bit2_out) = out_tmp;

                    offset_prev_NPC[channel][pixel] = offset_NPC[channel][pixel];
                }
            }

            if (col_index < imgInput_ncpr) stream_out.write(write_index++, write_word);

        }
    }
}

}
}
# 37 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_lensshadingcorrection.hpp" 1
# 28 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_lensshadingcorrection.hpp"
template <typename T>
T xf_satcast_lsc(int in_val){};

template <>
inline ap_uint<8> xf_satcast_lsc<ap_uint<8> >(int v) {
    v = (v > 255 ? 255 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<10> xf_satcast_lsc<ap_uint<10> >(int v) {
    v = (v > 1023 ? 1023 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<12> xf_satcast_lsc<ap_uint<12> >(int v) {
    v = (v > 4095 ? 4095 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<16> xf_satcast_lsc<ap_uint<16> >(int v) {
    v = (v > 65535 ? 65535 : v);
    v = (v < 0 ? 0 : v);
    return v;
};

namespace xf {
namespace cv {
# 68 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_lensshadingcorrection.hpp"
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void Lscdistancebased(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst) {
    int rows = src.rows;
    int cols = src.cols >> xfNPixelsPerCycle<NPC>::datashift;

    (__builtin_assume(static_cast <bool> (((rows <= ROWS) && (cols <= COLS)) && "ROWS and COLS should be greater than input image")));

    short center_pixel_pos_x = (src.cols >> 1);
    short center_pixel_pos_y = (rows >> 1);
    short y_distance = rows - center_pixel_pos_y;
    short x_distance = src.cols - center_pixel_pos_x;
    float y_2 = y_distance * y_distance;
    float x_2 = x_distance * x_distance;

    float max_distance = std::sqrt(y_2 + x_2);

    typename DataType<SRC_T, NPC>::name in_pix, in_pix1, out_pix;
    const int STEP = DataType<SRC_T, NPC>::bitdepth;
    float a = 0.01759;
    float b = 28.37;
    float c = 13.36;

    VITIS_LOOP_90_1: for (int i = 0; i < rows; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 VITIS_LOOP_94_2: for (int j = 0; j < cols; j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS/NPC max=COLS/NPC
#pragma HLS pipeline II=1
#pragma HLS LOOP_FLATTEN OFF

 float y_dist = center_pixel_pos_y - i;

            float y_dist_2 = y_dist * y_dist;

            in_pix = src.read(i * (cols) + j);

            VITIS_LOOP_106_3: for (ap_uint<9> p = 0; p < xfNPixelsPerCycle<NPC>::nppc; p++) {
                float x_dist = center_pixel_pos_x - (j * NPC + p);
                float x_dist_2 = x_dist * x_dist;

                float xy_2 = std::sqrt(y_dist_2 + x_dist_2);
                float distance = xy_2 / max_distance;

                float gain_val = (a * ((distance + b) * (distance + b))) - c;

                VITIS_LOOP_115_4: for (ap_uint<9> k = 0; k < DataType<SRC_T, NPC>::channel; k++) {

#pragma HLS unroll


 typename DataType<SRC_T, NPC>::cname
                    val = in_pix.range((k + p * 3) * STEP + STEP - 1, (k + p * 3) * STEP);
                    int value = (int)(val * gain_val);

                    out_pix.range((k + p * 3) * STEP + STEP - 1, (k + p * 3) * STEP) =
                        xf_satcast_lsc<typename DataType<SRC_T, NPC>::cname>(value);
                }
            }

            dst.write(i * cols + j, out_pix);
        }
    }
}
}
}
# 38 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_colorcorrectionmatrix.hpp" 1
# 24 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_colorcorrectionmatrix.hpp"
typedef unsigned short uint16_t;
typedef unsigned char uchar;






const ap_fixed<32, 4> bt2020_bt709_arr_hls_1[3][3] = {
    {1.6605, -0.5876, -0.0728}, {-0.1246, 1.1329, -0.0083}, {-0.0182, -0.1006, 1.1187}};

const ap_fixed<32, 4> bt2020_bt709_off_hls_1[3] = {0.0, 0.0, 0.0};

const ap_fixed<32, 4> bt709_bt2020_arr_hls_1[3][3] = {
    {0.627, 0.329, 0.0433}, {0.0691, 0.92, 0.0113}, {0.0164, 0.088, 0.896}};

const ap_fixed<32, 4> bt709_bt2020_off_hls_1[3] = {0.0, 0.0, 0.0};

const ap_fixed<32, 4> rgb_yuv_601_arr_hls_1[3][3] = {
    {0.257, 0.504, 0.098}, {-0.148, -0.291, 0.439}, {0.439, -0.368, -0.071}};

const ap_fixed<32, 4> rgb_yuv_601_off_hls_1[3] = {0.0625, 0.500, 0.500};

const ap_fixed<32, 4> rgb_yuv_709_arr_hls_1[3][3] = {
    {0.183, 0.614, 0.062}, {-0.101, -0.338, 0.439}, {0.439, -0.399, -0.040}};

const ap_fixed<32, 4> rgb_yuv_709_off_hls_1[3] = {0.0625, 0.500, 0.500};

const ap_fixed<32, 4> rgb_yuv_2020_arr_hls_1[3][3] = {
    {0.225613, 0.582282, 0.050928}, {-0.119918, -0.309494, 0.429412}, {0.429412, -0.394875, -0.034537}};

const ap_fixed<32, 4> rgb_yuv_2020_off_hls_1[3] = {0.062745, 0.500, 0.500};

const ap_fixed<32, 4> yuv_rgb_601_arr_hls_1[3][3] = {
    {1.164, 0.000, 1.596}, {1.164, -0.813, -0.391}, {1.164, 2.018, 0.000}};

const ap_fixed<32, 4> yuv_rgb_601_off_hls_1[3] = {-0.87075, 0.52925, -1.08175};

const ap_fixed<32, 4> yuv_rgb_709_arr_hls_1[3][3] = {
    {1.164, 0.000, 1.793}, {1.164, -0.213, -0.534}, {1.164, 2.115, 0.000}};

const ap_fixed<32, 4> yuv_rgb_709_off_hls_1[3] = {-0.96925, 0.30075, -1.13025};

const ap_fixed<32, 4> yuv_rgb_2020_arr_hls_1[3][3] = {
    {1.164384, 0.000000, 1.717000}, {1.164384, -0.191603, -0.665274}, {1.164384, 2.190671, 0.000000}};

const ap_fixed<32, 4> yuv_rgb_2020_off_hls_1[3] = {-0.931559, 0.355379, -1.168395};

const ap_fixed<32, 4> full_to_16_235_arr_hls_1[3][3] = {
    {0.856305, 0.000000, 0.000000}, {0.000000, 0.856305, 0.000000}, {0.000000, 0.000000, 0.856305}};

const ap_fixed<32, 4> full_to_16_235_off_hls_1[3] = {0.0625, 0.0625, 0.0625};

const ap_fixed<32, 4> full_from_16_235_arr_hls_1[3][3] = {
    {1.167808, 0.000000, 0.000000}, {0.000000, 1.167808, 0.000000}, {0.000000, 0.000000, 1.167808}};

const ap_fixed<32, 4> full_from_16_235_off_hls_1[3] = {-0.0729880, -0.0729880, -0.0729880};





template <typename T>
T xf_satcast_ccm(int in_val){};

template <>
inline ap_uint<8> xf_satcast_ccm<ap_uint<8> >(int v) {
    v = (v > 255 ? 255 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<10> xf_satcast_ccm<ap_uint<10> >(int v) {
    v = (v > 1023 ? 1023 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<12> xf_satcast_ccm<ap_uint<12> >(int v) {
    v = (v > 4095 ? 4095 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<16> xf_satcast_ccm<ap_uint<16> >(int v) {
    v = (v > 65535 ? 65535 : v);
    v = (v < 0 ? 0 : v);
    return v;
};

namespace xf {
namespace cv {

template <int SRC_T,
          int ROWS,
          int COLS,
          int DEPTH,
          int NPC,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int COLS_TRIP,
          int S_DEPTH>
void xfccmkernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC, S_DEPTH>& _src_mat,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst_mat,
                 ap_uint<8> _ccm_type,
                 unsigned short height,
                 unsigned short width) {
    ap_fixed<32, 4> ccm_matrix[3][3];
    ap_fixed<32, 4> offsetarray[3];

    switch (_ccm_type) {
        case 0:
            VITIS_LOOP_136_1: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_137_2: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = bt2020_bt709_arr_hls_1[i][j];
                }
                offsetarray[i] = bt2020_bt709_off_hls_1[i];
            }

            break;
        case 1:
            VITIS_LOOP_145_3: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_146_4: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = bt709_bt2020_arr_hls_1[i][j];
                }
                offsetarray[i] = bt709_bt2020_off_hls_1[i];
            }

            break;
        case 2:
            VITIS_LOOP_154_5: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_155_6: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = rgb_yuv_601_arr_hls_1[i][j];
                }
                offsetarray[i] = rgb_yuv_601_off_hls_1[i];
            }

            break;
        case 3:
            VITIS_LOOP_163_7: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_164_8: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = rgb_yuv_709_arr_hls_1[i][j];
                }
                offsetarray[i] = rgb_yuv_709_off_hls_1[i];
            }

            break;
        case 4:
            VITIS_LOOP_172_9: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_173_10: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = rgb_yuv_2020_arr_hls_1[i][j];
                }
                offsetarray[i] = rgb_yuv_2020_off_hls_1[i];
            }

            break;
        case 5:
            VITIS_LOOP_181_11: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_182_12: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = yuv_rgb_601_arr_hls_1[i][j];
                }
                offsetarray[i] = yuv_rgb_601_off_hls_1[i];
            }

            break;
        case 6:
            VITIS_LOOP_190_13: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_191_14: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = yuv_rgb_709_arr_hls_1[i][j];
                }
                offsetarray[i] = yuv_rgb_709_off_hls_1[i];
            }

            break;
        case 7:
            VITIS_LOOP_199_15: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_200_16: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = yuv_rgb_2020_arr_hls_1[i][j];
                }
                offsetarray[i] = yuv_rgb_2020_off_hls_1[i];
            }

            break;
        case 8:
            VITIS_LOOP_208_17: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_209_18: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = full_to_16_235_arr_hls_1[i][j];
                }
                offsetarray[i] = full_to_16_235_off_hls_1[i];
            }

            break;
        case 9:
            VITIS_LOOP_217_19: for (int i = 0; i < 3; i++) {
                VITIS_LOOP_218_20: for (int j = 0; j < 3; j++) {
                    ccm_matrix[i][j] = full_from_16_235_arr_hls_1[i][j];
                }
                offsetarray[i] = full_from_16_235_off_hls_1[i];
            }

            break;
        default:
            break;
    }

    const int STEP = DataType<SRC_T, NPC>::bitdepth;
    ap_uint<13> i, j, k;
    typename StreamType<WORDWIDTH_SRC>::name val_src;
    typename StreamType<WORDWIDTH_DST>::name val_dst;

    int value_r = 0, value_g = 0, value_b = 0;

    typename DataType<SRC_T, NPC>::cname r, g, b;
rowLoop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off


 colLoop:
        for (j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS_TRIP max=COLS_TRIP
#pragma HLS pipeline


 val_src =
                (typename StreamType<WORDWIDTH_SRC>::name)(_src_mat.read(i * width + j));

            VITIS_LOOP_254_21: for (int p = 0; p < (xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel); p = p + DataType<SRC_T, NPC>::channel) {

#pragma HLS unroll


 r = val_src.range(p * STEP + STEP - 1, p * STEP);
                g = val_src.range(p * STEP + (2 * STEP) - 1, p * STEP + STEP);
                b = val_src.range(p * STEP + (3 * STEP) - 1, p * STEP + 2 * STEP);

                ap_fixed<32, 24> value1 = (r * ccm_matrix[0][0]);
                ap_fixed<32, 24> value2 = (g * ccm_matrix[0][1]);
                ap_fixed<32, 24> value3 = (b * ccm_matrix[0][2]);

                ap_fixed<32, 24> value4 = (r * ccm_matrix[1][0]);
                ap_fixed<32, 24> value5 = (g * ccm_matrix[1][1]);
                ap_fixed<32, 24> value6 = (b * ccm_matrix[1][2]);

                ap_fixed<32, 24> value7 = (r * ccm_matrix[2][0]);
                ap_fixed<32, 24> value8 = (g * ccm_matrix[2][1]);
                ap_fixed<32, 24> value9 = (b * ccm_matrix[2][2]);

                value_r = (int)(value1 + value2 + value3 + offsetarray[0]);
                value_g = (int)(value4 + value5 + value6 + offsetarray[1]);
                value_b = (int)(value7 + value8 + value9 + offsetarray[2]);

                val_dst.range(p * STEP + STEP - 1, p * STEP) = xf_satcast_ccm<typename DataType<SRC_T, NPC>::cname>(value_r);
                val_dst.range(p * STEP + (2 * STEP) - 1, p * STEP + STEP) =
                    xf_satcast_ccm<typename DataType<SRC_T, NPC>::cname>(value_g);
                val_dst.range(p * STEP + (3 * STEP) - 1, p * STEP + 2 * STEP) =
                    xf_satcast_ccm<typename DataType<SRC_T, NPC>::cname>(value_b);
            }

            _dst_mat.write(i * width + j, (val_dst));
        }
    }
}
# 300 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_colorcorrectionmatrix.hpp"
template <int CCM_TYPE, int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1, int S_DEPTH = 2>
void colorcorrectionmatrix(xf::cv::Mat<SRC_T, ROWS, COLS, NPC, S_DEPTH>& _src_mat,
                           xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst_mat) {
    unsigned short width = _src_mat.cols >> xfNPixelsPerCycle<NPC>::datashift;
    unsigned short height = _src_mat.rows;
    (__builtin_assume(static_cast <bool> (((height <= ROWS) && (width <= COLS)) && "ROWS and COLS should be greater than input image")));


#pragma HLS INLINE OFF


 xfccmkernel<SRC_T, ROWS, COLS, DataType<SRC_T, NPC>::pixeldepth, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<SRC_T, NPC>::wordwidth,
                (COLS >> xfNPixelsPerCycle<NPC>::datashift), S_DEPTH>(_src_mat, _dst_mat, CCM_TYPE, height, width);
}
}
}
# 39 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_black_level.hpp" 1
# 29 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_black_level.hpp"
template <typename T>
T xf_satcast_bl(int in_val){};

template <>
inline ap_uint<8> xf_satcast_bl<ap_uint<8> >(int v) {
    v = (v > 255 ? 255 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<10> xf_satcast_bl<ap_uint<10> >(int v) {
    v = (v > 1023 ? 1023 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<12> xf_satcast_bl<ap_uint<12> >(int v) {
    v = (v > 4095 ? 4095 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<16> xf_satcast_bl<ap_uint<16> >(int v) {
    v = (v > 65535 ? 65535 : v);
    v = (v < 0 ? 0 : v);
    return v;
};

namespace xf {
namespace cv {

template <int SRC_T,
          int MAX_ROWS,
          int MAX_COLS,
          int NPPC = XF_NPPC1,
          int MUL_VALUE_WIDTH = 16,
          int FL_POS = 15,
          int USE_DSP = 1>
void blackLevelCorrection(xf::cv::Mat<SRC_T, MAX_ROWS, MAX_COLS, NPPC>& _Src,
                          xf::cv::Mat<SRC_T, MAX_ROWS, MAX_COLS, NPPC>& _Dst,
                          typename DataType<SRC_T, NPPC>::cname black_level,
                          float mul_value
                          ) {

#pragma HLS INLINE OFF




 const uint32_t _TC = MAX_ROWS * (MAX_COLS >> xfNPixelsPerCycle<NPPC>::datashift);

    const int STEP = DataType<SRC_T, NPPC>::bitdepth;

    uint32_t LoopCount = _Src.rows * (_Src.cols >> xfNPixelsPerCycle<NPPC>::datashift);
    uint32_t rw_ptr = 0, wrptr = 0;

    uint32_t max_value = (1 << (DataType<SRC_T, NPPC>::bitdepth)) - 1;

    ap_ufixed<16, 1> mulval = (ap_ufixed<16, 1>)mul_value;

    int value = 0;

    VITIS_LOOP_91_1: for (uint32_t i = 0; i < LoopCount; i++) {

#pragma HLS PIPELINE II=1
#pragma HLS LOOP_TRIPCOUNT min=_TC max=_TC


 typename DataType<SRC_T, NPPC>::name wr_val = 0;
        typename DataType<SRC_T, NPPC>::name rd_val = _Src.read(rw_ptr++);

        VITIS_LOOP_100_2: for (uint8_t j = 0; j < NPPC; j++) {

#pragma HLS UNROLL

 typename DataType<SRC_T, NPPC>::cname
            in_val = rd_val.range(j * STEP + STEP - 1, j * STEP);

            int med_val = (in_val - black_level);

            if (in_val < black_level) {
                value = 0;
            } else {
                value = (int)(med_val * mulval);
            }

            wr_val.range(j * STEP + STEP - 1, j * STEP) = xf_satcast_bl<typename DataType<SRC_T, NPPC>::cname>(value);
        }

        _Dst.write(wrptr++, wr_val);
    }
}
}
}
# 40 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_aec.hpp" 1
# 22 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_aec.hpp"
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bgr2hsv.hpp" 1
# 24 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_bgr2hsv.hpp"
typedef unsigned short uint16_t;

typedef unsigned int uint32_t;

namespace xf {
namespace cv {

const unsigned char icvSaturate8u_cv[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
    66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
    89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
    135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157,
    158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180,
    181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
    204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226,
    227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249,
    250, 251, 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255};

extern const unsigned char icvSaturate8u_cv[];




template <int SRC_T, int ROWS, int COLS, int NPC>
void bgr2hsv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src_mat, xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst_mat) {

#pragma HLS INLINE OFF


 int hdiv[256] = {
        0, 122880, 61440, 40960, 30720, 24576, 20480, 17554, 15360, 13653, 12288, 11171, 10240, 9452, 8777, 8192,
        7680, 7228, 6827, 6467, 6144, 5851, 5585, 5343, 5120, 4915, 4726, 4551, 4389, 4237, 4096, 3964,
        3840, 3724, 3614, 3511, 3413, 3321, 3234, 3151, 3072, 2997, 2926, 2858, 2793, 2731, 2671, 2614,
        2560, 2508, 2458, 2409, 2363, 2318, 2276, 2234, 2194, 2156, 2119, 2083, 2048, 2014, 1982, 1950,
        1920, 1890, 1862, 1834, 1807, 1781, 1755, 1731, 1707, 1683, 1661, 1638, 1617, 1596, 1575, 1555,
        1536, 1517, 1499, 1480, 1463, 1446, 1429, 1412, 1396, 1381, 1365, 1350, 1336, 1321, 1307, 1293,
        1280, 1267, 1254, 1241, 1229, 1217, 1205, 1193, 1182, 1170, 1159, 1148, 1138, 1127, 1117, 1107,
        1097, 1087, 1078, 1069, 1059, 1050, 1041, 1033, 1024, 1016, 1007, 999, 991, 983, 975, 968,
        960, 953, 945, 938, 931, 924, 917, 910, 904, 897, 890, 884, 878, 871, 865, 859,
        853, 847, 842, 836, 830, 825, 819, 814, 808, 803, 798, 793, 788, 783, 778, 773,
        768, 763, 759, 754, 749, 745, 740, 736, 731, 727, 723, 719, 714, 710, 706, 702,
        698, 694, 690, 686, 683, 679, 675, 671, 668, 664, 661, 657, 654, 650, 647, 643,
        640, 637, 633, 630, 627, 624, 621, 617, 614, 611, 608, 605, 602, 599, 597, 594,
        591, 588, 585, 582, 580, 577, 574, 572, 569, 566, 564, 561, 559, 556, 554, 551,
        549, 546, 544, 541, 539, 537, 534, 532, 530, 527, 525, 523, 521, 518, 516, 514,
        512, 510, 508, 506, 504, 502, 500, 497, 495, 493, 492, 490, 488, 486, 484, 482};
    int sdiv[256] = {
        0, 1044480, 522240, 348160, 261120, 208896, 174080, 149211, 130560, 116053, 104448, 94953, 87040, 80345,
        74606, 69632, 65280, 61440, 58027, 54973, 52224, 49737, 47476, 45412, 43520, 41779, 40172, 38684,
        37303, 36017, 34816, 33693, 32640, 31651, 30720, 29842, 29013, 28229, 27486, 26782, 26112, 25475,
        24869, 24290, 23738, 23211, 22706, 22223, 21760, 21316, 20890, 20480, 20086, 19707, 19342, 18991,
        18651, 18324, 18008, 17703, 17408, 17123, 16846, 16579, 16320, 16069, 15825, 15589, 15360, 15137,
        14921, 14711, 14507, 14308, 14115, 13926, 13743, 13565, 13391, 13221, 13056, 12895, 12738, 12584,
        12434, 12288, 12145, 12006, 11869, 11736, 11605, 11478, 11353, 11231, 11111, 10995, 10880, 10768,
        10658, 10550, 10445, 10341, 10240, 10141, 10043, 9947, 9854, 9761, 9671, 9582, 9495, 9410,
        9326, 9243, 9162, 9082, 9004, 8927, 8852, 8777, 8704, 8632, 8561, 8492, 8423, 8356,
        8290, 8224, 8160, 8097, 8034, 7973, 7913, 7853, 7795, 7737, 7680, 7624, 7569, 7514,
        7461, 7408, 7355, 7304, 7253, 7203, 7154, 7105, 7057, 7010, 6963, 6917, 6872, 6827,
        6782, 6739, 6695, 6653, 6611, 6569, 6528, 6487, 6447, 6408, 6369, 6330, 6292, 6254,
        6217, 6180, 6144, 6108, 6073, 6037, 6003, 5968, 5935, 5901, 5868, 5835, 5803, 5771,
        5739, 5708, 5677, 5646, 5615, 5585, 5556, 5526, 5497, 5468, 5440, 5412, 5384, 5356,
        5329, 5302, 5275, 5249, 5222, 5196, 5171, 5145, 5120, 5095, 5070, 5046, 5022, 4998,
        4974, 4950, 4927, 4904, 4881, 4858, 4836, 4813, 4791, 4769, 4748, 4726, 4705, 4684,
        4663, 4642, 4622, 4601, 4581, 4561, 4541, 4522, 4502, 4483, 4464, 4445, 4426, 4407,
        4389, 4370, 4352, 4334, 4316, 4298, 4281, 4263, 4246, 4229, 4212, 4195, 4178, 4161,
        4145, 4128, 4112, 4096};

    typename StreamType<DataType<SRC_T, NPC>::wordwidth>::name in_pix;
    typename StreamType<DataType<SRC_T, NPC>::wordwidth>::name out_pix;
    ap_uint<8> r, g, b;

    int rows = _src_mat.rows;
    int cols = (_src_mat.cols >> xfNPixelsPerCycle<NPC>::datashift);
    int h;
    int s, v;
    ap_uint<8> vmin;
    ap_uint<8> diff;
    int vr, vg;
    const int STEP = DataType<SRC_T, NPC>::bitdepth;
    VITIS_LOOP_128_1: for (uint16_t row = 0; row < rows; row++) {

#pragma HLS LOOP_TRIPCOUNT max=ROWS

 VITIS_LOOP_132_2: for (uint16_t col = 0; col < cols; col++) {

#pragma HLS LOOP_TRIPCOUNT max=COLS
#pragma HLS PIPELINE

 in_pix = _src_mat.read(row * cols + col);

            VITIS_LOOP_139_3: for (int p = 0; p < (xfNPixelsPerCycle<NPC>::nppc * DataType<SRC_T, NPC>::channel); p = p + DataType<SRC_T, NPC>::channel) {
                b = in_pix.range(p * STEP + STEP - 1, p * STEP);
                g = in_pix.range(p * STEP + (2 * STEP) - 1, p * STEP + STEP);
                r = in_pix.range(p * STEP + (3 * STEP) - 1, p * STEP + 2 * STEP);

                v = b;
                vmin = b;

                (v) += ((__builtin_assume(static_cast <bool> (-256 <= ((g) - (v)) && ((g) - (v)) <= 512))), icvSaturate8u_cv[((g) - (v)) + 256]);
                (v) += ((__builtin_assume(static_cast <bool> (-256 <= ((r) - (v)) && ((r) - (v)) <= 512))), icvSaturate8u_cv[((r) - (v)) + 256]);
                (vmin) -= ((__builtin_assume(static_cast <bool> (-256 <= ((vmin) - (g)) && ((vmin) - (g)) <= 512))), icvSaturate8u_cv[((vmin) - (g)) + 256]);
                (vmin) -= ((__builtin_assume(static_cast <bool> (-256 <= ((vmin) - (r)) && ((vmin) - (r)) <= 512))), icvSaturate8u_cv[((vmin) - (r)) + 256]);

                diff = v - vmin;
                vr = v == r ? -1 : 0;
                vg = v == g ? -1 : 0;

                s = (diff * sdiv[v] + (1 << (11))) >> 12;
                h = (vr & (g - b)) + (~vr & ((vg & (b - r + 2 * diff)) + ((~vg) & (r - g + 4 * diff))));
                h = (h * hdiv[diff] + (1 << (11))) >> 12;
                h += h < 0 ? 180 : 0;

                out_pix.range(p * STEP + STEP - 1, p * STEP) = (unsigned char)(h);
                out_pix.range(p * STEP + (2 * STEP) - 1, p * STEP + STEP) = (unsigned char)(s);
                out_pix.range(p * STEP + (3 * STEP) - 1, p * STEP + 2 * STEP) = (unsigned char)(v);
            }

            _dst_mat.write(row * cols + col, (out_pix));
        }
    }
}
}
}
# 23 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_aec.hpp" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_combine.hpp" 1
# 20 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_combine.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 21 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_combine.hpp" 2




namespace xf {
namespace cv {






template <int ROWS, int COLS, int SRC_T, int DST_T, int NPC, int TC>
void xfChannelCombineKernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _in1,
                            xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _in2,
                            xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _in3,
                            xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _in4,
                            xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _out,
                            uint16_t height,
                            uint16_t width) {
    typename DataType<SRC_T, NPC>::name val1, val2, val3, val4;

    width = width >> (xfNPixelsPerCycle<NPC>::datashift);
    uchar_t channel1, channel2, channel3, channel4;

    const int noofbits = DataType<SRC_T, NPC>::bitdepth;
    ap_uint<13> i, j, k;
RowLoop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 typename DataType<DST_T, NPC>::name res;

            val1 = (typename DataType<SRC_T, NPC>::name)(_in1.read(i * width + j));
            val2 = (typename DataType<SRC_T, NPC>::name)(_in2.read(i * width + j));
            val3 = (typename DataType<SRC_T, NPC>::name)(_in3.read(i * width + j));
            val4 = (typename DataType<SRC_T, NPC>::name)(_in4.read(i * width + j));

        ProcLoop:
            for (k = 0; k < (noofbits << xfNPixelsPerCycle<NPC>::datashift); k += noofbits) {

#pragma HLS UNROLL

 int y = k * DataType<DST_T, NPC>::channel;
                channel1 = val1.range(k + (noofbits - 1), k);
                channel2 = val2.range(k + (noofbits - 1), k);
                channel3 = val3.range(k + (noofbits - 1), k);
                channel4 = val4.range(k + (noofbits - 1), k);

                uint32_t result = ((uint32_t)channel3 << 0) | ((uint32_t)channel2 << noofbits) |
                                  ((uint32_t)channel1 << noofbits * 2) | ((uint32_t)channel4 << noofbits * 3);

                res.range(y + (DataType<DST_T, NPC>::pixelwidth - 1), y) = result;
            }
            _out.write((i * width + j), (typename DataType<DST_T, NPC>::name)res);
        }
    }
}

template <int ROWS, int COLS, int SRC_T, int DST_T, int NPC, int TC>
void xfChannelCombineKernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _in1,
                            xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _in2,
                            xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _in3,
                            xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _out,
                            uint16_t height,
                            uint16_t width) {
    typename DataType<SRC_T, NPC>::name val1, val2, val3;
    uchar_t channel1, channel2, channel3;
    const int noofbits = DataType<SRC_T, NPC>::bitdepth;
    width = width >> (xfNPixelsPerCycle<NPC>::datashift);
    int rows = height, cols = width;

RowLoop:
    for (int i = 0; i < rows; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < cols; j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 typename DataType<DST_T, NPC>::name res;

            val1 = (typename DataType<SRC_T, NPC>::name)(_in1.read(i * cols + j));
            val2 = (typename DataType<SRC_T, NPC>::name)(_in2.read(i * cols + j));
            val3 = (typename DataType<SRC_T, NPC>::name)(_in3.read(i * cols + j));

        ProcLoop:
            for (int k = 0; k < (noofbits << xfNPixelsPerCycle<NPC>::datashift); k += noofbits) {

#pragma HLS UNROLL

 int y = k * DataType<DST_T, NPC>::channel;
                channel1 = val1.range(k + (noofbits - 1), k);
                channel2 = val2.range(k + (noofbits - 1), k);
                channel3 = val3.range(k + (noofbits - 1), k);

                uint32_t result = (((uint32_t)channel3 << 0) | ((uint32_t)channel2 << noofbits) |
                                   ((uint32_t)channel1 << noofbits * 2));

                res.range(y + (DataType<DST_T, NPC>::pixelwidth - 1), y) = result;
            }
            _out.write((i * cols + j), (typename DataType<DST_T, NPC>::name)res);
        }
    }
}

template <int ROWS, int COLS, int SRC_T, int DST_T, int NPC, int TC>
void xfChannelCombineKernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _in1,
                            xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _in2,
                            xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _out,
                            uint16_t height,
                            uint16_t width) {
    typename DataType<SRC_T, NPC>::name val1, val2;
    uchar_t channel1, channel2;
    const int noofbits = DataType<SRC_T, NPC>::bitdepth;
    width = width >> (xfNPixelsPerCycle<NPC>::datashift);
    int rows = height, cols = width;

RowLoop:
    for (int i = 0; i < rows; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < cols; j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 typename DataType<DST_T, NPC>::name res;

            val1 = (typename DataType<SRC_T, NPC>::name)(_in1.read(i * cols + j));
            val2 = (typename DataType<SRC_T, NPC>::name)(_in2.read(i * cols + j));

        ProcLoop:
            for (int k = 0; k < (noofbits << xfNPixelsPerCycle<NPC>::datashift); k += noofbits) {

#pragma HLS UNROLL

 int y = k * DataType<DST_T, NPC>::channel;
                channel1 = val1.range(k + (noofbits - 1), k);
                channel2 = val2.range(k + (noofbits - 1), k);

                uint32_t result = ((uint32_t)channel1 << 0) | ((uint32_t)channel2 << noofbits);
                res.range(y + (DataType<DST_T, NPC>::pixelwidth - 1), y) = result;
            }
            _out.write((i * cols + j), (typename DataType<DST_T, NPC>::name)res);
        }
    }
}







template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void merge(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src1,
           xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src2,
           xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {
# 203 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_combine.hpp"
#pragma HLS inline off


 xfChannelCombineKernel<ROWS, COLS, SRC_T, DST_T, NPC, (COLS >> (xfNPixelsPerCycle<NPC>::datashift))>(_src1, _src2, _dst, _src1.rows,
                                                                                        _src1.cols);
}







template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void merge(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src1,
           xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src2,
           xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src3,
           xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {
# 233 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_combine.hpp"
#pragma HLS inline off


 xfChannelCombineKernel<ROWS, COLS, SRC_T, DST_T, NPC, (COLS >> (xfNPixelsPerCycle<NPC>::datashift))>(_src1, _src2, _src3, _dst,
                                                                                        _src1.rows, _src1.cols);
}







template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void merge(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src1,
           xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src2,
           xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src3,
           xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src4,
           xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {
# 265 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_combine.hpp"
#pragma HLS inline off


 xfChannelCombineKernel<ROWS, COLS, SRC_T, DST_T, NPC, (COLS >> (xfNPixelsPerCycle<NPC>::datashift))>(_src1, _src2, _src3, _src4,
                                                                                        _dst, _src1.rows, _src1.cols);
}

}
}
# 24 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_aec.hpp" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_extract.hpp" 1
# 21 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_extract.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 22 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_extract.hpp" 2



namespace xf {
namespace cv {
# 36 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_extract.hpp"
template <int ROWS, int COLS, int SRC_T, int DST_T, int NPC, int TC>
void xfChannelExtractKernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src_mat,
                            xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst_mat,
                            uint16_t _channel,
                            uint16_t height,
                            uint16_t width) {

    const int noofbits = DataType<SRC_T, NPC>::bitdepth;

    ap_uint<13> i, j, k;
    typename DataType<SRC_T, NPC>::name in_pix;
    typename DataType<DST_T, NPC>::name out_pix;
    ap_uint<DataType<DST_T, NPC>::bitdepth> result;
    int shift = 0;
    int bitdepth_src = DataType<SRC_T, NPC>::bitdepth / DataType<SRC_T, NPC>::channel;
    int bitdepth_dst = DataType<DST_T, NPC>::bitdepth / DataType<DST_T, NPC>::channel;

    if (_channel == XF_EXTRACT_CH_0 | _channel == XF_EXTRACT_CH_R | _channel == XF_EXTRACT_CH_Y) {
        shift = 0;
    } else if (_channel == XF_EXTRACT_CH_1 | _channel == XF_EXTRACT_CH_G | _channel == XF_EXTRACT_CH_U) {
        shift = noofbits;
    } else if (_channel == XF_EXTRACT_CH_2 | _channel == XF_EXTRACT_CH_B | _channel == XF_EXTRACT_CH_V) {
        shift = noofbits * 2;
    } else if (_channel == XF_EXTRACT_CH_3 | _channel == XF_EXTRACT_CH_A) {
        shift = noofbits * 3;
    }

RowLoop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 ColLoop:
        for (j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline

 int y;
            in_pix = _src_mat.read(i * width + j);

        ProcLoop:
            for (k = 0; k < (noofbits << xfNPixelsPerCycle<NPC>::datashift); k += noofbits) {

#pragma HLS unroll

 y = k * (DataType<SRC_T, NPC>::channel);
                result = in_pix.range(y + shift + noofbits - 1, y + shift);


                out_pix.range(k + (noofbits - 1), k) = result;
            }

            _dst_mat.write(i * width + j, out_pix);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void extractChannel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src_mat,
                    xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst_mat,
                    uint16_t _channel) {
# 111 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_channel_extract.hpp"
    short width = _src_mat.cols >> xfNPixelsPerCycle<NPC>::datashift;


#pragma HLS INLINE OFF


 xfChannelExtractKernel<ROWS, COLS, SRC_T, DST_T, NPC, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(_src_mat, _dst_mat, _channel,
                                                                                      _src_mat.rows, width);
}
}
}
# 25 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_aec.hpp" 2
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp" 1
# 22 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_1.hpp" 1
# 28 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_1.hpp"
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_utils.hpp" 1
# 25 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_utils.hpp"
# 1 "/tools/Xilinx/Vitis_HLS/2022.1/common/technology/autopilot/ap_int.h" 1
# 26 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_utils.hpp" 2
# 123 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_utils.hpp"
template <int WORDWIDTH>
typename StreamType<WORDWIDTH>::name
PackPixels(ap_uint8_t* buf) {
    typename StreamType<WORDWIDTH>::name val;
    VITIS_LOOP_127_1: for (int k = 0, l = 0; k < StreamType<WORDWIDTH>::bitdepth; k += 8, l++) {

#pragma HLS unroll


 val.range(k + 7, k) = buf[l];
    }
    return val;
}





template <int WORDWIDTH>
void ExtractUYVYPixels(typename StreamType<WORDWIDTH>::name pix, ap_uint8_t* buf) {
    int k;
    typename StreamType<WORDWIDTH>::name val;
    int pos = 0;

    VITIS_LOOP_147_1: for (k = 0; k < (StreamType<WORDWIDTH>::bitdepth); k += 8) {

#pragma HLS unroll

 val = (typename StreamType<WORDWIDTH>::name)pix;
  uint8_t p;


        p = val.range(k + 7, k);
        buf[pos++] = p;
    }
}

template <int SRC_T, int NPC, int WORDWIDTH>
void ExtractUYVYPixels(typename StreamType<WORDWIDTH>::name pix, typename DataType<SRC_T, NPC>::cname buf[]) {

    int k;
    typename StreamType<WORDWIDTH>::name val;
    int pos = 0;
 const int STEP = DataType<SRC_T, NPC>::bitdepth;
 typename DataType<SRC_T, NPC>::cname p;

    val = (typename StreamType<WORDWIDTH>::name)pix;
    VITIS_LOOP_170_1: for (k = 0; k < (StreamType<WORDWIDTH>::bitdepth); k += STEP) {

#pragma HLS unroll


 p = val.range(k + STEP - 1, k);
        buf[pos++] = p;
    }
}




template <int WORDDEPTH>
void ExtractRGBAPixels(typename StreamType<WORDDEPTH>::name pix, uint8_t* buf) {
    int k, pos = 0;
    uint8_t p;
    typename StreamType<WORDDEPTH>::name val;
    val = (typename StreamType<WORDDEPTH>::name)pix;
    VITIS_LOOP_189_1: for (k = 0; k < StreamType<WORDDEPTH>::bitdepth; k += 8) {

#pragma HLS unroll


 p = val.range(k + 7, k);
        buf[pos++] = p;
    }
}





template <int WORDWIDTH>
typename StreamType<WORDWIDTH>::name
PackRGBAPixels(ap_uint8_t* buf) {
    typename StreamType<WORDWIDTH>::name val;
    VITIS_LOOP_207_1: for (int k = 0, l = 0; k < (StreamType<WORDWIDTH>::bitdepth); k += 8, l++) {

#pragma HLS unroll


 val.range(k + 7, k) = buf[l];
    }
    return val;
}
# 757 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_utils.hpp"
static uint8_t saturate_cast(int32_t Value, int32_t offset) {

    int Value_int = (Value >> 15) + offset;
    unsigned char Value_uchar = 0;
    if (Value_int > 255)
        Value_uchar = 255;
    else if (Value_int < 0)
        Value_uchar = 0;
    else
        Value_uchar = (uint8_t)Value_int;

    return Value_uchar;
}
static uint16_t _saturate_cast(uint32_t Value, int32_t offset) {

    int Value_int = (Value >> 15) + offset;
    int Value_uchar = 0;
    if (Value_int > 65535)
        Value_uchar = 65535;
    else if (Value_int < 0)
        Value_uchar = 0;
    else
        Value_uchar = (uint16_t)Value_int;

    return Value_uchar;
}
static uint8_t saturate_cast(int32_t Value, int32_t offset, int fbits) {

    int Value_int = (Value >> fbits) + offset;
    unsigned char Value_uchar = 0;
    if (Value_int > 255)
        Value_uchar = 255;
    else if (Value_int < 0)
        Value_uchar = 0;
    else
        Value_uchar = (uint8_t)Value_int;

    return Value_uchar;
}





static uint8_t CalculateY(uint8_t R, uint8_t G, uint8_t B) {

#pragma HLS INLINE


 int32_t Y = ((short int)8422 * R) + ((short int)16516 * G) + ((short int)3212 * B) + 16384;
    uint8_t Yvalue = saturate_cast(Y, 16);
    return Yvalue;
}






static uint8_t CalculateU(uint8_t R, uint8_t G, uint8_t B) {

#pragma HLS INLINE

 int32_t U = ((short int)60686 * R) + ((short int)56000 * G) + ((short int)14386 * B) + 16384;
    uint8_t Uvalue = saturate_cast(U, 128);
    return Uvalue;
}






static uint8_t CalculateV(uint8_t R, uint8_t G, uint8_t B) {

#pragma HLS INLINE

 int32_t V = ((short int)14382 * R) + ((short int)53477 * G) + ((short int)63209 * B) + 16384;
    uint8_t Vvalue = saturate_cast(V, 128);
    return Vvalue;
}





static uint8_t CalculateR(uint8_t Y, int32_t V2Rtemp, int8_t V) {

#pragma HLS INLINE

 int32_t R = (short int)5374 * Y + V2Rtemp + 16384;
    uint8_t Rvalue = saturate_cast(R, V + Y);
    return (Rvalue);
}





static uint8_t CalculateG(uint8_t Y, int32_t U2Gtemp, int32_t V2Gtemp) {

#pragma HLS INLINE

 int32_t G = (short int)5374 * Y + U2Gtemp + V2Gtemp + 16384;
    uint8_t Gvalue = saturate_cast(G, Y);
    return (Gvalue);
}





static uint8_t CalculateB(uint8_t Y, int32_t U2Btemp, int8_t U) {

#pragma HLS INLINE

 int32_t B = (short int)5374 * Y + U2Btemp + 16384;
    uint8_t Bvalue = saturate_cast(B, 2 * U + Y);
    return (Bvalue);
}





static uint8_t CalculateGRAY(uint8_t R, uint8_t G, uint8_t B) {

#pragma HLS INLINE

 int32_t GRAY = (R * (short int)9798) + (G * (short int)19235) + (B * (short int)3736);
    uint8_t sat_GRAY = saturate_cast(GRAY, 0);

    return (sat_GRAY);
}
# 900 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_utils.hpp"
static uint8_t Calculate_X(uint8_t R, uint8_t G, uint8_t B) {

#pragma HLS INLINE

 int32_t X = (R * (short int)13515) + (G * (short int)11717) + (B * (short int)5915);
    uint8_t sat_X = saturate_cast(X, 0);

    return (sat_X);
}
static uint8_t Calculate_Y(uint8_t R, uint8_t G, uint8_t B) {

#pragma HLS INLINE

 int32_t Y = (R * (short int)6969) + (G * (short int)23434) + (B * (short int)2364);
    uint8_t sat_Y = saturate_cast(Y, 0);

    return (sat_Y);
}
static uint8_t Calculate_Z(uint8_t R, uint8_t G, uint8_t B) {

#pragma HLS INLINE

 int32_t Z = (R * (short int)636) + (G * (short int)3906) + (B * (short int)31137);
    uint8_t sat_Z = saturate_cast(Z, 0);

    return (sat_Z);
}
static uint16_t _Calculate_X(uint16_t R, uint16_t G, uint16_t B) {

#pragma HLS INLINE

 uint32_t X =
        ((uint32_t)R * (uint32_t)13515) + ((uint32_t)G * (uint32_t)11717) + ((uint32_t)B * (uint32_t)5915);
    uint16_t sat_X = _saturate_cast(X, 0);

    return (sat_X);
}
static uint16_t _Calculate_Y(uint16_t R, uint16_t G, uint16_t B) {

#pragma HLS INLINE

 uint32_t Y =
        ((uint32_t)R * (uint32_t)6969) + ((uint32_t)G * (uint32_t)23434) + ((uint32_t)B * (uint32_t)2364);
    uint16_t sat_Y = _saturate_cast(Y, 0);

    return (sat_Y);
}
static uint16_t _Calculate_Z(uint16_t R, uint16_t G, uint16_t B) {

#pragma HLS INLINE

 uint32_t Z =
        ((uint32_t)R * (uint32_t)636) + ((uint32_t)G * (uint32_t)3906) + ((uint32_t)B * (uint32_t)31137);
    uint16_t sat_Z = _saturate_cast(Z, 0);

    return (sat_Z);
}
# 965 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_utils.hpp"
static uint8_t Calculate_R(uint8_t X, uint8_t Y, uint8_t Z) {

#pragma HLS INLINE

 int32_t R = (X * (short int)26546) + (Y * (short int)52944) + (Z * (short int)61452);

    uint8_t sat_R = saturate_cast(R, 0, 13);

    return (sat_R);
}
static uint8_t Calculate_G(uint8_t X, uint8_t Y, uint8_t Z) {

#pragma HLS INLINE

 int32_t G = (X * (short int)57596) + (Y * (short int)15368) + (Z * (short int)340);
    uint8_t sat_G = saturate_cast(G, 0, 13);

    return (sat_G);
}
static uint8_t Calculate_B(uint8_t X, uint8_t Y, uint8_t Z) {

#pragma HLS INLINE

 int32_t B = (X * (short int)456) + (Y * (short int)63864) + (Z * (short int)8662);
    uint8_t sat_B = saturate_cast(B, 0, 13);

    return (sat_B);
}
# 1001 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_utils.hpp"
static uint8_t Calculate_CR(uint8_t R, uint8_t Y) {

#pragma HLS INLINE

 int32_t CR = ((R - Y) * (short int)23364);

    uint8_t sat_CR = saturate_cast(CR, 128);

    return (sat_CR);
}
static uint8_t Calculate_CB(uint8_t B, uint8_t Y) {

#pragma HLS INLINE

 int32_t CB = ((B - Y) * (short int)18481);

    uint8_t sat_CB = saturate_cast(CB, 128);

    return (sat_CB);
}
# 1034 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_utils.hpp"
static uint8_t Calculate_Ycrcb2R(uint8_t Y, uint8_t cr) {

#pragma HLS INLINE

 int32_t R = 45974 * (cr - 128);
    uint8_t sat_R = saturate_cast(R, Y);
    return (sat_R);
}
static uint8_t Calculate_Ycrcb2G(uint8_t Y, uint8_t cr, uint8_t cb) {

#pragma HLS INLINE


 int32_t H_G1 = (23396 * (cr - 128));
    int32_t H_G2 = (11272 * (cb - 128));

    int16_t sat_G1 = ((H_G1) >> 15);
    int16_t sat_G2 = ((H_G2) >> 15);

    uint16_t res = ((Y - sat_G1) - sat_G2);
    if (res > 255) {
        res = 255;
    } else if (res < 0) {
        res = 0;
    }
    return (res);
}
static uint8_t Calculate_Ycrcb2B(uint8_t Y, uint8_t cb) {

#pragma HLS INLINE

 int32_t B = 58098 * (cb - 128);
    uint8_t sat_R = saturate_cast(B, Y);

    return (sat_R);
}
# 29 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color_1.hpp" 2

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int TC, int TCC>
void write_y(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
             xf::cv::Mat<DST_T, ROWS, COLS, NPC>& out_y,
             uint16_t height,
             uint16_t width) {
    typename StreamType<WORDWIDTH_SRC>::name tmp;
    unsigned long long int idx = 0;
    VITIS_LOOP_37_1: for (int i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 VITIS_LOOP_42_2: for (int j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 tmp = src_y.read(i * width + j);
            out_y.write(idx++, tmp);
        }
    }
}
template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_UV, int WORDWIDTH_DST, int TC>
void KernNv122Yuv4(xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                   xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u,
                   xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v,
                   uint16_t height,
                   uint16_t width) {
    typename PixelType<XF_16UP>::name uv;
    typename StreamType<WORDWIDTH_DST>::name u, v;
    typename StreamType<WORDWIDTH_UV>::name uvPacked;
    typename DataType<SRC_T, NPC>::name arr_u[COLS];
    typename DataType<SRC_T, NPC>::name arr_v[COLS];

    unsigned long long int idx = 0, idx1 = 0;
    ap_uint<13> i, j;
    bool evenBlock = true;
RowLoop:
    for (i = 0; i < (height >> 1); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 if (evenBlock) {
                uv = _uv.read(idx++);
                u.range(7, 0) = (uint8_t)uv.range(7, 0);
                v.range(7, 0) = (uint8_t)uv.range(15, 8);
            }
            arr_u[j] = u;
            arr_v[j] = v;

            _u.write(((i * 2) * (_u.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, u);
            _v.write(((i * 2) * (_v.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, v);
            evenBlock = evenBlock ? false : true;
        }
        VITIS_LOOP_90_1: for (int k = 0; k < width; k++) {
            _u.write((((i * 2) + 1) * (_u.cols >> xfNPixelsPerCycle<NPC>::datashift)) + k, arr_u[k]);
            _v.write((((i * 2) + 1) * (_v.cols >> xfNPixelsPerCycle<NPC>::datashift)) + k, arr_v[k]);
        }
    }
}

template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST>
void KernNv122Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                   uint16_t height,
                   uint16_t width) {
    hls::stream<typename StreamType<WORDWIDTH_UV>::name> uvStream;

#pragma HLS STREAM variable=&uvStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_UV>::name uvPacked;
    typename StreamType<WORDWIDTH_DST>::name rgba;
    unsigned long long int idx = 0, idx1 = 0;
    uint8_t y1, y2;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t u, v;
    bool evenRow = true, evenBlock = true;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 yPacked = _y.read(i * width + j);
            if (evenRow) {
                if (evenBlock) {
                    uvPacked = _uv.read(idx++);
                    uvStream.write(uvPacked);
                }
            } else {
                if (evenBlock) {
                    uvPacked = uvStream.read();
                }
            }


            uint8_t t = yPacked.range(7, 0);
            y1 = t > 16 ? t - 16 : 0;
            v = (uint8_t)uvPacked.range(15, 8) - 128;
            u = (uint8_t)uvPacked.range(7, 0) - 128;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;




            rgba.range(7, 0) = CalculateR(y1, V2Rtemp, v);
            rgba.range(15, 8) = CalculateG(y1, U2Gtemp, V2Gtemp);
            rgba.range(23, 16) = CalculateB(y1, U2Btemp, u);
            rgba.range(31, 24) = 255;



            _rgba.write(idx1++, rgba);
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_176_1: for (int i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 uvStream.read();
        }
    }
}

template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernNv122Iyuv(xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                   xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u,
                   xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v,
                   uint16_t height,
                   uint16_t width) {
    typename PixelType<XF_8UP>::name u, v;
    typename StreamType<WORDWIDTH_SRC>::name uv;
    unsigned long long int idx = 0;
    ap_uint<13> i, j;
RowLoop:
    for (i = 0; i<height>> 1; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < (width >> 1); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC



 uv = _uv.read(i * (width >> 1) + j);

            _u.write(idx, uv.range(7, 0));
            _v.write(idx++, uv.range(15, 8));
        }
    }
}

template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_VU, int WORDWIDTH_DST, int TC>
void KernNv212Yuv4(xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _vu,
                   xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u,
                   xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v,
                   uint16_t height,
                   uint16_t width) {
    typename PixelType<XF_16UP>::name uv;
    typename StreamType<WORDWIDTH_DST>::name u, v;
    typename StreamType<WORDWIDTH_VU>::name uvPacked;
    typename DataType<SRC_T, NPC>::name arr_u[COLS];
    typename DataType<SRC_T, NPC>::name arr_v[COLS];

    unsigned long long int idx = 0, idx1 = 0;
    ap_uint<13> i, j;
    bool evenBlock = true;
RowLoop:
    for (i = 0; i < (height >> 1); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 if (evenBlock) {
                uv = _vu.read(idx++);
                v.range(7, 0) = (uint8_t)uv.range(7, 0);
                u.range(7, 0) = (uint8_t)uv.range(15, 8);
            }
            arr_u[j] = u;
            arr_v[j] = v;

            _u.write(((i * 2) * (_u.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, u);
            _v.write(((i * 2) * (_v.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, v);
            evenBlock = evenBlock ? false : true;
        }
        VITIS_LOOP_256_1: for (int k = 0; k < width; k++) {
            _u.write((((i * 2) + 1) * (_u.cols >> xfNPixelsPerCycle<NPC>::datashift)) + k, arr_u[k]);
            _v.write((((i * 2) + 1) * (_v.cols >> xfNPixelsPerCycle<NPC>::datashift)) + k, arr_v[k]);
        }
    }
}

template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_VU,
          int WORDWIDTH_DST>
void KernNv212Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _vu,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                   uint16_t height,
                   uint16_t width) {
    hls::stream<typename StreamType<WORDWIDTH_VU>::name> vuStream;

#pragma HLS STREAM variable=&vuStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_VU>::name vuPacked;
    typename StreamType<WORDWIDTH_DST>::name rgba;
    unsigned long long int idx = 0, idx1 = 0;
    ap_uint<13> i, j;
    uint8_t y1, y2;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t u, v;
    bool evenRow = true, evenBlock = true;
RowLoop:
    for (i = 0; i < (height); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 yPacked = _y.read(i * width + j);


            if (evenRow) {
                if (evenBlock) {
                    vuPacked = _vu.read(idx++);
                    vuStream.write(vuPacked);
                }
            } else {
                if (evenBlock) {
                    vuPacked = vuStream.read();
                }
            }


            uint8_t t = yPacked.range(7, 0);
            y1 = t > 16 ? t - 16 : 0;
            u = (uint8_t)vuPacked.range(15, 8) - 128;
            v = (uint8_t)vuPacked.range(7, 0) - 128;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;




            rgba.range(7, 0) = CalculateR(y1, V2Rtemp, v);
            rgba.range(15, 8) = CalculateG(y1, U2Gtemp, V2Gtemp);
            rgba.range(23, 16) = CalculateB(y1, U2Btemp, u);
            rgba.range(31, 24) = 255;



            _rgba.write(idx1++, rgba);
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_345_1: for (i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 vuStream.read();
        }
    }
}

template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernNv212Iyuv(xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _vu,
                   xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u,
                   xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v,
                   uint16_t height,
                   uint16_t width) {
    ap_uint<13> i, j;
    typename PixelType<XF_8UP>::name u, v;
    typename StreamType<WORDWIDTH_SRC>::name VUPacked, UVPacked0, UVPacked1;
    unsigned long long int idx = 0, idx1 = 0;
RowLoop:
    for (i = 0; i < (height >> 1); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < (width >> 1); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 VUPacked = _vu.read(idx++);
            u = (uint8_t)VUPacked.range(15, 8);
            v = (uint8_t)VUPacked.range(7, 0);
            _u.write(idx1, u);
            _v.write(idx1++, v);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernIyuv2Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u,
                   xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                   uint16_t height,
                   uint16_t width) {
    unsigned long long int idx = 0, idx1 = 0;
    ap_uint<13> i, j;
    hls::stream<typename StreamType<WORDWIDTH_SRC>::name> uStream, vStream;

#pragma HLS STREAM variable=&uStream depth=COLS
#pragma HLS STREAM variable=&vStream depth=COLS


 typename StreamType<WORDWIDTH_SRC>::name yPacked, uPacked, vPacked;
    typename StreamType<WORDWIDTH_DST>::name rgba;

    uint8_t y1, y2;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t u, v;
    bool evenRow = true, evenBlock = true;
RowLoop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 yPacked = _y.read(i * width + j);

            if (evenBlock) {
                if (evenRow) {
                    uPacked = _u.read(idx);
                    uStream.write(uPacked);
                    vPacked = _v.read(idx++);
                    vStream.write(vPacked);
                } else {


                    uPacked = uStream.read();
                    vPacked = vStream.read();
                }
            }

            y1 = (uint8_t)yPacked.range(7, 0) > 16 ? (uint8_t)yPacked.range(7, 0) - 16 : 0;

            u = (uint8_t)uPacked.range(7, 0) - 128;
            v = (uint8_t)vPacked.range(7, 0) - 128;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;




            rgba.range(7, 0) = CalculateR(y1, V2Rtemp, v);
            rgba.range(15, 8) = CalculateG(y1, U2Gtemp, V2Gtemp);
            rgba.range(23, 16) = CalculateB(y1, U2Btemp, u);
            rgba.range(31, 24) = 255;

            _rgba.write(idx1++, rgba);
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T, int ROWS, int COLS, int NPC, int WORDWIDTH, int rTC, int cTC>
void KernIyuv2Yuv4(xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _in_u,
                   xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _in_v,
                   xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u_image,
                   xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v_image,
                   uint16_t height,
                   uint16_t width) {
    hls::stream<typename StreamType<WORDWIDTH>::name> inter_u;

#pragma HLS stream variable=inter_u depth=COLS


 hls::stream<typename StreamType<WORDWIDTH>::name> inter_v;

#pragma HLS stream variable=inter_v depth=COLS


 typename DataType<SRC_T, NPC>::name arr_U[COLS];
    typename DataType<SRC_T, NPC>::name arr_V[COLS];

    typename StreamType<WORDWIDTH>::name IUPacked, IVPacked;
    typename PixelType<XF_8UP>::name in_u, in_v;
    unsigned long long int idx = 0, idx1 = 0, in_idx1 = 0, in_idx2 = 0;
RowLoop:
    for (int i = 0; i < ((height >> 2) << 1); i++) {

#pragma HLS LOOP_FLATTEN
#pragma HLS LOOP_TRIPCOUNT min=rTC max=rTC

 ColLoop:
        for (int j = 0, k = 0; j < (width >> 1); j++, k += 2) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=cTC max=cTC

 IUPacked = _in_u.read(in_idx1++);
            IVPacked = _in_v.read(in_idx2++);

            _u_image.write(((i * 2) * (width)) + k, IUPacked);
            _u_image.write(((i * 2) * (width)) + k + 1, IUPacked);
            _v_image.write(((i * 2) * (width)) + k, IVPacked);
            _v_image.write(((i * 2) * (width)) + k + 1, IVPacked);

            inter_u.write(IUPacked);
            inter_v.write(IVPacked);
            inter_u.write(IUPacked);
            inter_v.write(IVPacked);
        }
        VITIS_LOOP_508_1: for (int j = 0; j < width; j++) {

#pragma HLS pipeline

 _u_image.write((((i * 2) + 1) * (width) + j), inter_u.read());
            _v_image.write((((i * 2) + 1) * (width) + j), inter_v.read());
        }
    }
}

template <int SRC_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_UV,
          int rTC,
          int cTC>
void KernIyuv2Nv12(xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u,
                   xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v,
                   xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                   uint16_t height,
                   uint16_t width) {
    ap_uint<13> i, j;
    typename StreamType<WORDWIDTH_SRC>::name u, v;
    typename StreamType<WORDWIDTH_UV>::name uv;
    unsigned long long int idx = 0;
RowLoop:
    for (i = 0; i<height>> 1; i++) {



#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=rTC max=rTC

 ColLoop:
        for (j = 0; j < (width >> 1); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=cTC max=cTC

 u = _u.read(i * (width >> 1) + j);
            v = _v.read(i * (width >> 1) + j);
            uv.range(7, 0) = u;
            uv.range(15, 8) = v;
            _uv.write(idx++, uv);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void KernRgba2Yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _rgba,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _u,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _v,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<XF_32UW>::name rgba;
    uint8_t y, u, v;
    unsigned long long int idx = 0;
RowLoop:
    for (int i = 0; i < height; ++i) {

#pragma HLS LOOP_FLATTEN OFF
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; ++j) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS
#pragma HLS PIPELINE

 rgba = _rgba.read(i * width + j);

            y = CalculateY(rgba.range(7, 0), rgba.range(15, 8), rgba.range(23, 16));
            u = CalculateU(rgba.range(7, 0), rgba.range(15, 8), rgba.range(23, 16));
            v = CalculateV(rgba.range(7, 0), rgba.range(15, 8), rgba.range(23, 16));

            _y.write(idx, y);
            _u.write(idx, u);
            _v.write(idx++, v);
        }
    }
}

template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int ROWS_U,
          int ROWS_V>
void KernRgba2Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _rgba,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u,
                   xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<XF_32UW>::name rgba;
    uint8_t y, u, v;
    bool evenRow = true, evenBlock = true;
    unsigned long long int idx = 0, idx1 = 0;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 rgba = _rgba.read(i * width + j);
            uint8_t r = rgba.range(7, 0);
            uint8_t g = rgba.range(15, 8);
            uint8_t b = rgba.range(23, 16);

            y = CalculateY(r, g, b);
            if (evenRow) {
                if (evenBlock) {
                    u = CalculateU(r, g, b);
                    v = CalculateV(r, g, b);
                }
            }
            _y.write(idx1++, y);
            if (evenRow & !evenBlock) {
                _u.write(idx, u);
                _v.write(idx++, v);
            }
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void KernRgba2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _rgba,
                   xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                   uint16_t height,
                   uint16_t width) {

    typename DataType<SRC_T, NPC>::name rgba;
    ap_uint<16> val1;
    uint8_t y, u, v;
    unsigned long long int idx = 0, idx1 = 0;
    bool evenRow = true, evenBlock = true;

RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 rgba = _rgba.read(i * width + j);
            uint8_t r = rgba.range(7, 0);
            uint8_t g = rgba.range(15, 8);
            uint8_t b = rgba.range(23, 16);

            y = CalculateY(r, g, b);
            if (evenRow) {
                u = CalculateU(r, g, b);
                v = CalculateV(r, g, b);
            }
            _y.write(idx++, y);
            if (evenRow) {
                if ((j & 0x01) == 0)

                    _uv.write(idx1++, u | (uint16_t)v << 8);



            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_VU>
void KernRgba2Nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _rgba,
                   xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _vu,
                   uint16_t height,
                   uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    typename DataType<SRC_T, NPC>::name rgba;
    uint8_t y, u, v;
    unsigned long long int idx = 0, idx1 = 0;
    bool evenRow = true, evenBlock = true;

RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 rgba = _rgba.read(i * width + j);
            uint8_t r = rgba.range(7, 0);
            uint8_t g = rgba.range(15, 8);
            uint8_t b = rgba.range(23, 16);

            y = CalculateY(r, g, b);
            if (evenRow) {
                u = CalculateU(r, g, b);
                v = CalculateV(r, g, b);
            }
            _y.write(idx++, y);
            if (evenRow) {
                if ((j & 0x01) == 0) _vu.write(idx1++, v | ((uint16_t)u << 8));
            }
        }
        evenRow = evenRow ? false : true;
    }
}


template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernYuyv2Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _yuyv,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<WORDWIDTH_DST>::name rgba;
    typename StreamType<WORDWIDTH_SRC>::name yu, yv;
    typename PixelType<XF_8UP>::name r, g, b;
    int8_t y1, y2, u, v;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    unsigned long long int idx = 0;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline


 yu = _yuyv.read(i * width + j);
            yv = _yuyv.read(i * width + j + 1);
            u = (uint8_t)yu.range(15, 8) - 128;
            y1 = (yu.range(7, 0) > 16) ? ((uint8_t)yu.range(7, 0) - 16) : 0;

            v = (uint8_t)yv.range(15, 8) - 128;
            y2 = (yv.range(7, 0) > 16) ? ((uint8_t)yv.range(7, 0) - 16) : 0;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;

            r = CalculateR(y1, V2Rtemp, v);
            g = CalculateG(y1, U2Gtemp, V2Gtemp);
            b = CalculateB(y1, U2Btemp, u);

            rgba = ((ap_uint32_t)r) | ((ap_uint32_t)g << 8) | ((ap_uint32_t)b << 16) | (0xFF000000);
            _rgba.write(idx++, rgba);

            r = CalculateR(y2, V2Rtemp, v);
            g = CalculateG(y2, U2Gtemp, V2Gtemp);
            b = CalculateB(y2, U2Btemp, u);

            rgba = ((ap_uint32_t)r) | ((ap_uint32_t)g << 8) | ((ap_uint32_t)b << 16) | (0xFF000000);
            _rgba.write(idx++, rgba);
        }
    }
}


template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC>
void KernYuyv2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _yuyv,
                   xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<WORDWIDTH_SRC>::name yu, yv;
    typename PixelType<XF_8UP>::name y1, y2;
    unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_UV>::name uv;
    bool evenRow = true;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC


 yu = _yuyv.read(i * width + j);
            yv = _yuyv.read(i * width + j + 1);
            y1 = yu.range(7, 0);
            if (evenRow) uv.range(7, 0) = yu.range(15, 8);

            y2 = yv.range(7, 0);
            if (evenRow) uv.range(15, 8) = yv.range(15, 8);

            _y.write(idx++, y1);
            _y.write(idx++, y2);
            if (evenRow) {
                _uv.write(idx1++, uv);
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC>
void KernYuyv2Nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _yuyv,
                   xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<WORDWIDTH_SRC>::name yu, yv;
    typename PixelType<XF_8UP>::name y1, y2;
    unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_UV>::name uv;
    bool evenRow = true;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC


 yu = _yuyv.read(i * width + j);
            yv = _yuyv.read(i * width + j + 1);
            y1 = yu.range(7, 0);
            if (evenRow) uv.range(7, 0) = yv.range(15, 8);

            y2 = yv.range(7, 0);
            if (evenRow) uv.range(15, 8) = yu.range(15, 8);

            _y.write(idx++, y1);
            _y.write(idx++, y2);
            if (evenRow) {
                _uv.write(idx1++, uv);
            }
        }
        evenRow = evenRow ? false : true;
    }
}


template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernYuyv2Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _yuyv,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y,
                   xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u,
                   xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<WORDWIDTH_SRC>::name yu, yv;
    unsigned long long int idx = 0, idx1 = 0;
    bool evenRow = true, evenBlock = true;
    typename PixelType<XF_8UP>::name y1, y2, u, v;

RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC


 yu = _yuyv.read(i * width + j);
            yv = _yuyv.read(i * width + j + 1);
            y1 = yu.range(7, 0);
            y2 = yv.range(7, 0);
            _y.write(idx, y1);
            idx++;
            _y.write(idx, y2);
            idx++;
            if (evenRow) u = yu.range(15, 8);

            if (evenRow) v = yv.range(15, 8);

            if (evenRow) {
                _u.write(idx1, u);
                _v.write(idx1, v);
                idx1++;
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernUyvy2Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _uyvy,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& y_plane,
                   xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& u_plane,
                   xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& v_plane,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<WORDWIDTH_SRC>::name uy, vy;
    bool evenRow = true, evenBlock = true;
    typename PixelType<XF_8UP>::name y1, y2, u, v;
    unsigned long long int idx = 0, idx1 = 0;

RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC


 uy = _uyvy.read(i * width + j);
            vy = _uyvy.read(i * width + j + 1);

            y1 = uy.range(15, 8);

            y_plane.write(idx1, y1);
            idx1++;
            if (evenRow) u = uy.range(7, 0);

            y2 = vy.range(15, 8);

            y_plane.write(idx1, y2);
            idx1++;
            if (evenRow) v = vy.range(7, 0);

            if (evenRow) {
                u_plane.write(idx, u);
                v_plane.write(idx, v);
                idx++;
            }
        }

        evenRow = evenRow ? false : true;
    }
}


template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC>
void KernUyvy2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy,
                   xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                   xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<WORDWIDTH_SRC>::name uy, vy;
    typename PixelType<XF_8UP>::name y1, y2;
    typename StreamType<WORDWIDTH_UV>::name uv;
    bool evenRow = true;
    unsigned long long int idx = 0, idx1 = 0;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC


 uy = uyvy.read(i * width + j);
            vy = uyvy.read(i * width + j + 1);

            y1 = uy.range(15, 8);
            if (evenRow) uv.range(7, 0) = uy.range(7, 0);

            y2 = vy.range(15, 8);
            if (evenRow) uv.range(15, 8) = vy.range(7, 0);

            y_plane.write(idx1, y1);
            idx1++;
            y_plane.write(idx1, y2);
            idx1++;
            if (evenRow) {
                uv_plane.write(idx, uv);
                idx++;
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC>
void KernUyvy2Nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy,
                   xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                   xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<WORDWIDTH_SRC>::name uy, vy;
    typename PixelType<XF_8UP>::name y1, y2;
    typename StreamType<WORDWIDTH_UV>::name uv;
    bool evenRow = true;
    unsigned long long int idx = 0, idx1 = 0;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC


 uy = uyvy.read(i * width + j);
            vy = uyvy.read(i * width + j + 1);

            y1 = uy.range(15, 8);
            if (evenRow) uv.range(7, 0) = vy.range(7, 0);

            y2 = vy.range(15, 8);
            if (evenRow) uv.range(15, 8) = uy.range(7, 0);

            y_plane.write(idx1, y1);
            idx1++;
            y_plane.write(idx1, y2);
            idx1++;
            if (evenRow) {
                uv_plane.write(idx, uv);
                idx++;
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernUyvy2Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _uyvy,
                   xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                   uint16_t height,
                   uint16_t width) {
    typename StreamType<WORDWIDTH_DST>::name rgba;

    typename StreamType<WORDWIDTH_SRC>::name uyvy;

    typename StreamType<WORDWIDTH_SRC>::name uy;
    typename StreamType<WORDWIDTH_SRC>::name vy;
    unsigned long long int idx = 0;
    typename PixelType<XF_8UP>::name r, g, b;
    int8_t y1, y2, u, v;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;

RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline


 uy = _uyvy.read(i * width + j);
            vy = _uyvy.read(i * width + j + 1);

            u = (uint8_t)uy.range(7, 0) - 128;






            y1 = (uy.range(15, 8) > 16) ? ((uint8_t)uy.range(15, 8) - 16) : 0;

            v = (uint8_t)vy.range(7, 0) - 128;





            y2 = (vy.range(15, 8) > 16) ? ((uint8_t)vy.range(15, 8) - 16) : 0;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;

            r = CalculateR(y1, V2Rtemp, v);
            g = CalculateG(y1, U2Gtemp, V2Gtemp);
            b = CalculateB(y1, U2Btemp, u);

            rgba = ((ap_uint32_t)r) | ((ap_uint32_t)g << 8) | ((ap_uint32_t)b << 16) | (0xFF000000);
            _rgba.write(idx, rgba);
            idx++;

            r = CalculateR(y2, V2Rtemp, v);
            g = CalculateG(y2, U2Gtemp, V2Gtemp);
            b = CalculateB(y2, U2Btemp, u);

            rgba = ((ap_uint32_t)r) | ((ap_uint32_t)g << 8) | ((ap_uint32_t)b << 16) | (0xFF000000);
            _rgba.write(idx, rgba);
            idx++;
        }
    }
}
# 23 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp" 2

# 1 "/usr/include/assert.h" 1 3 4
# 25 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp" 2

namespace xf {
namespace cv {
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int TC>
void write_y_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& out_y,
                uint16_t height,
                uint16_t width) {
    typename StreamType<WORDWIDTH_SRC>::name tmp;
    unsigned long long int idx = 0;
    VITIS_LOOP_35_1: for (int i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 VITIS_LOOP_40_2: for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 tmp = src_y.read(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            out_y.write(idx++, tmp);
        }
    }
}


template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int PLANES,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernRgba2Yuv4_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst1,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst2,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst3,
                      uint16_t height,
                      uint16_t width) {

    typename PixelType<XF_8UP>::name Y0[16], U[16], V[16];
    uint8_t RGB[64];

#pragma HLS ARRAY_PARTITION variable=Y0 complete
#pragma HLS ARRAY_PARTITION variable=U complete
#pragma HLS ARRAY_PARTITION variable=V complete
#pragma HLS ARRAY_PARTITION variable=RGB complete

 unsigned long long int y_idx = 0, u_idx = 0, v_idx = 0;
    typename StreamType<WORDWIDTH_SRC>::name PackedPixels;
    typename StreamType<WORDWIDTH_DST>::name YPacked, UPacked, VPacked;
    uint8_t offset;

rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 PackedPixels = src.read(i * width + j);
            ExtractRGBAPixels<WORDWIDTH_SRC>(PackedPixels, RGB);




            VITIS_LOOP_99_1: for (int l = 0; l<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC


 if (PLANES == 4) {
                    offset = l << 3;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 4], RGB[offset + 5], RGB[offset + 6]);

                    U[(l << 1)] = CalculateU(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    U[(l << 1) + 1] = CalculateU(RGB[offset + 4], RGB[offset + 5], RGB[offset + 6]);

                    V[(l << 1)] = CalculateV(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    V[(l << 1) + 1] = CalculateV(RGB[offset + 4], RGB[offset + 5], RGB[offset + 6]);
                } else {
                    offset = l * 6;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 3], RGB[offset + 4], RGB[offset + 5]);

                    U[(l << 1)] = CalculateU(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    U[(l << 1) + 1] = CalculateU(RGB[offset + 3], RGB[offset + 4], RGB[offset + 5]);

                    V[(l << 1)] = CalculateV(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    V[(l << 1) + 1] = CalculateV(RGB[offset + 3], RGB[offset + 4], RGB[offset + 5]);
                }
            }
            YPacked = PackPixels<WORDWIDTH_DST>(Y0);
            UPacked = PackPixels<WORDWIDTH_DST>(U);
            VPacked = PackPixels<WORDWIDTH_DST>(V);

            dst1.write(y_idx++, YPacked);
            dst2.write(u_idx++, UPacked);
            dst3.write(v_idx++, VPacked);
        }
    }
}


template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int PLANES,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int ROWS_U,
          int ROWS_V,
          int TC,
          int iTC>
void KernRgba2Iyuv_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& rgba,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& y_plane,
                      xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& u_plane,
                      xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& v_plane,
                      uint16_t height,
                      uint16_t width) {
    ap_uint8_t Y0[16], U[16], V[16];
    uint8_t RGB[64];

#pragma HLS ARRAY_PARTITION variable=Y0 complete
#pragma HLS ARRAY_PARTITION variable=U complete
#pragma HLS ARRAY_PARTITION variable=V complete
#pragma HLS ARRAY_PARTITION variable=RGB complete

 unsigned long long int y_idx = 0, out_idx = 0, out_idx1 = 0;
    typename StreamType<WORDWIDTH_SRC>::name PackedPixels;
    typename StreamType<WORDWIDTH_DST>::name YPacked, UPacked, VPacked;

    uint8_t Ycount = 0, UVcount = 0;
    int offset;
    uchar_t UVoffset_ind, l;
    ap_uint<13> i, j;
    UVoffset_ind = (1 << xfNPixelsPerCycle<NPC>::datashift) >> 1;

    bool evenRow = true, evenBlock = true;
rowloop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 PackedPixels = rgba.read(i * width + j);
            ExtractRGBAPixels<WORDWIDTH_SRC>(PackedPixels, RGB);
            VITIS_LOOP_189_1: for (l = 0; l<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 if (PLANES == 4) {
                    offset = l << 3;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 4], RGB[offset + 5], RGB[offset + 6]);
                } else {
                    offset = l * 6;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 3], RGB[offset + 4], RGB[offset + 5]);
                }
                if (evenRow)

                {


                    if (evenBlock) {
                        U[l] = CalculateU(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                        V[l] = CalculateV(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    } else {
                        U[UVoffset_ind + l] = CalculateU(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                        V[UVoffset_ind + l] = CalculateV(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    }
                }
            }
            YPacked = PackPixels<WORDWIDTH_DST>(Y0);
            y_plane.write(y_idx++, YPacked);
            if (evenRow & !evenBlock) {
                UPacked = PackPixels<WORDWIDTH_DST>(U);
                VPacked = PackPixels<WORDWIDTH_DST>(V);
                u_plane.write(out_idx++, UPacked);
                v_plane.write(out_idx1++, VPacked);
            }
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
# 240 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
}


template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int PLANES,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC,
          int iTC>
void KernRgba2Nv12_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& rgba,
                      xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                      xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                      uint16_t height,
                      uint16_t width) {

    typename PixelType<XF_8UP>::name Y0[16], UV[16];
    uint8_t RGB[64];

#pragma HLS ARRAY_PARTITION variable=Y0 complete
#pragma HLS ARRAY_PARTITION variable=UV complete
#pragma HLS ARRAY_PARTITION variable=RGB complete

 typename StreamType<WORDWIDTH_SRC>::name PackedPixels;
    typename StreamType<WORDWIDTH_Y>::name YPacked, UVPacked;
    unsigned long long int idx = 0, idx1 = 0;
    uint8_t offset;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 PackedPixels = rgba.read(i * width + j);
            ExtractRGBAPixels<WORDWIDTH_SRC>(PackedPixels, RGB);
            VITIS_LOOP_288_1: for (int l = 0; l<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 if (PLANES == 4) {
                    offset = l << 3;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 4], RGB[offset + 5], RGB[offset + 6]);
                } else {
                    offset = l * 6;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 3], RGB[offset + 4], RGB[offset + 5]);
                }
                if (evenRow) {
                    UV[l << 1] = CalculateU(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    UV[(l << 1) + 1] = CalculateV(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                }
            }
            YPacked = PackPixels<WORDWIDTH_Y>(Y0);
            y_plane.write(idx++, YPacked);
            if (evenRow) {
                UVPacked = PackPixels<WORDWIDTH_UV>(UV);
                uv_plane.write(idx1++, UVPacked);
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int PLANES,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC,
          int iTC>
void Kernbgr2Nv12_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& rgba,
                     xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                     xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                     uint16_t height,
                     uint16_t width) {

    typename PixelType<XF_8UP>::name Y0[16], UV[16];
    uint8_t RGB[64];

#pragma HLS ARRAY_PARTITION variable=Y0 complete
#pragma HLS ARRAY_PARTITION variable=UV complete
#pragma HLS ARRAY_PARTITION variable=RGB complete

 typename StreamType<WORDWIDTH_SRC>::name PackedPixels;
    typename StreamType<WORDWIDTH_Y>::name YPacked, UVPacked;
    unsigned long long int idx = 0, idx1 = 0;
    uint8_t offset;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 PackedPixels = rgba.read(i * width + j);
            ExtractRGBAPixels<WORDWIDTH_SRC>(PackedPixels, RGB);
            VITIS_LOOP_363_1: for (int l = 0; l<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 if (PLANES == 4) {





                } else {
                    offset = l * 6;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 2], RGB[offset + 1], RGB[offset + 0]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 5], RGB[offset + 4], RGB[offset + 3]);
                }
                if (evenRow) {
                    UV[l << 1] = CalculateU(RGB[offset + 2], RGB[offset + 1], RGB[offset + 0]);
                    UV[(l << 1) + 1] = CalculateV(RGB[offset + 2], RGB[offset + 1], RGB[offset + 0]);
                }
            }
            YPacked = PackPixels<WORDWIDTH_Y>(Y0);
            y_plane.write(idx++, YPacked);
            if (evenRow) {
                UVPacked = PackPixels<WORDWIDTH_UV>(UV);
                uv_plane.write(idx1++, UVPacked);
            }
        }
        evenRow = evenRow ? false : true;
    }
}


template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int PLANES,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_VU,
          int TC,
          int iTC>
void KernRgba2Nv21_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& rgba,
                      xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                      xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& vu_plane,
                      uint16_t height,
                      uint16_t width) {

    uint16_t i, j, k, l;
    ap_uint8_t Y0[16], VU[16];
    uint8_t RGB[64];

#pragma HLS ARRAY_PARTITION variable=Y0 complete
#pragma HLS ARRAY_PARTITION variable=VU complete
#pragma HLS ARRAY_PARTITION variable=RGB complete

 typename StreamType<WORDWIDTH_SRC>::name PackedPixels;
    typename StreamType<WORDWIDTH_Y>::name YPacked, VUPacked;
    uint8_t offset;
    unsigned long long int idx = 0, idx1 = 0;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 PackedPixels = (typename StreamType<WORDWIDTH_SRC>::name)rgba.read(i * width + j);
            ExtractRGBAPixels<WORDWIDTH_SRC>(PackedPixels, RGB);
            VITIS_LOOP_442_1: for (int l = 0; l<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 if (PLANES == 4) {
                    offset = l << 3;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 4], RGB[offset + 5], RGB[offset + 6]);
                } else {
                    offset = l * 6;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 3], RGB[offset + 4], RGB[offset + 5]);
                }
                if (evenRow) {
                    VU[(l << 1)] = CalculateV(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                    VU[(l << 1) + 1] = CalculateU(RGB[offset + 0], RGB[offset + 1], RGB[offset + 2]);
                }
            }
            YPacked = PackPixels<WORDWIDTH_Y>(Y0);
            y_plane.write(idx++, YPacked);
            if (evenRow) {
                VUPacked = PackPixels<WORDWIDTH_Y>(VU);
                vu_plane.write(idx1++, VUPacked);
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int PLANES,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_VU,
          int TC,
          int iTC>
void Kernbgr2Nv21_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& rgba,
                     xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                     xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& vu_plane,
                     uint16_t height,
                     uint16_t width) {

    uint16_t i, j, k, l;
    ap_uint8_t Y0[16], VU[16];
    uint8_t RGB[64];

#pragma HLS ARRAY_PARTITION variable=Y0 complete
#pragma HLS ARRAY_PARTITION variable=VU complete
#pragma HLS ARRAY_PARTITION variable=RGB complete

 typename StreamType<WORDWIDTH_SRC>::name PackedPixels;
    typename StreamType<WORDWIDTH_Y>::name YPacked, VUPacked;
    uint8_t offset;
    unsigned long long int idx = 0, idx1 = 0;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 PackedPixels = (typename StreamType<WORDWIDTH_SRC>::name)rgba.read(i * width + j);
            ExtractRGBAPixels<WORDWIDTH_SRC>(PackedPixels, RGB);
            VITIS_LOOP_518_1: for (int l = 0; l<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 if (PLANES == 4) {





                } else {
                    offset = l * 6;
                    Y0[(l << 1)] = CalculateY(RGB[offset + 2], RGB[offset + 1], RGB[offset + 0]);
                    Y0[(l << 1) + 1] = CalculateY(RGB[offset + 5], RGB[offset + 4], RGB[offset + 3]);
                }
                if (evenRow) {
                    VU[(l << 1)] = CalculateV(RGB[offset + 2], RGB[offset + 1], RGB[offset + 0]);
                    VU[(l << 1) + 1] = CalculateU(RGB[offset + 2], RGB[offset + 1], RGB[offset + 0]);
                }
            }
            YPacked = PackPixels<WORDWIDTH_Y>(Y0);
            y_plane.write(idx++, YPacked);
            if (evenRow) {
                VUPacked = PackPixels<WORDWIDTH_Y>(VU);
                vu_plane.write(idx1++, VUPacked);
            }
        }
        evenRow = evenRow ? false : true;
    }
}


template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void KernIyuv2Rgba_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& in_y,
                      xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& in_u,
                      xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& in_v,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                      uint16_t height,
                      uint16_t width) {



    typename PixelType<XF_8UP>::name RGB[64], Ybuf[16], Ubuf[16], Vbuf[16];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=Ubuf complete
#pragma HLS ARRAY_PARTITION variable=Vbuf complete


 hls::stream<typename StreamType<WORDWIDTH_SRC>::name> UStream, VStream;

#pragma HLS STREAM variable=&UStream depth=COLS
#pragma HLS STREAM variable=&VStream depth=COLS


 typename StreamType<WORDWIDTH_SRC>::name YPacked, UPacked, VPacked;
    typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    unsigned long long int idx = 0, out_idx = 0;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t U, V;
    uint8_t offset;
    bool evenRow = true, evenBlock = true;

rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YPacked = in_y.read(i * width + j);

            xfExtractPixels<NPC, WORDWIDTH_SRC, XF_8UP>(Ybuf, YPacked, 0);
            if (evenBlock) {
                if (evenRow) {
                    UPacked = in_u.read(idx);
                    UStream.write(UPacked);
                    VPacked = in_v.read(idx++);
                    VStream.write(VPacked);
                } else {


                    UPacked = UStream.read();
                    VPacked = VStream.read();
                }
                xfExtractPixels<NPC, WORDWIDTH_SRC, XF_8UP>(Ubuf, UPacked, 0);
                xfExtractPixels<NPC, WORDWIDTH_SRC, XF_8UP>(Vbuf, VPacked, 0);
                offset = 0;
            } else {
                offset = (1 << xfNPixelsPerCycle<NPC>::datashift) >> 1;
            }
            VITIS_LOOP_617_1: for (int k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll




 if ((Ybuf[k << 1] > 16)) {
                    Y00 = (Ybuf[k << 1] - 16);
                } else {
                    Y00 = 0;
                }

                if ((Ybuf[(k << 1) + 1] > 16)) {
                    Y01 = (Ybuf[(k << 1) + 1] - 16);
                } else {
                    Y01 = 0;
                }

                U = Ubuf[k + offset] - 128;
                V = Vbuf[k + offset] - 128;

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;




                RGB[(k << 3)] = CalculateR(Y00, V2Rtemp, V);
                RGB[(k << 3) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                RGB[(k << 3) + 2] = CalculateB(Y00, U2Btemp, U);
                RGB[(k << 3) + 3] = 255;
                RGB[(k << 3) + 4] = CalculateR(Y01, V2Rtemp, V);
                RGB[(k << 3) + 5] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                RGB[(k << 3) + 6] = CalculateB(Y01, U2Btemp, U);
                RGB[(k << 3) + 7] = 255;
            }
            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            _rgba.write(out_idx++, PackedPixels);
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
}


template <int SRC_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_UV,
          int rTC,
          int cTC,
          int iTC>
void KernIyuv2Nv12_ro(xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u,
                      xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v,
                      xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                      uint16_t height,
                      uint16_t width) {
    ap_uint<13> i, j;
    typename PixelType<XF_8UP>::name U[16], V[16];

#pragma HLS ARRAY_PARTITION variable=U complete
#pragma HLS ARRAY_PARTITION variable=V complete

 unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_SRC>::name UVPacked0, UVPacked1, UPacked, VPacked;
rowloop:
    for (i = 0; i<height>> 1; i++) {






#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=rTC max=rTC

 columnloop:
        for (j = 0; j < (width >> (1 + xfNPixelsPerCycle<NPC>::datashift)); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=cTC max=cTC

 UPacked = _u.read(idx);
            VPacked = _v.read(idx++);

            xfExtractPixels<NPC, WORDWIDTH_SRC, XF_8UP>(U, UPacked, 0);
            xfExtractPixels<NPC, WORDWIDTH_SRC, XF_8UP>(V, VPacked, 0);


            ap_uint<4> off = (1 << xfNPixelsPerCycle<NPC>::datashift) >> 1;
            ap_uint<4> k;
            int l;
            VITIS_LOOP_717_1: for (k = 0, l = 0; k < ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1); k++, l += 16) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS UNROLL

 UVPacked0.range(l + 16 - 1, l) = (U[k]) | ((ap_uint<16>)V[k] << (8));
                UVPacked1.range(l + 16 - 1, l) = (U[k + off]) | ((ap_uint<16>)V[k + off] << (8));
            }
            _uv.write(idx1++, UVPacked0);
            _uv.write(idx1++, UVPacked1);
        }
    }
}


template <int SRC_T, int ROWS, int COLS, int NPC, int WORDWIDTH, int rTC, int cTC, int iTC>
void KernIyuv2Yuv4_ro(xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _in_u,
                      xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _in_v,
                      xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u_image,
                      xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v_image,
                      uint16_t height,
                      uint16_t width) {
    typename DataType<SRC_T, NPC>::name arr[COLS >> xfNPixelsPerCycle<NPC>::datashift];
    typename DataType<SRC_T, NPC>::name arr1[COLS >> xfNPixelsPerCycle<NPC>::datashift];

    hls::stream<typename DataType<SRC_T, NPC>::name> inter_u, inter_v;

#pragma HLS stream variable=&inter_u depth=COLS/2
#pragma HLS stream variable=&inter_v depth=COLS/2

 unsigned long long int idx = 0, idx1 = 0;
    typename PixelType<XF_8UP>::name U[16], V[16];

#pragma HLS ARRAY_PARTITION variable=U complete
#pragma HLS ARRAY_PARTITION variable=V complete


 typename StreamType<WORDWIDTH>::name
    IUPacked, IVPacked, UPacked0, VPacked0, UPacked1, VPacked1;
rowloop:
    for (int i = 0; i < ((height >> 2) << 1); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=rTC max=rTC

 columnloop:
        for (int j = 0, k = 0; j < ((width >> xfNPixelsPerCycle<NPC>::datashift) >> 1); j++, k += 2) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=cTC max=cTC

 IUPacked = _in_u.read(idx);
            IVPacked = _in_v.read(idx++);

            xfExtractPixels<NPC, WORDWIDTH, XF_8UP>(U, IUPacked, 0);
            xfExtractPixels<NPC, WORDWIDTH, XF_8UP>(V, IVPacked, 0);

            int off = 1 << (2);
            VITIS_LOOP_775_1: for (int k = 0, l = 0; k < (1 << (2)); k++, l += 16) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS UNROLL

 UPacked0.range(l + 16 - 1, l) = (U[k]) | ((ap_uint<16>)U[k] << (8));
                VPacked0.range(l + 16 - 1, l) = (V[k]) | ((ap_uint<16>)V[k] << (8));
                UPacked1.range(l + 16 - 1, l) = (U[k + off]) | ((ap_uint<16>)U[k + off] << (8));
                VPacked1.range(l + 16 - 1, l) = (V[k + off]) | ((ap_uint<16>)V[k + off] << (8));
            }
            _u_image.write((((i * 2)) * (_u_image.cols >> xfNPixelsPerCycle<NPC>::datashift)) + k, UPacked0);
            _v_image.write((((i * 2)) * (_v_image.cols >> xfNPixelsPerCycle<NPC>::datashift)) + k, VPacked0);
            _u_image.write((((i * 2)) * (_u_image.cols >> xfNPixelsPerCycle<NPC>::datashift)) + k + 1, UPacked1);
            _v_image.write((((i * 2)) * (_v_image.cols >> xfNPixelsPerCycle<NPC>::datashift)) + k + 1, VPacked1);

            inter_u.write(UPacked0);
            inter_v.write(VPacked0);
            inter_u.write(UPacked1);
            inter_v.write(VPacked1);
        }
        VITIS_LOOP_795_2: for (int j = 0; j < (_u_image.cols >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline

 _u_image.write((((i * 2) + 1) * (_u_image.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, inter_u.read());
            _v_image.write((((i * 2) + 1) * (_u_image.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, inter_v.read());
        }
    }
}


template <int SRC_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernNv122Iyuv_ro(xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                      xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u,
                      xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v,
                      uint16_t height,
                      uint16_t width) {
    typename PixelType<XF_8UP>::name UV0[16], UV1[16];

#pragma HLS ARRAY_PARTITION variable=UV0 complete
#pragma HLS ARRAY_PARTITION variable=UV1 complete

 unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_DST>::name UPacked, VPacked;
    typename StreamType<WORDWIDTH_SRC>::name UVPacked0, UVPacked1;
    ap_uint<13> i, j;
rowloop:
    for (i = 0; i < (height >> 1); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (j = 0; j < ((width >> xfNPixelsPerCycle<NPC>::datashift) >> 1); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 UVPacked0 = _uv.read(idx++);
            UVPacked1 = _uv.read(idx++);

            xfExtractPixels<NPC, WORDWIDTH_SRC, XF_8UP>(UV0, UVPacked0, 0);
            xfExtractPixels<NPC, WORDWIDTH_SRC, XF_8UP>(UV1, UVPacked1, 0);


            int sft = 1 << (xfNPixelsPerCycle<NPC>::datashift + 2);
            int l;
            ap_uint<9> k;
            VITIS_LOOP_852_1: for (int k = 0, l = 0; k < (1 << (xfNPixelsPerCycle<NPC>::datashift)); k += 4, l += 16) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS UNROLL

 VPacked.range(l + 16 - 1, l) = (UV0[k + 1]) | ((ap_uint<16>)UV0[k + 3] << (8));
                UPacked.range(l + 16 - 1, l) = (UV0[k]) | ((ap_uint<16>)UV0[k + 2] << (8));

                VPacked.range(l + sft + 16 - 1, l + sft) = (UV1[k + 1]) | ((ap_uint<16>)UV1[k + 3] << (8));
                UPacked.range(l + sft + 16 - 1, l + sft) = (UV1[k]) | ((ap_uint<16>)UV1[k + 2] << (8));
            }
            _u.write(idx1, UPacked);
            _v.write(idx1++, VPacked);
        }
    }
}


template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int PLANES,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernNv122Rgba_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& in_y,
                      xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& in_uv,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& rgba,
                      uint16_t height,
                      uint16_t width) {

    typename PixelType<XF_8UP>::name RGB[64], Ybuf[16], UVbuf[16];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=UVbuf complete


 hls::stream<typename StreamType<WORDWIDTH_UV>::name> UVStream;

#pragma HLS STREAM variable=&UVStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name YPacked;
    typename StreamType<WORDWIDTH_UV>::name UVPacked;
    typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    unsigned long long int uv_idx = 0, out_idx = 0;
    int8_t U, V;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS


 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC


 YPacked = in_y.read(i * width + j);
            xfExtractPixels<NPC, WORDWIDTH_Y, XF_8UP>(Ybuf, YPacked, 0);
            if (evenRow) {
                UVPacked = in_uv.read(uv_idx++);
                UVStream.write(UVPacked);
            } else
                UVPacked = UVStream.read();

            xfExtractPixels<NPC, WORDWIDTH_UV, XF_8UP>(UVbuf, UVPacked, 0);
            VITIS_LOOP_931_1: for (int k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll




 if ((Ybuf[k << 1] > 16)) {
                    Y00 = (Ybuf[k << 1] - 16);
                } else {
                    Y00 = 0;
                }

                if ((Ybuf[(k << 1) + 1] > 16)) {
                    Y01 = (Ybuf[(k << 1) + 1] - 16);
                } else {
                    Y01 = 0;
                }

                U = UVbuf[k << 1] - 128;
                V = UVbuf[(k << 1) + 1] - 128;

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;




                if (PLANES == 4) {
                    RGB[(k << 3) + 0] = CalculateR(Y00, V2Rtemp, V);
                    RGB[(k << 3) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                    RGB[(k << 3) + 2] = CalculateB(Y00, U2Btemp, U);
                    RGB[(k << 3) + 3] = 255;
                    RGB[(k << 3) + 4] = CalculateR(Y01, V2Rtemp, V);
                    RGB[(k << 3) + 5] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                    RGB[(k << 3) + 6] = CalculateB(Y01, U2Btemp, U);
                    RGB[(k << 3) + 7] = 255;
                } else {
                    RGB[(k * 6) + 0] = CalculateR(Y00, V2Rtemp, V);
                    RGB[(k * 6) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                    RGB[(k * 6) + 2] = CalculateB(Y00, U2Btemp, U);
                    RGB[(k * 6) + 3] = CalculateR(Y01, V2Rtemp, V);
                    RGB[(k * 6) + 4] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                    RGB[(k * 6) + 5] = CalculateB(Y01, U2Btemp, U);
                }
            }
            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            rgba.write(out_idx++, PackedPixels);
        }
        evenRow = evenRow ? false : true;
    }
# 994 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
}

template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int PLANES,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernNv122bgr_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& in_y,
                     xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& in_uv,
                     xf::cv::Mat<DST_T, ROWS, COLS, NPC>& rgba,
                     uint16_t height,
                     uint16_t width) {

    typename PixelType<XF_8UP>::name RGB[64], Ybuf[16], UVbuf[16];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=UVbuf complete


 hls::stream<typename StreamType<WORDWIDTH_UV>::name> UVStream;

#pragma HLS STREAM variable=&UVStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name YPacked;
    typename StreamType<WORDWIDTH_UV>::name UVPacked;
    typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    unsigned long long int uv_idx = 0, out_idx = 0;
    int8_t U, V;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS


 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC


 YPacked = in_y.read(i * width + j);
            xfExtractPixels<NPC, WORDWIDTH_Y, XF_8UP>(Ybuf, YPacked, 0);
            if (evenRow) {
                UVPacked = in_uv.read(uv_idx++);
                UVStream.write(UVPacked);
            } else
                UVPacked = UVStream.read();

            xfExtractPixels<NPC, WORDWIDTH_UV, XF_8UP>(UVbuf, UVPacked, 0);
            VITIS_LOOP_1057_1: for (int k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll




 if ((Ybuf[k << 1] > 16)) {
                    Y00 = (Ybuf[k << 1] - 16);
                } else {
                    Y00 = 0;
                }

                if ((Ybuf[(k << 1) + 1] > 16)) {
                    Y01 = (Ybuf[(k << 1) + 1] - 16);
                } else {
                    Y01 = 0;
                }

                U = UVbuf[k << 1] - 128;
                V = UVbuf[(k << 1) + 1] - 128;

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;




                if (PLANES == 4) {
                    RGB[(k << 3) + 0] = CalculateR(Y00, V2Rtemp, V);
                    RGB[(k << 3) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                    RGB[(k << 3) + 2] = CalculateB(Y00, U2Btemp, U);
                    RGB[(k << 3) + 3] = 255;
                    RGB[(k << 3) + 4] = CalculateR(Y01, V2Rtemp, V);
                    RGB[(k << 3) + 5] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                    RGB[(k << 3) + 6] = CalculateB(Y01, U2Btemp, U);
                    RGB[(k << 3) + 7] = 255;
                } else {
                    RGB[(k * 6) + 0] = CalculateB(Y00, U2Btemp, U);
                    RGB[(k * 6) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                    RGB[(k * 6) + 2] = CalculateR(Y00, V2Rtemp, V);
                    RGB[(k * 6) + 3] = CalculateB(Y01, U2Btemp, U);
                    RGB[(k * 6) + 4] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                    RGB[(k * 6) + 5] = CalculateR(Y01, V2Rtemp, V);
                }
            }
            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            rgba.write(out_idx++, PackedPixels);
        }
        evenRow = evenRow ? false : true;
    }
# 1120 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
}


template <int SRC_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernNv122Yuv4_ro(xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                      xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u,
                      xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v,
                      uint16_t height,
                      uint16_t width) {
    typename PixelType<XF_8UP>::name UV[16];

#pragma HLS ARRAY_PARTITION variable=UV complete

 ap_uint<13> i, j;
    typename StreamType<WORDWIDTH_UV>::name UPacked;
    typename StreamType<WORDWIDTH_DST>::name VPacked, UVPacked;
    typename StreamType<WORDWIDTH_DST>::name
    arr_UPacked[COLS >> (xfNPixelsPerCycle<NPC>::datashift)], arr_VPacked[COLS >> (xfNPixelsPerCycle<NPC>::datashift)];

    unsigned long long int idx = 0, idx1 = 0;
rowloop:
    for (i = 0; i < (height >> 1); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 UVPacked = _uv.read(idx1++);
            xfExtractPixels<NPC, WORDWIDTH_DST, XF_8UP>(UV, UVPacked, 0);

            VITIS_LOOP_1164_1: for (int k = 0, l = 0; k < (1 << (xfNPixelsPerCycle<NPC>::datashift)); k += 2, l += 16) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS UNROLL

 VPacked.range(l + 16 - 1, l) = (UV[k + 1]) | ((ap_uint<16>)UV[k + 1] << (8));
                UPacked.range(l + 16 - 1, l) = (UV[k]) | ((ap_uint<16>)UV[k] << (8));
            }
            _u.write(((i * 2) * (_u.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, UPacked);
            _v.write(((i * 2) * (_v.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, VPacked);
            arr_UPacked[j] = UPacked;
            arr_VPacked[j] = VPacked;
        }
        VITIS_LOOP_1177_2: for (j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {
            _u.write((((i * 2) + 1) * (_u.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, arr_UPacked[j]);
            _v.write((((i * 2) + 1) * (_v.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, arr_VPacked[j]);
        }
    }
}


template <int SRC_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernNv212Iyuv_ro(xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& in_uv,
                      xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& u_out,
                      xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& v_out,
                      uint16_t height,
                      uint16_t width) {
    typename PixelType<XF_8UP>::name VU0[16], VU1[16];

#pragma HLS ARRAY_PARTITION variable=VU0 complete
#pragma HLS ARRAY_PARTITION variable=VU1 complete

 ap_uint<13> i, j;
    typename StreamType<WORDWIDTH_DST>::name UPacked, VPacked;
    typename StreamType<WORDWIDTH_SRC>::name VUPacked0, VUPacked1;
    unsigned long long int idx = 0, idx1 = 0;
    int l;
    ap_uint<4> k;
rowloop:
    for (i = 0; i < (height >> 1); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (j = 0; j < ((width >> xfNPixelsPerCycle<NPC>::datashift) >> 1);
             j++) {


#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 VUPacked0 = in_uv.read(idx++);
            VUPacked1 = in_uv.read(idx++);

            xfExtractPixels<NPC, WORDWIDTH_SRC, XF_8UP>(VU0, VUPacked0, 0);
            xfExtractPixels<NPC, WORDWIDTH_SRC, XF_8UP>(VU1, VUPacked1, 0);


            int sft = 1 << (xfNPixelsPerCycle<NPC>::datashift + 2);
            VITIS_LOOP_1233_1: for (k = 0, l = 0; k < (1 << (xfNPixelsPerCycle<NPC>::datashift)); k += 4, l += 16) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS UNROLL

 UPacked.range(l + 16 - 1, l) = (VU0[k + 1]) | ((ap_uint<16>)VU0[k + 3] << (8));
                VPacked.range(l + 16 - 1, l) = (VU0[k]) | ((ap_uint<16>)VU0[k + 2] << (8));

                UPacked.range(l + sft + 16 - 1, l + sft) = (VU1[k + 1]) | ((ap_uint<16>)VU1[k + 3] << (8));
                VPacked.range(l + sft + 16 - 1, l + sft) = (VU1[k]) | ((ap_uint<16>)VU1[k + 2] << (8));
            }
            u_out.write(idx1, UPacked);
            v_out.write(idx1, VPacked);
            idx1++;
        }
    }
# 1261 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
}
# 1390 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int PLANES,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernNv212Rgba_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& in_y,
                      xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& in_uv,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& rgba,
                      uint16_t height,
                      uint16_t width) {
    typename PixelType<XF_8UP>::name RGB[64], Ybuf[16], UVbuf[16];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=UVbuf complete

 ap_uint<13> i, j;
    unsigned long long int in_idx = 0, out_idx = 0;
    int k;
    hls::stream<typename StreamType<WORDWIDTH_UV>::name> UVStream;

#pragma HLS STREAM variable=&UVStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name YPacked;
    typename StreamType<WORDWIDTH_UV>::name UVPacked;
    typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t U, V;
    bool evenRow = true;
rowloop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YPacked = in_y.read(i * width + j);
            xfExtractPixels<NPC, WORDWIDTH_Y, XF_8UP>(Ybuf, YPacked, 0);
            if (evenRow) {
                UVPacked = in_uv.read(in_idx++);
                UVStream.write(UVPacked);
            } else
                UVPacked = UVStream.read();

            xfExtractPixels<NPC, WORDWIDTH_UV, XF_8UP>(UVbuf, UVPacked, 0);
            VITIS_LOOP_1449_1: for (k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll




 if ((Ybuf[k << 1] > 16)) {
                    Y00 = (Ybuf[k << 1] - 16);
                } else {
                    Y00 = 0;
                }

                if ((Ybuf[(k << 1) + 1] > 16)) {
                    Y01 = (Ybuf[(k << 1) + 1] - 16);
                } else {
                    Y01 = 0;
                }

                V = UVbuf[k << 1] - 128;
                U = UVbuf[(k << 1) + 1] - 128;

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;




                if (PLANES == 4) {
                    RGB[(k << 3) + 0] = CalculateR(Y00, V2Rtemp, V);
                    RGB[(k << 3) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                    RGB[(k << 3) + 2] = CalculateB(Y00, U2Btemp, U);
                    RGB[(k << 3) + 3] = 255;
                    RGB[(k << 3) + 4] = CalculateR(Y01, V2Rtemp, V);
                    RGB[(k << 3) + 5] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                    RGB[(k << 3) + 6] = CalculateB(Y01, U2Btemp, U);
                    RGB[(k << 3) + 7] = 255;
                } else {
                    RGB[(k * 6) + 0] = CalculateR(Y00, V2Rtemp, V);
                    RGB[(k * 6) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                    RGB[(k * 6) + 2] = CalculateB(Y00, U2Btemp, U);
                    RGB[(k * 6) + 3] = CalculateR(Y01, V2Rtemp, V);
                    RGB[(k * 6) + 4] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                    RGB[(k * 6) + 5] = CalculateB(Y01, U2Btemp, U);
                }
            }

            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            rgba.write(out_idx++, PackedPixels);
        }
        evenRow = evenRow ? false : true;
    }
# 1512 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
}


template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int PLANES,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernNv212bgr_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& in_y,
                     xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& in_uv,
                     xf::cv::Mat<DST_T, ROWS, COLS, NPC>& rgba,
                     uint16_t height,
                     uint16_t width) {
    typename PixelType<XF_8UP>::name RGB[64], Ybuf[16], UVbuf[16];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=UVbuf complete

 ap_uint<13> i, j;
    unsigned long long int in_idx = 0, out_idx = 0;
    int k;
    hls::stream<typename StreamType<WORDWIDTH_UV>::name> UVStream;

#pragma HLS STREAM variable=&UVStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name YPacked;
    typename StreamType<WORDWIDTH_UV>::name UVPacked;
    typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t U, V;
    bool evenRow = true;
rowloop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YPacked = in_y.read(i * width + j);
            xfExtractPixels<NPC, WORDWIDTH_Y, XF_8UP>(Ybuf, YPacked, 0);
            if (evenRow) {
                UVPacked = in_uv.read(in_idx++);
                UVStream.write(UVPacked);
            } else
                UVPacked = UVStream.read();

            xfExtractPixels<NPC, WORDWIDTH_UV, XF_8UP>(UVbuf, UVPacked, 0);
            VITIS_LOOP_1574_1: for (k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll




 if ((Ybuf[k << 1] > 16)) {
                    Y00 = (Ybuf[k << 1] - 16);
                } else {
                    Y00 = 0;
                }

                if ((Ybuf[(k << 1) + 1] > 16)) {
                    Y01 = (Ybuf[(k << 1) + 1] - 16);
                } else {
                    Y01 = 0;
                }

                V = UVbuf[k << 1] - 128;
                U = UVbuf[(k << 1) + 1] - 128;

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;
# 1630 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
                RGB[(k * 6) + 0] = CalculateB(Y00, U2Btemp, U);
                RGB[(k * 6) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                RGB[(k * 6) + 2] = CalculateR(Y00, V2Rtemp, V);
                RGB[(k * 6) + 3] = CalculateB(Y01, U2Btemp, U);
                RGB[(k * 6) + 4] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                RGB[(k * 6) + 5] = CalculateR(Y01, V2Rtemp, V);


            }

            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            rgba.write(out_idx++, PackedPixels);
        }
        evenRow = evenRow ? false : true;
    }
# 1653 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
}

template <int SRC_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_VU,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernNv212Yuv4_ro(xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _vu,
                      xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u,
                      xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v,
                      uint16_t height,
                      uint16_t width) {
    typename PixelType<XF_8UP>::name VUbuf[16];

#pragma HLS ARRAY_PARTITION variable=VUbuf complete

 typename StreamType<WORDWIDTH_DST>::name UPacked, VPacked;
    typename StreamType<WORDWIDTH_VU>::name VUPacked;
    typename StreamType<WORDWIDTH_DST>::name
    arr_UPacked[COLS >> (xfNPixelsPerCycle<NPC>::datashift)], arr_VPacked[COLS >> (xfNPixelsPerCycle<NPC>::datashift)];
    ap_uint<13> i, j;
    ap_uint<4> k;
    unsigned long long int idx = 0, idx1 = 0;
    int l;
rowloop:
    for (i = 0; i < (height >> 1); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 VUPacked = _vu.read(idx1++);
            xfExtractPixels<NPC, WORDWIDTH_VU, XF_8UP>(VUbuf, VUPacked, 0);

            VITIS_LOOP_1697_1: for (k = 0, l = 0; k < (1 << (xfNPixelsPerCycle<NPC>::datashift)); k += 2, l += 16) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS UNROLL

 UPacked.range(l + 16 - 1, l) = (VUbuf[k + 1]) | ((ap_uint<16>)VUbuf[k + 1] << (8));
                VPacked.range(l + 16 - 1, l) = (VUbuf[k]) | ((ap_uint<16>)VUbuf[k] << (8));
            }


            _u.write(((i * 2) * (_u.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, UPacked);
            _v.write(((i * 2) * (_v.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, VPacked);
            arr_UPacked[j] = UPacked;
            arr_VPacked[j] = VPacked;
        }
        VITIS_LOOP_1712_2: for (j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {
            _u.write((((i * 2) + 1) * (_u.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, arr_UPacked[j]);
            _v.write((((i * 2) + 1) * (_v.cols >> xfNPixelsPerCycle<NPC>::datashift)) + j, arr_VPacked[j]);
        }
    }
}


template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int PLANES,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernYuyv2Rgba_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& yuyv,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& rgba,
                      uint16_t height,
                      uint16_t width) {
    ap_uint8_t RGB[64];
    typename PixelType<XF_8UP>::name YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete


 typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    unsigned long long int idx = 0;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t U, V;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YUVPacked = yuyv.read(i * width + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);
            VITIS_LOOP_1761_1: for (int k = 0; k < (xfNPixelsPerCycle<NPC>::nppc >> 1); k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC


 if (YUVbuf[(k << 2)] > 16) {
                    Y00 = (YUVbuf[(k << 2)] - 16);
                } else {
                    Y00 = 0;
                }
                U = YUVbuf[(k << 2) + 1] - 128;


                if (YUVbuf[(k << 2) + 2] > 16) {
                    Y01 = YUVbuf[(k << 2) + 2] - 16;
                } else {
                    Y01 = 0;
                }
                V = YUVbuf[(k << 2) + 3] - 128;

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;
                if (PLANES == 4) {
                    RGB[(k << 3)] = CalculateR(Y00, V2Rtemp, V);
                    RGB[(k << 3) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                    RGB[(k << 3) + 2] = CalculateB(Y00, U2Btemp, U);
                    RGB[(k << 3) + 3] = 255;
                    RGB[(k << 3) + 4] = CalculateR(Y01, V2Rtemp, V);
                    RGB[(k << 3) + 5] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                    RGB[(k << 3) + 6] = CalculateB(Y01, U2Btemp, U);
                    RGB[(k << 3) + 7] = 255;
                } else {
                    RGB[(k * 6)] = CalculateR(Y00, V2Rtemp, V);
                    RGB[(k * 6) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                    RGB[(k * 6) + 2] = CalculateB(Y00, U2Btemp, U);
                    RGB[(k * 6) + 3] = CalculateR(Y01, V2Rtemp, V);
                    RGB[(k * 6) + 4] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                    RGB[(k * 6) + 5] = CalculateB(Y01, U2Btemp, U);
                }
            }

            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            rgba.write(idx++, PackedPixels);
        }
    }
}

template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int PLANES,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int TC,
          int iTC>
void KernYuyv2bgr_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& yuyv,
                     xf::cv::Mat<DST_T, ROWS, COLS, NPC>& rgba,
                     uint16_t height,
                     uint16_t width) {
    ap_uint8_t RGB[64];
    typename PixelType<XF_8UP>::name YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete


 typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    unsigned long long int idx = 0;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t U, V;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YUVPacked = yuyv.read(i * width + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);
            VITIS_LOOP_1851_1: for (int k = 0; k < (xfNPixelsPerCycle<NPC>::nppc >> 1); k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC


 if (YUVbuf[(k << 2)] > 16) {
                    Y00 = (YUVbuf[(k << 2)] - 16);
                } else {
                    Y00 = 0;
                }
                U = YUVbuf[(k << 2) + 1] - 128;


                if (YUVbuf[(k << 2) + 2] > 16) {
                    Y01 = YUVbuf[(k << 2) + 2] - 16;
                } else {
                    Y01 = 0;
                }
                V = YUVbuf[(k << 2) + 3] - 128;

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;

                RGB[(k * 6)] = CalculateB(Y00, U2Btemp, U);
                RGB[(k * 6) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                RGB[(k * 6) + 2] = CalculateR(Y00, V2Rtemp, V);
                RGB[(k * 6) + 3] = CalculateB(Y01, U2Btemp, U);
                RGB[(k * 6) + 4] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                RGB[(k * 6) + 5] = CalculateR(Y01, V2Rtemp, V);
            }

            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            rgba.write(idx++, PackedPixels);
        }
    }
}


template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC,
          int iTC>
void KernYuyv2Nv12_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _yuyv,
                      xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                      xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                      uint16_t height,
                      uint16_t width) {
    typename PixelType<XF_8UP>::name Ybuf[16], UVbuf[16], YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=UVbuf complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete

 typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    typename StreamType<WORDWIDTH_Y>::name YPacked, UVPacked;
    unsigned long long idx = 0, idx1 = 0;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YUVPacked = _yuyv.read(i * width + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);

            VITIS_LOOP_1933_1: for (int k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1;
                 k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 Ybuf[(k << 1)] = YUVbuf[(k << 2)];
                Ybuf[(k << 1) + 1] = YUVbuf[(k << 2) + 2];
                if (evenRow) {
                    UVbuf[(k << 1)] = YUVbuf[(k << 2) + 1];
                    UVbuf[(k << 1) + 1] = YUVbuf[(k << 2) + 3];
                }
            }
            YPacked = PackPixels<WORDWIDTH_Y>(Ybuf);
            y_plane.write(idx++, YPacked);
            if (evenRow) {
                UVPacked = PackPixels<WORDWIDTH_UV>(UVbuf);
                uv_plane.write(idx1++, UVPacked);
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC,
          int iTC>
void KernYuyv2Nv21_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _yuyv,
                      xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                      xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                      uint16_t height,
                      uint16_t width) {
    typename PixelType<XF_8UP>::name Ybuf[16], UVbuf[16], YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=UVbuf complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete

 typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    typename StreamType<WORDWIDTH_Y>::name YPacked, UVPacked;
    unsigned long long idx = 0, idx1 = 0;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YUVPacked = _yuyv.read(i * width + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);

            VITIS_LOOP_1999_1: for (int k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1;
                 k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 Ybuf[(k << 1)] = YUVbuf[(k << 2)];
                Ybuf[(k << 1) + 1] = YUVbuf[(k << 2) + 2];
                if (evenRow) {
                    UVbuf[(k << 1) + 1] = YUVbuf[(k << 2) + 1];
                    UVbuf[(k << 1)] = YUVbuf[(k << 2) + 3];
                }
            }
            YPacked = PackPixels<WORDWIDTH_Y>(Ybuf);
            y_plane.write(idx++, YPacked);
            if (evenRow) {
                UVPacked = PackPixels<WORDWIDTH_UV>(UVbuf);
                uv_plane.write(idx1++, UVPacked);
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void KernYuyv2Iyuv_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _yuyv,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y,
                      xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u,
                      xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v,
                      uint16_t height,
                      uint16_t width) {
    uint16_t i, j, k, l;
    ap_uint8_t Ybuf[16], Ubuf[16], Vbuf[16], YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=Ubuf complete
#pragma HLS ARRAY_PARTITION variable=Vbuf complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete

 unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    typename StreamType<WORDWIDTH_DST>::name YPacked0, UPacked, VPacked;
    uint8_t offset;
    bool evenRow = true, evenBlock = true;
    offset = (1 << xfNPixelsPerCycle<NPC>::datashift) >> 1;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YUVPacked = _yuyv.read(i * width + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);
            VITIS_LOOP_2058_1: for (int k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 Ybuf[(k << 1)] = YUVbuf[(k << 2)];
                Ybuf[(k << 1) + 1] = YUVbuf[(k << 2) + 2];
                if (evenRow) {
                    if (evenBlock) {
                        Ubuf[k] = YUVbuf[(k << 2) + 1];
                        Vbuf[k] = YUVbuf[(k << 2) + 3];
                    } else {
                        Ubuf[k + offset] = YUVbuf[(k << 2) + 1];
                        Vbuf[k + offset] = YUVbuf[(k << 2) + 3];
                    }
                }
            }
            YPacked0 = PackPixels<WORDWIDTH_DST>(Ybuf);
            _y.write(idx++, YPacked0);
            if (evenRow & !evenBlock) {
                UPacked = PackPixels<WORDWIDTH_DST>(Ubuf);
                VPacked = PackPixels<WORDWIDTH_DST>(Vbuf);
                _u.write(idx1, UPacked);
                _v.write(idx1++, VPacked);
            }
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
}


template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void KernUyvy2Iyuv_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _uyvy,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& y_plane,
                      xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& u_plane,
                      xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& v_plane,
                      uint16_t height,
                      uint16_t width) {
    ap_uint8_t Ybuf[16], Ubuf[16], Vbuf[16], YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=Ubuf complete
#pragma HLS ARRAY_PARTITION variable=Vbuf complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete


 typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    typename StreamType<WORDWIDTH_DST>::name YPacked0, UPacked, VPacked;
    uint8_t offset;
    unsigned long long int idx = 0, idx1 = 0;
    bool evenRow = true, evenBlock = true;

    offset = (1 << xfNPixelsPerCycle<NPC>::datashift) >> 1;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YUVPacked = _uyvy.read(i * width + j);

            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);
            VITIS_LOOP_2127_1: for (int k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 Ybuf[(k << 1)] = YUVbuf[(k << 2) + 1];
                Ybuf[(k << 1) + 1] = YUVbuf[(k << 2) + 3];
                if (evenRow) {
                    if (evenBlock) {
                        Ubuf[k] = YUVbuf[(k << 2)];
                        Vbuf[k] = YUVbuf[(k << 2) + 2];
                    } else {
                        Ubuf[k + offset] = YUVbuf[(k << 2)];
                        Vbuf[k + offset] = YUVbuf[(k << 2) + 2];
                    }
                }
            }
            YPacked0 = PackPixels<WORDWIDTH_DST>(Ybuf);
            y_plane.write(idx1++, YPacked0);
            if (evenRow & !evenBlock) {
                UPacked = PackPixels<WORDWIDTH_DST>(Ubuf);
                VPacked = PackPixels<WORDWIDTH_DST>(Vbuf);
                u_plane.write(idx, UPacked);
                v_plane.write(idx++, VPacked);
            }
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
}


template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC,
          int iTC>
void KernUyvy2Nv12_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _uyvy,
                      xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                      xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                      uint16_t height,
                      uint16_t width) {
    ap_uint8_t Ybuf[16], UVbuf[16], YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=UVbuf complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete

 typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    typename StreamType<WORDWIDTH_Y>::name YPacked, UVPacked;
    unsigned long long int idx = 0, idx1 = 0;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YUVPacked = _uyvy.read(i * width + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);

            VITIS_LOOP_2201_1: for (int k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 Ybuf[(k << 1)] = YUVbuf[(k << 2) + 1];
                Ybuf[(k << 1) + 1] = YUVbuf[(k << 2) + 3];
                if (evenRow) {
                    UVbuf[(k << 1)] = YUVbuf[(k << 2)];
                    UVbuf[(k << 1) + 1] = YUVbuf[(k << 2) + 2];
                }
            }
            YPacked = PackPixels<WORDWIDTH_Y>(Ybuf);
            y_plane.write(idx++, YPacked);
            if (evenRow) {
                UVPacked = PackPixels<WORDWIDTH_Y>(UVbuf);
                uv_plane.write(idx1++, UVPacked);
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int TC,
          int iTC>
void KernUyvy2Nv21_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _uyvy,
                      xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                      xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                      uint16_t height,
                      uint16_t width) {
    ap_uint8_t Ybuf[16], UVbuf[16], YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=Ybuf complete
#pragma HLS ARRAY_PARTITION variable=UVbuf complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete

 typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    typename StreamType<WORDWIDTH_Y>::name YPacked, UVPacked;
    unsigned long long int idx = 0, idx1 = 0;
    bool evenRow = true;
rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 YUVPacked = _uyvy.read(i * width + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);

            VITIS_LOOP_2266_1: for (int k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 Ybuf[(k << 1)] = YUVbuf[(k << 2) + 1];
                Ybuf[(k << 1) + 1] = YUVbuf[(k << 2) + 3];
                if (evenRow) {
                    UVbuf[(k << 1)] = YUVbuf[(k << 2) + 2];
                    UVbuf[(k << 1) + 1] = YUVbuf[(k << 2)];
                }
            }
            YPacked = PackPixels<WORDWIDTH_Y>(Ybuf);
            y_plane.write(idx++, YPacked);
            if (evenRow) {
                UVPacked = PackPixels<WORDWIDTH_Y>(UVbuf);
                uv_plane.write(idx1++, UVPacked);
            }
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void KernUyvy2Rgb_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy,
                     xf::cv::Mat<DST_T, ROWS, COLS, NPC>& rgba,
                     uint16_t height,
                     uint16_t width) {
    uint16_t i, j, k;
    typename PixelType<XF_8UP>::name RGB[64], YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete


 typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t U, V;
    unsigned long long int idx = 0, out_idx = 0;
rowloop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 columnloop:
        for (j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline

 YUVPacked = uyvy.read(idx++);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);
            VITIS_LOOP_2321_1: for (k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 U = YUVbuf[(k << 2)] - 128;

                if (YUVbuf[(k << 2) + 1] > 16) {
                    Y00 = (YUVbuf[(k << 2) + 1] - 16);
                } else {
                    Y00 = 0;
                }
                V = YUVbuf[(k << 2) + 2] - 128;

                if ((YUVbuf[(k << 2) + 3] > 16)) {
                    Y01 = (YUVbuf[(k << 2) + 3] - 16);
                } else {
                    Y01 = 0;
                }

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;

                RGB[(k * 6)] = CalculateR(Y00, V2Rtemp, V);
                RGB[(k * 6) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                RGB[(k * 6) + 2] = CalculateB(Y00, U2Btemp, U);
                RGB[(k * 6) + 3] = CalculateR(Y01, V2Rtemp, V);
                RGB[(k * 6) + 4] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                RGB[(k * 6) + 5] = CalculateB(Y01, U2Btemp, U);
            }
            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            rgba.write(out_idx++, PackedPixels);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void KernUyvy2bgr_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy,
                     xf::cv::Mat<DST_T, ROWS, COLS, NPC>& rgba,
                     uint16_t height,
                     uint16_t width) {
    uint16_t i, j, k;
    typename PixelType<XF_8UP>::name RGB[64], YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete


 typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t U, V;
    unsigned long long int idx = 0, out_idx = 0;
rowloop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 columnloop:
        for (j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline

 YUVPacked = uyvy.read(idx++);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);
            VITIS_LOOP_2391_1: for (k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 U = YUVbuf[(k << 2)] - 128;

                if (YUVbuf[(k << 2) + 1] > 16) {
                    Y00 = (YUVbuf[(k << 2) + 1] - 16);
                } else {
                    Y00 = 0;
                }
                V = YUVbuf[(k << 2) + 2] - 128;

                if ((YUVbuf[(k << 2) + 3] > 16)) {
                    Y01 = (YUVbuf[(k << 2) + 3] - 16);
                } else {
                    Y01 = 0;
                }

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;

                RGB[(k * 6)] = CalculateB(Y00, U2Btemp, U);
                RGB[(k * 6) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                RGB[(k * 6) + 2] = CalculateR(Y00, V2Rtemp, V);
                RGB[(k * 6) + 3] = CalculateB(Y01, U2Btemp, U);
                RGB[(k * 6) + 4] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                RGB[(k * 6) + 5] = CalculateR(Y01, V2Rtemp, V);
            }
            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            rgba.write(out_idx++, PackedPixels);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void KernUyvy2Rgba_ro(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy,
                      xf::cv::Mat<DST_T, ROWS, COLS, NPC>& rgba,
                      uint16_t height,
                      uint16_t width) {
    uint16_t i, j, k;
    typename PixelType<XF_8UP>::name RGB[64], YUVbuf[32];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=YUVbuf complete


 typename StreamType<WORDWIDTH_DST>::name PackedPixels;
    typename StreamType<WORDWIDTH_SRC>::name YUVPacked;
    uint8_t Y00, Y01;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t U, V;
    unsigned long long int idx = 0, out_idx = 0;
rowloop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 columnloop:
        for (j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline

 YUVPacked = uyvy.read(idx++);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YUVPacked, YUVbuf);
            VITIS_LOOP_2461_1: for (k = 0; k<(1 << xfNPixelsPerCycle<NPC>::datashift)>> 1; k++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 U = YUVbuf[(k << 2)] - 128;

                if (YUVbuf[(k << 2) + 1] > 16) {
                    Y00 = (YUVbuf[(k << 2) + 1] - 16);
                } else {
                    Y00 = 0;
                }
                V = YUVbuf[(k << 2) + 2] - 128;

                if ((YUVbuf[(k << 2) + 3] > 16)) {
                    Y01 = (YUVbuf[(k << 2) + 3] - 16);
                } else {
                    Y01 = 0;
                }

                V2Rtemp = V * (short int)19530;
                U2Gtemp = (short int)52723 * U;
                V2Gtemp = (short int)38895 * V;
                U2Btemp = U * (short int)590;

                RGB[(k << 3)] = CalculateR(Y00, V2Rtemp, V);
                RGB[(k << 3) + 1] = CalculateG(Y00, U2Gtemp, V2Gtemp);
                RGB[(k << 3) + 2] = CalculateB(Y00, U2Btemp, U);
                RGB[(k << 3) + 3] = 255;
                RGB[(k << 3) + 4] = CalculateR(Y01, V2Rtemp, V);
                RGB[(k << 3) + 5] = CalculateG(Y01, U2Gtemp, V2Gtemp);
                RGB[(k << 3) + 6] = CalculateB(Y01, U2Btemp, U);
                RGB[(k << 3) + 7] = 255;
            }
            PackedPixels = PackRGBAPixels<WORDWIDTH_DST>(RGB);
            rgba.write(out_idx++, PackedPixels);
        }
    }
}





template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFRgba2Yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _u_image,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _v_image,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    if (NPC == 1) {
        KernRgba2Yuv4<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST>(_src, _y_image, _u_image, _v_image,
                                                                                   height, width);
    } else {
        KernRgba2Yuv4_ro<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_DST,
                         (COLS >> xfNPixelsPerCycle<NPC>::datashift), ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(_src, _y_image, _u_image, _v_image,
                                                                                     height, width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void rgba2yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _u_image,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 2541 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFRgba2Yuv4<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(
        _src, _y_image, _u_image, _v_image, _src.rows, _src.cols);
}



template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int ROWS_U,
          int ROWS_V>
void KernRgb2Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _rgba,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y,
                  xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u,
                  xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v,
                  uint16_t height,
                  uint16_t width) {
    ap_uint<24> rgba;
    uint8_t y, u, v;
    bool evenRow = true, evenBlock = true;
    unsigned long long int idx = 0, idx1 = 0;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 rgba = _rgba.read(i * width + j);
            uint8_t r = rgba.range(7, 0);
            uint8_t g = rgba.range(15, 8);
            uint8_t b = rgba.range(23, 16);

            y = CalculateY(r, g, b);
            if (evenRow) {
                if (evenBlock) {
                    u = CalculateU(r, g, b);
                    v = CalculateV(r, g, b);
                }
            }
            _y.write(idx++, y);
            if (evenRow & !evenBlock) {
                _u.write(idx1, u);
                _v.write(idx1++, v);
            }
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
}

template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int ROWS_U,
          int ROWS_V>
void xFRgb2Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
                xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u_image,
                xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v_image,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == XF_NPPC1) {
        KernRgb2Iyuv<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ROWS_U, ROWS_V>(
            _src, _y_image, _u_image, _v_image, height, width);

    } else {
        KernRgba2Iyuv_ro<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_DST, ROWS_U,
                         ROWS_V, (COLS >> xfNPixelsPerCycle<NPC>::datashift), ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(_src, _y_image, _u_image,
                                                                                             _v_image, height, width);
    }
}
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 0>
void rgb2iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
              xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u_image,
              xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 2647 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFRgb2Iyuv<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth, ROWS / 4, ROWS / 4>(
        _src, _y_image, _u_image, _v_image, _src.rows, _src.cols);
}



template <int SRC_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int ROWS_U,
          int ROWS_V>
void xFRgba2Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u_image,
                 xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v_image,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    if (NPC == XF_NPPC1) {
        KernRgba2Iyuv<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ROWS_U, ROWS_V>(
            _src, _y_image, _u_image, _v_image, height, width);

    } else {
        KernRgba2Iyuv_ro<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_DST, ROWS_U,
                         ROWS_V, (COLS >> xfNPixelsPerCycle<NPC>::datashift), ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(_src, _y_image, _u_image,
                                                                                             _v_image, height, width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 0>
void rgba2iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u_image,
               xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 2701 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFRgba2Iyuv<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth, ROWS / 4, ROWS / 4>(
        _src, _y_image, _u_image, _v_image, _src.rows, _src.cols);
}




template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFRgba2Nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernRgba2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV>(
            _src, _y, _uv, height, width);

    } else {
        KernRgba2Nv21_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_Y,
                         WORDWIDTH_UV, (COLS >> xfNPixelsPerCycle<NPC>::datashift), (1 << (xfNPixelsPerCycle<NPC>::datashift + 1))>(_src, _y, _uv, height,
                                                                                                  width);
    }
}

template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void rgba2nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv) {

#pragma HLS INLINE OFF
# 2760 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFRgba2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
                DataType<UV_T, NPC_UV>::wordwidth>(_src, _y, _uv, _src.rows, _src.cols);
}
template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFRgba2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernRgba2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV>(
            _src, _y, _uv, height, width);
    } else {
        KernRgba2Nv12_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_Y,
                         WORDWIDTH_UV, (COLS >> xfNPixelsPerCycle<NPC>::datashift), (1 << (xfNPixelsPerCycle<NPC>::datashift + 1))>(_src, _y, _uv, height,
                                                                                                  width);
    }
}
template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void rgba2nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv) {

#pragma HLS INLINE OFF
# 2813 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFRgba2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
                DataType<UV_T, NPC_UV>::wordwidth>(_src, _y, _uv, _src.rows, _src.cols);
}


template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFIyuv2Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_u,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_v,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if ((NPC == XF_NPPC8)) {
        KernIyuv2Rgba_ro<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift),
                         (1 << (xfNPixelsPerCycle<NPC>::datashift + 1))>(src_y, src_u, src_v, _dst0, height, width);
    } else {
        KernIyuv2Rgba<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(
            src_y, src_u, src_v, _dst0, height, width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void iyuv2rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_u,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_v,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0) {

#pragma HLS INLINE OFF
# 2854 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFIyuv2Rgba<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(
        src_y, src_u, src_v, _dst0, src_y.rows, src_y.cols);
}


template <int SRC_T, int ROWS, int COLS, int NPC, int WORDWIDTH>
void xFIyuv2Yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_u,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_v,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u_image,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v_image,
                 uint16_t height,
                 uint16_t width) {
    if (NPC == XF_NPPC8) {

#pragma HLS DATAFLOW

 KernIyuv2Yuv4_ro<SRC_T, ROWS, COLS, NPC, WORDWIDTH, (ROWS << 1), ((COLS >> xfNPixelsPerCycle<NPC>::datashift) >> 1),
                         ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_u, src_v, _u_image, _v_image, height, width);
        write_y_ro<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src_y, _y_image, height,
                                                                                         width);
    } else if (NPC == XF_NPPC1) {

#pragma HLS DATAFLOW

 KernIyuv2Yuv4<SRC_T, ROWS, COLS, NPC, WORDWIDTH, (ROWS >> 1), ((COLS >> xfNPixelsPerCycle<NPC>::datashift) >> 1)>(
            src_u, src_v, _u_image, _v_image, height, width);
        write_y<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH, (COLS >> xfNPixelsPerCycle<NPC>::datashift), ROWS>(src_y, _y_image, height,
                                                                                            width);
    }
}

template <int SRC_T, int ROWS, int COLS, int NPC = 1>
void iyuv2yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_u,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_v,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u_image,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 2909 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFIyuv2Yuv4<SRC_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth>(src_y, src_u, src_v, _y_image, _u_image, _v_image,
                                                                  src_y.rows, src_y.cols);
}

template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_SRC, int WORDWIDTH_UV>
void xFIyuv2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_u,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_v,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv_image,
                 uint16_t height,
                 uint16_t width) {
    if (NPC == XF_NPPC8) {

#pragma HLS DATAFLOW

 KernIyuv2Nv12_ro<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_UV, (ROWS >> 1),
                         ((COLS >> xfNPixelsPerCycle<NPC>::datashift) >> 1), ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_u, src_v, _uv_image,
                                                                                            height, width);
        write_y_ro<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_SRC, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src_y, _y_image, height,
                                                                                             width);
    } else {

#pragma HLS DATAFLOW

 KernIyuv2Nv12<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_UV, (ROWS >> 1),
                      ((COLS >> xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_u, src_v, _uv_image, height, width);

        write_y<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_SRC, (COLS >> xfNPixelsPerCycle<NPC>::datashift), (ROWS >> 1)>(src_y, _y_image,
                                                                                                       height, width);
    }
}

template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void iyuv2nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_u,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_v,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv_image) {

#pragma HLS INLINE OFF
# 2971 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFIyuv2Nv12<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<UV_T, NPC_UV>::wordwidth>(
        src_y, src_u, src_v, _y_image, _uv_image, src_y.rows, src_y.cols);
}



template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFNv122Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u_image,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v_image,
                 uint16_t height,
                 uint16_t width) {
    if (NPC == XF_NPPC8) {

#pragma HLS DATAFLOW

 KernNv122Iyuv_ro<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_DST,
                         ((COLS >> xfNPixelsPerCycle<NPC>::datashift) >> 1), ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 2)>(src_uv, _u_image, _v_image,
                                                                                            height, width);
        write_y_ro<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src_y, _y_image, height,
                                                                                             width);

    } else {

#pragma HLS DATAFLOW

 KernNv122Iyuv<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_DST,
                      ((COLS >> xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_uv, _u_image, _v_image, height, width);
        write_y<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift), (ROWS >> xfNPixelsPerCycle<NPC>::datashift)>(
            src_y, _y_image, height, width);
    }
}


template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv122iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u_image,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 3037 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFNv122Iyuv<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<UV_T, NPC_UV>::wordwidth, DataType<SRC_T, NPC>::wordwidth>(
        src_y, src_uv, _y_image, _u_image, _v_image, src_y.rows, src_y.cols);
}
template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST>
void xFNv122Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernNv122Rgba<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_Y, WORDWIDTH_UV, WORDWIDTH_DST>(
            src_y, src_uv, _dst0, height, width);
    } else {
        KernNv122Rgba_ro<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<DST_T, NPC>::channel, DataType<SRC_T, NPC>::wordwidth,
                         DataType<UV_T, NPC_UV>::wordwidth, DataType<DST_T, NPC>::wordwidth, (COLS >> xfNPixelsPerCycle<NPC>::datashift),
                         ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_y, src_uv, _dst0, height, width);
    }
}

template <int SRC_T, int UV_T, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv122rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0) {

#pragma HLS INLINE OFF
# 3092 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFNv122Rgba<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<UV_T, NPC_UV>::wordwidth,
                DataType<DST_T, NPC>::wordwidth>(src_y, src_uv, _dst0, src_y.rows, src_y.cols);
}
template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_UV, int WORDWIDTH_DST>
void xFNv122Yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u_image,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v_image,
                 uint16_t height,
                 uint16_t width) {






    if (NPC == XF_NPPC8) {

#pragma HLS DATAFLOW

 KernNv122Yuv4_ro<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_UV, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift),
                         ((1 << (xfNPixelsPerCycle<NPC>::datashift)) >> 1)>(src_uv, _u_image, _v_image, height, width);
        write_y_ro<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src_y, _y_image, height,
                                                                                             width);
    } else {

#pragma HLS DATAFLOW

 KernNv122Yuv4<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_UV, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(
            src_uv, _u_image, _v_image, height, width);
        write_y<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift), ROWS>(src_y, _y_image, height,
                                                                                                width);
    }
}


template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv122yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u_image,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF

 xFNv122Yuv4<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<UV_T, NPC_UV>::wordwidth, DataType<SRC_T, NPC>::wordwidth>(
        src_y, src_uv, _y_image, _u_image, _v_image, src_y.rows, src_y.cols);
}
template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFNv212Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u_image,
                 xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v_image,
                 uint16_t height,
                 uint16_t width) {
    if (NPC == XF_NPPC8) {

#pragma HLS DATAFLOW

 KernNv212Iyuv_ro<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_DST,
                         ((COLS >> xfNPixelsPerCycle<NPC>::datashift) >> 1), ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 2)>(src_uv, _u_image, _v_image,
                                                                                            height, width);
        write_y_ro<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src_y, _y_image, height,
                                                                                             width);

    } else {

#pragma HLS DATAFLOW

 KernNv212Iyuv<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_DST,
                      ((COLS >> xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_uv, _u_image, _v_image, height, width);
        write_y<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift), ROWS>(src_y, _y_image, height,
                                                                                                width);
    }
}



template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv212iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u_image,
               xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 3203 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFNv212Iyuv<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<UV_T, NPC_UV>::wordwidth, DataType<SRC_T, NPC>::wordwidth>(
        src_y, src_uv, _y_image, _u_image, _v_image, src_y.rows, src_y.cols);
}

template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST>
void xFNv212Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernNv212Rgba<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_Y, WORDWIDTH_UV, WORDWIDTH_DST>(
            src_y, src_uv, _dst0, height, width);
    } else {
        KernNv212Rgba_ro<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<DST_T, NPC>::channel, DataType<SRC_T, NPC>::wordwidth,
                         DataType<UV_T, NPC_UV>::wordwidth, DataType<DST_T, NPC>::wordwidth, (COLS >> xfNPixelsPerCycle<NPC>::datashift),
                         ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_y, src_uv, _dst0, height, width);
    }
}


template <int SRC_T, int UV_T, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv212rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0) {

#pragma HLS INLINE OFF
# 3259 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFNv212Rgba<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<DST_T, NPC>::wordwidth, DataType<UV_T, NPC_UV>::wordwidth,
                DataType<DST_T, NPC>::wordwidth>(src_y, src_uv, _dst0, src_y.rows, src_y.cols);
}

template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_UV, int WORDWIDTH_DST>
void xFNv212Yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u_image,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v_image,
                 uint16_t height,
                 uint16_t width) {
    if (NPC == XF_NPPC8) {

#pragma HLS DATAFLOW

 KernNv212Yuv4_ro<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_UV, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift),
                         ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_uv, _u_image, _v_image, height, width);
        write_y_ro<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src_y, _y_image, height,
                                                                                             width);

    } else {

#pragma HLS DATAFLOW

 KernNv212Yuv4<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_UV, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(
            src_uv, _u_image, _v_image, height, width);
        write_y<SRC_T, SRC_T, ROWS, COLS, NPC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift), ROWS>(src_y, _y_image, height,
                                                                                                width);
    }
}


template <int SRC_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv212yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _u_image,
               xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 3319 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFNv212Yuv4<SRC_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<UV_T, NPC_UV>::wordwidth, DataType<SRC_T, NPC>::wordwidth>(
        src_y, src_uv, _y_image, _u_image, _v_image, src_y.rows, src_y.cols);
}
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFUyvy2Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& y_plane,
                 xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& u_plane,
                 xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& v_plane,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == XF_NPPC8) {
        KernUyvy2Iyuv_ro<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift),
                         ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(uyvy, y_plane, u_plane, v_plane, height, width);
    } else {
        KernUyvy2Iyuv<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(
            uyvy, y_plane, u_plane, v_plane, height, width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void uyvy2iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u_image,
               xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 3358 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFUyvy2Iyuv<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(
        _src, _y_image, _u_image, _v_image, _src.rows, _src.cols);
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFUyvy2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy,
                 xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                 uint16_t height,
                 uint16_t width) {







    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    if (NPC == XF_NPPC1) {

#pragma HLS DATAFLOW

 KernUyvy2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV,
                      ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(uyvy, y_plane, uv_plane, height, width);
    } else {
        KernUyvy2Nv12_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV,
                         ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift), ((1 << NPC) >> 1)>(uyvy, y_plane, uv_plane, height, width);
    }
}

template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void uyvy2nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv_image) {

#pragma HLS INLINE OFF
# 3427 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFUyvy2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
                DataType<UV_T, NPC_UV>::wordwidth>(_src, _y_image, _uv_image, _src.rows, _src.cols);
}


template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFUyvy2Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    if (NPC == 1) {
        KernUyvy2Rgba<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(
            _src, _dst, height, width);
    } else {
        KernUyvy2Rgba_ro<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift),
                         (1 << xfNPixelsPerCycle<NPC>::datashift >> 1)>(_src, _dst, height, width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void uyvy2rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xFUyvy2Rgba<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(
        _src, _dst, _src.rows, _src.cols);
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFYuyv2Iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u_image,
                 xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v_image,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    if (NPC == XF_NPPC8) {
        KernYuyv2Iyuv_ro<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift),
                         ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(_src, _y_image, _u_image, _v_image, height, width);
    } else {
        KernYuyv2Iyuv<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(
            _src, _y_image, _u_image, _v_image, height, width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void yuyv2iyuv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _u_image,
               xf::cv::Mat<DST_T, ROWS / 4, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 3500 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFYuyv2Iyuv<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(
        _src, _y_image, _u_image, _v_image, _src.rows, _src.cols);
}


template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFYuyv2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv_image,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == XF_NPPC1) {
        KernYuyv2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV,
                      ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(_src, _y_image, _uv_image, height, width);
    } else {
        KernYuyv2Nv12_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV,
                         ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift), ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(_src, _y_image, _uv_image,
                                                                                            height, width);
    }
}
template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void yuyv2nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv_image) {

#pragma HLS INLINE OFF
# 3556 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFYuyv2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
                DataType<UV_T, NPC_UV>::wordwidth>(_src, _y_image, _uv_image, _src.rows, _src.cols);
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFYuyv2Rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernYuyv2Rgba<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(
            _src, _dst, height, width);
    } else {
        KernYuyv2Rgba_ro<SRC_T, DST_T, ROWS, COLS, NPC, DataType<DST_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_DST,
                         ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift), ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(_src, _dst, height,
                                                                                               width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void yuyv2rgba(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 3590 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFYuyv2Rgba<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(
        _src, _dst, _src.rows, _src.cols);
}

template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFRgb2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernRgba2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV>(
            _src, _y, _uv, height, width);

    } else {
        KernRgba2Nv12_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_Y,
                         WORDWIDTH_UV, (COLS >> xfNPixelsPerCycle<NPC>::datashift), (1 << (xfNPixelsPerCycle<NPC>::datashift + 1))>(_src, _y, _uv, height,
                                                                                                  width);
    }
}
template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void rgb2nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
              xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
              xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv) {

#pragma HLS INLINE OFF

 (__builtin_assume(static_cast <bool> ((SRC_T == XF_8UC3) && " RGB image Type must be XF_8UC3")));
    (__builtin_assume(static_cast <bool> ((Y_T == XF_8UC1) && " Y image Type must be XF_8UC1")));
    (__builtin_assume(static_cast <bool> ((UV_T == XF_8UC2) && " UV image Type must be XF_8UC2")));

    (__builtin_assume(static_cast <bool> (((_src.rows <= ROWS) && (_y.cols <= COLS)) && " Y image ROWS and COLS should be less than ROWS, COLS")));
    (__builtin_assume(static_cast <bool> (((_src.cols == _y.cols) && (_src.rows == _y.rows)) && "Y and RGB plane dimensions mismatch")));
    (__builtin_assume(static_cast <bool> (((_y.cols == (_uv.cols << 1)) && (_y.rows == (_uv.rows << 1))) && "Y and UV planes dimensions mismatch")));

    if (NPC != XF_NPPC1) {
        (__builtin_assume(static_cast <bool> ((NPC == (NPC_UV * 2)) && " NPC of Y plane must be double the UV " "plane for multipixel parallelism  ")));


    } else {
        (__builtin_assume(static_cast <bool> ((NPC == NPC_UV == XF_NPPC1) && " Both NPC,NPC_UV values must be same  ")));
    }
    xFRgb2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
               DataType<UV_T, NPC_UV>::wordwidth>(_src, _y, _uv, _src.rows, _src.cols);
}
# 3692 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFRgb2Nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernRgba2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV>(
            _src, _y, _uv, height, width);
    } else {
        KernRgba2Nv21_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_Y,
                         WORDWIDTH_UV, (COLS >> xfNPixelsPerCycle<NPC>::datashift), (1 << (xfNPixelsPerCycle<NPC>::datashift + 1))>(_src, _y, _uv, height,
                                                                                                  width);
    }
}
template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void rgb2nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
              xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
              xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv) {

#pragma HLS INLINE OFF
# 3741 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFRgb2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
               DataType<UV_T, NPC_UV>::wordwidth>(_src, _y, _uv, _src.rows, _src.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void KernRgb2Yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _rgba,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _u,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _v,
                  uint16_t height,
                  uint16_t width) {
    typename StreamType<XF_32UW>::name rgba;
    uint8_t y, u, v;
    unsigned long long int idx = 0;
RowLoop:
    for (int i = 0; i < height; ++i) {

#pragma HLS LOOP_FLATTEN OFF
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; ++j) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS
#pragma HLS PIPELINE

 rgba = _rgba.read(i * width + j);

            y = CalculateY(rgba.range(7, 0), rgba.range(15, 8), rgba.range(23, 16));
            u = CalculateU(rgba.range(7, 0), rgba.range(15, 8), rgba.range(23, 16));
            v = CalculateV(rgba.range(7, 0), rgba.range(15, 8), rgba.range(23, 16));

            _y.write(idx, y);
            _u.write(idx, u);
            _v.write(idx++, v);
        }
    }
}
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFRgb2Yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _u_image,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _v_image,
                uint16_t height,
                uint16_t width) {







    width = width >> (xfNPixelsPerCycle<NPC>::datashift);
    if (NPC == 1) {
        KernRgb2Yuv4<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST>(_src, _y_image, _u_image, _v_image,
                                                                                  height, width);
    } else {
        KernRgba2Yuv4_ro<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_DST,
                         (COLS >> xfNPixelsPerCycle<NPC>::datashift), ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(_src, _y_image, _u_image, _v_image,
                                                                                     height, width);
    }
}
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void rgb2yuv4(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _y_image,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _u_image,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _v_image) {

#pragma HLS INLINE OFF
# 3824 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFRgb2Yuv4<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(
        _src, _y_image, _u_image, _v_image, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernUyvy2Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _uyvy,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                  uint16_t height,
                  uint16_t width) {
    typename StreamType<WORDWIDTH_DST>::name rgba;

    typename StreamType<WORDWIDTH_SRC>::name uyvy;

    typename StreamType<WORDWIDTH_SRC>::name uy;
    typename StreamType<WORDWIDTH_SRC>::name vy;

    unsigned long long int idx = 0;
    typename PixelType<XF_8UP>::name r, g, b;
    int8_t y1, y2, u, v;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;

RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline




 uy = _uyvy.read(i * width + j);
            vy = _uyvy.read(i * width + j + 1);

            u = (uint8_t)uy.range(7, 0) - 128;






            y1 = (uy.range(15, 8) > 16) ? ((uint8_t)uy.range(15, 8) - 16) : 0;

            v = (uint8_t)vy.range(7, 0) - 128;





            y2 = (vy.range(15, 8) > 16) ? ((uint8_t)vy.range(15, 8) - 16) : 0;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;

            r = CalculateR(y1, V2Rtemp, v);
            g = CalculateG(y1, U2Gtemp, V2Gtemp);
            b = CalculateB(y1, U2Btemp, u);

            rgba = ((ap_uint24_t)r) | ((ap_uint24_t)g << 8) | ((ap_uint24_t)b << 16);
            _rgba.write(idx, rgba);
            idx++;
            r = CalculateR(y2, V2Rtemp, v);
            g = CalculateG(y2, U2Gtemp, V2Gtemp);
            b = CalculateB(y2, U2Btemp, u);

            rgba = ((ap_uint24_t)r) | ((ap_uint24_t)g << 8) | ((ap_uint24_t)b << 16);
            _rgba.write(idx, rgba);
            idx++;
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFUyvy2Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst,
                uint16_t height,
                uint16_t width) {


    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    if (NPC == 1) {
        KernUyvy2Rgb<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(
            _src, _dst, height, width);
    } else {
        KernUyvy2Rgb_ro<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift),
                        ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(_src, _dst, height, width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void uyvy2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 3938 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFUyvy2Rgb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(_src, _dst, _src.rows,
                                                                                                  _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernYuyv2Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _yuyv,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                  uint16_t height,
                  uint16_t width) {
    typename StreamType<WORDWIDTH_DST>::name rgba;
    typename StreamType<WORDWIDTH_SRC>::name yu, yv;
    typename PixelType<XF_8UP>::name r, g, b;
    int8_t y1, y2, u, v;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    unsigned long long int idx = 0;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline


 yu = _yuyv.read(i * width + j);
            yv = _yuyv.read(i * width + j + 1);
            u = (uint8_t)yu.range(15, 8) - 128;
            y1 = (yu.range(7, 0) > 16) ? ((uint8_t)yu.range(7, 0) - 16) : 0;

            v = (uint8_t)yv.range(15, 8) - 128;
            y2 = (yv.range(7, 0) > 16) ? ((uint8_t)yv.range(7, 0) - 16) : 0;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;

            r = CalculateR(y1, V2Rtemp, v);
            g = CalculateG(y1, U2Gtemp, V2Gtemp);
            b = CalculateB(y1, U2Btemp, u);

            rgba = ((ap_uint24_t)r) | ((ap_uint24_t)g << 8) | ((ap_uint24_t)b << 16);
            _rgba.write(idx++, rgba);

            r = CalculateR(y2, V2Rtemp, v);
            g = CalculateG(y2, U2Gtemp, V2Gtemp);
            b = CalculateB(y2, U2Btemp, u);

            rgba = ((ap_uint24_t)r) | ((ap_uint24_t)g << 8) | ((ap_uint24_t)b << 16);
            _rgba.write(idx++, rgba);
        }
    }
}


template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFYuyv2Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernYuyv2Rgb<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(
            _src, _dst, height, width);
    } else {
        KernYuyv2Rgba_ro<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_DST,
                         ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift), ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(_src, _dst, height,
                                                                                               width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void yuyv2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 4029 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFYuyv2Rgb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(_src, _dst, _src.rows,
                                                                                                  _src.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernIyuv2Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y,
                  xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _u,
                  xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& _v,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                  uint16_t height,
                  uint16_t width) {
    ap_uint<13> i, j;
    hls::stream<typename StreamType<WORDWIDTH_SRC>::name> uStream, vStream;

#pragma HLS STREAM variable=&uStream depth=TC
#pragma HLS STREAM variable=&vStream depth=TC


 typename StreamType<WORDWIDTH_SRC>::name yPacked, uPacked, vPacked;
    typename StreamType<WORDWIDTH_DST>::name rgba;
    unsigned long long int idx = 0, idx1 = 0;

    uint8_t y1, y2;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t u, v;
    bool evenRow = true, evenBlock = true;
RowLoop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 yPacked = _y.read(i * width + j);



            ap_uint<xfNPixelsPerCycle<NPC>::datashift + 1> k1;
            if (evenBlock) {
                if (evenRow) {
                    uPacked = _u.read(idx);
                    uStream.write(uPacked);
                    vPacked = _v.read(idx++);
                    vStream.write(vPacked);
                } else {


                    uPacked = uStream.read();
                    vPacked = vStream.read();
                }
                k1 = 0;
            } else {
                k1 = NPC / 2;
            }

            ap_uint<xfNPixelsPerCycle<NPC>::datashift + 1> k;
            bool evenPixel = true;
            VITIS_LOOP_4094_1: for (k = 0; k < NPC; k++) {

#pragma HLS UNROLL


 y1 = (uint8_t)yPacked.range((8 * k + 7), 8 * k) > 16 ? (uint8_t)yPacked.range((8 * k + 7), 8 * k) - 16
                                                                     : 0;
                u = (uint8_t)uPacked.range((8 * k1 + 7), 8 * k1) - 128;
                v = (uint8_t)vPacked.range((8 * k1 + 7), 8 * k1) - 128;
                if (evenPixel == false) {
                    k1 = k1 + 1;
                    evenPixel = true;
                } else {
                    evenPixel = false;
                }

                V2Rtemp = v * (short int)19530;
                U2Gtemp = (short int)52723 * u;
                V2Gtemp = (short int)38895 * v;
                U2Btemp = u * (short int)590;




                rgba.range((24 * k + 7), (24 * k)) = CalculateR(y1, V2Rtemp, v);
                rgba.range((24 * k + 15), (24 * k + 8)) = CalculateG(y1, U2Gtemp, V2Gtemp);
                rgba.range((24 * k + 23), (24 * k + 16)) = CalculateB(y1, U2Btemp, u);
            }
            _rgba.write(idx1++, rgba);
            evenBlock = evenBlock ? false : true;
        }

        evenRow = evenRow ? false : true;
    }
}
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFIyuv2Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_u,
                xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_v,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    KernIyuv2Rgb<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(
        src_y, src_u, src_v, _dst0, height, width);
}
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void iyuv2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
              xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_u,
              xf::cv::Mat<SRC_T, ROWS / 4, COLS, NPC>& src_v,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0) {

#pragma HLS INLINE OFF
# 4159 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFIyuv2Rgb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(
        src_y, src_u, src_v, _dst0, src_y.rows, src_y.cols);
}




template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST>
void KernNv122bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y,
                  xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                  uint16_t height,
                  uint16_t width) {
    unsigned long long int idx = 0, idx1 = 0;
    hls::stream<typename StreamType<WORDWIDTH_UV>::name> uvStream;

#pragma HLS STREAM variable=&uvStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_UV>::name uvPacked;
    typename StreamType<WORDWIDTH_DST>::name rgba;
    uint8_t y1, y2;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t u, v;
    bool evenRow = true, evenBlock = true;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 yPacked = _y.read(i * width + j);
            if (evenRow) {
                if (evenBlock) {
                    uvPacked = _uv.read(idx++);
                    uvStream.write(uvPacked);
                }
            } else {
                if (evenBlock) {
                    uvPacked = uvStream.read();
                }
            }


            uint8_t t = yPacked.range(7, 0);
            y1 = t > 16 ? t - 16 : 0;
            v = (uint8_t)uvPacked.range(15, 8) - 128;
            u = (uint8_t)uvPacked.range(7, 0) - 128;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;




            rgba.range(23, 16) = CalculateR(y1, V2Rtemp, v);
            rgba.range(15, 8) = CalculateG(y1, U2Gtemp, V2Gtemp);
            rgba.range(7, 0) = CalculateB(y1, U2Btemp, u);



            _rgba.write(idx1++, rgba);
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_4244_1: for (int i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 uvStream.read();
        }
    }
}
template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST>
void xFNv122bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernNv122bgr<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_Y, WORDWIDTH_UV, WORDWIDTH_DST>(
            src_y, src_uv, _dst0, height, width);
    } else {
        KernNv122bgr_ro<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<DST_T, NPC>::channel, DataType<SRC_T, NPC>::wordwidth,
                        DataType<UV_T, NPC_UV>::wordwidth, DataType<DST_T, NPC>::wordwidth, (COLS >> xfNPixelsPerCycle<NPC>::datashift),
                        ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_y, src_uv, _dst0, height, width);
    }
}

template <int SRC_T, int UV_T, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv122bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
              xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0) {

#pragma HLS INLINE OFF
# 4302 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFNv122bgr<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<UV_T, NPC_UV>::wordwidth,
               DataType<DST_T, NPC>::wordwidth>(src_y, src_uv, _dst0, src_y.rows, src_y.cols);
}




template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST>
void KernNv122Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y,
                  xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                  uint16_t height,
                  uint16_t width) {
    unsigned long long int idx = 0, idx1 = 0;
    hls::stream<typename StreamType<WORDWIDTH_UV>::name> uvStream;

#pragma HLS STREAM variable=&uvStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_UV>::name uvPacked;
    typename StreamType<WORDWIDTH_DST>::name rgba;
    uint8_t y1, y2;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t u, v;
    bool evenRow = true, evenBlock = true;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 yPacked = _y.read(i * width + j);
            if (evenRow) {
                if (evenBlock) {
                    uvPacked = _uv.read(idx++);
                    uvStream.write(uvPacked);
                }
            } else {
                if (evenBlock) {
                    uvPacked = uvStream.read();
                }
            }


            uint8_t t = yPacked.range(7, 0);
            y1 = t > 16 ? t - 16 : 0;
            v = (uint8_t)uvPacked.range(15, 8) - 128;
            u = (uint8_t)uvPacked.range(7, 0) - 128;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;




            rgba.range(7, 0) = CalculateR(y1, V2Rtemp, v);
            rgba.range(15, 8) = CalculateG(y1, U2Gtemp, V2Gtemp);
            rgba.range(23, 16) = CalculateB(y1, U2Btemp, u);



            _rgba.write(idx1++, rgba);
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_4387_1: for (int i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 uvStream.read();
        }
    }
}
template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST>
void xFNv122Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernNv122Rgb<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_Y, WORDWIDTH_UV, WORDWIDTH_DST>(
            src_y, src_uv, _dst0, height, width);
    } else {
        KernNv122Rgba_ro<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<DST_T, NPC>::channel, DataType<SRC_T, NPC>::wordwidth,
                         DataType<UV_T, NPC_UV>::wordwidth, DataType<DST_T, NPC>::wordwidth, (COLS >> xfNPixelsPerCycle<NPC>::datashift),
                         ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_y, src_uv, _dst0, height, width);
    }
}

template <int SRC_T, int UV_T, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv122rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
              xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0) {

#pragma HLS INLINE OFF
# 4445 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFNv122Rgb<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<UV_T, NPC_UV>::wordwidth,
               DataType<DST_T, NPC>::wordwidth>(src_y, src_uv, _dst0, src_y.rows, src_y.cols);
}



template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_VU,
          int WORDWIDTH_DST>
void KernNv212Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y,
                  xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _vu,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                  uint16_t height,
                  uint16_t width) {
    hls::stream<typename StreamType<WORDWIDTH_VU>::name> vuStream;

#pragma HLS STREAM variable=&vuStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_VU>::name vuPacked;
    unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_DST>::name rgba;
    ap_uint<13> i, j;
    uint8_t y1, y2;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t u, v;
    bool evenRow = true, evenBlock = true;
RowLoop:
    for (i = 0; i < (height); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 yPacked = _y.read(i * width + j);


            if (evenRow) {
                if (evenBlock) {
                    vuPacked = _vu.read(idx++);
                    vuStream.write(vuPacked);
                }
            } else {
                if (evenBlock) {
                    vuPacked = vuStream.read();
                }
            }


            uint8_t t = yPacked.range(7, 0);
            y1 = t > 16 ? t - 16 : 0;
            u = (uint8_t)vuPacked.range(15, 8) - 128;
            v = (uint8_t)vuPacked.range(7, 0) - 128;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;




            rgba.range(7, 0) = CalculateR(y1, V2Rtemp, v);
            rgba.range(15, 8) = CalculateG(y1, U2Gtemp, V2Gtemp);
            rgba.range(23, 16) = CalculateB(y1, U2Btemp, u);



            _rgba.write(idx1++, rgba);
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_4532_1: for (i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 vuStream.read();
        }
    }
}
template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST>
void xFNv212Rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernNv212Rgb<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_Y, WORDWIDTH_UV, WORDWIDTH_DST>(
            src_y, src_uv, _dst0, height, width);
    } else {
        KernNv212Rgba_ro<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<DST_T, NPC>::channel, DataType<SRC_T, NPC>::wordwidth,
                         DataType<UV_T, NPC_UV>::wordwidth, DataType<DST_T, NPC>::wordwidth, (COLS >> xfNPixelsPerCycle<NPC>::datashift),
                         ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_y, src_uv, _dst0, height, width);
    }
}
template <int SRC_T, int UV_T, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv212rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
              xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0) {

#pragma HLS INLINE OFF
# 4589 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFNv212Rgb<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<UV_T, NPC>::wordwidth,
               DataType<DST_T, NPC>::wordwidth>(src_y, src_uv, _dst0, src_y.rows, src_y.cols);
}



template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int PLANES,
          int WORDWIDTH_Y,
          int WORDWIDTH_VU,
          int WORDWIDTH_DST>
void KernNv212bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _y,
                  xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _vu,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                  uint16_t height,
                  uint16_t width) {
    hls::stream<typename StreamType<WORDWIDTH_VU>::name> vuStream;

#pragma HLS STREAM variable=&vuStream depth=COLS

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_VU>::name vuPacked;
    unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_DST>::name rgba;
    ap_uint<13> i, j;
    uint8_t y1, y2;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    int8_t u, v;
    bool evenRow = true, evenBlock = true;
RowLoop:
    for (i = 0; i < (height); i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 yPacked = _y.read(i * width + j);


            if (evenRow) {
                if (evenBlock) {
                    vuPacked = _vu.read(idx++);
                    vuStream.write(vuPacked);
                }
            } else {
                if (evenBlock) {
                    vuPacked = vuStream.read();
                }
            }


            uint8_t t = yPacked.range(7, 0);
            y1 = t > 16 ? t - 16 : 0;
            u = (uint8_t)vuPacked.range(15, 8) - 128;
            v = (uint8_t)vuPacked.range(7, 0) - 128;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;




            rgba.range(23, 16) = CalculateR(y1, V2Rtemp, v);
            rgba.range(15, 8) = CalculateG(y1, U2Gtemp, V2Gtemp);
            rgba.range(7, 0) = CalculateB(y1, U2Btemp, u);



            _rgba.write(idx1++, rgba);
            evenBlock = evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_4677_1: for (i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 vuStream.read();
        }
    }
}
template <int SRC_T,
          int UV_T,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST>
void xFNv212bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
                xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernNv212bgr<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<DST_T, NPC>::channel, WORDWIDTH_Y, WORDWIDTH_UV,
                     WORDWIDTH_DST>(src_y, src_uv, _dst0, height, width);
    } else {
        KernNv212bgr_ro<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<DST_T, NPC>::channel, DataType<SRC_T, NPC>::wordwidth,
                        DataType<UV_T, NPC_UV>::wordwidth, DataType<DST_T, NPC>::wordwidth, (COLS >> xfNPixelsPerCycle<NPC>::datashift),
                        ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(src_y, src_uv, _dst0, height, width);
    }
}

template <int SRC_T, int UV_T, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv212bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src_y,
              xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& src_uv,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst0) {

#pragma HLS INLINE OFF
# 4735 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFNv212bgr<SRC_T, UV_T, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<UV_T, NPC_UV>::wordwidth,
               DataType<DST_T, NPC>::wordwidth>(src_y, src_uv, _dst0, src_y.rows, src_y.cols);
}






template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfrgb2gray(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                unsigned short int height,
                unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname RGB[DataType<SRC_T, NPC>::channel * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete


 typename DataType<SRC_T, NPC>::name RGB_packed;
    typename DataType<DST_T, NPC>::cname GRAY[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<DST_T, NPC>::name Gray_packed;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 RGB_packed = src.read(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(RGB_packed, RGB);
            VITIS_LOOP_4772_1: for (ap_uint<13> k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {

#pragma HLS UNROLL

 GRAY[k] = CalculateGRAY(RGB[offset], RGB[offset + 1], RGB[offset + 2]);
                Gray_packed.range((k * DataType<DST_T, NPC>::bitdepth + (DataType<DST_T, NPC>::bitdepth - 1)),
                                  k * DataType<DST_T, NPC>::bitdepth) = GRAY[k];
            }
            dst.write((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j, Gray_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void rgb2gray(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfrgb2gray<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
               (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfbgr2gray(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                unsigned short int height,
                unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname RGB[DataType<SRC_T, NPC>::channel * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete


 typename DataType<SRC_T, NPC>::name RGB_packed;
    typename DataType<DST_T, NPC>::cname GRAY[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<DST_T, NPC>::name Gray_packed;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 RGB_packed = src.read(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(RGB_packed, RGB);
            VITIS_LOOP_4832_1: for (ap_uint<13> k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {

#pragma HLS UNROLL

 GRAY[k] = CalculateGRAY(RGB[offset + 2], RGB[offset + 1], RGB[offset]);
                Gray_packed.range((k * DataType<DST_T, NPC>::bitdepth + (DataType<DST_T, NPC>::bitdepth - 1)),
                                  k * DataType<DST_T, NPC>::bitdepth) = GRAY[k];
            }
            dst.write((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j, Gray_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void bgr2gray(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfbgr2gray<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
               (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfgray2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                unsigned short int height,
                unsigned short int width) {
    typename DataType<DST_T, NPC>::uname RGB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<DST_T, NPC>::name RGB_packed;
    typename DataType<SRC_T, NPC>::name GRAY_packed;
    typename DataType<SRC_T, NPC>::name GRAY[xfNPixelsPerCycle<NPC>::nppc];
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:

        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 GRAY_packed = src.read(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j);

            VITIS_LOOP_4889_1: for (int k = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++) {

#pragma HLS UNROLL

 GRAY[k] = GRAY_packed.range(k * (DataType<SRC_T, NPC>::pixelwidth) + DataType<SRC_T, NPC>::pixelwidth - 1,
                                            k * DataType<SRC_T, NPC>::pixelwidth);
                RGB[k].range(7, 0) = GRAY[k];
                RGB[k].range(15, 8) = GRAY[k];
                RGB[k].range(23, 16) = GRAY[k];
                RGB_packed.range(k * (DataType<DST_T, NPC>::pixelwidth) + DataType<DST_T, NPC>::pixelwidth - 1,
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }

            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void gray2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfgray2rgb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
               (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfgray2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                unsigned short int height,
                unsigned short int width) {
    typename DataType<DST_T, NPC>::uname RGB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<DST_T, NPC>::name RGB_packed;
    typename DataType<SRC_T, NPC>::name GRAY_packed;
    typename DataType<SRC_T, NPC>::name GRAY[xfNPixelsPerCycle<NPC>::nppc];
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:

        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 GRAY_packed = src.read(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j);

            VITIS_LOOP_4950_1: for (int k = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++) {

#pragma HLS UNROLL

 GRAY[k] = GRAY_packed.range(k * (DataType<SRC_T, NPC>::pixelwidth) + DataType<SRC_T, NPC>::pixelwidth - 1,
                                            k * DataType<SRC_T, NPC>::pixelwidth);
                RGB[k].range(7, 0) = GRAY[k];
                RGB[k].range(15, 8) = GRAY[k];
                RGB[k].range(23, 16) = GRAY[k];
                RGB_packed.range(k * (DataType<DST_T, NPC>::pixelwidth) + DataType<DST_T, NPC>::pixelwidth - 1,
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }

            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void gray2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfgray2bgr<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
               (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfrgb2xyz(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    ap_uint<8> RGB[3];

#pragma HLS ARRAY_PARTITION variable=RGB complete


 typename DataType<SRC_T, NPC>::name RGB_packed = 0;
    typename DataType<DST_T, NPC>::name XYZ_packed = 0;
    typename DataType<DST_T, NPC>::uname XYZ[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<DST_T, NPC>::name X, Y, Z;
    short int depth = DataType<DST_T, NPC>::pixelwidth / DataType<SRC_T, NPC>::channel;
    int k = 0;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j<width>> xfNPixelsPerCycle<NPC>::datashift; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 RGB_packed = src.read((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(RGB_packed, RGB);

            VITIS_LOOP_5018_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {

#pragma HLS UNROLL

 X = Calculate_X(RGB[offset], RGB[offset + 1], RGB[offset + 2]);
                Y = Calculate_Y(RGB[offset], RGB[offset + 1], RGB[offset + 2]);
                Z = Calculate_Z(RGB[offset], RGB[offset + 1], RGB[offset + 2]);

                XYZ[k].range((DataType<DST_T, NPC>::bitdepth - 1), 0) = X;
                XYZ[k].range((DataType<DST_T, NPC>::bitdepth * 2) - 1, DataType<DST_T, NPC>::bitdepth) = Y;
                XYZ[k].range((DataType<DST_T, NPC>::bitdepth * 3) - 1, DataType<DST_T, NPC>::bitdepth * 2) = Z;
                XYZ_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = XYZ[k];
            }

            dst.write((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j, XYZ_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void rgb2xyz(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfrgb2xyz<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfbgr2xyz(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname RGB[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete


 typename DataType<SRC_T, NPC>::name RGB_packed = 0;
    typename DataType<DST_T, NPC>::name XYZ_packed = 0;
    typename DataType<DST_T, NPC>::uname XYZ[xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=XYZ complete


 typename DataType<DST_T, NPC>::name X, Y, Z;
    short int depth = DataType<DST_T, NPC>::pixelwidth / DataType<SRC_T, NPC>::channel;
    int k = 0;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j<width>> xfNPixelsPerCycle<NPC>::datashift; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC


 RGB_packed = src.read((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j);
            ExtractUYVYPixels<SRC_T, NPC, WORDWIDTH_SRC>(RGB_packed, RGB);

            VITIS_LOOP_5092_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {

#pragma HLS UNROLL


 X = _Calculate_X(RGB[offset + 2], RGB[offset + 1], RGB[offset]);
                Y = _Calculate_Y(RGB[offset + 2], RGB[offset + 1], RGB[offset]);
                Z = _Calculate_Z(RGB[offset + 2], RGB[offset + 1], RGB[offset]);

                XYZ[k].range((DataType<DST_T, NPC>::bitdepth - 1), 0) = X;
                XYZ[k].range((DataType<DST_T, NPC>::bitdepth * 2) - 1, DataType<DST_T, NPC>::bitdepth) = Y;
                XYZ[k].range((DataType<DST_T, NPC>::bitdepth * 3) - 1, DataType<DST_T, NPC>::bitdepth * 2) = Z;
                XYZ_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = XYZ[k];
            }

            dst.write((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j, XYZ_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void bgr2xyz(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfbgr2xyz<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (COLS >> (xfNPixelsPerCycle<NPC>::nppc))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfxyz2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname XYZ[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=XYZ complete


 typename DataType<DST_T, NPC>::name RGB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<DST_T, NPC>::name XYZ_packed = 0, RGB_packed = 0;
    typename DataType<DST_T, NPC>::name R, G, B;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 XYZ_packed = src.read((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(XYZ_packed, XYZ);

            VITIS_LOOP_5159_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {

#pragma HLS UNROLL

 R = Calculate_R(XYZ[offset], XYZ[offset + 1], XYZ[offset + 2]);
                G = Calculate_G(XYZ[offset], XYZ[offset + 1], XYZ[offset + 2]);
                B = Calculate_B(XYZ[offset], XYZ[offset + 1], XYZ[offset + 2]);

                RGB[k].range((DataType<DST_T, NPC>::bitdepth - 1), 0) = R;
                RGB[k].range((DataType<DST_T, NPC>::bitdepth * 2) - 1, DataType<DST_T, NPC>::bitdepth) = G;
                RGB[k].range((DataType<DST_T, NPC>::bitdepth * 3) - 1, DataType<DST_T, NPC>::bitdepth * 2) = B;
                RGB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }
            dst.write((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void xyz2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfxyz2rgb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfxyz2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname XYZ[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=XYZ complete


 typename DataType<DST_T, NPC>::name RGB[xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete


 typename DataType<DST_T, NPC>::name XYZ_packed = 0, RGB_packed = 0;
    typename DataType<DST_T, NPC>::name R, G, B;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 XYZ_packed = src.read((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(XYZ_packed, XYZ);

            VITIS_LOOP_5228_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {

#pragma HLS UNROLL

 R = Calculate_R(XYZ[offset], XYZ[offset + 1], XYZ[offset + 2]);
                G = Calculate_G(XYZ[offset], XYZ[offset + 1], XYZ[offset + 2]);
                B = Calculate_B(XYZ[offset], XYZ[offset + 1], XYZ[offset + 2]);

                RGB[k].range((DataType<DST_T, NPC>::bitdepth - 1), 0) = B;
                RGB[k].range((DataType<DST_T, NPC>::bitdepth * 2) - 1, DataType<DST_T, NPC>::bitdepth) = G;
                RGB[k].range((DataType<DST_T, NPC>::bitdepth * 3) - 1, DataType<DST_T, NPC>::bitdepth * 2) = R;
                RGB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }
            dst.write((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void xyz2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfxyz2bgr<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (COLS >> (xfNPixelsPerCycle<NPC>::nppc))>(_src, _dst, _src.rows, _src.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfrgb2ycrcb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                 unsigned short int height,
                 unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname RGB[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete

 typename DataType<DST_T, NPC>::uname YCRCB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<SRC_T, NPC>::name RGB_packed = 0;

    typename DataType<DST_T, NPC>::name YCRCB_packed = 0;
    typename DataType<DST_T, NPC>::name Y, CR, CB;

rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j<width>> xfNPixelsPerCycle<NPC>::datashift; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 RGB_packed = src.read((i * width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(RGB_packed, RGB);
            VITIS_LOOP_5296_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                Y = CalculateGRAY(RGB[offset], RGB[offset + 1], RGB[offset + 2]);
                CR = Calculate_CR(RGB[offset], Y);
                CB = Calculate_CB(RGB[offset + 2], Y);

                YCRCB[k].range((DataType<DST_T, NPC>::bitdepth - 1), 0) = Y;
                YCRCB[k].range((DataType<DST_T, NPC>::bitdepth * 2) - 1, DataType<DST_T, NPC>::bitdepth) = CR;
                YCRCB[k].range((DataType<DST_T, NPC>::bitdepth * 3) - 1, DataType<DST_T, NPC>::bitdepth * 2) = CB;
                YCRCB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                   k * DataType<DST_T, NPC>::pixelwidth) = YCRCB[k];
            }

            dst.write((i * width >> xfNPixelsPerCycle<NPC>::datashift) + j, YCRCB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void rgb2ycrcb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfrgb2ycrcb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
                (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfbgr2ycrcb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                 unsigned short int height,
                 unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname RGB[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete

 typename DataType<DST_T, NPC>::uname YCRCB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<SRC_T, NPC>::name RGB_packed = 0;

    typename DataType<DST_T, NPC>::name YCRCB_packed = 0;
    typename DataType<DST_T, NPC>::name Y, CR, CB;

rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 RGB_packed = src.read((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(RGB_packed, RGB);
            VITIS_LOOP_5361_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                Y = CalculateGRAY(RGB[offset + 2], RGB[offset + 1], RGB[offset]);
                CR = Calculate_CR(RGB[offset + 2], Y);
                CB = Calculate_CB(RGB[offset], Y);

                YCRCB[k].range((DataType<DST_T, NPC>::bitdepth - 1), 0) = Y;
                YCRCB[k].range((DataType<DST_T, NPC>::bitdepth * 2) - 1, DataType<DST_T, NPC>::bitdepth) = CR;
                YCRCB[k].range((DataType<DST_T, NPC>::bitdepth * 3) - 1, DataType<DST_T, NPC>::bitdepth * 2) = CB;
                YCRCB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                   k * DataType<DST_T, NPC>::pixelwidth) = YCRCB[k];
            }

            dst.write((i * width >> xfNPixelsPerCycle<NPC>::datashift) + j, YCRCB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void bgr2ycrcb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfbgr2ycrcb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
                (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfycrcb2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                 unsigned short int height,
                 unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname YCRCB[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=YCRCB complete


 typename DataType<SRC_T, NPC>::name YCRCB_packed = 0;
    typename DataType<DST_T, NPC>::name RGB_packed = 0;
    typename DataType<DST_T, NPC>::name RGB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<DST_T, NPC>::name Y, R, B, G;

rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 YCRCB_packed = src.read((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YCRCB_packed, YCRCB);

            VITIS_LOOP_5427_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                R = Calculate_Ycrcb2R(YCRCB[offset], YCRCB[offset + 1]);
                G = Calculate_Ycrcb2G(YCRCB[offset], YCRCB[offset + 1], YCRCB[offset + 2]);
                B = Calculate_Ycrcb2B(YCRCB[offset], YCRCB[offset + 2]);
                RGB[k].range((DataType<DST_T, NPC>::bitdepth - 1), 0) = R;
                RGB[k].range((DataType<DST_T, NPC>::bitdepth * 2) - 1, DataType<DST_T, NPC>::bitdepth) = G;
                RGB[k].range((DataType<DST_T, NPC>::bitdepth * 3) - 1, DataType<DST_T, NPC>::bitdepth * 2) = B;
                RGB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }
            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void ycrcb2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfycrcb2rgb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
                (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfycrcb2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                 unsigned short int height,
                 unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname YCRCB[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=YCRCB complete


 typename DataType<SRC_T, NPC>::name YCRCB_packed = 0;
    typename DataType<DST_T, NPC>::name RGB_packed = 0;
    typename DataType<DST_T, NPC>::name RGB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<DST_T, NPC>::name Y, R, B, G;

rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 YCRCB_packed = src.read((i * (width >> xfNPixelsPerCycle<NPC>::datashift)) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(YCRCB_packed, YCRCB);

            VITIS_LOOP_5491_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                R = Calculate_Ycrcb2R(YCRCB[offset], YCRCB[offset + 1]);
                G = Calculate_Ycrcb2G(YCRCB[offset], YCRCB[offset + 1], YCRCB[offset + 2]);
                B = Calculate_Ycrcb2B(YCRCB[offset], YCRCB[offset + 2]);
                RGB[k].range((DataType<DST_T, NPC>::bitdepth - 1), 0) = B;
                RGB[k].range((DataType<DST_T, NPC>::bitdepth * 2) - 1, DataType<DST_T, NPC>::bitdepth) = G;
                RGB[k].range((DataType<DST_T, NPC>::bitdepth * 3) - 1, DataType<DST_T, NPC>::bitdepth * 2) = R;
                RGB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }
            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void ycrcb2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfycrcb2bgr<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
                (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfrgb2hls(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname RGB[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete


 typename DataType<SRC_T, NPC>::name RGB_packed = 0;
    typename DataType<DST_T, NPC>::name HSV_packed = 0;
    typename DataType<DST_T, NPC>::name HSV[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<SRC_T, NPC>::cname r, g, b;
    typename DataType<SRC_T, NPC>::cname Vmax, Vmin;

    int consta;
    int sub;
    int two_L = 0;
    int inv_sub = 0;
    int less_if = 0;
    short int depth = DataType<DST_T, NPC>::pixelwidth / DataType<SRC_T, NPC>::channel;
    int inv_add = 0;
    int S = 0;
    int k = 0;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 RGB_packed = src.read((i * width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(RGB_packed, RGB);
            VITIS_LOOP_5564_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                r = RGB[offset], g = RGB[offset + 1], b = RGB[offset + 2];
                Vmax = b;
                Vmin = b;

                if ((g > r) && (g > b)) {
                    Vmax = g;
                } else if ((r > b)) {
                    Vmax = r;
                }
                if ((g < r) && (g < b)) {
                    Vmin = g;
                } else if ((r < b)) {
                    Vmin = r;
                }

                short int v_add = (Vmax + Vmin);
                short int v_sub = (Vmax - Vmin);
                two_L = (Vmax + Vmin);
                if (v_add == 0) {
                    v_add = 1;
                }
                if (v_sub == 0) {
                    v_sub = 1;
                }
                int h = 0;
                if (two_L < 255) {
                    inv_add = ((255 << 12) / (v_add));
                    less_if = (v_sub * inv_add + (1 << (11))) >> 12;
                    S = less_if;
                } else {
                    if (Vmax == Vmin) {
                        S = 0;

                    } else {
                        int inv_sub = ((255 << 12) / ((2 * 255) - v_add));
                        int less_if = (v_sub * inv_sub + (1 << (11))) >> 12;
                        S = less_if;
                    }
                }
                sub = (Vmax == b) ? (r - g) : (Vmax == g) ? (b - r) : (g - b);
                consta = (Vmax == b) ? 240 : (Vmax == g) ? 120 : 0;
                if (Vmax == Vmin) {
                    h = 0;

                } else {
                    inv_sub = ((1 << 15) / (v_sub));
                    h = consta + ((60 * sub * inv_sub) >> 15);

                    if (h < 0) {
                        h += 360;
                    }
                }

                HSV[k].range(7, 0) = (h >> 1);
                HSV[k].range(15, 8) = (unsigned char)((two_L + 1) >> 1);
                HSV[k].range(23, 16) = S;
                HSV_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = HSV[k];
            }

            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, HSV_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void rgb2hls(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfrgb2hls<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfbgr2hls(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname RGB[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete


 typename DataType<SRC_T, NPC>::name RGB_packed = 0;
    typename DataType<DST_T, NPC>::name HSV_packed = 0;
    typename DataType<DST_T, NPC>::name HSV[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<SRC_T, NPC>::cname r, g, b;
    typename DataType<SRC_T, NPC>::cname Vmax, Vmin;

    int consta;
    int sub;
    int two_L = 0;
    int inv_sub = 0;
    int less_if = 0;
    short int depth = DataType<DST_T, NPC>::pixelwidth / DataType<SRC_T, NPC>::channel;
    int inv_add = 0;
    int S = 0;
    int k = 0;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 RGB_packed = src.read((i * width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(RGB_packed, RGB);
            VITIS_LOOP_5687_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                b = RGB[offset], g = RGB[offset + 1], r = RGB[offset + 2];
                Vmax = b;
                Vmin = b;

                if ((g > r) && (g > b)) {
                    Vmax = g;
                } else if ((r > b)) {
                    Vmax = r;
                }
                if ((g < r) && (g < b)) {
                    Vmin = g;
                } else if ((r < b)) {
                    Vmin = r;
                }

                short int v_add = (Vmax + Vmin);
                short int v_sub = (Vmax - Vmin);

                if (v_add == 0) {
                    v_add = 1;
                }
                if (v_sub == 0) {
                    v_sub = 1;
                }
                two_L = (Vmax + Vmin);
                int h = 0;
                if (two_L < 255) {
                    inv_add = ((255 << 12) / (v_add));
                    less_if = (v_sub * inv_add + (1 << (11))) >> 12;
                    S = less_if;
                } else {
                    if (Vmax == Vmin) {
                        S = 0;

                    } else {
                        int inv_sub = ((255 << 12) / ((2 * 255) - v_add));
                        int less_if = (v_sub * inv_sub + (1 << (11))) >> 12;
                        S = less_if;
                    }
                }
                sub = (Vmax == b) ? (r - g) : (Vmax == g) ? (b - r) : (g - b);
                consta = (Vmax == b) ? 240 : (Vmax == g) ? 120 : 0;
                if (Vmax == Vmin) {
                    h = 0;

                } else {
                    inv_sub = ((1 << 15) / (v_sub));
                    h = consta + ((60 * sub * inv_sub) >> 15);

                    if (h < 0) {
                        h += 360;
                    }
                }

                HSV[k].range(7, 0) = (h >> 1);
                HSV[k].range(15, 8) = (unsigned char)((two_L + 1) >> 1);
                HSV[k].range(23, 16) = S;
                HSV_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = HSV[k];
            }

            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, HSV_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void bgr2hls(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfbgr2hls<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfhls2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname HLS[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=HLS complete

 typename DataType<SRC_T, NPC>::uname RGB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<SRC_T, NPC>::name HLS_packed = 0;
    typename DataType<DST_T, NPC>::name RGB_packed = 0;
    short int depth = DataType<DST_T, NPC>::pixelwidth / DataType<SRC_T, NPC>::channel;
    unsigned long int r = 0;
    unsigned long int g = 0;
    unsigned long int b = 0;
    typename DataType<SRC_T, NPC>::cname H, L, S;
    ap_fixed<28, 9> tab[4];
    ap_fixed<28, 9> p1, p2;
    ap_ufixed<20, 1, AP_RND> hscale = 0.0333333333333333333;
    ap_ufixed<20, 1, AP_RND> s_scale = 0.0039215686274509803921568627451f;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 HLS_packed = src.read((i * width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(HLS_packed, HLS);

            VITIS_LOOP_5808_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                H = HLS[offset], L = HLS[offset + 1], S = HLS[offset + 2];

                if (S == 0)
                    b = g = r = L;
                else {
                    static const int sector_data[][3] = {{1, 3, 0}, {1, 0, 2}, {3, 0, 1},
                                                         {0, 2, 1}, {0, 1, 3}, {2, 1, 0}};

                    ap_fixed<28, 9> mul_scl = s_scale * S;

                    if (2 * L <= 255) {
                        p2 = L + L * mul_scl;
                    } else {
                        p2 = L + S - ((L * mul_scl));
                    }

                    p1 = 2 * L - p2;

                    unsigned char H_scl = (unsigned char)H * hscale;
                    ap_fixed<28, 9> h_fix = H * hscale - H_scl;
                    if (H_scl >= 6)
                        H_scl -= 6;

                    tab[0] = p2;
                    tab[1] = p1;
                    tab[2] = p2 - (p2 - p1) * (h_fix);
                    tab[3] = p1 + (p2 - p1) * (h_fix);

                    b = (tab[sector_data[H_scl][0]]);
                    g = (tab[sector_data[H_scl][1]]);
                    r = (tab[sector_data[H_scl][2]]);
                }
                RGB[k].range(7, 0) = (unsigned char)(r);
                RGB[k].range(15, 8) = (unsigned char)(g);
                RGB[k].range(23, 16) = (unsigned char)(b);
                RGB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }
            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void hls2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfhls2rgb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfhls2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname HLS[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=HLS complete

 typename DataType<SRC_T, NPC>::uname RGB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<SRC_T, NPC>::name HLS_packed = 0;
    typename DataType<DST_T, NPC>::name RGB_packed = 0;
    short int depth = DataType<DST_T, NPC>::pixelwidth / DataType<SRC_T, NPC>::channel;
    unsigned long int r = 0;
    unsigned long int g = 0;
    unsigned long int b = 0;
    typename DataType<SRC_T, NPC>::cname H, L, S;
    ap_fixed<28, 9> tab[4];
    ap_fixed<28, 9> p1, p2;
    ap_ufixed<20, 1, AP_RND> hscale = 0.0333333333333333333;
    ap_ufixed<20, 1, AP_RND> s_scale = 0.0039215686274509803921568627451f;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 HLS_packed = src.read((i * width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(HLS_packed, HLS);

            VITIS_LOOP_5906_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                H = HLS[offset], L = HLS[offset + 1], S = HLS[offset + 2];

                if (S == 0)
                    b = g = r = L;
                else {
                    static const int sector_data[][3] = {{1, 3, 0}, {1, 0, 2}, {3, 0, 1},
                                                         {0, 2, 1}, {0, 1, 3}, {2, 1, 0}};

                    ap_fixed<28, 9> mul_scl = s_scale * S;

                    if (2 * L <= 255) {
                        p2 = L + L * mul_scl;
                    } else {
                        p2 = L + S - ((L * mul_scl));
                    }

                    p1 = 2 * L - p2;

                    unsigned char H_scl = (unsigned char)H * hscale;
                    ap_fixed<28, 9> h_fix = H * hscale - H_scl;
                    if (H_scl >= 6)
                        H_scl -= 6;

                    tab[0] = p2;
                    tab[1] = p1;
                    tab[2] = p2 - (p2 - p1) * (h_fix);
                    tab[3] = p1 + (p2 - p1) * (h_fix);

                    b = (tab[sector_data[H_scl][0]]);
                    g = (tab[sector_data[H_scl][1]]);
                    r = (tab[sector_data[H_scl][2]]);
                }
                RGB[k].range(7, 0) = (unsigned char)(b);
                RGB[k].range(15, 8) = (unsigned char)(g);
                RGB[k].range(23, 16) = (unsigned char)(r);
                RGB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }
            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void hls2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfhls2bgr<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfhsv2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname HSV[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=HSV complete

 typename DataType<DST_T, NPC>::uname RGB[xfNPixelsPerCycle<NPC>::nppc];
    typename DataType<SRC_T, NPC>::name HSV_packed = 0;
    typename DataType<DST_T, NPC>::name RGB_packed = 0;
    typename DataType<SRC_T, NPC>::cname H, S, V;
    unsigned long int r = 0;
    unsigned long int g = 0;
    unsigned long int b = 0;
    ap_fixed<28, 9> tab[4];
    ap_fixed<28, 9> p1, p2;
    ap_ufixed<20, 1, AP_RND> hscale = 0.0333333333333333333;
    ap_ufixed<20, 1, AP_RND> s_scale = 0.0039215686274509803921568627451;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j<width>> xfNPixelsPerCycle<NPC>::datashift; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 HSV_packed = src.read((i * width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(HSV_packed, HSV);

            VITIS_LOOP_6003_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                H = HSV[offset], S = HSV[offset + 1], V = HSV[offset + 2];

                static const int sector_data[][3] = {{1, 3, 0}, {1, 0, 2}, {3, 0, 1}, {0, 2, 1}, {0, 1, 3}, {2, 1, 0}};

                ap_fixed<28, 9> mul_scl = s_scale * S;

                unsigned char H_scl = (unsigned char)H * hscale;
                ap_fixed<28, 9> h_fix = H * hscale - H_scl;
                if (H_scl >= 6)
                    H_scl -= 6;

                tab[0] = V;
                tab[1] = V * (1 - mul_scl);
                tab[2] = V * (1 - mul_scl * h_fix);
                tab[3] = V * (1 - mul_scl + mul_scl * h_fix);

                b = (tab[sector_data[H_scl][0]]);

                g = (tab[sector_data[H_scl][1]]);
                r = (tab[sector_data[H_scl][2]]);
                RGB[k].range(7, 0) = (unsigned char)(r);
                RGB[k].range(15, 8) = (unsigned char)(g);
                RGB[k].range(23, 16) = (unsigned char)(b);
                RGB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }

            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void hsv2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF








 xfhsv2rgb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfhsv2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    typename DataType<SRC_T, NPC>::cname HSV[3 * xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=HSV complete

 typename DataType<DST_T, NPC>::uname RGB[xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete

 typename DataType<SRC_T, NPC>::name HSV_packed = 0;
    typename DataType<DST_T, NPC>::name RGB_packed = 0;
    typename DataType<SRC_T, NPC>::cname H, S, V;
    unsigned long int r = 0;
    unsigned long int g = 0;
    unsigned long int b = 0;
    ap_fixed<28, 9> tab[4];

#pragma HLS ARRAY_PARTITION variable=tab complete

 ap_fixed<28, 9> p1, p2;
    ap_ufixed<20, 1, AP_RND> hscale = 0.0333333333333333333;
    ap_ufixed<20, 1, AP_RND> s_scale = 0.0039215686274509803921568627451;
rowloop:
    for (ap_uint<13> i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (ap_uint<13> j = 0; j<width>> xfNPixelsPerCycle<NPC>::datashift; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 HSV_packed = src.read((i * width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            ExtractUYVYPixels<WORDWIDTH_SRC>(HSV_packed, HSV);

            VITIS_LOOP_6095_1: for (int k = 0, offset = 0; k < xfNPixelsPerCycle<NPC>::nppc; k++, offset += 3) {
                H = HSV[offset], S = HSV[offset + 1], V = HSV[offset + 2];

                static const int sector_data[][3] = {{1, 3, 0}, {1, 0, 2}, {3, 0, 1}, {0, 2, 1}, {0, 1, 3}, {2, 1, 0}};

                ap_fixed<28, 9> mul_scl = s_scale * S;

                unsigned char H_scl = (unsigned char)H * hscale;
                ap_fixed<28, 9> h_fix = H * hscale - H_scl;
                if (H_scl >= 6)
                    H_scl -= 6;

                tab[0] = V;
                tab[1] = V * (1 - mul_scl);
                tab[2] = V * (1 - mul_scl * h_fix);
                tab[3] = V * (1 - mul_scl + mul_scl * h_fix);

                b = (tab[sector_data[H_scl][0]]);

                g = (tab[sector_data[H_scl][1]]);
                r = (tab[sector_data[H_scl][2]]);
                RGB[k].range(7, 0) = (unsigned char)(b);
                RGB[k].range(15, 8) = (unsigned char)(g);
                RGB[k].range(23, 16) = (unsigned char)(r);
                RGB_packed.range(k * DataType<DST_T, NPC>::pixelwidth + (DataType<DST_T, NPC>::pixelwidth - 1),
                                 k * DataType<DST_T, NPC>::pixelwidth) = RGB[k];
            }

            dst.write(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j, RGB_packed);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void hsv2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 6141 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfhsv2bgr<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_src, _dst, _src.rows, _src.cols);
}


template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void xfrgb2uyvy(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                unsigned short int height,
                unsigned short int width) {

    typename PixelType<XF_8UP>::name Y[xfNPixelsPerCycle<NPC>::nppc];
    typename PixelType<XF_8UP>::name U[xfNPixelsPerCycle<NPC>::nppc];
    typename PixelType<XF_8UP>::name V[xfNPixelsPerCycle<NPC>::nppc];

    ap_uint<24> RGB1[xfNPixelsPerCycle<NPC>::nppc];


#pragma HLS ARRAY_PARTITION variable=Y complete
#pragma HLS ARRAY_PARTITION variable=U complete
#pragma HLS ARRAY_PARTITION variable=V complete
#pragma HLS ARRAY_PARTITION variable=RGB1 complete


 unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_SRC>::name Packed_rgb1;
    typename PixelType<DataType<DST_T, NPC>::pixeldepth>::name
    UYPacked, VYPacked, packed_uyvy[xfNPixelsPerCycle<NPC>::nppc];
    typename StreamType<WORDWIDTH_DST>::name val_dst = 0;
    uint8_t offset = 0;
    uint16_t shift = 0;
    bool evencol = true;

rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 evencol = true;

    columnloop:
        for (int j = 0; j < (width >> (xfNPixelsPerCycle<NPC>::datashift)); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 val_dst = 0;

            Packed_rgb1 = src.read(idx++);
            xfExtractPixels<NPC, DataType<SRC_T, NPC>::wordwidth, DataType<SRC_T, NPC>::pixeldepth>(RGB1, Packed_rgb1, 0);
            shift = 0;
            VITIS_LOOP_6193_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll






 Y[l] = CalculateY(RGB1[l].range(7, 0), RGB1[l].range(15, 8), RGB1[l].range(23, 16));
                if (evencol) {
                    U[l / 2] = CalculateU(RGB1[l].range(7, 0), RGB1[l].range(15, 8), RGB1[l].range(23, 16));
                    V[l / 2] = CalculateV(RGB1[l].range(7, 0), RGB1[l].range(15, 8), RGB1[l].range(23, 16));
# 6215 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
                    UYPacked.range(7, 0) = U[l / 2];
                    UYPacked.range(15, 8) = Y[l];
                    packed_uyvy[l] = UYPacked;
                } else {
                    VYPacked.range(7, 0) = V[l / 2];
                    VYPacked.range(15, 8) = Y[l];
                    packed_uyvy[l] = VYPacked;
                }

                xfPackPixels<NPC, DataType<DST_T, NPC>::wordwidth, DataType<DST_T, NPC>::pixeldepth>(&packed_uyvy[l], val_dst, 0, 1,
                                                                                  shift);

                evencol = evencol ? false : true;
            }
            dst.write(idx1++, val_dst);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void rgb2uyvy(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 6248 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfrgb2uyvy<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
               (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc))), xfNPixelsPerCycle<NPC>::nppc>(_src, _dst, _src.rows, _src.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void xfrgb2yuyv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                unsigned short int height,
                unsigned short int width) {

    typename PixelType<XF_8UP>::name Y[xfNPixelsPerCycle<NPC>::nppc];
    typename PixelType<XF_8UP>::name U[xfNPixelsPerCycle<NPC>::nppc];
    typename PixelType<XF_8UP>::name V[xfNPixelsPerCycle<NPC>::nppc];

    ap_uint<24> RGB1[xfNPixelsPerCycle<NPC>::nppc];


#pragma HLS ARRAY_PARTITION variable=Y complete
#pragma HLS ARRAY_PARTITION variable=U complete
#pragma HLS ARRAY_PARTITION variable=V complete
#pragma HLS ARRAY_PARTITION variable=RGB1 complete


 unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_SRC>::name Packed_rgb1;
    typename PixelType<DataType<DST_T, NPC>::pixeldepth>::name
    YUPacked, YVPacked, packed_yuyv[xfNPixelsPerCycle<NPC>::nppc];
    typename StreamType<WORDWIDTH_DST>::name val_dst = 0;
    uint8_t offset = 0;
    uint16_t shift = 0;
    bool evencol = true;

rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 evencol = true;

    columnloop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 val_dst = 0;
            Packed_rgb1 = src.read(idx++);
            xfExtractPixels<NPC, DataType<SRC_T, NPC>::wordwidth, DataType<SRC_T, NPC>::pixeldepth>(RGB1, Packed_rgb1, 0);
            shift = 0;
            VITIS_LOOP_6301_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll


 Y[l] = CalculateY(RGB1[l].range(7, 0), RGB1[l].range(15, 8), RGB1[l].range(23, 16));
                if (evencol) {
                    U[l / 2] = CalculateU(RGB1[l].range(7, 0), RGB1[l].range(15, 8), RGB1[l].range(23, 16));
                    V[l / 2] = CalculateV(RGB1[l].range(7, 0), RGB1[l].range(15, 8), RGB1[l].range(23, 16));
                    YUPacked.range(7, 0) = Y[l];
                    YUPacked.range(15, 8) = U[l / 2];
                    packed_yuyv[l] = YUPacked;
                } else {
                    YVPacked.range(7, 0) = Y[l];
                    YVPacked.range(15, 8) = V[l / 2];
                    packed_yuyv[l] = YVPacked;
                }
                xfPackPixels<NPC, DataType<DST_T, NPC>::wordwidth, DataType<DST_T, NPC>::pixeldepth>(&packed_yuyv[l], val_dst, 0, 1,
                                                                                  shift);

                evencol = evencol ? false : true;
            }
            dst.write(idx1++, val_dst);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void rgb2yuyv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 6343 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfrgb2yuyv<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
               (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc))), xfNPixelsPerCycle<NPC>::nppc>(_src, _dst, _src.rows, _src.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void xfrgb2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    ap_uint<24> RGB[xfNPixelsPerCycle<NPC>::nppc], BGR[xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=BGR complete


 unsigned long long int idx = 0, idx1 = 0;
    typename DataType<SRC_T, NPC>::name Packed_rgb1;
    typename DataType<DST_T, NPC>::name val_dst = 0;
    uint8_t offset = 0;
    uint16_t shift = 0;

rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 val_dst = 0;
            Packed_rgb1 = src.read(idx++);
            VITIS_LOOP_6381_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 RGB[l] = Packed_rgb1(l * 24 + 23, l * 24);
                BGR[l].range(23, 16) = RGB[l].range(7, 0);
                BGR[l].range(15, 8) = RGB[l].range(15, 8);
                BGR[l].range(7, 0) = RGB[l].range(23, 16);
                val_dst.range(l * 24 + 23, l * 24) = BGR[l];
            }
            dst.write(idx1++, val_dst);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void rgb2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 6411 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfrgb2bgr<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              ((COLS >> (xfNPixelsPerCycle<NPC>::nppc))), xfNPixelsPerCycle<NPC>::nppc>(_src, _dst, _src.rows, _src.cols);
}




template <int SRC_Y,
          int SRC_UV,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST,
          int TC>
void xfnv122uyvy(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
                 xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                 unsigned short int height,
                 unsigned short int width) {

    hls::stream<typename StreamType<WORDWIDTH_UV>::name> uvStream;

#pragma HLS STREAM variable=&uvStream depth=COLS/2

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_UV>::name uvPacked;
    typename StreamType<WORDWIDTH_DST>::name uyvyPacked;
    unsigned long long int y_idx = 0, uv_idx = 0, out_idx = 0;
    uint8_t y;

    int8_t u, v;
    bool evenRow = true, evenBlock = true, evenPix = true;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 yPacked = _y.read(y_idx++);
            uyvyPacked = 0;
            if (evenRow) {
                if (evenBlock) {
                    uvPacked = _uv.read(uv_idx++);
                    uvStream.write(uvPacked);
                }
            } else {
                if (evenBlock) {
                    uvPacked = uvStream.read();
                }
            }
            VITIS_LOOP_6471_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {
                uint8_t y = yPacked.range(l * 8 + 7, l * 8 + 0);
                if (evenPix) {
                    v = (uint8_t)uvPacked.range((l / 2) * 16 + 15, (l / 2) * 16 + 8);
                    u = (uint8_t)uvPacked.range((l / 2) * 16 + 7, (l / 2) * 16 + 0);
                    uyvyPacked.range(l * 16 + 7, l * 16 + 0) = u;
                    uyvyPacked.range(l * 16 + 15, l * 16 + 8) = y;
                } else {
                    uyvyPacked.range(l * 16 + 7, l * 16 + 0) = v;
                    uyvyPacked.range(l * 16 + 15, l * 16 + 8) = y;
                }
                evenPix = evenPix ? false : true;
            }
            dst.write(out_idx++, uyvyPacked);
            evenBlock = ((xfNPixelsPerCycle<NPC>::nppc) != 1) ? true : evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_6490_2: for (int i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 uvStream.read();
        }
    }
}

template <int SRC_Y, int SRC_UV, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv122uyvy(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
               xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 6521 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfnv122uyvy<SRC_Y, SRC_UV, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_Y, NPC>::wordwidth, DataType<SRC_UV, NPC_UV>::wordwidth,
                DataType<DST_T, NPC>::wordwidth, (COLS >> (xfNPixelsPerCycle<NPC>::nppc))>(_y, _uv, _dst, _y.rows, _y.cols);
}




template <int SRC_Y,
          int SRC_UV,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST,
          int TC>
void xfnv212uyvy(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
                 xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                 unsigned short int height,
                 unsigned short int width) {

    hls::stream<typename StreamType<WORDWIDTH_UV>::name> uvStream;

#pragma HLS STREAM variable=&uvStream depth=COLS/2

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_UV>::name uvPacked;
    typename StreamType<WORDWIDTH_DST>::name uyvyPacked;
    unsigned long long int y_idx = 0, uv_idx = 0, out_idx = 0;
    uint8_t y;

    int8_t u, v;
    bool evenRow = true, evenBlock = true, evenPix = true;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 yPacked = _y.read(y_idx++);
            uyvyPacked = 0;
            if (evenRow) {
                if (evenBlock) {
                    uvPacked = _uv.read(uv_idx++);
                    uvStream.write(uvPacked);
                }
            } else {
                if (evenBlock) {
                    uvPacked = uvStream.read();
                }
            }
            VITIS_LOOP_6581_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {
                y = yPacked.range(l * 8 + 7, l * 8 + 0);
                if (evenPix) {
                    u = (uint8_t)uvPacked.range((l / 2) * 16 + 15, (l / 2) * 16 + 8);
                    v = (uint8_t)uvPacked.range((l / 2) * 16 + 7, (l / 2) * 16 + 0);
                    uyvyPacked.range(l * 16 + 7, l * 16 + 0) = u;
                    uyvyPacked.range(l * 16 + 15, l * 16 + 8) = y;
                } else {
                    uyvyPacked.range(l * 16 + 7, l * 16 + 0) = v;
                    uyvyPacked.range(l * 16 + 15, l * 16 + 8) = y;
                }
                evenPix = evenPix ? false : true;
            }
            dst.write(out_idx++, uyvyPacked);
            evenBlock = ((xfNPixelsPerCycle<NPC>::nppc) != 1) ? true : evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_6600_2: for (int i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 uvStream.read();
        }
    }
}

template <int SRC_Y, int SRC_UV, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv212uyvy(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
               xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 6631 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfnv212uyvy<SRC_Y, SRC_UV, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_Y, NPC>::wordwidth, DataType<SRC_UV, NPC_UV>::wordwidth,
                DataType<DST_T, NPC>::wordwidth, (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_y, _uv, _dst, _y.rows, _y.cols);
}



template <int SRC_Y,
          int SRC_UV,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST,
          int TC>
void xfnv122yuyv(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
                 xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                 unsigned short int height,
                 unsigned short int width) {

    hls::stream<typename StreamType<WORDWIDTH_UV>::name> uvStream;

#pragma HLS STREAM variable=&uvStream depth=COLS/2

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_UV>::name uvPacked;
    typename StreamType<WORDWIDTH_DST>::name uyvyPacked;
    unsigned long long int y_idx = 0, uv_idx = 0, out_idx = 0;
    uint8_t y;

    int8_t u, v;
    bool evenRow = true, evenBlock = true, evenPix = true;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 yPacked = _y.read(y_idx++);
            uyvyPacked = 0;
            if (evenRow) {
                if (evenBlock) {
                    uvPacked = _uv.read(uv_idx++);
                    uvStream.write(uvPacked);
                }
            } else {
                if (evenBlock) {
                    uvPacked = uvStream.read();
                }
            }
            VITIS_LOOP_6690_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {
                y = yPacked.range(l * 8 + 7, l * 8 + 0);
                if (evenPix) {
                    v = (uint8_t)uvPacked.range((l / 2) * 16 + 15, (l / 2) * 16 + 8);
                    u = (uint8_t)uvPacked.range((l / 2) * 16 + 7, (l / 2) * 16 + 0);
                    uyvyPacked.range(l * 16 + 7, l * 16 + 0) = y;
                    uyvyPacked.range(l * 16 + 15, l * 16 + 8) = u;
                } else {
                    uyvyPacked.range(l * 16 + 7, l * 16 + 0) = y;
                    uyvyPacked.range(l * 16 + 15, l * 16 + 8) = v;
                }
                evenPix = evenPix ? false : true;
            }
            dst.write(out_idx++, uyvyPacked);
            evenBlock = ((xfNPixelsPerCycle<NPC>::nppc) != 1) ? true : evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_6709_2: for (int i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 uvStream.read();
        }
    }
}

template <int SRC_Y, int SRC_UV, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv122yuyv(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
               xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 6740 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfnv122yuyv<SRC_Y, SRC_UV, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_Y, NPC>::wordwidth, DataType<SRC_UV, NPC_UV>::wordwidth,
                DataType<DST_T, NPC>::wordwidth, (COLS >> (xfNPixelsPerCycle<NPC>::nppc))>(_y, _uv, _dst, _y.rows, _y.cols);
}



template <int SRC_Y,
          int SRC_UV,
          int DST_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV,
          int WORDWIDTH_DST,
          int TC>
void xfnv212yuyv(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
                 xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                 unsigned short int height,
                 unsigned short int width) {

    hls::stream<typename StreamType<WORDWIDTH_UV>::name> uvStream;

#pragma HLS STREAM variable=&uvStream depth=COLS/2

 typename StreamType<WORDWIDTH_Y>::name yPacked;
    typename StreamType<WORDWIDTH_UV>::name uvPacked;
    typename StreamType<WORDWIDTH_DST>::name uyvyPacked;
    unsigned long long int y_idx = 0, uv_idx = 0, out_idx = 0;
    uint8_t y;

    int8_t u, v;
    bool evenRow = true, evenBlock = true, evenPix = true;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 yPacked = _y.read(y_idx++);
            uyvyPacked = 0;
            if (evenRow) {
                if (evenBlock) {
                    uvPacked = _uv.read(uv_idx++);
                    uvStream.write(uvPacked);
                }
            } else {
                if (evenBlock) {
                    uvPacked = uvStream.read();
                }
            }
            VITIS_LOOP_6799_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {
                y = yPacked.range(l * 8 + 7, l * 8 + 0);
                if (evenPix) {
                    u = (uint8_t)uvPacked.range((l / 2) * 16 + 15, (l / 2) * 16 + 8);
                    v = (uint8_t)uvPacked.range((l / 2) * 16 + 7, (l / 2) * 16 + 0);
                    uyvyPacked.range(l * 16 + 7, l * 16 + 0) = y;
                    uyvyPacked.range(l * 16 + 15, l * 16 + 8) = u;
                } else {
                    uyvyPacked.range(l * 16 + 7, l * 16 + 0) = y;
                    uyvyPacked.range(l * 16 + 15, l * 16 + 8) = v;
                }
                evenPix = evenPix ? false : true;
            }
            dst.write(out_idx++, uyvyPacked);
            evenBlock = ((xfNPixelsPerCycle<NPC>::nppc) != 1) ? true : evenBlock ? false : true;
        }
        evenRow = evenRow ? false : true;
    }
    if (height & 1) {
        VITIS_LOOP_6818_2: for (int i = 0; i < width; i++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 uvStream.read();
        }
    }
}

template <int SRC_Y, int SRC_UV, int DST_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv212yuyv(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
               xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 6849 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfnv212yuyv<SRC_Y, SRC_UV, DST_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_Y, NPC>::wordwidth, DataType<SRC_UV, NPC_UV>::wordwidth,
                DataType<DST_T, NPC>::wordwidth, (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_y, _uv, _dst, _y.rows, _y.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void xfbgr2uyvy(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                unsigned short int height,
                unsigned short int width) {

    typename PixelType<XF_8UP>::name Y[xfNPixelsPerCycle<NPC>::nppc];
    typename PixelType<XF_8UP>::name U[xfNPixelsPerCycle<NPC>::nppc];
    typename PixelType<XF_8UP>::name V[xfNPixelsPerCycle<NPC>::nppc];

    ap_uint<24> RGB1[xfNPixelsPerCycle<NPC>::nppc];


#pragma HLS ARRAY_PARTITION variable=Y complete
#pragma HLS ARRAY_PARTITION variable=U complete
#pragma HLS ARRAY_PARTITION variable=V complete
#pragma HLS ARRAY_PARTITION variable=RGB1 complete


 unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_SRC>::name Packed_rgb1;
    typename PixelType<DataType<DST_T, NPC>::pixeldepth>::name
    UYPacked, VYPacked, packed_uyvy[xfNPixelsPerCycle<NPC>::nppc];
    typename StreamType<WORDWIDTH_DST>::name val_dst = 0;
    uint8_t offset = 0;
    uint16_t shift = 0;
    bool evencol = true;

rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 evencol = true;

    columnloop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 val_dst = 0;

            Packed_rgb1 = src.read(idx++);
            xfExtractPixels<NPC, DataType<SRC_T, NPC>::wordwidth, DataType<SRC_T, NPC>::pixeldepth>(RGB1, Packed_rgb1, 0);
            shift = 0;
            VITIS_LOOP_6903_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll






 Y[l] = CalculateY(RGB1[l].range(23, 16), RGB1[l].range(15, 8), RGB1[l].range(7, 0));
                if (evencol) {
                    U[l / 2] = CalculateU(RGB1[l].range(23, 16), RGB1[l].range(15, 8), RGB1[l].range(7, 0));
                    V[l / 2] = CalculateV(RGB1[l].range(23, 16), RGB1[l].range(15, 8), RGB1[l].range(7, 0));
# 6926 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
                    UYPacked.range(7, 0) = U[l / 2];
                    UYPacked.range(15, 8) = Y[l];
                    packed_uyvy[l] = UYPacked;
                } else {
                    VYPacked.range(7, 0) = V[l / 2];
                    VYPacked.range(15, 8) = Y[l];
                    packed_uyvy[l] = VYPacked;
                }

                xfPackPixels<NPC, DataType<DST_T, NPC>::wordwidth, DataType<DST_T, NPC>::pixeldepth>(&packed_uyvy[l], val_dst, 0, 1,
                                                                                  shift);

                evencol = evencol ? false : true;
            }
            dst.write(idx1++, val_dst);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void bgr2uyvy(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 6959 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfbgr2uyvy<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
               (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc))), xfNPixelsPerCycle<NPC>::nppc>(_src, _dst, _src.rows, _src.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void xfbgr2yuyv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                unsigned short int height,
                unsigned short int width) {

    typename PixelType<XF_8UP>::name Y[xfNPixelsPerCycle<NPC>::nppc];
    typename PixelType<XF_8UP>::name U[xfNPixelsPerCycle<NPC>::nppc];
    typename PixelType<XF_8UP>::name V[xfNPixelsPerCycle<NPC>::nppc];

    ap_uint<24> RGB1[xfNPixelsPerCycle<NPC>::nppc];


#pragma HLS ARRAY_PARTITION variable=Y complete
#pragma HLS ARRAY_PARTITION variable=U complete
#pragma HLS ARRAY_PARTITION variable=V complete
#pragma HLS ARRAY_PARTITION variable=RGB1 complete


 unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_SRC>::name Packed_rgb1;
    typename PixelType<DataType<DST_T, NPC>::pixeldepth>::name
    YUPacked, YVPacked, packed_yuyv[xfNPixelsPerCycle<NPC>::nppc];
    typename StreamType<WORDWIDTH_DST>::name val_dst = 0;
    uint8_t offset = 0;
    uint16_t shift = 0;
    bool evencol = true;

rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 evencol = true;

    columnloop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 val_dst = 0;
            Packed_rgb1 = src.read(idx++);
            xfExtractPixels<NPC, DataType<SRC_T, NPC>::wordwidth, DataType<SRC_T, NPC>::pixeldepth>(RGB1, Packed_rgb1, 0);
            shift = 0;
            VITIS_LOOP_7012_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll


 Y[l] = CalculateY(RGB1[l].range(23, 16), RGB1[l].range(15, 8), RGB1[l].range(7, 0));
                if (evencol) {
                    U[l / 2] = CalculateU(RGB1[l].range(23, 16), RGB1[l].range(15, 8), RGB1[l].range(7, 0));
                    V[l / 2] = CalculateV(RGB1[l].range(23, 16), RGB1[l].range(15, 8), RGB1[l].range(7, 0));
                    YUPacked.range(7, 0) = Y[l];
                    YUPacked.range(15, 8) = U[l / 2];
                    packed_yuyv[l] = YUPacked;
                } else {
                    YVPacked.range(7, 0) = Y[l];
                    YVPacked.range(15, 8) = V[l / 2];
                    packed_yuyv[l] = YVPacked;
                }
                xfPackPixels<NPC, DataType<DST_T, NPC>::wordwidth, DataType<DST_T, NPC>::pixeldepth>(&packed_yuyv[l], val_dst, 0, 1,
                                                                                  shift);

                evencol = evencol ? false : true;
            }
            dst.write(idx1++, val_dst);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void bgr2yuyv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 7054 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfbgr2yuyv<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
               (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc))), xfNPixelsPerCycle<NPC>::nppc>(_src, _dst, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC, int iTC>
void xfbgr2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
               unsigned short int height,
               unsigned short int width) {
    ap_uint<24> RGB[xfNPixelsPerCycle<NPC>::nppc], BGR[xfNPixelsPerCycle<NPC>::nppc];

#pragma HLS ARRAY_PARTITION variable=RGB complete
#pragma HLS ARRAY_PARTITION variable=BGR complete


 unsigned long long int idx = 0, idx1 = 0;
    typename StreamType<WORDWIDTH_SRC>::name Packed_rgb1;
    typename StreamType<WORDWIDTH_DST>::name val_dst = 0;
    uint8_t offset = 0;
    uint16_t shift = 0;

rowloop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 columnloop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=TC max=TC

 val_dst = 0;
            Packed_rgb1 = src.read(idx++);
            VITIS_LOOP_7091_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {

#pragma HLS LOOP_TRIPCOUNT min=iTC max=iTC
#pragma HLS unroll

 xfExtractPixels<NPC, DataType<SRC_T, NPC>::wordwidth, DataType<SRC_T, NPC>::pixeldepth>(BGR, Packed_rgb1, 0);

                RGB[l].range(23, 16) = BGR[l].range(7, 0);
                RGB[l].range(15, 8) = BGR[l].range(15, 8);
                RGB[l].range(7, 0) = BGR[l].range(23, 16);
                val_dst.range(l * DataType<SRC_T, NPC>::pixelwidth + DataType<SRC_T, NPC>::pixelwidth - 1,
                              l * DataType<SRC_T, NPC>::pixelwidth) = RGB[l];
            }
            dst.write(idx1++, val_dst);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void bgr2rgb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 7123 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfbgr2rgb<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
              (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc))), xfNPixelsPerCycle<NPC>::nppc>(_src, _dst, _src.rows, _src.cols);
}




template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void Kernbgr2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _rgba,
                  xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                  xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                  uint16_t height,
                  uint16_t width) {
    unsigned long long int idx = 0, idx1 = 0;
    ap_uint<32> rgba;
    ap_uint<16> val1;
    uint8_t y, u, v;
    bool evenRow = true, evenBlock = true;

RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 rgba = _rgba.read(i * width + j);
            uint8_t b = rgba.range(7, 0);
            uint8_t g = rgba.range(15, 8);
            uint8_t r = rgba.range(23, 16);

            y = CalculateY(r, g, b);
            if (evenRow) {
                u = CalculateU(r, g, b);
                v = CalculateV(r, g, b);
            }
            _y.write(idx++, y);
            if (evenRow) {
                if ((j & 0x01) == 0)

                    _uv.write(idx1++, u | (uint16_t)v << 8);



            }
        }
        evenRow = evenRow ? false : true;
    }
}


template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFbgr2Nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        Kernbgr2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV>(
            _src, _y, _uv, height, width);

    } else {
        Kernbgr2Nv12_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_Y,
                        WORDWIDTH_UV, (COLS >> xfNPixelsPerCycle<NPC>::datashift), (1 << (xfNPixelsPerCycle<NPC>::datashift + 1))>(_src, _y, _uv, height,
                                                                                                 width);
    }
}
template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void bgr2nv12(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
              xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
              xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv) {

#pragma HLS INLINE OFF
# 7238 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFbgr2Nv12<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
               DataType<UV_T, NPC_UV>::wordwidth>(_src, _y, _uv, _src.rows, _src.cols);
}



template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_VU>
void Kernbgr2Nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _rgba,
                  xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                  xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _vu,
                  uint16_t height,
                  uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    typename StreamType<XF_32UW>::name rgba;
    unsigned long long int idx = 0, idx1 = 0;
    uint8_t y, u, v;
    bool evenRow = true, evenBlock = true;

RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 ColLoop:
        for (int j = 0; j < width; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS

 rgba = _rgba.read(i * width + j);
            uint8_t b = rgba.range(7, 0);
            uint8_t g = rgba.range(15, 8);
            uint8_t r = rgba.range(23, 16);

            y = CalculateY(r, g, b);
            if (evenRow) {
                u = CalculateU(r, g, b);
                v = CalculateV(r, g, b);
            }
            _y.write(idx++, y);
            if (evenRow) {
                if ((j & 0x01) == 0) _vu.write(idx1++, v | ((uint16_t)u << 8));
            }
        }
        evenRow = evenRow ? false : true;
    }
}
template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFbgr2Nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
                xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        Kernbgr2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV>(
            _src, _y, _uv, height, width);
    } else {
        Kernbgr2Nv21_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_Y,
                        WORDWIDTH_UV, (COLS >> xfNPixelsPerCycle<NPC>::datashift), (1 << (xfNPixelsPerCycle<NPC>::datashift + 1))>(_src, _y, _uv, height,
                                                                                                 width);
    }
}
template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void bgr2nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
              xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y,
              xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv) {

#pragma HLS INLINE OFF
# 7344 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFbgr2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
               DataType<UV_T, NPC_UV>::wordwidth>(_src, _y, _uv, _src.rows, _src.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernYuyv2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _yuyv,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                  uint16_t height,
                  uint16_t width) {
    typename StreamType<WORDWIDTH_DST>::name rgba;
    typename StreamType<WORDWIDTH_SRC>::name yu, yv;
    typename PixelType<XF_8UP>::name r, g, b;
    int8_t y1, y2, u, v;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;
    unsigned long long int idx = 0;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline


 yu = _yuyv.read(i * width + j);
            yv = _yuyv.read(i * width + j + 1);
            u = (uint8_t)yu.range(15, 8) - 128;
            y1 = (yu.range(7, 0) > 16) ? ((uint8_t)yu.range(7, 0) - 16) : 0;

            v = (uint8_t)yv.range(15, 8) - 128;
            y2 = (yv.range(7, 0) > 16) ? ((uint8_t)yv.range(7, 0) - 16) : 0;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;

            r = CalculateR(y1, V2Rtemp, v);
            g = CalculateG(y1, U2Gtemp, V2Gtemp);
            b = CalculateB(y1, U2Btemp, u);

            rgba = ((ap_uint24_t)b) | ((ap_uint24_t)g << 8) | ((ap_uint24_t)r << 16);
            _rgba.write(idx++, rgba);

            r = CalculateR(y2, V2Rtemp, v);
            g = CalculateG(y2, U2Gtemp, V2Gtemp);
            b = CalculateB(y2, U2Btemp, u);

            rgba = ((ap_uint24_t)b) | ((ap_uint24_t)g << 8) | ((ap_uint24_t)r << 16);
            _rgba.write(idx++, rgba);
        }
    }
}


template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFYuyv2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    if (NPC == 1) {
        KernYuyv2bgr<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(
            _src, _dst, height, width);
    } else {
        KernYuyv2bgr_ro<SRC_T, DST_T, ROWS, COLS, NPC, DataType<DST_T, NPC>::channel, WORDWIDTH_SRC, WORDWIDTH_DST,
                        ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift), ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(_src, _dst, height,
                                                                                              width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void yuyv2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 7436 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFYuyv2bgr<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(_src, _dst, _src.rows,
                                                                                                  _src.cols);
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void KernUyvy2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _uyvy,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _rgba,
                  uint16_t height,
                  uint16_t width) {
    typename StreamType<WORDWIDTH_DST>::name rgba;

    typename StreamType<WORDWIDTH_SRC>::name uyvy;

    typename StreamType<WORDWIDTH_SRC>::name uy;
    typename StreamType<WORDWIDTH_SRC>::name vy;

    unsigned long long int idx = 0;
    typename PixelType<XF_8UP>::name r, g, b;
    int8_t y1, y2, u, v;
    int32_t V2Rtemp, U2Gtemp, V2Gtemp, U2Btemp;

RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 ColLoop:
        for (int j = 0; j < width; j += 2) {

#pragma HLS LOOP_TRIPCOUNT min=TC max=TC
#pragma HLS pipeline




 uy = _uyvy.read(i * width + j);
            vy = _uyvy.read(i * width + j + 1);

            u = (uint8_t)uy.range(7, 0) - 128;






            y1 = (uy.range(15, 8) > 16) ? ((uint8_t)uy.range(15, 8) - 16) : 0;

            v = (uint8_t)vy.range(7, 0) - 128;





            y2 = (vy.range(15, 8) > 16) ? ((uint8_t)vy.range(15, 8) - 16) : 0;

            V2Rtemp = v * (short int)19530;
            U2Gtemp = (short int)52723 * u;
            V2Gtemp = (short int)38895 * v;
            U2Btemp = u * (short int)590;

            r = CalculateR(y1, V2Rtemp, v);
            g = CalculateG(y1, U2Gtemp, V2Gtemp);
            b = CalculateB(y1, U2Btemp, u);

            rgba = ((ap_uint24_t)b) | ((ap_uint24_t)g << 8) | ((ap_uint24_t)r << 16);
            _rgba.write(idx, rgba);
            idx++;
            r = CalculateR(y2, V2Rtemp, v);
            g = CalculateG(y2, U2Gtemp, V2Gtemp);
            b = CalculateB(y2, U2Btemp, u);

            rgba = ((ap_uint24_t)b) | ((ap_uint24_t)g << 8) | ((ap_uint24_t)r << 16);
            _rgba.write(idx, rgba);
            idx++;
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST>
void xFUyvy2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst,
                uint16_t height,
                uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    if (NPC == 1) {
        KernUyvy2bgr<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(
            _src, _dst, height, width);
    } else {
        KernUyvy2bgr_ro<SRC_T, DST_T, ROWS, COLS, NPC, WORDWIDTH_SRC, WORDWIDTH_DST, ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift),
                        ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(_src, _dst, height, width);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void uyvy2bgr(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS INLINE OFF
# 7546 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFUyvy2bgr<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth>(_src, _dst, _src.rows,
                                                                                                  _src.cols);
}



template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFYuyv2Nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y_image,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv_image,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    if (NPC == XF_NPPC1) {
        KernYuyv2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV,
                      ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(_src, _y_image, _uv_image, height, width);
    } else {
        KernYuyv2Nv21_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV,
                         ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift), ((1 << xfNPixelsPerCycle<NPC>::datashift) >> 1)>(_src, _y_image, _uv_image,
                                                                                            height, width);
    }
}
template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void yuyv2nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv_image) {

#pragma HLS INLINE OFF
# 7606 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFYuyv2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
                DataType<UV_T, NPC_UV>::wordwidth>(_src, _y_image, _uv_image, _src.rows, _src.cols);
}


template <int SRC_T,
          int Y_T,
          int UV_T,
          int ROWS,
          int COLS,
          int NPC,
          int NPC_UV,
          int WORDWIDTH_SRC,
          int WORDWIDTH_Y,
          int WORDWIDTH_UV>
void xFUyvy2Nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy,
                 xf::cv::Mat<Y_T, ROWS, COLS, NPC>& y_plane,
                 xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& uv_plane,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;

    if (NPC == XF_NPPC1) {

#pragma HLS DATAFLOW

 KernUyvy2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV,
                      ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift)>(uyvy, y_plane, uv_plane, height, width);
    } else {
        KernUyvy2Nv21_ro<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, WORDWIDTH_SRC, WORDWIDTH_Y, WORDWIDTH_UV,
                         ((COLS >> 1) >> xfNPixelsPerCycle<NPC>::datashift), ((1 << NPC) >> 1)>(uyvy, y_plane, uv_plane, height, width);
    }
}

template <int SRC_T, int Y_T, int UV_T, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void uyvy2nv21(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
               xf::cv::Mat<Y_T, ROWS, COLS, NPC>& _y_image,
               xf::cv::Mat<UV_T, ROWS / 2, COLS / 2, NPC_UV>& _uv_image) {

#pragma HLS INLINE OFF
# 7669 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xFUyvy2Nv21<SRC_T, Y_T, UV_T, ROWS, COLS, NPC, NPC_UV, DataType<SRC_T, NPC>::wordwidth, DataType<Y_T, NPC>::wordwidth,
                DataType<UV_T, NPC_UV>::wordwidth>(_src, _y_image, _uv_image, _src.rows, _src.cols);
}

template <int SRC_Y, int SRC_UV, int ROWS, int COLS, int NPC, int NPC_UV, int WORDWIDTH_Y, int WORDWIDTH_UV, int TC>
void xfnv122nv21(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
                 xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
                 xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& out_y,
                 xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& out_uv,
                 unsigned short int height,
                 unsigned short int width) {

    typename StreamType<WORDWIDTH_Y>::name yPacked = 0;
    typename StreamType<WORDWIDTH_UV>::name uvPacked[8], vuPacked[8], packed_Data = 0, val_dst = 0;
    unsigned long long int y_idx = 0, uv_idx = 0;
    unsigned long long int outUV_idx = 0;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS


 ColLoop:
        for (int j = 0; j<width>> xfNPixelsPerCycle<NPC>::datashift; j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 yPacked = _y.read(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j);
            out_y.write(y_idx++, yPacked);

            if (i < _uv.rows && j < (_uv.cols >> xfNPixelsPerCycle<NPC_UV>::datashift)) {
                packed_Data = _uv.read(uv_idx++);
            }

            VITIS_LOOP_7706_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC_UV>::nppc); l++) {

#pragma HLS unroll


 uvPacked[l] = packed_Data(l * 16 + 15, l * 16);
                vuPacked[l].range(15, 8) = uvPacked[l].range(7, 0);
                vuPacked[l].range(7, 0) = uvPacked[l].range(15, 8);
                val_dst.range(l * 16 + 15, l * 16) = vuPacked[l];
            }
            if (i < _uv.rows && j < (_uv.cols >> xfNPixelsPerCycle<NPC_UV>::datashift)) {
                out_uv.write(outUV_idx++, val_dst);
            }
        }
    }
}

template <int SRC_Y, int SRC_UV, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv122nv21(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
               xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
               xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& out_y,
               xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& out_uv) {

#pragma HLS INLINE OFF
# 7747 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfnv122nv21<SRC_Y, SRC_UV, ROWS, COLS, NPC, NPC_UV, DataType<SRC_Y, NPC>::wordwidth, DataType<SRC_UV, NPC_UV>::wordwidth,
                (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_y, _uv, out_y, out_uv, _y.rows, _y.cols);
}




template <int SRC_Y, int SRC_UV, int ROWS, int COLS, int NPC = 1, int NPC_UV = 1>
void nv212nv12(xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& _y,
               xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& _uv,
               xf::cv::Mat<SRC_Y, ROWS, COLS, NPC>& out_y,
               xf::cv::Mat<SRC_UV, ROWS / 2, COLS / 2, NPC_UV>& out_uv) {

#pragma HLS INLINE OFF
# 7778 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfnv122nv21<SRC_Y, SRC_UV, ROWS, COLS, NPC, NPC_UV, DataType<SRC_Y, NPC>::wordwidth, DataType<SRC_UV, NPC_UV>::wordwidth,
                (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(_y, _uv, out_y, out_uv, _y.rows, _y.cols);
}




template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC, int WORDWIDTH_SRC, int WORDWIDTH_DST, int TC>
void xfuyvy2yuyv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy,
                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& yuyv,
                 unsigned short int height,
                 unsigned short int width) {

    typename StreamType<WORDWIDTH_SRC>::name uy = 0;
    typename StreamType<WORDWIDTH_DST>::name yu[8], uyPacked[8], packed_Data = 0, val_dst = 0;
    unsigned long long int y_idx = 0, uv_idx = 0;
    unsigned long long int outUV_idx = 0;
RowLoop:
    for (int i = 0; i < height; i++) {

#pragma HLS LOOP_FLATTEN off
#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS


 ColLoop:
        for (int j = 0; j < (width >> xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT min=COLS max=COLS


 uy = uyvy.read(i * (width >> xfNPixelsPerCycle<NPC>::datashift) + j);

            VITIS_LOOP_7811_1: for (int l = 0; l < (xfNPixelsPerCycle<NPC>::nppc); l++) {

#pragma HLS unroll


 uyPacked[l] = uy(l * 16 + 15, l * 16);
                yu[l].range(15, 8) = uyPacked[l].range(7, 0);
                yu[l].range(7, 0) = uyPacked[l].range(15, 8);
                val_dst.range(l * 16 + 15, l * 16) = yu[l];
            }
            yuyv.write(outUV_idx++, val_dst);
        }
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void uyvy2yuyv(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& uyvy, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& yuyv) {

#pragma HLS INLINE OFF
# 7839 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfuyvy2yuyv<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
                (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(uyvy, yuyv, uyvy.rows, uyvy.cols);
}



template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void yuyv2uyvy(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& yuyv, xf::cv::Mat<DST_T, ROWS, COLS, NPC>& uyvy) {

#pragma HLS INLINE OFF
# 7858 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_cvt_color.hpp"
 xfuyvy2yuyv<SRC_T, DST_T, ROWS, COLS, NPC, DataType<SRC_T, NPC>::wordwidth, DataType<DST_T, NPC>::wordwidth,
                (ROWS * (COLS >> (xfNPixelsPerCycle<NPC>::nppc)))>(yuyv, uyvy, uyvy.rows, uyvy.cols);
}


}
}
# 26 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_aec.hpp" 2


# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_hist_equalize.hpp" 1
# 27 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_hist_equalize.hpp"
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_histogram.hpp" 1
# 26 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_histogram.hpp"
namespace xf {
namespace cv {

template <int SRC_T, int ROWS, int COLS, int DEPTH, int NPC, int WORDWIDTH, int SRC_TC, int PLANES>
void xFHistogramKernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src_mat,
                       uint32_t hist_array[PLANES][256],
                       uint16_t& imgheight,
                       uint16_t& imgwidth) {

    uint32_t tmp_hist[(PLANES << xfNPixelsPerCycle<NPC>::datashift)][256];
    uint32_t tmp_hist1[(PLANES << xfNPixelsPerCycle<NPC>::datashift)][256];

#pragma HLS ARRAY_PARTITION variable=tmp_hist complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_hist1 complete dim=1

 typename StreamType<WORDWIDTH>::name in_buf, in_buf1, temp_buf;

    bool flag = 0;

HIST_INITIALIZE_LOOP:
    for (ap_uint<10> i = 0; i < 256; i++)
    {

#pragma HLS PIPELINE

 VITIS_LOOP_51_1: for (ap_uint<5> j = 0; j < (1 << xfNPixelsPerCycle<NPC>::datashift * PLANES); j++) {

#pragma HLS LOOP_TRIPCOUNT min=256 max=256

 tmp_hist[j][i] = 0;
            tmp_hist1[j][i] = 0;
        }
    }

HISTOGRAM_ROW_LOOP:
    for (ap_uint<13> row = 0; row < imgheight; row++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 HISTOGRAM_COL_LOOP:
        for (ap_uint<13> col = 0; col < (imgwidth); col = col + 2) {

#pragma HLS PIPELINE II=2
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS LOOP_TRIPCOUNT min=SRC_TC max=SRC_TC

 in_buf = _src_mat.read(row * (imgwidth) + col);

            if (col == (imgwidth - 1))
                in_buf1 = 0;
            else
                in_buf1 = _src_mat.read(row * (imgwidth) + col + 1);


#pragma HLS DEPENDENCE variable=tmp_hist array intra false
#pragma HLS DEPENDENCE variable=tmp_hist1 array intra false

 EXTRACT_UPDATE:
            for (ap_uint<9> i = 0, j = 0; i < ((8 << xfNPixelsPerCycle<NPC>::datashift) * PLANES); j++, i += 8) {
#pragma HLS UNROLL
 ap_uint<8> val = 0, val1 = 0;
                val = in_buf.range(i + 7, i);
                val1 = in_buf1.range(i + 7, i);

                uint32_t tmpval = tmp_hist[j][val];
                uint32_t tmpval1 = tmp_hist1[j][val1];
                tmp_hist[j][val] = tmpval + 1;
                if (!(col == (imgwidth - 1))) tmp_hist1[j][val1] = tmpval1 + 1;
            }
        }
    }

    const int num_ch = DataType<SRC_T, NPC>::channel;

MERGE_HIST_LOOP:
    for (ap_uint<32> i = 0; i < 256; i++) {

#pragma HLS pipeline


 MERGE_HIST_CH_UNROLL:
        for (ap_uint<5> ch = 0; ch < num_ch; ch++) {

#pragma HLS UNROLL


 uint32_t value = 0;

        MERGE_HIST_NPPC_UNROLL:
            for (ap_uint<5> p = 0; p < xfNPixelsPerCycle<NPC>::nppc; p++) {

#pragma HLS UNROLL

 value += tmp_hist[p * num_ch + ch][i] + tmp_hist1[p * num_ch + ch][i];
            }

            hist_array[ch][i] = value;
        }
    }
}

template <int SRC_T, int ROWS, int COLS, int NPC = 1>
void calcHist(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, uint32_t* histogram) {





#pragma HLS INLINE OFF


 uint32_t hist_array[DataType<SRC_T, NPC>::channel][256] = {0};
    uint16_t width = _src.cols >> (xfNPixelsPerCycle<NPC>::datashift);
    uint16_t height = _src.rows;

    xFHistogramKernel<SRC_T, ROWS, COLS, DataType<SRC_T, NPC>::pixeldepth, NPC, DataType<SRC_T, NPC>::wordwidth,
                      ((COLS >> (xfNPixelsPerCycle<NPC>::datashift)) >> 1), DataType<SRC_T, NPC>::channel>(_src, hist_array, height, width);

    VITIS_LOOP_144_1: for (int i = 0; i < (DataType<SRC_T, NPC>::channel); i++) {
        VITIS_LOOP_145_2: for (int j = 0; j < 256; j++) {

#pragma HLS LOOP_TRIPCOUNT min=1 max=256
#pragma HLS PIPELINE
#pragma HLS LOOP_FLATTEN off

 histogram[(i * 256) + j] = hist_array[i][j];
        }
    }
}

}
}
# 28 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_hist_equalize.hpp" 2







namespace xf {
namespace cv {

template <int SRC_T, int ROWS, int COLS, int DEPTH, int NPC, int WORDWIDTH, int SRC_TC>
void xFEqualize(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src1,
                uint32_t hist_stream[0][256],
                xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst_mat,
                uint16_t img_height,
                uint16_t img_width) {
    typename StreamType<WORDWIDTH>::name
    in_buf, temp_buf;

    ap_uint<8> cum_hist[256];

#pragma HLS ARRAY_PARTITION variable=cum_hist complete dim=1


 ap_uint<8> tmp_cum_hist[(1 << xfNPixelsPerCycle<NPC>::datashift)][256];

#pragma HLS ARRAY_PARTITION variable=tmp_cum_hist complete dim=1




 uint32_t temp_val = (uint32_t)(img_height * (img_width << xfNPixelsPerCycle<NPC>::datashift));
    uint32_t init_val = (uint32_t)(temp_val - hist_stream[0][0]);
    uint32_t scale;
    if (init_val == 0) {
        scale = 0;
    } else {
        scale = (uint32_t)(((1 << 31)) / init_val);
    }

    ap_uint<40> scale1 = (ap_uint<40>)((ap_uint<40>)255 * (ap_uint<40>)scale);
    ap_uint32_t temp_sum = 0;

    cum_hist[0] = 0;
Normalize_Loop:
    for (ap_uint<9> i = 1; i < 256; i++) {

#pragma HLS LOOP_TRIPCOUNT min=256 max=256
#pragma HLS PIPELINE

 temp_sum = (uint32_t)temp_sum + (uint32_t)hist_stream[0][i];
        uint64_t sum = (uint64_t)((uint64_t)temp_sum * (uint64_t)scale1);
        sum = (uint64_t)(sum + 0x40000000);
        cum_hist[i] = sum >> 31;
    }

    VITIS_LOOP_84_1: for (ap_uint<9> i = 0; i < 256; i++) {

#pragma HLS PIPELINE

 VITIS_LOOP_88_2: for (ap_uint<5> j = 0; j < (1 << xfNPixelsPerCycle<NPC>::datashift); j++) {

#pragma HLS UNROLL

 ap_uint<8> tmpval = cum_hist[i];
            tmp_cum_hist[j][i] = tmpval;
        }
    }

NORMALISE_ROW_LOOP:
    for (ap_uint<13> row = 0; row < img_height; row++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS

 NORMALISE_COL_LOOP:
        for (ap_uint<13> col = 0; col < img_width; col++) {

#pragma HLS LOOP_TRIPCOUNT min=SRC_TC max=SRC_TC
#pragma HLS PIPELINE
#pragma HLS LOOP_FLATTEN OFF

 in_buf = _src1.read(row * img_width + col);
        Normalise_Extract:
            for (ap_uint<9> i = 0, j = 0; i < (8 << xfNPixelsPerCycle<NPC>::datashift); j++, i += 8) {

#pragma HLS DEPENDENCE variable=tmp_cum_hist array intra false
#pragma HLS unroll

 typename PixelType<DEPTH>::name
                val;
                val = in_buf.range(i + 7, i);
                temp_buf(i + 7, i) = tmp_cum_hist[j][val];
            }
            _dst_mat.write(row * img_width + col, temp_buf);
        }
    }
}





template <int SRC_T, int ROWS, int COLS, int NPC = 1>
void equalizeHist(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src1,
                  xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst) {

#pragma HLS inline off


 uint16_t img_height = _src1.rows;
    uint16_t img_width = _src1.cols;






    uint32_t histogram[1][256];

    img_width = img_width >> xfNPixelsPerCycle<NPC>::datashift;
    xFHistogramKernel<SRC_T, ROWS, COLS, DataType<SRC_T, NPC>::pixeldepth, NPC, DataType<SRC_T, NPC>::wordwidth,
                      ((COLS >> (xfNPixelsPerCycle<NPC>::datashift)) >> 1), DataType<SRC_T, NPC>::channel>(_src, histogram, img_height,
                                                                                    img_width);

    xFEqualize<SRC_T, ROWS, COLS, DataType<SRC_T, NPC>::pixeldepth, NPC, DataType<SRC_T, NPC>::wordwidth, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(
        _src1, histogram, _dst, img_height, img_width);
}
}
}
# 29 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_aec.hpp" 2


template <typename T>
T xf_satcast_aec(int in_val){};

template <>
inline ap_uint<8> xf_satcast_aec<ap_uint<8> >(int v) {
    v = (v > 255 ? 255 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<10> xf_satcast_aec<ap_uint<10> >(int v) {
    v = (v > 1023 ? 1023 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<12> xf_satcast_aec<ap_uint<12> >(int v) {
    v = (v > 4095 ? 4095 : v);
    v = (v < 0 ? 0 : v);
    return v;
};
template <>
inline ap_uint<16> xf_satcast_aec<ap_uint<16> >(int v) {
    v = (v > 65535 ? 65535 : v);
    v = (v < 0 ? 0 : v);
    return v;
};

namespace xf {
namespace cv {

template <int SRC_T, int DST_T, int XF_8UC1, int ROWS, int COLS, int NPC = 1>
void autoexposurecorrection_mono(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                                 xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                                 uint32_t hist_array1[1][256],
                                 uint32_t hist_array2[1][256]) {
#pragma HLS INLINE OFF

 int rows = src.rows;
    int cols = src.cols;

    uint16_t cols_shifted = cols >> (xfNPixelsPerCycle<NPC>::datashift);
    uint16_t rows_shifted = rows;

    xf::cv::Mat<XF_8UC1, ROWS, COLS, NPC> vimage1(rows, cols);
    xf::cv::Mat<XF_8UC1, ROWS, COLS, NPC> vimage2(rows, cols);

    xf::cv::duplicateMat(src, vimage1, vimage2);

    xFHistogramKernel<XF_8UC1, ROWS, COLS, DataType<XF_8UC1, NPC>::pixeldepth, NPC,
                      DataType<XF_8UC1, NPC>::wordwidth, ((COLS >> (xfNPixelsPerCycle<NPC>::datashift)) >> 1),
                      DataType<XF_8UC1, NPC>::channel>(vimage1, hist_array1, rows_shifted, cols_shifted);

    xFEqualize<XF_8UC1, ROWS, COLS, DataType<XF_8UC1, NPC>::pixeldepth, NPC, DataType<XF_8UC1, NPC>::wordwidth,
               (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(vimage2, hist_array2, dst, rows_shifted, cols_shifted);
}

template <int SRC_T, int DST_T, int XF_8UC1, int ROWS, int COLS, int NPC = 1>
void autoexposurecorrection(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                            xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                            uint32_t hist_array1[1][256],
                            uint32_t hist_array2[1][256]) {
#pragma HLS INLINE OFF

 int rows = src.rows;
    int cols = src.cols;

    uint16_t cols_shifted = cols >> (xfNPixelsPerCycle<NPC>::datashift);
    uint16_t rows_shifted = rows;

    xf::cv::Mat<SRC_T, ROWS, COLS, NPC> bgr2hsv(rows, cols);

    xf::cv::Mat<SRC_T, ROWS, COLS, NPC> hsvimg1(rows, cols);
    xf::cv::Mat<SRC_T, ROWS, COLS, NPC> hsvimg2(rows, cols);
    xf::cv::Mat<SRC_T, ROWS, COLS, NPC> hsvimg3(rows, cols);

    xf::cv::Mat<XF_8UC1, ROWS, COLS, NPC> himage(rows, cols);
    xf::cv::Mat<XF_8UC1, ROWS, COLS, NPC> simage(rows, cols);
    xf::cv::Mat<XF_8UC1, ROWS, COLS, NPC> vimage(rows, cols);
    xf::cv::Mat<XF_8UC1, ROWS, COLS, NPC> vimage1(rows, cols);
    xf::cv::Mat<XF_8UC1, ROWS, COLS, NPC> vimage2(rows, cols);

    xf::cv::Mat<XF_8UC1, ROWS, COLS, NPC> vimage_eq(rows, cols);
    xf::cv::Mat<SRC_T, ROWS, COLS, NPC> imgHelper6(rows, cols);

    (__builtin_assume(static_cast <bool> (((rows <= ROWS) && (cols <= COLS)) && "ROWS and COLS should be greater than input image")));


#pragma HLS DATAFLOW



 xf::cv::bgr2hsv<SRC_T, ROWS, COLS, NPC>(src, bgr2hsv);

    xf::cv::duplicateimages<SRC_T, ROWS, COLS, NPC>(bgr2hsv, hsvimg1, hsvimg2, hsvimg3);

    xf::cv::extractChannel<SRC_T, XF_8UC1, ROWS, COLS, NPC>(hsvimg1, himage, 0);

    xf::cv::extractChannel<SRC_T, XF_8UC1, ROWS, COLS, NPC>(hsvimg2, simage, 1);

    xf::cv::extractChannel<SRC_T, XF_8UC1, ROWS, COLS, NPC>(hsvimg3, vimage, 2);

    xf::cv::duplicateMat(vimage, vimage1, vimage2);



    xFHistogramKernel<XF_8UC1, ROWS, COLS, DataType<XF_8UC1, NPC>::pixeldepth, NPC,
                      DataType<XF_8UC1, NPC>::wordwidth, ((COLS >> (xfNPixelsPerCycle<NPC>::datashift)) >> 1),
                      DataType<XF_8UC1, NPC>::channel>(vimage1, hist_array1, rows_shifted, cols_shifted);

    xFEqualize<XF_8UC1, ROWS, COLS, DataType<XF_8UC1, NPC>::pixeldepth, NPC, DataType<XF_8UC1, NPC>::wordwidth,
               (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(vimage2, hist_array2, vimage_eq, rows_shifted, cols_shifted);

    xf::cv::merge<XF_8UC1, SRC_T, ROWS, COLS, NPC>(vimage_eq, simage, himage, imgHelper6);

    xf::cv::hsv2bgr<SRC_T, SRC_T, ROWS, COLS, NPC>(imgHelper6, dst);
}
}
}
# 41 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2


# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_gammacorrection.hpp" 1
# 22 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_gammacorrection.hpp"
# 1 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_lut.hpp" 1
# 36 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_lut.hpp"
namespace xf {
namespace cv {

template <int SRC_T,
          int ROWS,
          int COLS,
          int PLANES,
          int DEPTH,
          int NPC,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int COLS_TRIP>
void xFLUTKernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                 xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst,
                 unsigned char* _lut,
                 uint16_t height,
                 uint16_t width) {
    width = width >> xfNPixelsPerCycle<NPC>::datashift;
    ap_uint<13> i, j, k;

    uchar_t lut[xfNPixelsPerCycle<NPC>::nppc * PLANES][256];

    if ((NPC != 0) || (PLANES != 1)) {

#pragma HLS ARRAY_PARTITION variable=lut complete dim=1

 }


    if ((NPC != 0) || (PLANES != 3)) {
        VITIS_LOOP_66_1: for (i = 0; i < (xfNPixelsPerCycle<NPC>::nppc * PLANES); i++) {
            VITIS_LOOP_67_2: for (j = 0; j < 256; j++) {
                lut[i][j] = _lut[j];
            }
        }
    }

    typename StreamType<WORDWIDTH_SRC>::name val_src;
    typename StreamType<WORDWIDTH_DST>::name val_dst;

rowLoop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off


 colLoop:
        for (j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS_TRIP max=COLS_TRIP
#pragma HLS pipeline


 val_src = (typename StreamType<WORDWIDTH_SRC>::name)(_src.read(i * width + j));

            uchar_t l = 0;
            int c = 0;
        procLoop:
            for (k = 0; k < (StreamType<WORDWIDTH_SRC>::bitdepth); k += 16) {

#pragma HLS unroll

 typename PixelType<DEPTH>::name p;
                p = val_src.range(k + (16 - 1), k);


                if ((NPC == XF_NPPC1) && (PLANES == 1)) {
                    val_dst.range(k + (16 - 1), k) = _lut[p];
                }


                else {
                    val_dst.range(k + (16 - 1), k) = lut[l][p];
                    l++;
                }
            }
            _dst.write(i * width + j, val_dst);
        }
    }
}
template <int SRC_T, int ROWS, int COLS, int NPC = 1>
void LUT(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src, xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst, unsigned char* _lut) {

#pragma HLS INLINE OFF
 unsigned char height=_src.rows;
 unsigned char width=_src.cols;







    xFLUTKernel<SRC_T, ROWS, COLS, DataType<SRC_T, NPC>::channel, DataType<SRC_T, NPC>::pixeldepth, NPC, DataType<SRC_T, NPC>::wordwidth,
               DataType<SRC_T, NPC>::wordwidth,(COLS >> xfNPixelsPerCycle<NPC>::datashift)>(_src, _dst, _lut, _src.rows, _src.cols);
}
}
}
# 23 "../../../../../overlays/Vitis_Libraries/vision//L1/include/imgproc/xf_gammacorrection.hpp" 2


namespace xf {
namespace cv {
template <int SRC_T,
          int ROWS,
          int COLS,
          int PLANES,
          int DEPTH,
          int NPC,
          int WORDWIDTH_SRC,
          int WORDWIDTH_DST,
          int COLS_TRIP>
void xFGAMMAKernel(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _src,
                   xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& _dst,
                   unsigned char lut_table[256 * PLANES],
                   uint16_t height,
                   uint16_t width) {

    ap_uint<13> i, j, k;
    const int STEP = DataType<SRC_T, NPC>::bitdepth;

    unsigned char lut_p[xfNPixelsPerCycle<NPC>::nppc * PLANES]
                       [256];


#pragma HLS ARRAY_PARTITION variable=lut_p complete dim=1




 VITIS_LOOP_54_1: for (i = 0; i < (xfNPixelsPerCycle<NPC>::nppc); i++) {
        VITIS_LOOP_55_2: for (k = 0; k < PLANES; k++) {
            VITIS_LOOP_56_3: for (j = 0; j < 256; j++) {
                lut_p[i * PLANES + k][j] = lut_table[256 * k + j];
            }
        }
    }

    typename DataType<SRC_T, NPC>::name val_src;
    typename DataType<SRC_T, NPC>::name val_dst;

    printf("gamma correction width:%d height%d\n", width, height);

rowLoop:
    for (i = 0; i < height; i++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off


 colLoop:
        for (j = 0; j < width; j++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS_TRIP max=COLS_TRIP
#pragma HLS pipeline


 val_src = _src.read(i * width + j);

            VITIS_LOOP_83_4: for (int p = 0, b = 0; p < xfNPixelsPerCycle<NPC>::nppc * PLANES; p++, b = b + 3) {

#pragma HLS unroll

 typename DataType<SRC_T, NPC>::cname val1 = val_src.range(p * STEP + STEP - 1, p * STEP);

                typename DataType<SRC_T, NPC>::cname outval1 = lut_p[p][val1];

                val_dst.range(p * STEP + STEP - 1, p * STEP) = outval1;
            }

            _dst.write(i * width + j, val_dst);
        }
    }
}
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void gammacorrection(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& src,
                     xf::cv::Mat<DST_T, ROWS, COLS, NPC>& dst,
                     unsigned char lut_table[256 * DataType<SRC_T, NPC>::channel]) {

#pragma HLS INLINE OFF


 unsigned short height = src.rows;
    unsigned short width = src.cols >> xfNPixelsPerCycle<NPC>::datashift;

    xFGAMMAKernel<SRC_T, ROWS, COLS, DataType<SRC_T, NPC>::channel, DataType<SRC_T, NPC>::pixeldepth, NPC, DataType<SRC_T, NPC>::wordwidth,
                  DataType<SRC_T, NPC>::wordwidth, (COLS >> xfNPixelsPerCycle<NPC>::datashift)>(src, dst, lut_table, height, width);
}
}
}
# 44 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h" 2
# 64 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h"
static constexpr int BLOCK_HEIGHT = 64;
static constexpr int BLOCK_WIDTH = 64;




typedef ap_axiu<(((((DataType<XF_10UC1, XF_NPPC1>::pixelwidth * xfNPixelsPerCycle<XF_NPPC1>::nppc)) + 7) / 8) * 8), 1, 1, 1> InVideoStrmBus_t;
typedef ap_axiu<(((((DataType<XF_8UC3, XF_NPPC1>::pixelwidth * xfNPixelsPerCycle<XF_NPPC1>::nppc)) + 7) / 8) * 8), 1, 1, 1> OutVideoStrmBus_t;


typedef hls::stream<InVideoStrmBus_t> InVideoStrm_t;
typedef hls::stream<OutVideoStrmBus_t> OutVideoStrm_t;
# 94 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_types.h"
typedef struct {
    uint16_t width;
    uint16_t height;

    uint16_t bayer_phase;
} HW_STRUCT_REG;





__attribute__((sdx_kernel("ISPPipeline_accel", 0))) void ISPPipeline_accel(uint16_t width,
                       uint16_t height,
                       InVideoStrm_t& s_axis_video,
                       OutVideoStrm_t& m_axis_video,
                       uint16_t rgain,
                       uint16_t bgain,
                       unsigned char r_lut[256 * 3],
                       unsigned char mode_reg,
                       uint16_t pawb);
# 18 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_accel.cpp" 2

static bool flag = 0;

static uint32_t hist0_awb[3][1024] = {0};
static uint32_t hist1_awb[3][1024] = {0};

static int igain_0[3] = {0};
static int igain_1[3] = {0};







template <int TYPE, int ROWS, int COLS, int NPPC>
void AXIVideo2BayerMat(InVideoStrm_t& bayer_strm, xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& bayer_mat) {

#pragma HLS INLINE OFF

 InVideoStrmBus_t axi;

    const int m_pix_width = DataType<TYPE, NPPC>::pixelwidth * xfNPixelsPerCycle<NPPC>::nppc;

    int rows = bayer_mat.rows;
    int cols = bayer_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift;
    int idx = 0;

    bool start = false;
    bool last = false;

loop_start_hunt:
    while (!start) {

#pragma HLS pipeline II=1
#pragma HLS loop_tripcount avg=0 max=0


 bayer_strm >> axi;
        start = axi.user.to_bool();
    }

loop_row_axi2mat:
    for (int i = 0; i < rows; i++) {
        last = false;

#pragma HLS loop_tripcount avg=ROWS max=ROWS

 loop_col_zxi2mat:
        for (int j = 0; j < cols; j++) {

#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
#pragma HLS loop_tripcount avg=COLS/NPPC max=COLS/NPPC


 if (start || last) {
                start = false;
            } else {
                bayer_strm >> axi;
            }

            last = axi.last.to_bool();

            bayer_mat.write(idx++, axi.data(m_pix_width - 1, 0));
        }

    loop_last_hunt:
        while (!last) {

#pragma HLS pipeline II=1
#pragma HLS loop_tripcount avg=0 max=0


 bayer_strm >> axi;
            last = axi.last.to_bool();
        }
    }

    return;
}
template <int TYPE, int ROWS, int COLS, int NPPC>
void ColorMat2AXIvideo(xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& color_mat, OutVideoStrm_t& color_strm) {

#pragma HLS INLINE OFF


 OutVideoStrmBus_t axi;

    int rows = color_mat.rows;
    int cols = color_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift;
    int idx = 0;

    typename DataType<TYPE, NPPC>::name srcpixel;

    const int m_pix_width = DataType<TYPE, NPPC>::pixelwidth * xfNPixelsPerCycle<NPPC>::nppc;

    int depth = DataType<XF_8UC3, XF_NPPC1>::bitdepth;

    bool sof = true;

loop_row_mat2axi:
    for (int i = 0; i < rows; i++) {

#pragma HLS loop_tripcount avg=ROWS max=ROWS

 loop_col_mat2axi:
        for (int j = 0; j < cols; j++) {

#pragma HLS loop_flatten off
#pragma HLS pipeline II = 1
#pragma HLS loop_tripcount avg=COLS/NPPC max=COLS/NPPC

 if (sof) {
                axi.user = 1;
            } else {
                axi.user = 0;
            }

            if (j == cols - 1) {
                axi.last = 1;
            } else {
                axi.last = 0;
            }

            axi.data = 0;

            srcpixel = color_mat.read(idx++);

            VITIS_LOOP_147_1: for (int npc = 0; npc < NPPC; npc++) {
                VITIS_LOOP_148_2: for (int rs = 0; rs < 3; rs++) {

                    int kmap[3] = {1, 0, 2};




                    int start = (rs + npc * 3) * depth;

                    int start_format = (kmap[rs] + npc * 3) * depth;

                    axi.data(start + (depth - 1), start) = srcpixel.range(start_format + (depth - 1), start_format);
                }
            }

            axi.keep = -1;
            color_strm << axi;

            sof = false;
        }
    }

    return;
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void fifo_copy(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& demosaic_out,
               xf::cv::Mat<DST_T, ROWS, COLS, NPC>& ltm_in,
               unsigned short height,
               unsigned short width) {

#pragma HLS INLINE OFF

 ap_uint<13> row, col;
    int readindex = 0, writeindex = 0;

    ap_uint<13> img_width = width >> xfNPixelsPerCycle<NPC>::datashift;

Row_Loop:
    for (row = 0; row < height; row++) {

#pragma HLS LOOP_TRIPCOUNT min=ROWS max=ROWS
#pragma HLS LOOP_FLATTEN off

 Col_Loop:
        for (col = 0; col < img_width; col++) {

#pragma HLS LOOP_TRIPCOUNT min=COLS/NPC max=COLS/NPC
#pragma HLS pipeline

 typename DataType<SRC_T, NPC>::name tmp_src;
            tmp_src = demosaic_out.read(readindex++);
            ltm_in.write(writeindex++, tmp_src);
        }
    }
}
template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void fifo_awb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& demosaic_out,
              xf::cv::Mat<DST_T, ROWS, COLS, NPC>& ltm_in,
              uint32_t hist0[3][1024],
              uint32_t hist1[3][1024],
              int gain0[3],
              int gain1[3],
              unsigned short height,
              unsigned short width,
              float thresh) {

#pragma HLS INLINE OFF

 xf::cv::Mat<XF_10UC3, 1080, 1920, XF_NPPC1> impop(height, width);

 float inputMin = 0.0f;
    float inputMax = (1 << (DataType<XF_10UC1, XF_NPPC1>::bitdepth)) - 1;
    float outputMin = 0.0f;
    float outputMax = (1 << (DataType<XF_10UC1, XF_NPPC1>::bitdepth)) - 1;


#pragma HLS DATAFLOW

 if (XF_WB_SIMPLE) {
        xf::cv::AWBhistogram<XF_10UC3, XF_10UC3, 1080, 1920, XF_NPPC1, XF_WB_SIMPLE, 1024>(
            demosaic_out, impop, hist0, thresh, inputMin, inputMax, outputMin, outputMax);
        xf::cv::AWBNormalization<XF_10UC3, XF_10UC3, 1080, 1920, XF_NPPC1, XF_WB_SIMPLE, 1024>(
            impop, ltm_in, hist1, thresh, inputMin, inputMax, outputMin, outputMax);
    } else {
        xf::cv::AWBChannelGain<XF_10UC3, XF_10UC3, 1080, 1920, XF_NPPC1, 0>(demosaic_out, impop, thresh, gain0);
        xf::cv::AWBGainUpdate<XF_10UC3, XF_10UC3, 1080, 1920, XF_NPPC1, 0>(impop, ltm_in, thresh, gain1);
    }
}

template <int SRC_T, int DST_T, int ROWS, int COLS, int NPC = 1>
void function_awb(xf::cv::Mat<SRC_T, ROWS, COLS, NPC>& demosaic_out,
                  xf::cv::Mat<DST_T, ROWS, COLS, NPC>& ltm_in,
                  uint32_t hist0[3][1024],
                  uint32_t hist1[3][1024],
                  int gain0[3],
                  int gain1[3],
                  unsigned short height,
                  unsigned short width,
                  unsigned char mode_reg,
                  float thresh) {

#pragma HLS INLINE OFF


 ap_uint<8> mode = (ap_uint<8>)mode_reg;
    ap_uint<1> mode_flg = mode.range(0, 0);

    if (mode_flg) {
        fifo_awb<XF_10UC3, XF_10UC3, 1080, 1920, XF_NPPC1>(demosaic_out, ltm_in, hist0, hist1, gain0, gain1,
                                                                   height, width, thresh);
    } else {
        fifo_copy<XF_10UC3, XF_10UC3, 1080, 1920, XF_NPPC1>(demosaic_out, ltm_in, height, width);
    }
}

template <int TYPE, int ROWS, int COLS, int NPPC>
void ColorMat2AXIvideo_yuv(xf::cv::Mat<TYPE, ROWS, COLS, NPPC>& color_mat, OutVideoStrm_t& color_strm) {

#pragma HLS INLINE OFF


 OutVideoStrmBus_t axi;

    int rows = color_mat.rows;
    int cols = color_mat.cols >> xfNPixelsPerCycle<NPPC>::datashift;
    int idx = 0;

    typename DataType<TYPE, NPPC>::name srcpixel;

    const int m_pix_width = DataType<TYPE, NPPC>::pixelwidth * xfNPixelsPerCycle<NPPC>::nppc;

    int depth = DataType<TYPE, XF_NPPC1>::bitdepth;

    bool sof = true;

loop_row_mat2axi:
    for (int i = 0; i < rows; i++) {

#pragma HLS loop_tripcount avg=ROWS max=ROWS

 loop_col_mat2axi:
        for (int j = 0; j < cols; j++) {

#pragma HLS loop_flatten off
#pragma HLS pipeline II = 1
#pragma HLS loop_tripcount avg=COLS/NPPC max=COLS/NPPC

 if (sof) {
                axi.user = 1;
            } else {
                axi.user = 0;
            }

            if (j == cols - 1) {
                axi.last = 1;
            } else {
                axi.last = 0;
            }

            axi.data = 0;

            srcpixel = color_mat.read(idx++);

            VITIS_LOOP_312_1: for (int npc = 0; npc < NPPC; npc++) {
                VITIS_LOOP_313_2: for (int rs = 0; rs < 1; rs++) {
                    int start = (rs + npc) * depth;

                    axi.data(start + (depth - 1), start) = srcpixel.range(start + (depth - 1), start);
                }
            }

            axi.keep = -1;
            color_strm << axi;

            sof = false;
        }
    }

    return;
}
void ISPpipeline(InVideoStrm_t& s_axis_video,
                 OutVideoStrm_t& m_axis_video,
                 unsigned short height,
                 unsigned short width,
                 uint32_t hist0[3][1024],
                 uint32_t hist1[3][1024],
                 int gain0[3],
                 int gain1[3],
                 uint16_t rgain,
                 uint16_t bgain,
                 unsigned char gamma_lut[256 * 3],
                 unsigned char mode_reg,
                 uint16_t pawb) {


#pragma HLS INLINE OFF

 xf::cv::Mat<XF_10UC1, 1080, 1920, XF_NPPC1> imgInput1(height, width);
    xf::cv::Mat<XF_10UC1, 1080, 1920, XF_NPPC1> imgInput2(height, width);
    xf::cv::Mat<XF_10UC1, 1080, 1920, XF_NPPC1> bpc_out(height, width);
    xf::cv::Mat<XF_10UC1, 1080, 1920, XF_NPPC1> gain_out(height, width);
    xf::cv::Mat<XF_10UC3, 1080, 1920, XF_NPPC1> demosaic_out(height, width);
    xf::cv::Mat<XF_10UC3, 1080, 1920, XF_NPPC1> impop(height, width);
    xf::cv::Mat<XF_10UC3, 1080, 1920, XF_NPPC1> ltm_in(height, width);
    xf::cv::Mat<XF_10UC3, 1080, 1920, XF_NPPC1> lsc_out(height, width);
    xf::cv::Mat<XF_8UC3, 1080, 1920, XF_NPPC1> _dst(height, width);
    xf::cv::Mat<XF_8UC3, 1080, 1920, XF_NPPC1> aecin(height, width);
    xf::cv::Mat<XF_16UC1, 1080, 1920, XF_NPPC1> _imgOutput(height, width);


#pragma HLS DATAFLOW


 const int Q_VAL = 1 << (DataType<XF_10UC1, XF_NPPC1>::bitdepth);

    float thresh = (float)pawb / 256;
    float inputMax = (1 << (DataType<XF_10UC1, XF_NPPC1>::bitdepth)) - 1;

    float mul_fact = (inputMax / (inputMax - 32));

    AXIVideo2BayerMat<XF_10UC1, 1080, 1920, XF_NPPC1>(s_axis_video, imgInput1);
    xf::cv::blackLevelCorrection<XF_10UC1, 1080, 1920, XF_NPPC1, 16, 15, 1>(imgInput1, imgInput2, 32,
                                                                                    mul_fact);

    xf::cv::gaincontrol<XF_BAYER_RG, XF_10UC1, 1080, 1920, XF_NPPC1>(imgInput2, gain_out, rgain, bgain);
    xf::cv::demosaicing<XF_BAYER_RG, XF_10UC1, XF_10UC3, 1080, 1920, XF_NPPC1, 0>(gain_out, demosaic_out);

    function_awb<XF_10UC3, XF_10UC3, 1080, 1920, XF_NPPC1>(demosaic_out, ltm_in, hist0, hist1, gain0, gain1,
                                                                   height, width, mode_reg, thresh);

    xf::cv::colorcorrectionmatrix<XF_CCM_bt2020_bt709, XF_10UC3, XF_10UC3, 1080, 1920, XF_NPPC1>(ltm_in, lsc_out);

    if (XF_10UC3 == XF_8UC3) {
        fifo_copy<XF_10UC3, XF_8UC3, 1080, 1920, XF_NPPC1>(lsc_out, aecin, height, width);
    } else {
        xf::cv::xf_QuatizationDithering<XF_10UC3, XF_8UC3, 1080, 1920, 256, Q_VAL, XF_NPPC1>(lsc_out, aecin);
    }
    xf::cv::gammacorrection<XF_8UC3, XF_8UC3, 1080, 1920, XF_NPPC1>(aecin, _dst, gamma_lut);
    ColorMat2AXIvideo<XF_8UC3, 1080, 1920, XF_NPPC1>(_dst, m_axis_video);



}
# 400 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_accel.cpp"
__attribute__((sdx_kernel("ISPPipeline_accel", 0))) void ISPPipeline_accel(uint16_t width,
                       uint16_t height,
                       InVideoStrm_t& s_axis_video,
                       OutVideoStrm_t& m_axis_video,
                       uint16_t rgain,
                       uint16_t bgain,
                       unsigned char gamma_lut[256 * 3],
                       unsigned char mode_reg,
                       uint16_t pawb) {
#line 30 "/home/amahpour/code/kria-vitis-platforms/kv260/platforms/vivado/kv260_ispMipiRx_rpiMipiRx_DP/ip/isp_single_kv260/run_hls.tcl"
#pragma HLSDIRECTIVE TOP name=ISPPipeline_accel
# 408 "../../../../../overlays/Vitis_Libraries/vision//L1/examples/isppipeline/xf_isp_accel.cpp"



#pragma HLS INTERFACE axis port=&s_axis_video register
#pragma HLS INTERFACE axis port=&m_axis_video register

#pragma HLS INTERFACE s_axilite port=width bundle=CTRL offset=0x0010
#pragma HLS INTERFACE s_axilite port=height bundle=CTRL offset=0x0018
#pragma HLS INTERFACE s_axilite port=rgain bundle=CTRL offset=0x0030
#pragma HLS INTERFACE s_axilite port=bgain bundle=CTRL offset=0x0038
#pragma HLS INTERFACE s_axilite port=mode_reg bundle=CTRL offset=0x0046
#pragma HLS INTERFACE s_axilite port=pawb bundle=CTRL offset=0x0054
#pragma HLS INTERFACE s_axilite port=gamma_lut bundle=CTRL offset=0x0800

#pragma HLS INTERFACE s_axilite port=return bundle=CTRL


#pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1
#pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1


 if (!flag) {
        ISPpipeline(s_axis_video, m_axis_video, height, width, hist0_awb, hist1_awb, igain_0, igain_1, rgain, bgain,
                    gamma_lut, mode_reg, pawb);
        flag = 1;

    } else {
        ISPpipeline(s_axis_video, m_axis_video, height, width, hist1_awb, hist0_awb, igain_1, igain_0, rgain, bgain,
                    gamma_lut, mode_reg, pawb);
        flag = 0;
    }
}
